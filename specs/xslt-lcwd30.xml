<?xml version="1.0" encoding="utf-8"?>
<!--{xsl-query} XSLT Processor: Saxonica SAXON HE 9.4.0.3-->
<!--{xmlspec} XSLT Processor: SaxonicaSAXONHE 9.4.0.3-->
<!--<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
--><html lang="EN" xmlns="http://www.w3.org/1999/xhtml" xml:lang="EN">
<head>
<meta name="generator" content=
"HTML Tidy for Mac OS X (vers 31 October 2006 - Apple Inc. build 15.12), see www.w3.org" />
<title>XSL Transformations (XSLT) Version 3.0</title>

<style type="text/css">
/*<![CDATA[*/
/* from xsl:query.xsl (C) */          
code           { font-family: monospace; }

div.constraint,
div.issue,
div.note,
div.notice     { margin-left: 2em; }

div.issue
p.title        { margin-left: -2em; }

ol.enumar      { list-style-type: decimal; }
ol.enumla      { list-style-type: lower-alpha; }
ol.enumlr      { list-style-type: lower-roman; }
ol.enumua      { list-style-type: upper-alpha; }
ol.enumur      { list-style-type: upper-roman; }

li p           { margin-top: 0.3em;
                 margin-bottom: 0.3em; }

sup small      { font-style: italic;
                 color: #8F8F8F;
               }
    
/* from xsl:query.xsl (D) */          
div.exampleInner pre { margin-left: 1em;
                       margin-top: 0em; margin-bottom: 0em}
div.exampleOuter {border: 4px double gray;
                  margin: 0em; padding: 0em}
div.exampleInner { background-color: #d5dee3;
                   border-top-width: 4px;
                   border-top-style: double;
                   border-top-color: #d3d3d3;
                   border-bottom-width: 4px;
                   border-bottom-style: double;
                   border-bottom-color: #d3d3d3;
                   padding: 4px; margin: 0em }
div.exampleWrapper { margin: 4px }
div.exampleHeader { font-weight: bold;
                    margin: 4px}

div.issue { border-bottom-color: black;
            border-bottom-style: solid;
            border-bottom-width: 1pt;
            margin-bottom: 20pt;
}

th.issue-toc-head { border-bottom-color: black;
                    border-bottom-style: solid;
                    border-bottom-width: 1pt;
}

      
/* from xslt3.0/diff.xsl (B) */  
dd.indent { margin-left: 2em; }
p.element-syntax { border: solid thin; background-color: #ffccff }
p.element-syntax-chg { border: solid thick yellow; background-color: #ffccff }
div.proto { border: solid thin; background-color: #ffccff }
div.proto + div.proto { margin-top : 2em; }
div.example { border: solid thin; background-color: #40e0d0; padding: 1em }
div.example-chg { border: solid thick yellow; background-color: #40e0d0; padding: 1em }
span.verb { font: small-caps 100% sans-serif } 
span.error { font-size: small } 
span.definition { font: small-caps 100% sans-serif } 
span.grayed { color: gray }

/* from xsl-query.xsl (B) */    
table.small                             { font-size: x-small; }
a.judgment:visited, a.judgment:link     { font-family: sans-serif;
                                          color: black; 
                                          text-decoration: none }
a.processing:visited, a.processing:link { color: black; 
                                                text-decoration: none }
a.env:visited, a.env:link               { color: black; 
                                          text-decoration: none }
/*]]>*/
</style>
<link rel="stylesheet" type="text/css" href=
"//www.w3.org/StyleSheets/TR/W3C-WD.css" />
</head>
<body>
<div class="head">
<p><a href="http://www.w3.org/"><img src=
"http://www.w3.org/Icons/w3c_home" alt="W3C" height="48" width=
"72" /></a></p>
<h1><a name="title" id="title"></a>XSL Transformations (XSLT)
Version 3.0</h1>
<h2><a name="w3c-doctype" id="w3c-doctype"></a>W3C Last Call
Working Draft 2 October 2014</h2>
<dl>
<dt>This version:</dt>
<dd><a href=
"http://www.w3.org/TR/2014/WD-xslt-30-20141002/">http://www.w3.org/TR/2014/WD-xslt-30-20141002/</a></dd>
<dt>Latest version:</dt>
<dd><a href=
"http://www.w3.org/TR/xslt-30/">http://www.w3.org/TR/xslt-30/</a><br />
</dd>
<dt>Previous versions:</dt>
<dd><a href=
"http://www.w3.org/TR/2013/WD-xslt-30-20131212/">http://www.w3.org/TR/2013/WD-xslt-30-20131212/</a><br />
<br />
<a href=
"http://www.w3.org/TR/2012/WD-xslt-30-20120710/">http://www.w3.org/TR/2012/WD-xslt-30-20120710/</a><br />
<br />
<a href=
"http://www.w3.org/TR/2010/WD-xslt-21-20100511/">http://www.w3.org/TR/2010/WD-xslt-21-20100511/</a><br />
</dd>
<dt>Editor:</dt>
<dd>Michael Kay, Saxonica <a href=
"http://www.saxonica.com/">&lt;http://www.saxonica.com/&gt;</a></dd>
</dl>
<p>See also <a href=
"http://www.w3.org/2003/03/Translations/byTechnology?technology=xslt-30">
<strong>translations</strong></a>.</p>
<p>The following associated resources are available:</p>
<ul>
<li><a href="Overview.html">Normative specification in HTML
format</a></li>
<li><a href="Overview-diff.html">HTML with revision markings
(non-normative)</a></li>
<li><a href="schema-for-xslt30.xsd">Schema for XSLT 3.0 stylesheets
(non-normative)</a></li>
<li><a href="schema-for-json.xsd">Schema for the XML representation
of JSON used by fn:json-to-xml (non-normative)</a></li>
<li><a href="xml-to-json.xsl">Stylesheet for XML-to-JSON conversion
(non-normative)</a></li>
</ul>
<p class="copyright"><a href=
"http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>&#160;©&#160;2014&#160;<a href="http://www.w3.org/"><acronym title="World Wide Web Consortium">W3C</acronym></a><sup>®</sup>
(<a href="http://www.csail.mit.edu/"><acronym title=
"Massachusetts Institute of Technology">MIT</acronym></a>, <a href=
"http://www.ercim.eu/"><acronym title=
"European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>,
<a href="http://www.keio.ac.jp/">Keio</a>, <a href=
"http://ev.buaa.edu.cn/">Beihang</a>), All Rights Reserved. W3C
<a href=
"http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>,
<a href=
"http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a>
and <a href=
"http://www.w3.org/Consortium/Legal/copyright-documents">document
use</a> rules apply.</p>
</div>
<hr />
<div>
<h2><a name="abstract" id="abstract"></a>Abstract</h2>
<p>This specification defines the syntax and semantics of XSLT
<span>3.0</span>, a language for transforming XML documents into
other XML documents.</p>
<p>XSLT 3.0 is a revised version of the XSLT 2.0 Recommendation
<a href="#xslt20">[XSLT 2.0]</a> published on 23 January 2007.</p>
<p>The primary purpose of the changes in this version of the
language is to enable transformations to be performed in streaming
mode, where neither the source document nor the result document is
ever held in memory in its entirety. Another important aim is to
improve the modularity of large stylesheets, allowing stylesheets
to be developed from independently-developed components with a high
level of software engineering robustness.</p>
<p>XSLT 3.0 is designed to be used in conjunction with XPath 3.0,
which is defined in <a href="#xpath-30">[XPath 3.0]</a>. XSLT
shares the same data model as XPath 3.0, which is defined in
<a href="#xpath-datamodel-30">[Data Model]</a>, and it uses the
library of functions and operators defined in <a href=
"#xpath-functions-30">[Functions and Operators]</a>. XPath 3.0 and
the underlying function library introduce a number of enhancements,
for example the availability of higher-order functions. Some of the
functions that were previously defined in <span>the XSLT 2.0</span>
specification, such as the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-date"><code>format-date</code></a><sup><small>FO30</small></sup>
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-number"><code>
format-number</code></a><sup><small>FO30</small></sup> functions,
are now defined in the standard function library to make them
available to other host languages.</p>
<p>XSLT 3.0 also includes optional facilities to serialize the
results of a transformation, by means of an interface to the
serialization component described in <a href=
"#xslt-xquery-serialization-30">[XSLT and XQuery
Serialization]</a>.</p>
<p><em>This document contains hyperlinks to specific sections or
definitions within other documents in this family of
specifications. These links are indicated visually by a superscript
identifying the target specification: for example XP30 for XPath
3.0, DM30 for the XDM data model version 3.0, FO30 for Functions
and Operators version 3.0.</em></p>
</div>
<div>
<h2><a name="status" id="status"></a>Status of this Document</h2>
<p><em>This section describes the status of this document at the
time of its publication. Other documents may supersede this
document. A list of current W3C publications and the latest
revision of this technical report can be found in the <a href=
"http://www.w3.org/TR/">W3C technical reports index at
http://www.w3.org/TR/.</a></em></p>
<p >This document is governed by the <a id="w3c_process_revision" href=
"http://www.w3.org/2005/10/Process-20051014/">14 October 2005 W3C
Process Document</a>.</p>
<p>This is a <a href=
"http://www.w3.org/2005/10/Process-20051014/tr.html#last-call">Last
Call Working Draft</a> as described in the <a href=
"http://www.w3.org/2005/10/Process-20051014/">W3C Process
Document</a>. It has been developed by the <a href=
"http://www.w3.org/Style/XSL/">W3C XSLT Working Group</a>, which is
part of the <a href="http://www.w3.org/XML/Activity">XML
Activity</a>. Comments on this document will be formally accepted
until 26 November 2014. The Working Group expects to advance this
specification to <a href=
"http://www.w3.org/2005/10/Process-20051014/tr.html#RecsW3C">Recommendation</a>
Status.</p>
<p>This specification has been developed in conjunction with
<a href="#xpath-30">[XPath 3.0]</a> and other documents that
underpin both XSLT and XQuery. XSLT 3.0 is dependent on XPath 3.0,
which is already at Recommendation status. The relationship of XSLT
3.0 to XPath 3.1, which us currently under development, is being
kept under constant review, and may change before final
publication.</p>
<p><em>This document specifies extensions to the XDM 3.0 data model
and to XPath 3.0 language syntax to underpin the introduction of
maps, which have been found necessary to support some XSLT
streaming use cases and make many other processing tasks easier.
This has involved extensive consultation with the XQuery Working
Group (which has joint responsibility for XDM and XPath), and these
extensions have been incorporated into working drafts of XDM 3.1
and XPath 3.1.</em></p>
<p>Changes since the previous Recommendation are listed in <a href=
"#changes-since-2.0"><i>J Changes since XSLT 2.0</i></a>. The only
incompatibilities with XSLT 2.0 relate to the way in which certain
error conditions are handled: the details are given in <a href=
"#incompatibilities"><i>M Incompatibilities with XSLT
2.0</i></a>.</p>
<p>A previous Last Call Working Draft was published on 12 December
2013. Some 148 comments were received and most of these resulted to
changes in the specification. There are also a number changes
resulting from the incorporation of previously-agreed XSLT 2.0
errata which had been accidentally omitted from previous XSLT 3.0
drafts. The changes are listed at <a href=
"#changes-since-dec-2013"><i>L Changes since the Last Call Working
Draft of 12 December 2013</i></a>. The change-marked version of
this publication links each entry in the change list to the
specific places in the text that changed as a result. Some of the
changes are substantive. Many are concerned with the detailed rules
for streamability of stylesheets. Most of the changes result from
practical experience in implementing product features and writing
test cases.</p>
<p>Please report errors in this document using W3C's <a href=
"https://www.w3.org/Bugs/Public/">public Bugzilla system</a>
(instructions can be found at <a href=
"http://www.w3.org/XML/2005/04/qt-bugzilla">http://www.w3.org/XML/2005/04/qt-bugzilla</a>).
If access to that system is not feasible, you may send your
comments to the W3C XSLT/XPath/XQuery public comments mailing list,
<a href=
"mailto:public-qt-comments@w3.org">public-qt-comments@w3.org</a>.
It will be very helpful if you include the string "[XSLT30]" in the
subject line of your report, whether made in Bugzilla or in email.
Please use multiple Bugzilla entries (or, if necessary, multiple
email messages) if you have more than one comment to make. Archives
of the comments and responses are available at <a href=
"http://lists.w3.org/Archives/Public/public-qt-comments/">http://lists.w3.org/Archives/Public/public-qt-comments/</a>.</p>
<p>A public test suite for XSLT 3.0 is under development.
Implementers and others are encouraged to run these tests, to
submit comments and contributions, and to report their results. The
test suite is available at <a href=
"https://dvcs.w3.org/hg/xslt30-test/">https://dvcs.w3.org/hg/xslt30-test/</a>.</p>
<p>Publication as a Last Call Working Draft does not imply
endorsement by the W3C Membership. This is a draft document and may
be updated, replaced or obsoleted by other documents at any time.
It is inappropriate to cite this document as other than work in
progress.</p>
<p>This document was produced by a group operating under the
<a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5
February 2004 W3C Patent Policy</a>. W3C maintains a <a href=
"http://www.w3.org/2004/01/pp-impl/19552/status#disclosures">public
list of any patent disclosures</a> made in connection with the
deliverables of the group; that page also includes instructions for
disclosing a patent. An individual who has actual knowledge of a
patent which the individual believes contains <a href=
"http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">
Essential Claim(s)</a> must disclose the information in accordance
with <a href=
"http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">
section 6 of the W3C Patent Policy</a>.</p>
</div>
<div class="toc">
<h2><a name="contents" id="contents"></a>Table of Contents</h2>
<p class="toc">1 <a href="#introduction">Introduction</a><br />
&#160;&#160;&#160;&#160;1.1 <a href="#what-is-xslt">What is
XSLT?</a><br />
&#160;&#160;&#160;&#160;1.2 <a href="#whats-new-in-xslt3">What's
New in XSLT 3.0?</a><br />
2 <a href="#concepts">Concepts</a><br />
&#160;&#160;&#160;&#160;2.1 <a href=
"#terminology">Terminology</a><br />
&#160;&#160;&#160;&#160;2.2 <a href="#notation">Notation</a><br />
&#160;&#160;&#160;&#160;2.3 <a href="#initiating">Initiating a
Transformation</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.3.1 <a href=
"#info-for-static-analysis">Information needed for Static
Analysis</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.3.2 <a href=
"#priming-stylesheet">Priming a Stylesheet</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.3.3 <a href=
"#invoking-initial-mode">Apply-Templates Invocation</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.3.4 <a href=
"#invoking-initial-template">Call-Template Invocation</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.3.5 <a href=
"#invoking-initial-function">Function Call Invocation</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2.3.6 <a href=
"#post-processing">Post-processing the Raw Result</a><br />
&#160;&#160;&#160;&#160;2.4 <a href=
"#executing-a-transformation">Executing a Transformation</a><br />
&#160;&#160;&#160;&#160;2.5 <a href="#context">The Evaluation
Context</a><br />
&#160;&#160;&#160;&#160;2.6 <a href=
"#parsing-and-serialization">Parsing and Serialization</a><br />
&#160;&#160;&#160;&#160;2.7 <a href=
"#packages-and-modules">Packages and Modules</a><br />
&#160;&#160;&#160;&#160;2.8 <a href=
"#extensibility">Extensibility</a><br />
&#160;&#160;&#160;&#160;2.9 <a href=
"#stylesheets-and-schemas">Stylesheets and XML Schemas</a><br />
&#160;&#160;&#160;&#160;2.10 <a href=
"#streaming-concepts">Streaming</a><br />
&#160;&#160;&#160;&#160;2.11 <a href="#errors">Error
Handling</a><br />
3 <a href="#stylesheet-structure">Stylesheet Structure</a><br />
&#160;&#160;&#160;&#160;3.1 <a href="#xslt-namespace">XSLT
Namespace</a><br />
&#160;&#160;&#160;&#160;3.2 <a href="#reserved-namespaces">Reserved
Namespaces</a><br />
&#160;&#160;&#160;&#160;3.3 <a href=
"#extension-attributes">Extension Attributes</a><br />
&#160;&#160;&#160;&#160;3.4 <a href="#xslt-media-type">XSLT Media
Type</a><br />
&#160;&#160;&#160;&#160;3.5 <a href="#standard-attributes">Standard
Attributes</a><br />
&#160;&#160;&#160;&#160;3.6 <a href="#packages">Packages</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.6.1 <a href=
"#package-versions">Versions of a Package</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.6.2 <a href=
"#package-dependencies">Dependencies between Packages</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.6.3 <a href=
"#named-components">Named Components in Packages</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.6.3.1
<a href="#visibility">Visibility of Components</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.6.3.2
<a href="#accepting-components">Accepting Components</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.6.3.3
<a href="#package-overriding-components">Overriding Named
Components from a Used Package</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.6.3.4
<a href="#component-references">Binding References to
Components</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.6.4 <a href=
"#modes-and-packages">Overriding Template Rules from a Used
Package</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.6.4.1
<a href="#requiring-explicit-modes">Requiring Explicit Mode
Declarations</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.6.5 <a href=
"#package-local-declarations">Declarations Local to a
Package</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.6.6 <a href=
"#declaring-global-context-item">Declaring the Global Context
Item</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.6.7 <a href=
"#xquery-packages">Using an XQuery Library Package</a><br />
&#160;&#160;&#160;&#160;3.7 <a href=
"#stylesheet-modules">Stylesheet Modules</a><br />
&#160;&#160;&#160;&#160;3.8 <a href=
"#stylesheet-element">Stylesheet Element</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.8.1 <a href=
"#default-collation-attribute">The default-collation
Attribute</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.8.2 <a href=
"#default-mode">The [xsl:]default-mode Attribute</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.8.3 <a href=
"#user-defined-top-level">User-defined Data Elements</a><br />
&#160;&#160;&#160;&#160;3.9 <a href=
"#simplified-stylesheet">Simplified Stylesheet Modules</a><br />
&#160;&#160;&#160;&#160;3.10 <a href="#backwards">Backwards
Compatible Processing</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.10.1 <a href=
"#backwards-1.0">XSLT 1.0 Compatibility Mode</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.10.2 <a href=
"#backwards-2.0">XSLT 2.0 Compatibility Mode</a><br />
&#160;&#160;&#160;&#160;3.11 <a href="#forwards">Forwards
Compatible Processing</a><br />
&#160;&#160;&#160;&#160;3.12 <a href="#combining-modules">Combining
Stylesheet Modules</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.12.1 <a href=
"#locating-modules">Locating Stylesheet Modules</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.12.2 <a href=
"#include">Stylesheet Inclusion</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.12.3 <a href=
"#import">Stylesheet Import</a><br />
&#160;&#160;&#160;&#160;3.13 <a href="#embedded">Embedded
Stylesheet Modules</a><br />
&#160;&#160;&#160;&#160;3.14 <a href="#preprocessing">Stylesheet
Preprocessing</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.14.1 <a href=
"#conditional-inclusion">Conditional Element Inclusion</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.14.2 <a href=
"#shadow-attributes">Shadow Attributes</a><br />
&#160;&#160;&#160;&#160;3.15 <a href="#built-in-types">Built-in
Types</a><br />
&#160;&#160;&#160;&#160;3.16 <a href="#import-schema">Importing
Schema Components</a><br />
4 <a href="#data-model">Data Model</a><br />
&#160;&#160;&#160;&#160;4.1 <a href="#xml-versions">XML
Versions</a><br />
&#160;&#160;&#160;&#160;4.2 <a href=
"#stylesheet-stripping">Stripping Whitespace from the
Stylesheet</a><br />
&#160;&#160;&#160;&#160;4.3 <a href=
"#stripping-annotations">Stripping Type Annotations from a Source
Tree</a><br />
&#160;&#160;&#160;&#160;4.4 <a href="#strip">Stripping Whitespace
from a Source Tree</a><br />
&#160;&#160;&#160;&#160;4.5 <a href="#id-in-data-model">Attribute
Types and DTD Validation</a><br />
&#160;&#160;&#160;&#160;4.6 <a href="#model-for-streaming">Data
Model for Streaming</a><br />
&#160;&#160;&#160;&#160;4.7 <a href="#limits">Limits</a><br />
&#160;&#160;&#160;&#160;4.8 <a href="#d-o-e-in-data-model">Disable
Output Escaping</a><br />
5 <a href="#constructs">Features of the XSLT Language</a><br />
&#160;&#160;&#160;&#160;5.1 <a href="#qname">Qualified
Names</a><br />
&#160;&#160;&#160;&#160;5.2 <a href="#unprefixed-qnames">Unprefixed
Lexical QNames in Expressions and Patterns</a><br />
&#160;&#160;&#160;&#160;5.3 <a href=
"#expressions">Expressions</a><br />
&#160;&#160;&#160;&#160;5.4 <a href=
"#static-and-dynamic-context">The Static and Dynamic
Context</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.4.1 <a href=
"#static-context">Initializing the Static Context</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.4.2 <a href=
"#additional-static-context">Additional Static Context Components
used by XSLT</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.4.3 <a href=
"#xpath-dynamic-context">Initializing the Dynamic Context</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.4.3.1
<a href="#focus">Maintaining Position: the Focus</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.4.3.2
<a href="#evaluation-context">Other Components of the XPath Dynamic
Context</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.4.4 <a href=
"#additional-dynamic-context">Additional Dynamic Context Components
used by XSLT</a><br />
&#160;&#160;&#160;&#160;5.5 <a href=
"#defining-decimal-format">Defining a Decimal Format</a><br />
&#160;&#160;&#160;&#160;5.6 <a href="#patterns">Patterns</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.6.1 <a href=
"#pattern-examples">Examples of Patterns</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.6.2 <a href=
"#pattern-syntax">Syntax of Patterns</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.6.3 <a href=
"#pattern-semantics">The Meaning of a Pattern</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.6.4 <a href=
"#pattern-errors">Errors in Patterns</a><br />
&#160;&#160;&#160;&#160;5.7 <a href="#value-templates">Value
Templates</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.7.1 <a href=
"#attribute-value-templates">Attribute Value Templates</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.7.2 <a href=
"#text-value-templates">Text Value Templates</a><br />
&#160;&#160;&#160;&#160;5.8 <a href=
"#sequence-constructors">Sequence Constructors</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.8.1 <a href=
"#constructing-complex-content">Constructing Complex
Content</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.8.2 <a href=
"#constructing-simple-content">Constructing Simple
Content</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.8.3 <a href=
"#namespace-fixup">Namespace Fixup</a><br />
&#160;&#160;&#160;&#160;5.9 <a href="#uri-references">URI
References</a><br />
6 <a href="#rules">Template Rules</a><br />
&#160;&#160;&#160;&#160;6.1 <a href="#defining-templates">Defining
Templates</a><br />
&#160;&#160;&#160;&#160;6.2 <a href=
"#defining-template-rules">Defining Template Rules</a><br />
&#160;&#160;&#160;&#160;6.3 <a href="#applying-templates">Applying
Template Rules</a><br />
&#160;&#160;&#160;&#160;6.4 <a href="#conflict">Conflict Resolution
for Template Rules</a><br />
&#160;&#160;&#160;&#160;6.5 <a href="#default-priority">Default
Priority for Template Rules</a><br />
&#160;&#160;&#160;&#160;6.6 <a href="#modes">Modes</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;6.6.1 <a href=
"#declaring-modes">Declaring Modes</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;6.6.2 <a href=
"#using-modes">Using Modes</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;6.6.3 <a href=
"#xsl-mode-typed">Declaring the Type of Nodes Processed by a
Mode</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;6.6.4 <a href=
"#streamable-templates">Streamable Templates</a><br />
&#160;&#160;&#160;&#160;6.7 <a href="#built-in-rule">Built-in
Template Rules</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;6.7.1 <a href=
"#built-in-templates-text-only-copy">Built-in Templates: Text-only
Copy</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;6.7.2 <a href=
"#built-in-templates-deep-copy">Built-in Templates: Deep
Copy</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;6.7.3 <a href=
"#built-in-templates-shallow-copy">Built-in Templates: Shallow
Copy</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;6.7.4 <a href=
"#built-in-templates-deep-skip">Built-in Templates: Deep
Skip</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;6.7.5 <a href=
"#built-in-templates-shallow-skip">Built-in Templates: Shallow
Skip</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;6.7.6 <a href=
"#built-in-templates-fail">Built-in Templates: Fail</a><br />
&#160;&#160;&#160;&#160;6.8 <a href="#apply-imports">Overriding
Template Rules</a><br />
&#160;&#160;&#160;&#160;6.9 <a href=
"#parameters-to-template-rules">Passing Parameters to Template
Rules</a><br />
7 <a href="#repetition">Repetition</a><br />
&#160;&#160;&#160;&#160;7.1 <a href="#for-each">The xsl:for-each
instruction</a><br />
&#160;&#160;&#160;&#160;7.2 <a href="#iterate">The xsl:iterate
Instruction</a><br />
8 <a href="#conditionals">Conditional Processing</a><br />
&#160;&#160;&#160;&#160;8.1 <a href="#xsl-if">Conditional
Processing with xsl:if</a><br />
&#160;&#160;&#160;&#160;8.2 <a href="#xsl-choose">Conditional
Processing with xsl:choose</a><br />
&#160;&#160;&#160;&#160;8.3 <a href=
"#try-catch">Try/Catch</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;8.3.1 <a href=
"#recovery">Recovery of Result Trees</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;8.3.2 <a href=
"#try-catch-examples">Try/Catch Examples</a><br />
9 <a href="#variables-and-parameters">Variables and
Parameters</a><br />
&#160;&#160;&#160;&#160;9.1 <a href=
"#variables">Variables</a><br />
&#160;&#160;&#160;&#160;9.2 <a href=
"#parameters">Parameters</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;9.2.1 <a href=
"#parameter-type">The Required Type of a Parameter</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;9.2.2 <a href=
"#default-values-of-parameters">Default Values of
Parameters</a><br />
&#160;&#160;&#160;&#160;9.3 <a href="#variable-values">Values of
Variables and Parameters</a><br />
&#160;&#160;&#160;&#160;9.4 <a href="#temporary-trees">Creating
Implicit Document Nodes</a><br />
&#160;&#160;&#160;&#160;9.5 <a href="#global-variables">Global
Variables and Parameters</a><br />
&#160;&#160;&#160;&#160;9.6 <a href="#static-params">Static
Variables and Parameters</a><br />
&#160;&#160;&#160;&#160;9.7 <a href="#static-expression">Static
Expressions</a><br />
&#160;&#160;&#160;&#160;9.8 <a href="#local-variables">Local
Variables and Parameters</a><br />
&#160;&#160;&#160;&#160;9.9 <a href="#scope-of-variables">Scope of
Variables</a><br />
&#160;&#160;&#160;&#160;9.10 <a href="#with-param">Setting
Parameter Values</a><br />
&#160;&#160;&#160;&#160;9.11 <a href="#circularity">Circular
Definitions</a><br />
10 <a href="#callable-components">Callable Components</a><br />
&#160;&#160;&#160;&#160;10.1 <a href="#named-templates">Named
Templates</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.1.1 <a href=
"#declaring-context-item">Declaring the Context Item for a
Template</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.1.2 <a href=
"#call-template-params">Passing Parameters to Named
Templates</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.1.3 <a href=
"#tunnel-params">Tunnel Parameters</a><br />
&#160;&#160;&#160;&#160;10.2 <a href="#attribute-sets">Named
Attribute Sets</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.2.1 <a href=
"#using-attribute-sets">Using Attribute Sets</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.2.2 <a href=
"#visibility-of-attribute-sets">Visibility of Attribute
Sets</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.2.3 <a href=
"#streamability-of-attribute-sets">Streamability of Attribute
Sets</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.2.4 <a href=
"#evaluating-attribute-sets">Evaluating Attribute Sets</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.2.5 <a href=
"#attribute-sets-examples">Attribute Sets: Examples</a><br />
&#160;&#160;&#160;&#160;10.3 <a href=
"#stylesheet-functions">Stylesheet Functions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.3.1 <a href=
"#xsl-function-name">Function Name and Arity</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.3.2 <a href=
"#function-arguments">Arguments</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.3.3 <a href=
"#function-result">Function Result</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.3.4 <a href=
"#function-visibility-and-overriding">Visibility and Overriding of
Functions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.3.5 <a href=
"#streamable-stylesheet-functions">Streamability of Stylesheet
Functions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.3.6 <a href=
"#function-lookup">Dynamic Access to Functions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.3.7 <a href=
"#function-determinism">Determinism of Functions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.3.8 <a href=
"#memoization">Memoization</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.3.9 <a href=
"#function-examples">Examples of Stylesheet Functions</a><br />
&#160;&#160;&#160;&#160;10.4 <a href="#dynamic-xpath">Dynamic XPath
Evaluation</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.4.1 <a href=
"#evaluate-static-context">Static context for the target
expression</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.4.2 <a href=
"#evaluate-dynamic-context">Dynamic context for the target
expression</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.4.3 <a href=
"#evaluate-effect">The effect of the xsl:evaluate
instruction</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.4.4 <a href=
"#evaluation-as-optional-feature">xsl:evaluate as an optional
feature</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.4.5 <a href=
"#evaluate-examples">Examples of xsl:evaluate</a><br />
11 <a href="#creating-new-nodes">Creating Nodes and
Sequences</a><br />
&#160;&#160;&#160;&#160;11.1 <a href=
"#literal-result-element">Literal Result Elements</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.1.1 <a href=
"#setting-annotation-for-lre">Setting the Type Annotation for
Literal Result Elements</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.1.2 <a href=
"#attributes-for-lres">Attribute Nodes for Literal Result
Elements</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.1.3 <a href=
"#lre-namespaces">Namespace Nodes for Literal Result
Elements</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.1.4 <a href=
"#conditional-literal-result-elements">Conditional Creation of
Literal Result Elements</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.1.5 <a href=
"#namespace-aliasing">Namespace Aliasing</a><br />
&#160;&#160;&#160;&#160;11.2 <a href="#xsl-element">Creating
Element Nodes Using xsl:element</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.2.1 <a href=
"#xsl-element-content">The Content of the Constructed Element
Node</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.2.2 <a href=
"#xsl-element-name">The Name of the Constructed Element
Node</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.2.3 <a href=
"#xsl-element-properties">Other Properties of the Constructed
Element Node</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.2.4 <a href=
"#annotation-for-constructed-element">The Type Annotation of the
Constructed Element Node</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.2.5 <a href=
"#xsl-element-on-empty">Conditional Construction of Element
Nodes</a><br />
&#160;&#160;&#160;&#160;11.3 <a href=
"#creating-attributes">Creating Attribute Nodes Using
xsl:attribute</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.3.1 <a href=
"#annotation-for-constructed-attribute">Setting the Type Annotation
for a Constructed Attribute Node</a><br />
&#160;&#160;&#160;&#160;11.4 <a href=
"#creating-text-nodes">Creating Text Nodes</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.4.1 <a href=
"#literal-text-nodes">Literal Text Nodes</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.4.2 <a href=
"#xsl-text">Creating Text Nodes Using xsl:text</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.4.3 <a href=
"#value-of">Generating Text with xsl:value-of</a><br />
&#160;&#160;&#160;&#160;11.5 <a href=
"#creating-document-nodes">Creating Document Nodes</a><br />
&#160;&#160;&#160;&#160;11.6 <a href=
"#creating-processing-instructions">Creating Processing
Instructions</a><br />
&#160;&#160;&#160;&#160;11.7 <a href=
"#creating-namespace-nodes">Creating Namespace Nodes</a><br />
&#160;&#160;&#160;&#160;11.8 <a href="#creating-comments">Creating
Comments</a><br />
&#160;&#160;&#160;&#160;11.9 <a href="#copying">Copying
Nodes</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.9.1 <a href=
"#shallow-copy">Shallow Copy</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.9.1.1
<a href="#conditional-copy">Conditional Copying of Nodes</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.9.2 <a href=
"#copy-of">Deep Copy</a><br />
&#160;&#160;&#160;&#160;11.10 <a href=
"#constructing-sequences">Constructing Sequences</a><br />
12 <a href="#number">Numbering</a><br />
&#160;&#160;&#160;&#160;12.1 <a href=
"#formatting-supplied-number">Formatting a Supplied
Number</a><br />
&#160;&#160;&#160;&#160;12.2 <a href=
"#numbering-based-on-position">Numbering based on Position in a
Document</a><br />
&#160;&#160;&#160;&#160;12.3 <a href="#convert">Number to String
Conversion Attributes</a><br />
13 <a href="#sorting">Sorting</a><br />
&#160;&#160;&#160;&#160;13.1 <a href="#xsl-sort">The xsl:sort
Element</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;13.1.1 <a href=
"#sorting-process">The Sorting Process</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;13.1.2 <a href=
"#comparing-sort-keys">Comparing Sort Key Values</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;13.1.3 <a href=
"#collating-sequences">Sorting Using Collations</a><br />
&#160;&#160;&#160;&#160;13.2 <a href=
"#creating-sorted-sequence">Creating a Sorted Sequence</a><br />
&#160;&#160;&#160;&#160;13.3 <a href="#sorted-iteration">Processing
a Sequence in Sorted Order</a><br />
&#160;&#160;&#160;&#160;13.4 <a href="#uca-collations">The Unicode
Collation Algorithm</a><br />
14 <a href="#grouping">Grouping</a><br />
&#160;&#160;&#160;&#160;14.1 <a href="#xsl-for-each-group">The
xsl:for-each-group Element</a><br />
&#160;&#160;&#160;&#160;14.2 <a href=
"#information-about-group">Accessing Information about the Current
Group Value</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;14.2.1 <a href=
"#func-current-group">fn:current-group</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;14.2.2 <a href=
"#func-current-grouping-key">fn:current-grouping-key</a><br />
&#160;&#160;&#160;&#160;14.3 <a href="#order-of-groups">Ordering
among Groups</a><br />
&#160;&#160;&#160;&#160;14.4 <a href="#grouping-examples">Examples
of Grouping</a><br />
&#160;&#160;&#160;&#160;14.5 <a href=
"#non-transitivity">Non-Transitivity</a><br />
15 <a href="#merging">Merging</a><br />
&#160;&#160;&#160;&#160;15.1 <a href=
"#merge-terminology">Terminology for Merging</a><br />
&#160;&#160;&#160;&#160;15.2 <a href="#merge-instruction">The
xsl:merge Instruction</a><br />
&#160;&#160;&#160;&#160;15.3 <a href=
"#merge-input-sequences">Selecting the Sequences to be
Merged</a><br />
&#160;&#160;&#160;&#160;15.4 <a href=
"#streamable-merging">Streamable Merging</a><br />
&#160;&#160;&#160;&#160;15.5 <a href="#merge-keys">Defining the
Merge Keys</a><br />
&#160;&#160;&#160;&#160;15.6 <a href=
"#current-merge-group-and-key">The Current Merge Group and
Key</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;15.6.1 <a href=
"#func-current-merge-group">fn:current-merge-group</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;15.6.2 <a href=
"#func-current-merge-key">fn:current-merge-key</a><br />
&#160;&#160;&#160;&#160;15.7 <a href="#merge-action">The
xsl:merge-action Element</a><br />
&#160;&#160;&#160;&#160;15.8 <a href="#merge-examples">Examples of
xsl:merge</a><br />
16 <a href="#splitting">Splitting</a><br />
&#160;&#160;&#160;&#160;16.1 <a href="#fork-instruction">The
xsl:fork Instruction</a><br />
&#160;&#160;&#160;&#160;16.2 <a href="#splitting-examples">Examples
of Splitting with Streamed Data</a><br />
17 <a href="#regular-expressions">Regular Expressions</a><br />
&#160;&#160;&#160;&#160;17.1 <a href="#analyze-string">The
xsl:analyze-string Instruction</a><br />
&#160;&#160;&#160;&#160;17.2 <a href=
"#func-regex-group">fn:regex-group</a><br />
&#160;&#160;&#160;&#160;17.3 <a href="#regex-examples">Examples of
Regular Expression Matching</a><br />
18 <a href="#streaming">Streaming</a><br />
&#160;&#160;&#160;&#160;18.1 <a href="#stream-instruction">The
xsl:stream Instruction</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;18.1.1 <a href=
"#stream-validation">Validation of Streamed Documents</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;18.1.2 <a href=
"#stream-examples">Examples of xsl:stream</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;18.1.3 <a href=
"#func-stream-available">fn:stream-available</a><br />
&#160;&#160;&#160;&#160;18.2 <a href=
"#accumulators">Accumulators</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;18.2.1 <a href=
"#accumulator-declaration">Declaring an Accumulator</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;18.2.2 <a href=
"#accumulator-informal-rules">Informal Model for
Accumulators</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;18.2.3 <a href=
"#accumulator-formal-rules">Formal Model for Accumulators</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;18.2.4 <a href=
"#func-accumulator-before">fn:accumulator-before</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;18.2.5 <a href=
"#func-accumulator-after">fn:accumulator-after</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;18.2.6 <a href=
"#accumulators-visibility-and-overriding">Visibility and Overriding
of Accumulators</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;18.2.7 <a href=
"#streamability-of-accumulators">Streamability of
Accumulators</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;18.2.8 <a href=
"#accumulator-examples">Examples of Accumulators</a><br />
&#160;&#160;&#160;&#160;18.3 <a href=
"#func-copy-of">fn:copy-of</a><br />
&#160;&#160;&#160;&#160;18.4 <a href=
"#func-snapshot">fn:snapshot</a><br />
19 <a href="#streamability">Streamability</a><br />
&#160;&#160;&#160;&#160;19.2 <a href=
"#determining-static-type">Determining the Static Type of a
Construct</a><br />
&#160;&#160;&#160;&#160;19.3 <a href=
"#determining-context-item-type">Determining the Context Item
Type</a><br />
&#160;&#160;&#160;&#160;19.4 <a href="#operand-roles">Operand
Roles</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.4.1 <a href=
"#operand-usage-examples">Examples showing the Effect of Operand
Usage</a><br />
&#160;&#160;&#160;&#160;19.5 <a href="#posture">Determining the
Posture of a Construct</a><br />
&#160;&#160;&#160;&#160;19.6 <a href=
"#determining-context-posture">Determining the Context
Posture</a><br />
&#160;&#160;&#160;&#160;19.7 <a href="#sweep">The Sweep of a
Construct</a><br />
&#160;&#160;&#160;&#160;19.8 <a href=
"#classifying-constructs">Classifying Constructs</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.1 <a href=
"#general-streamability-rules">General Rules for
Streamability</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.2 <a href=
"#general-streamability-examples">Examples of the General
Streamability Rules</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.3 <a href=
"#classifying-sequence-constructors">Classifying Sequence
Constructors</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4 <a href=
"#classifying-instructions">Classifying Instructions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.1
<a href="#streamability-literal-result-elements">Streamability of
Literal Result Elements</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.2
<a href="#streamability-extension-instructions">Streamability of
extension instructions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.3
<a href="#streamability-xsl-analyze-string">Streamability of
xsl:analyze-string</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.4
<a href="#streamability-xsl-apply-imports">Streamability of
xsl:apply-imports</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.5
<a href="#streamability-xsl-apply-templates">Streamability of
xsl:apply-templates</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.6
<a href="#streamability-xsl-assert">Streamability of
xsl:assert</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.7
<a href="#streamability-xsl-attribute">Streamability of
xsl:attribute</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.8
<a href="#streamability-xsl-break">Streamability of
xsl:break</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.9
<a href="#streamability-xsl-call-template">Streamability of
xsl:call-template</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.10
<a href="#streamability-xsl-choose">Streamability of
xsl:choose</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.11
<a href="#streamability-xsl-comment">Streamability of
xsl:comment</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.12
<a href="#streamability-xsl-copy">Streamability of
xsl:copy</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.13
<a href="#streamability-xsl-copy-of">Streamability of
xsl:copy-of</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.14
<a href="#streamability-xsl-document">Streamability of
xsl:document</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.15
<a href="#streamability-xsl-element">Streamability of
xsl:element</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.16
<a href="#streamability-xsl-evaluate">Streamability of
xsl:evaluate</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.17
<a href="#streamability-xsl-fallback">Streamability of
xsl:fallback</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.18
<a href="#streamability-xsl-for-each">Streamability of
xsl:for-each</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.19
<a href="#streamability-xsl-for-each-group">Streamability of
xsl:for-each-group</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.20
<a href="#streamability-xsl-fork">Streamability of
xsl:fork</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.21
<a href="#streamability-xsl-if">Streamability of xsl:if</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.22
<a href="#streamability-xsl-iterate">Streamability of
xsl:iterate</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.23
<a href="#streamability-xsl-map">Streamability of xsl:map</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.24
<a href="#streamability-xsl-map-entry">Streamability of
xsl:map-entry</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.25
<a href="#streamability-xsl-merge">Streamability of
xsl:merge</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.26
<a href="#streamability-xsl-message">Streamability of
xsl:message</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.27
<a href="#streamability-xsl-namespace">Streamability of
xsl:namespace</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.28
<a href="#streamability-xsl-next-iteration">Streamability of
xsl:next-iteration</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.29
<a href="#streamability-xsl-next-match">Streamability of
xsl:next-match</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.30
<a href="#streamability-xsl-number">Streamability of
xsl:number</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.31
<a href="#streamability-xsl-perform-sort">Streamability of
xsl:perform-sort</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.32
<a href="#streamability-xsl-processing-instruction">Streamability
of xsl:processing-instruction</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.33
<a href="#streamability-xsl-result-document">Streamability of
xsl:result-document</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.34
<a href="#streamability-xsl-sequence">Streamability of
xsl:sequence</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.35
<a href="#streamability-xsl-stream">Streamability of
xsl:stream</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.36
<a href="#streamability-xsl-text">Streamability of
xsl:text</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.37
<a href="#streamability-xsl-try">Streamability of xsl:try</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.38
<a href="#streamability-xsl-value-of">Streamability of
xsl:value-of</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.4.39
<a href="#streamability-xsl-variable">Streamability of
xsl:variable</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.5 <a href=
"#classifying-attribute-sets">Classifying Attribute Sets</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.6 <a href=
"#classifying-vts">Classifying Value Templates</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.7 <a href=
"#classifying-expressions">Classifying Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.7.1
<a href="#streamability-of-for-expressions">Streamability of for
expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.7.2
<a href="#streamability-of-quantified-expressions">Streamability of
Quantified Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.7.3
<a href="#streamability-of-if-expressions">Streamability of if
expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.7.4
<a href="#streamability-of-union-expressions">Streamability of
union, intersect, and except expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.7.5
<a href=
"#streamability-of-simple-mapping-expressions">Streamability of
Simple Mapping Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.7.6
<a href="#streamability-of-path-expressions">Streamability of Path
Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.7.7
<a href="#streamability-of-axis-steps">Streamability of Axis
Steps</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.7.8
<a href="#streamability-of-filter-expressions">Streamability of
Filter Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.7.9
<a href="#streamability-of-dynamic-function-calls">Streamability of
Dynamic Function Calls</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.7.10
<a href="#streamability-of-variable-references">Streamability of
Variable References</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.7.11
<a href="#streamability-of-context-item-expression">Streamability
of the Context Item Expression</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.7.12
<a href="#streamability-of-function-calls">Streamability of
Function Calls</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.7.13
<a href="#streamability-of-named-function-ref">Streamability of
Named Function References</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.7.14
<a href="#streamability-of-inline-functions">Streamability of
Inline Function Declarations</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.7.15
<a href="#streamability-of-map-expressions">Streamability of map
expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.8 <a href=
"#classifying-built-in-functions">Classifying Calls to Built-In
Functions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.8.1
<a href="#streamability-fn-accumulator-after">Streamability of the
accumulator-after function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.8.2
<a href="#streamability-fn-accumulator-before">Streamability of the
accumulator-before function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.8.3
<a href="#streamability-fn-current">Streamability of the current
function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.8.4
<a href="#streamability-fn-current-group">Streamability of the
current-group function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.8.5
<a href="#streamability-fn-current-grouping-key">Streamability of
the current-grouping-key function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.8.6
<a href="#streamability-fn-current-merge-group">Streamability of
the current-merge-group function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.8.7
<a href="#streamability-fn-current-merge-key">Streamability of the
current-merge-key function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.8.8
<a href="#streamability-fn-fold-left">Streamability of the
fold-left function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.8.9
<a href="#streamability-fn-fold-right">Streamability of the
fold-right function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.8.10
<a href="#streamability-fn-for-each">Streamability of the for-each
function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.8.11
<a href="#streamability-fn-for-each-pair">Streamability of the
for-each-pair function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.8.12
<a href="#streamability-fn-function-lookup">Streamability of the
function-lookup function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.8.13
<a href="#streamability-fn-innermost">Streamability of the
innermost function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.8.14
<a href="#streamability-fn-last">Streamability of the last
function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.8.15
<a href="#streamability-fn-outermost">Streamability of the
outermost function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.8.16
<a href="#streamability-fn-position">Streamability of the position
function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.8.17
<a href="#streamability-fn-reverse">Streamability of the reverse
function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.8.18
<a href="#streamability-fn-root">Streamability of the root
function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.8.19
<a href="#streamability-fn-unparsed-entity-public-id">Streamability
of the unparsed-entity-public-id function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.8.20
<a href="#streamability-fn-unparsed-entity-uri">Streamability of
the unparsed-entity-uri function</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.8.9 <a href=
"#classifying-patterns">Classifying Patterns</a><br />
&#160;&#160;&#160;&#160;19.9 <a href=
"#streamability-analysis-examples">Examples of Streamability
Analysis</a><br />
&#160;&#160;&#160;&#160;19.10 <a href=
"#streamability-guarantees">Streamability Guarantees</a><br />
20 <a href="#add-func">Additional Functions</a><br />
&#160;&#160;&#160;&#160;20.1 <a href=
"#func-document">fn:document</a><br />
&#160;&#160;&#160;&#160;20.2 <a href="#key">Keys</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;20.2.1 <a href=
"#xsl-key">The xsl:key Declaration</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;20.2.2 <a href=
"#func-key">fn:key</a><br />
&#160;&#160;&#160;&#160;20.3 <a href="#misc-func">Miscellaneous
Additional Functions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;20.3.1 <a href=
"#func-current">fn:current</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;20.3.2 <a href=
"#func-unparsed-entity-uri">fn:unparsed-entity-uri</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;20.3.3 <a href=
"#func-unparsed-entity-public-id">fn:unparsed-entity-public-id</a><br />

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;20.3.4 <a href=
"#func-system-property">fn:system-property</a><br />
21 <a href="#additional-types">XPath Extensions</a><br />
&#160;&#160;&#160;&#160;21.1 <a href="#map">Maps</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;21.1.1 <a href=
"#map-type">The Type of a Map</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;21.1.2 <a href=
"#map-functions">Functions that Operate on Maps</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;21.1.2.1
<a href="#func-map-merge">map:merge</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;21.1.2.2
<a href="#func-map-size">map:size</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;21.1.2.3
<a href="#func-map-keys">map:keys</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;21.1.2.4
<a href="#func-map-contains">map:contains</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;21.1.2.5
<a href="#func-map-get">map:get</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;21.1.2.6
<a href="#func-map-put">map:put</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;21.1.2.7
<a href="#func-map-entry">map:entry</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;21.1.2.8
<a href="#func-map-remove">map:remove</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;21.1.2.9
<a href="#func-map-for-each">map:for-each</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;21.1.2.10
<a href="#func-collation-key">fn:collation-key</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;21.1.2.12
<a href="#func-deep-equal">fn:deep-equal</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;21.1.3 <a href=
"#map-instructions">Map Instructions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;21.1.4 <a href=
"#map-expressions">Map Expressions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;21.1.5 <a href=
"#maps-streaming">Maps and Streaming</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;21.1.6 <a href=
"#map-examples">Examples using Maps</a><br />
&#160;&#160;&#160;&#160;21.2 <a href="#json">Processing JSON
Data</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;21.2.1 <a href=
"#json-to-xml-mapping">XML Representation of JSON</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;21.2.2 <a href=
"#func-json-to-xml">fn:json-to-xml</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;21.2.3 <a href=
"#func-xml-to-json">fn:xml-to-json</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;21.2.4 <a href=
"#xml-to-json-transformation">Transforming XML to JSON</a><br />
22 <a href="#diagnostics">Diagnostics</a><br />
&#160;&#160;&#160;&#160;22.1 <a href="#message">Messages</a><br />
&#160;&#160;&#160;&#160;22.2 <a href=
"#assertions">Assertions</a><br />
23 <a href="#extension">Extensibility and Fallback</a><br />
&#160;&#160;&#160;&#160;23.1 <a href=
"#extension-functions">Extension Functions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;23.1.1 <a href=
"#func-function-available">fn:function-available</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;23.1.2 <a href=
"#calling-extension-functions">Calling Extension
Functions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;23.1.3 <a href=
"#external-objects">External Objects</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;23.1.4 <a href=
"#func-type-available">fn:type-available</a><br />
&#160;&#160;&#160;&#160;23.2 <a href=
"#extension-instruction">Extension Instructions</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;23.2.1 <a href=
"#designating-extension-namespace">Designating an Extension
Namespace</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;23.2.2 <a href=
"#func-element-available">fn:element-available</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;23.2.3 <a href=
"#fallback">Fallback</a><br />
24 <a href="#result-trees">Final Result Trees</a><br />
&#160;&#160;&#160;&#160;24.1 <a href=
"#creating-result-trees">Creating Final Result Trees</a><br />
&#160;&#160;&#160;&#160;24.2 <a href=
"#result-document-restrictions">Restrictions on the use of
xsl:result-document</a><br />
&#160;&#160;&#160;&#160;24.3 <a href="#current-output-uri">The
Current Output URI</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;24.3.1 <a href=
"#func-current-output-uri">fn:current-output-uri</a><br />
&#160;&#160;&#160;&#160;24.4 <a href=
"#validation">Validation</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;24.4.1 <a href=
"#validating-constructed-nodes">Validating Constructed Elements and
Attributes</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;24.4.1.1
<a href="#validating-using-validation-attribute">Validation using
the [xsl:]validation Attribute</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;24.4.1.2
<a href="#validation-xsl-type">Validation using the [xsl:]type
Attribute</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;24.4.1.3
<a href="#validation-process">The Validation Process</a><br />
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;24.4.2 <a href=
"#validating-document-nodes">Validating Document Nodes</a><br />
25 <a href="#serialization">Serialization</a><br />
&#160;&#160;&#160;&#160;25.1 <a href="#character-maps">Character
Maps</a><br />
&#160;&#160;&#160;&#160;25.2 <a href=
"#disable-output-escaping">Disabling Output Escaping</a><br />
26 <a href="#conformance">Conformance</a><br />
&#160;&#160;&#160;&#160;26.1 <a href="#basic-conformance">Basic
XSLT Processor</a><br />
&#160;&#160;&#160;&#160;26.2 <a href=
"#schema-aware-conformance">Schema-Awareness Conformance
Feature</a><br />
&#160;&#160;&#160;&#160;26.3 <a href=
"#serialization-feature">Serialization Feature</a><br />
&#160;&#160;&#160;&#160;26.4 <a href=
"#backwards-compatibility-feature">Compatibility Features</a><br />
&#160;&#160;&#160;&#160;26.5 <a href="#streaming-feature">Streaming
Feature</a><br />
&#160;&#160;&#160;&#160;26.6 <a href=
"#dynamic-evaluation-feature">Dynamic Evaluation Feature</a><br />
&#160;&#160;&#160;&#160;26.7 <a href=
"#xquery-invocation-feature">XQuery Invocation
Feature</a><br /></p>
<h3><a name="appendices" id="appendices"></a>Appendices</h3>
<p class="toc">A <a href="#references">References</a><br />
&#160;&#160;&#160;&#160;A.1 <a href=
"#normative-references">Normative References</a><br />
&#160;&#160;&#160;&#160;A.2 <a href="#other-references">Other
References</a><br />
B <a href="#json-in-xml">XML Representation of JSON</a><br />
&#160;&#160;&#160;&#160;B.1 <a href="#schema-for-json">Schema for
the XML Representation of JSON</a><br />
&#160;&#160;&#160;&#160;B.2 <a href=
"#xml-to-json-stylesheet">Stylesheet for converting XML to JSON
(without indentation)</a><br />
C <a href="#glossary">Glossary</a> (Non-Normative)<br />
D <a href="#element-syntax-summary">Element Syntax Summary</a>
(Non-Normative)<br />
E <a href="#error-summary">Summary of Error Conditions</a>
(Non-Normative)<br />
F <a href="#implementation-defined-features">Checklist of
Implementation-Defined Features</a> (Non-Normative)<br />
G <a href="#XSLT-defined-functions">List of XSLT-defined
functions</a> (Non-Normative)<br />
H <a href="#schema-for-xslt">Schema for XSLT Stylesheets</a>
(Non-Normative)<br />
I <a href="#acknowledgements">Acknowledgements</a>
(Non-Normative)<br />
J <a href="#changes-since-2.0">Changes since XSLT 2.0</a>
(Non-Normative)<br />
&#160;&#160;&#160;&#160;J.1 <a href=
"#xslt-changes-since-2.0">Changes in this Specification</a><br />
&#160;&#160;&#160;&#160;J.2 <a href=
"#xpath-changes-since-2.0">Changes in Other Related
Specifications</a><br />
K <a href="#changes-since-july-2012">Changes since the Working
Draft of 10 July 2012</a> (Non-Normative)<br />
L <a href="#changes-since-dec-2013">Changes since the Last Call
Working Draft of 12 December 2013</a> (Non-Normative)<br />
M <a href="#incompatibilities">Incompatibilities with XSLT 2.0</a>
(Non-Normative)<br /></p>
</div>
<hr />
<div class="body">
<div class="div1">
<h2><a name="introduction" id="introduction"></a>1 <a href=
"#introduction" style="text-decoration: none">Introduction</a></h2>
<div class="div2">
<h3><a name="what-is-xslt" id="what-is-xslt"></a>1.1 <a href=
"#what-is-xslt" style="text-decoration: none">What is
XSLT?</a></h3>
<p>This specification defines the syntax and semantics of the XSLT
<span>3.0</span> language.</p>
<p>A transformation in the XSLT language is expressed in the form
of a <b>stylesheet</b>. A stylesheet is made up of one or more
well-formed XML <a href="#REC-xml">[XML 1.0]</a> documents
conforming to the Namespaces in XML Recommendation <a href=
"#xml-names">[Namespaces in XML]</a>.</p>
<p>A stylesheet generally includes elements that are defined by
XSLT as well as elements that are not defined by XSLT. XSLT-defined
elements are distinguished by use of the namespace
<code>http://www.w3.org/1999/XSL/Transform</code> (see <a href=
"#xslt-namespace"><i>3.1 XSLT Namespace</i></a>), which is referred
to in this specification as the <a title="XSLT namespace" class=
"termref" href="#dt-xslt-namespace">XSLT namespace</a>. Thus this
specification is a definition of the syntax and semantics of the
XSLT namespace.</p>
<p>The term <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> reflects the fact that one of the
important roles of XSLT is to add styling information to an XML
source document, by transforming it into a document consisting of
XSL formatting objects (see <a href="#xsl11">[XSL-FO]</a>), or into
another presentation-oriented format such as HTML, XHTML, or SVG.
However, XSLT is used for a wide range of transformation tasks, not
exclusively for formatting and presentation applications.</p>
<p>A transformation expressed in XSLT describes rules for
transforming zero or more source trees into one or more result
trees. The structure of these trees is described in <a href=
"#xpath-datamodel-30">[Data Model]</a>. The transformation is
achieved by a set of <a title="template rule" class="termref" href=
"#dt-template-rule">template rules</a>. A template rule associates
a <a title="pattern" class="termref" href=
"#dt-pattern">pattern</a>, which matches nodes in the source
document, with a <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a>. In many
cases, evaluating the sequence constructor will cause new nodes to
be constructed, which can be used to produce part of a result tree.
The structure of the result trees can be completely different from
the structure of the source trees. In constructing a result tree,
nodes from the source trees can be filtered and reordered, and
arbitrary structure can be added. This mechanism allows a <a title=
"stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>
to be applicable to a wide class of documents that have similar
source tree structures.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The use of the term <b>tree</b> in this document does not imply
the use of a data structure in memory that holds the entire
contents of the document at one time. It implies rather a logical
view of the XML input and output in which elements have a
hierarchic relationship to each other. When a source document is
being processed in a streaming manner, access to the nodes in this
tree is constrained, but it is still viewed and described as a
tree.</p>
</div>
<p>Stylesheets have a modular structure; they may contain several
packages developed independently of each other, and each package
may consist of several stylesheet modules.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-stylesheet" id="dt-stylesheet" title="stylesheet"></a>A
<b>stylesheet</b> consists of one or more packages: specifically,
one <a title="top-level package" class="termref" href=
"#dt-top-level-package">top-level package</a> and zero or more
<a title="library package" class="termref" href=
"#dt-library-package">library packages</a>.<span class=
"definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-top-level-package" id="dt-top-level-package" title=
"top-level package"></a>For a given transformation, one <a title=
"package" class="termref" href="#dt-package">package</a> functions
as the <b>top-level package</b>. The complete <a title="stylesheet"
class="termref" href="#dt-stylesheet">stylesheet</a> is assembled
by finding the packages referenced directly or indirectly from the
top-level package using <a href=
"#element-use-package"><code>xsl:use-package</code></a>
declarations: see <a href="#package-dependencies"><i>3.6.2
Dependencies between Packages</i></a>.<span class=
"definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-library-package" id="dt-library-package" title=
"library package"></a>Every <a title="package" class="termref"
href="#dt-package">package</a> within a <a title="stylesheet"
class="termref" href="#dt-stylesheet">stylesheet</a>, other than
the <a title="top-level package" class="termref" href=
"#dt-top-level-package">top-level package</a>, is referred to as a
<b>library package</b>.<span class="definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-principal-stylesheet-module" id=
"dt-principal-stylesheet-module" title=
"principal stylesheet module"></a>Within a <a title="package"
class="termref" href="#dt-package">package</a>, one <a title=
"stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet module</a> functions as the
<b>principal stylesheet module</b>. The complete package is
assembled by finding the stylesheet modules referenced directly or
indirectly from the principal stylesheet module using <a href=
"#element-include"><code>xsl:include</code></a> and <a href=
"#element-import"><code>xsl:import</code></a> elements: see
<a href="#include"><i>3.12.2 Stylesheet Inclusion</i></a> and
<a href="#import"><i>3.12.3 Stylesheet Import</i></a>.<span class=
"definition">]</span></p>
</div>
<div class="div2">
<h3><a name="whats-new-in-xslt3" id="whats-new-in-xslt3"></a>1.2
<a href="#whats-new-in-xslt3" style="text-decoration: none">What's
New in XSLT 3.0?</a></h3>
<p>A major focus for enhancements in XSLT 3.0 is the requirement to
enable streaming of source documents. This is needed when source
documents become too large to hold in main memory, and also for
applications where it is important to start delivering results
before the entire source document is available.</p>
<p>While implementations of XSLT that use streaming have always
been theoretically possible, the nature of the language has made it
very difficult to achieve this in practice. The approach adopted in
this specification is twofold: it identifies a set of restrictions
which, if followed by stylesheet authors, will enable
implementations to adopt a streaming mode of operation without
placing excessive demands on the optimization capabilities of the
processor; and it provides new constructs to indicate that
streaming is required, or to express transformations in a way that
makes it easier for the processor to adopt a streaming execution
plan.</p>
<p>Capabilities provided in this category include:</p>
<ul>
<li>
<p>A new <a href="#element-stream"><code>xsl:stream</code></a>
instruction, which reads and processes a source document in
streaming mode;</p>
</li>
<li>
<p>The ability to declare that a <a title="mode" class="termref"
href="#dt-mode">mode</a> is a streaming mode, in which case all the
template rules using that mode must be streamable;</p>
</li>
<li>
<p>A new <a href="#element-iterate"><code>xsl:iterate</code></a>
instruction, which iterates over the items in a sequence, allowing
parameters for the processing of one item to be set during the
processing of the previous item;</p>
</li>
<li>
<p>A new <a href="#element-merge"><code>xsl:merge</code></a>
instruction, allowing multiple input streams to be merged into a
single output stream;</p>
</li>
<li>
<p>A new <a href="#element-fork"><code>xsl:fork</code></a>
instruction, allowing multiple computations to be performed in
parallel during a single pass through an input document.</p>
</li>
<li>
<p><a title="accumulator function" class="termref" href=
"#dt-accumulator-function">Accumulators</a>, which allow a value to
be computed progressively during streamed processing of a document,
and accessed as a function of a node in the document, without
compromise to the functional nature of the XSLT language.</p>
</li>
</ul>
<p>A second focus for enhancements in XSLT 3.0 is the introduction
of a new mechanism for stylesheet modularity, called the package.
Unlike the stylesheet modules of XSLT 1.0 and 2.0 (which remain
available), a package defines an interface that regulates which
functions, variables, templates and other components are visible
outside the package, and which can be overridden. There are two
main goals for this facility: it is designed to deliver software
engineering benefits by improving the reusability and
maintainability of code, and it is intended to streamline
stylesheet deployment by allowing packages to be compiled
independently of each other, and compiled instances of packages to
be shared between multiple applications.</p>
<p>Other significant features in XSLT 3.0 include:</p>
<ul>
<li>
<p>An <a href="#element-evaluate"><code>xsl:evaluate</code></a>
instruction allowing evaluation of XPath expressions that are
dynamically constructed as strings, or that are read from a source
document;</p>
</li>
<li>
<p>Enhancements to the syntax of <a title="pattern" class="termref"
href="#dt-pattern">patterns</a>, in particular enabling the
matching of atomic values as well as nodes;</p>
</li>
<li>
<p>An <a href="#element-try"><code>xsl:try</code></a> instruction
to allow recovery from dynamic errors;</p>
</li>
<li>
<p>The element <a href=
"#element-global-context-item"><code>xsl:global-context-item</code></a>,
used to declare the stylesheet's expectations of the global context
item (notably, its type).</p>
</li>
<li>
<p>A new instruction <a href=
"#element-assert"><code>xsl:assert</code></a> to assist developers
in producing correct and robust code.</p>
</li>
</ul>
<p>XSLT 3.0 also delivers enhancements made to the XPath language
and to the standard function library, including the following:</p>
<ul>
<li>
<p>Variables can now be bound in XPath using the <code>let</code>
expression.</p>
</li>
<li>
<p>Functions are now first class values, and can be passed as
arguments to other (higher-order) functions, making XSLT a
fully-fledged functional programming language.</p>
</li>
<li>
<p>A number of new functions are available, for example
trigonometric functions, and the functions <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-parse-xml"><code>parse-xml</code></a><sup><small>FO30</small></sup>
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-serialize"><code>serialize</code></a><sup><small>FO30</small></sup>
to convert between lexical and tree representations of XML.</p>
</li>
</ul>
<p>This Working Draft includes support for maps (a data structure
consisting of key/value pairs, sometimes referred to in other
programming languages as dictionaries, hashes, or associative
arrays). This feature extends the data model, provides new syntax
in XPath, and adds a number of new functions and operators. The XSL
Working Group intends that these changes should eventually become
part of XPath: however, this has not yet been agreed with all
interested parties.</p>
<p>A full list of changes is at <a href="#changes-since-2.0"><i>J
Changes since XSLT 2.0</i></a>.</p>
</div>
</div>
<div class="div1">
<h2><a name="concepts" id="concepts"></a>2 <a href="#concepts"
style="text-decoration: none">Concepts</a></h2>
<div class="div2">
<h3><a name="terminology" id="terminology"></a>2.1 <a href=
"#terminology" style="text-decoration: none">Terminology</a></h3>
<p>For a full glossary of terms, see <a href="#glossary"><i>C
Glossary</i></a>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-processor" id="dt-processor" title="processor"></a>The software
responsible for transforming source trees into result trees using
an XSLT stylesheet is referred to as the <b>processor</b>. This is
sometimes expanded to <em>XSLT processor</em> to avoid any
confusion with other processors, for example an XML
processor.<span class="definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-implementation" id="dt-implementation" title=
"implementation"></a>A specific product that performs the functions
of an <a title="processor" class="termref" href=
"#dt-processor">XSLT processor</a> is referred to as an
<b>implementation</b>. <span class="definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-result-tree" id="dt-result-tree" title="result tree"></a>The
term <b>result tree</b> is used to refer to any tree constructed by
<a title="instruction" class="termref" href=
"#dt-instruction">instructions</a> in the stylesheet. A result tree
is either a <a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a> or a <a title=
"temporary tree" class="termref" href=
"#dt-temporary-tree">temporary tree</a>.<span class=
"definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-final-result-tree" id="dt-final-result-tree" title=
"final result tree"></a>A <b>final result tree</b> is a <a title=
"result tree" class="termref" href="#dt-result-tree">result
tree</a> that forms part of the final output of a transformation.
Once created, the contents of a final result tree are not
accessible within the stylesheet itself.<span class=
"definition">]</span> The <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction always creates a final result tree, and a final result
tree may also be created implicitly by post-processing the
<a title="raw result" class="termref" href="#dt-raw-result">raw
result</a> of a stylesheet evaluation. The conditions under which
this happens are described in <a href=
"#executing-a-transformation"><i>2.4 Executing a
Transformation</i></a>. Any final result tree <span class=
"verb">may</span> be serialized as described in <a href=
"#serialization"><i>25 Serialization</i></a>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-source-tree" id="dt-source-tree" title="source tree"></a>The
term <b>source tree</b> means any tree provided as input to the
transformation. This includes the document containing the
<span><a title="global context item" class="termref" href=
"#dt-global-context-item">global context item</a></span> if any,
<span>documents containing nodes present in the <a title=
"initial match selection" class="termref" href=
"#dt-initial-match-selection">initial match selection</a></span>,
documents containing nodes supplied as the values of <a title=
"stylesheet parameter" class="termref" href=
"#dt-stylesheet-parameter">stylesheet parameters</a>, documents
obtained from the results of functions such as <a href=
"#func-document"><code>document</code></a>, <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-collection"><code>collection</code></a><sup><small>FO30</small></sup>,
<span>documents read using the <a href=
"#element-stream"><code>xsl:stream</code></a> instruction,</span>
and documents returned by extension functions or extension
instructions. In the context of a particular XSLT instruction, the
term <b>source tree</b> means any tree provided as input to that
instruction; this may be a source tree of the transformation as a
whole, or it may be a <a title="temporary tree" class="termref"
href="#dt-temporary-tree">temporary tree</a> produced during the
course of the transformation.<span class="definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-temporary-tree" id="dt-temporary-tree" title=
"temporary tree"></a>The term <b>temporary tree</b> means any tree
that is neither a <a title="source tree" class="termref" href=
"#dt-source-tree">source tree</a> nor a <a title=
"final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a>.<span class=
"definition">]</span> Temporary trees are used to hold intermediate
results during the execution of the transformation.</p>
<p>The use of the term "tree" in phrases such as <b>source
tree</b>, <b>result tree</b>, and <b>temporary tree</b> is not
confined to documents that the processor materializes in memory in
their entirety. The processor <span class="verb">may</span>, and in
some cases <span class="verb">must</span>, use streaming techniques
to limit the amount of memory used to hold source and result
documents. When streaming is used, the nodes of the tree may never
all be in memory at the same time, but at an abstract level the
information is still modeled as a tree of nodes, and the document
is therefore still described as a tree. <span>Unless otherwise
stated, the term "tree" refers to a tree rooted at a parentless
node: that is, the term does not include subtrees of larger trees.
Every node therefore belongs to exactly one tree.</span></p>
<p>In this specification the phrases <span class=
"verb">must</span>, <span class="verb">must not</span>,
<span class="verb">should</span>, <span class="verb">should
not</span>, <span class="verb">may</span>, <span class=
"verb">required</span>, and <span class="verb">recommended</span>,
<span>when used in normative text and rendered in capitals,</span>
are to be interpreted as described in <a href=
"#rfc2119">[RFC2119]</a>.</p>
<p>Where the phrase <span class="verb">must</span>, <span class=
"verb">must not</span>, or <span class="verb">required</span>
relates to the behavior of the XSLT processor, then an
implementation is not conformant unless it behaves as specified,
subject to the more detailed rules in <a href="#conformance"><i>26
Conformance</i></a>.</p>
<p>Where the phrase <span class="verb">must</span>, <span class=
"verb">must not</span>, or <span class="verb">required</span>
relates to a stylesheet then the processor <span class=
"verb">must</span> enforce this constraint on stylesheets by
reporting an error if the constraint is not satisfied.</p>
<p>Where the phrase <span class="verb">should</span>, <span class=
"verb">should not</span>, or <span class="verb">recommended</span>
relates to a stylesheet then a processor <span class=
"verb">may</span> produce warning messages if the constraint is not
satisfied, but <span class="verb">must not</span> treat this as an
error.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-implementation-defined" id="dt-implementation-defined" title=
"implementation-defined"></a>In this specification, the term
<b>implementation-defined</b> refers to a feature where the
implementation is allowed some flexibility, and where the choices
made by the implementation <span class="verb">must</span> be
described in documentation that accompanies any conformance
claim.<span class="definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-implementation-dependent" id="dt-implementation-dependent"
title="implementation-dependent"></a>The term
<b>implementation-dependent</b> refers to a feature where the
behavior <span class="verb">may</span> vary from one implementation
to another, and where the vendor is not expected to provide a full
specification of the behavior.<span class="definition">]</span>
(This might apply, for example, to limits on the size of source
documents that can be transformed.)</p>
<p>In all cases where this specification leaves the behavior
implementation-defined or implementation-dependent, the
implementation has the option of providing mechanisms that allow
the user to influence the behavior.</p>
<p>A paragraph labeled as a <b>Note</b> or described as an
<b>example</b> is non-normative.</p>
<p>Many terms used in this document are defined in the XPath
specification <a href="#xpath-30">[XPath 3.0]</a> or the XDM
specification <a href="#xpath-datamodel-30">[Data Model]</a>.
Particular attention is drawn to the following:</p>
<ul>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-atomization" id="dt-atomization" title="atomize"></a>The term
<b>atomization</b> is defined in <a href=
"http://www.w3.org/TR/xpath-30/#id-atomization">Section 2.4.2
Atomization</a> <sup><small>XP30</small></sup>. It is a process
that takes as input a sequence of <span>items</span>, and returns a
sequence of atomic values, in which the nodes are replaced by their
typed values as defined in <a href="#xpath-datamodel-30">[Data
Model]</a>.<span class="definition">]</span> For some
<span>items</span> (for example, elements with element-only
content, <span>and function items</span>), atomization generates a
<a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a>.</p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-typed-value" id="dt-typed-value" title="typed value"></a>The
term <b>typed value</b> is defined in <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dm-typed-value">Section
5.15 typed-value Accessor</a> <sup><small>DM30</small></sup>. Every
node, <span>other than an element whose type annotation identifies
it as having</span> element-only content, has a <a title=
"string value" class="termref" href="#dt-string-value">typed
value</a>. For example, the <a title="typed value" class="termref"
href="#dt-typed-value">typed value</a> of an attribute of type
<code>xs:IDREFS</code> is a sequence of zero or more
<code>xs:IDREF</code> values.<span class="definition">]</span></p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-string-value" id="dt-string-value" title="string value"></a>The
term <b>string value</b> is defined in <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dm-string-value">Section
5.13 string-value Accessor</a> <sup><small>DM30</small></sup>.
Every node has a <a title="string value" class="termref" href=
"#dt-string-value">string value</a>. For example, the <a title=
"string value" class="termref" href="#dt-string-value">string
value</a> of an element is the concatenation of the <a title=
"string value" class="termref" href="#dt-string-value">string
values</a> of all its descendant text nodes.<span class=
"definition">]</span></p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-xpath-compat-mode" id="dt-xpath-compat-mode" title=
"XPath 1.0 compatibility mode"></a>The term <b>XPath 1.0
compatibility mode</b> is defined in <a href=
"http://www.w3.org/TR/xpath-30/#static_context">Section 2.1.1
Static Context</a> <sup><small>XP30</small></sup>. This is a
setting in the static context of an XPath expression; it has two
values, <code>true</code> and <code>false</code>. When the value is
set to true, the semantics of function calls and certain other
operations are adjusted to give a greater degree of backwards
compatibility between <span>XPath 3.0</span> and XPath
1.0.<span class="definition">]</span></p>
</li>
</ul>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-core-function" id="dt-core-function" title=
"core function"></a>The <b>core functions</b> are: functions
specified in <a href="#xpath-functions-30">[Functions and
Operators]</a> in either the <a title="standard function namespace"
class="termref" href="#dt-standard-function-namespace">standard
function namespace</a> <span>or the namespace
<code>http://www.w3.org/2005/xpath-functions/math</code>; plus
functions defined in this specification in namespace
<code>http://www.w3.org/2005/xpath-functions/map</code></span>.<span class="definition">]</span></p>
</div>
<div class="div2">
<h3><a name="notation" id="notation"></a>2.2 <a href="#notation"
style="text-decoration: none">Notation</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-xslt-element" id="dt-xslt-element" title="XSLT element"></a>An
<b>XSLT element</b> is an element in the <a title="XSLT namespace"
class="termref" href="#dt-xslt-namespace">XSLT namespace</a> whose
syntax and semantics are defined in this specification.<span class=
"definition">]</span> For a non-normative list of XSLT elements,
see <a href="#element-syntax-summary"><i>D Element Syntax
Summary</i></a>.</p>
<p>In this document the specification of each <a title=
"XSLT element" class="termref" href="#dt-xslt-element">XSLT
element</a> is preceded by a summary of its syntax in the form of a
model for elements of that element type. A full list of all these
specifications can be found in <a href=
"#element-syntax-summary"><i>D Element Syntax Summary</i></a>. The
meaning of the syntax summary notation is as follows:</p>
<ul>
<li>
<p>An attribute that is <span class="verb">required</span> is shown
with its name in bold. An attribute that may be omitted is shown
with a question mark following its name.</p>
</li>
<li>
<p>An attribute that is <a title="deprecated" class="termref" href=
"#dt-deprecated">deprecated</a> is shown in a grayed font within
square brackets.</p>
</li>
<li>
<p>The string that occurs in the place of an attribute value
specifies the allowed values of the attribute. If this is
surrounded by curly brackets (<code>{...}</code>), then the
attribute value is treated as an <a title=
"attribute value template" class="termref" href=
"#dt-attribute-value-template">attribute value template</a>, and
the string occurring within curly brackets specifies the allowed
values of the result of evaluating the attribute value template.
Alternative allowed values are separated by <code>|</code>. A
quoted string indicates a value equal to that specific string. An
unquoted, italicized name specifies a particular type of value.</p>
<p>The types used are as follows:</p>
<table summary=
"Types used in element syntax summaries, and their meaning" border=
"1" cellpadding="5" width="100%">
<thead>
<tr>
<th colspan="1" align="left" valign="top">Type name</th>
<th colspan="1" align="left" valign="top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top">boolean</td>
<td align="left" valign="top">One of the strings
<code>"yes"</code>, <code>"true"</code>, or <code>"1"</code> to
indicate the value <code>true</code>, or one of the strings
<code>"no"</code>, <code>"false"</code>, or <code>"0"</code> to
indicate the value <code>false</code>. Note: the values are
synonyms; where this specification uses a phrase such as "If
<code>required='yes'</code> is specified ..." this is to be
interpreted as meaning "If the attribute named
<code>required</code> is present, and has the value
<code>yes</code>, <code>true</code>, or <code>1</code> (after
stripping leading and trailing whitespace) ...".</td>
</tr>
<tr>
<td align="left" valign="top">string</td>
<td align="left" valign="top">Any string</td>
</tr>
<tr>
<td align="left" valign="top">expression</td>
<td align="left" valign="top">An XPath <a title="expression" class=
"termref" href="#dt-expression">expression</a></td>
</tr>
<tr>
<td align="left" valign="top">pattern</td>
<td align="left" valign="top">A <a title="pattern" class="termref"
href="#dt-pattern">pattern</a> as described in <a href=
"#patterns"><i>5.6 Patterns</i></a>.</td>
</tr>
<tr>
<td align="left" valign="top">sequence-type</td>
<td align="left" valign="top">A <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-SequenceType">SequenceType</a><sup><small>XP30</small></sup>
as defined in the XPath specification</td>
</tr>
<tr>
<td align="left" valign="top">uri; uris</td>
<td align="left" valign="top">A URI, for example a namespace URI or
a collation URI; a whitespace-separated list of URIs</td>
</tr>
<tr>
<td align="left" valign="top">qname</td>
<td align="left" valign="top">A <a title="lexical QName" class=
"termref" href="#dt-lexical-qname">lexical QName</a> as defined in
<a href="#qname"><i>5.1 Qualified Names</i></a></td>
</tr>
<tr>
<td align="left" valign="top">eqname; eqnames</td>
<td align="left" valign="top">An <a title="EQName" class="termref"
href="#dt-eqname">EQName</a> as defined in <a href="#qname"><i>5.1
Qualified Names</i></a>; a whitespace-separated list of
EQNames</td>
</tr>
<tr>
<td align="left" valign="top">token; tokens</td>
<td align="left" valign="top">A string containing no significant
whitespace; a whitespace-separated list of such strings</td>
</tr>
<tr>
<td align="left" valign="top">nmtoken; nmtokens</td>
<td align="left" valign="top">A string conforming to the XML schema
rules for the type <code>xs:NMTOKEN</code>; a whitespace-separated
list of such strings.</td>
</tr>
<tr>
<td align="left" valign="top">char</td>
<td align="left" valign="top">A string comprising a single Unicode
character</td>
</tr>
<tr>
<td align="left" valign="top">integer</td>
<td align="left" valign="top">An integer, that is a string in the
lexical space of the schema type <code>xs:integer</code></td>
</tr>
<tr>
<td align="left" valign="top">decimal</td>
<td align="left" valign="top">A decimal value, that is a string in
the lexical space of the schema type <code>xs:decimal</code></td>
</tr>
<tr>
<td align="left" valign="top">ncname</td>
<td align="left" valign="top">An unprefixed name: a string in the
value space of the schema type <code>xs:NCName</code></td>
</tr>
<tr>
<td align="left" valign="top">prefix</td>
<td align="left" valign="top">An <code>xs:NCName</code>
representing a namespace prefix, which must be in scope for the
element on which it appears</td>
</tr>
<tr>
<td align="left" valign="top">id</td>
<td align="left" valign="top">An <code>xs:NCName</code> used as a
unique identifier for an element in the containing XML
document</td>
</tr>
</tbody>
</table>
<p>Except where the set of allowed values of an attribute is
specified using the italicized name <em>string</em> or
<em>char</em>, leading and trailing whitespace in the attribute
value is ignored. In the case of an <a title=
"attribute value template" class="termref" href=
"#dt-attribute-value-template">attribute value template</a>, this
applies to the <a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> obtained when the
attribute value template is expanded.</p>
</li>
<li>
<p>Unless the element is <span class="verb">required</span> to be
empty, the model element contains a comment specifying the allowed
content. The allowed content is specified in a similar way to an
element type declaration in XML; <em>sequence constructor</em>
means that any mixture of text nodes, <a title=
"literal result element" class="termref" href=
"#dt-literal-result-element">literal result elements</a>, <a title=
"extension instruction" class="termref" href=
"#dt-extension-instruction">extension instructions</a>, and
<a title="XSLT element" class="termref" href=
"#dt-xslt-element">XSLT elements</a> from the <a title=
"instruction" class="termref" href=
"#dt-instruction">instruction</a> category is allowed;
<em>other-declarations</em> means that any mixture of XSLT elements
from the <a title="declaration" class="termref" href=
"#dt-declaration">declaration</a> category is allowed, together
with <a title="user-defined data element" class="termref" href=
"#dt-data-element">user-defined data elements</a>.</p>
</li>
<li>
<p>The element is prefaced by comments indicating if it belongs to
the <code>instruction</code> category or <code>declaration</code>
category or both. The category of an element only affects whether
it is allowed in the content of elements that allow a <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> or
<em>other-declarations</em>.</p>
</li>
</ul>
<div class="example">
<div class="exampleHeader"><a name="d7e1093" id=
"d7e1093"></a>Example: Syntax Notation</div>
<p>This example illustrates the notation used to describe <a title=
"XSLT element" class="termref" href="#dt-xslt-element">XSLT
elements</a>.</p>
<p class="element-syntax"><a name="element-example-element" id=
"element-example-element"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:example-element<br />
&#160;&#160;<b>select</b> = <var>expression</var><br />
&#160;&#160;debug? = <var>boolean</var><br />
&#160;&#160;validation? = { "strict" | "lax" }&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: ((<a href=
"#element-variable">xsl:variable</a> | <a href=
"#element-param">xsl:param</a>)*, <a href=
"#element-sequence">xsl:sequence</a>) --&gt;<br />
&lt;/xsl:example-element&gt;</code></p>
<p>This example defines a (non-existent) element
<code>xsl:example-element</code>. The element is classified as an
instruction. It takes the following attributes:</p>
<ol class="enumar">
<li>
<p>A mandatory <code>select</code> attribute, whose value is an
XPath <a title="expression" class="termref" href=
"#dt-expression">expression</a></p>
</li>
<li>
<p>An optional <code>debug</code> attribute, whose value
<span class="verb">must</span> be <code>yes</code>,
<code>true</code>, or <code>1</code> to indicate <code>true</code>,
or <code>no</code>, <code>false</code>, or <code>0</code> to
indicate <code>false</code>.</p>
</li>
<li>
<p>An optional <code>validation</code> attribute, whose value must
be <code>strict</code> or <code>lax</code>; the curly brackets
indicate that the value can be defined as an <a title=
"attribute value template" class="termref" href=
"#dt-attribute-value-template">attribute value template</a>,
allowing a value such as <code>validation="{$val}"</code>, where
the <a title="variable" class="termref" href=
"#dt-variable">variable</a> <code>val</code> is evaluated to yield
<code>"strict"</code> or <code>"lax"</code> at run-time.</p>
</li>
</ol>
<p>The content of an <code>xsl:example-element</code> instruction
is defined to be a sequence of zero or more <a href=
"#element-variable"><code>xsl:variable</code></a> and <a href=
"#element-param"><code>xsl:param</code></a> elements, followed by
an <a href="#element-sequence"><code>xsl:sequence</code></a>
element.</p>
</div>
<p><a name="err-XTSE0010" id="err-XTSE0010"><span class=
"error">[ERR XTSE0010]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if an
XSLT-defined element is used in a context where it is not
permitted, if a <span class="verb">required</span> attribute is
omitted, or if the content of the element does not correspond to
the content that is allowed for the element.</p>
<p>The rules in the element syntax summary (both for the element
structure and for its attributes) apply to the stylesheet content
after preprocessing as described in <a href=
"#preprocessing"><i>3.14 Stylesheet Preprocessing</i></a>.</p>
<p>Attributes are validated as follows. These rules apply to the
value of the attribute after removing leading and trailing
whitespace.</p>
<ul>
<li>
<p><a name="err-XTSE0020" id="err-XTSE0020"><span class=
"error">[ERR XTSE0020]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if an
attribute (other than an attribute written using curly brackets in
a position where an <a title="attribute value template" class=
"termref" href="#dt-attribute-value-template">attribute value
template</a> is permitted) contains a value that is not one of the
permitted values for that attribute.</p>
</li>
<li>
<p><a name="err-XTDE0030" id="err-XTDE0030"><span class=
"error">[ERR XTDE0030]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of an attribute written
using curly brackets, in a position where an <a title=
"attribute value template" class="termref" href=
"#dt-attribute-value-template">attribute value template</a> is
permitted, is a value that is not one of the permitted values for
that attribute. If the processor is able to detect the error
statically (for example, when any XPath expressions within the
curly brackets can be evaluated statically), then the processor may
optionally signal this as a static error.</p>
</li>
</ul>
<p>Special rules apply if the construct appears in part of the
<a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> that is processed with <a title=
"forwards compatible behavior" class="termref" href=
"#dt-forwards-compatible-behavior">forwards compatible
behavior</a>: see <a href="#forwards"><i>3.11 Forwards Compatible
Processing</i></a>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-deprecated" id="dt-deprecated" title="deprecated"></a>Some
constructs defined in this specification are described as being
<b>deprecated</b>. The use of this term implies that stylesheet
authors <span class="verb">should not</span> use the construct, and
that the construct may be removed in a later version of this
specification.<span class="definition">]</span></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This working draft includes a non-normative XML Schema for XSLT
<a title="stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet modules</a> (see <a href=
"#schema-for-xslt"><i>H Schema for XSLT Stylesheets</i></a>). The
syntax summaries described in this section are normative.</p>
</div>
<p>XSLT defines a set of standard functions which are additional to
those defined in <a href="#xpath-functions-30">[Functions and
Operators]</a>. <span>A list of these functions appears in <a href=
"#XSLT-defined-functions"><i>G List of XSLT-defined
functions</i></a>.</span> The signatures of these functions are
described using the same notation as used in <a href=
"#xpath-functions-30">[Functions and Operators]</a>. The names of
<span>many of</span> these functions are in the <a title=
"standard function namespace" class="termref" href=
"#dt-standard-function-namespace">standard function
namespace</a>.</p>
</div>
<div class="div2">
<h3><a name="initiating" id="initiating"></a>2.3 <a href=
"#initiating" style="text-decoration: none">Initiating a
Transformation</a></h3>
<p>This document does not specify any application programming
interfaces or other interfaces for initiating a transformation.
This section, however, describes the information that is supplied
when a transformation is initiated. Except where otherwise
indicated, the information is <span class=
"verb">required</span>.</p>
<p>The execution of a stylesheet necessarily involves two
activities: static analysis and dynamic evaluation. Static analysis
consists of those tasks that can be performed by inspection of the
stylesheet alone, including <span>the binding of <a title=
"static variable" class="termref" href="#dt-static-variable">static
variables</a>,</span> the evaluation of <code>[xsl:]use-when</code>
expressions (see <a href="#conditional-inclusion"><i>3.14.1
Conditional Element Inclusion</i></a>), <span>and shadow attributes
(see <a href="#shadow-attributes"><i>3.14.2 Shadow
Attributes</i></a>)</span> and detection of <a title="static error"
class="termref" href="#dt-static-error">static errors</a>. Dynamic
evaluation consists of tasks which in general cannot be carried out
until a source document is available.</p>
<p>Dynamic evaluation is further divided into two activities:
<b>priming</b> the stylesheet, and <b>invoking</b> a selected
component.</p>
<ul>
<li>
<p>Priming the stylesheet provides the dynamic context for
evaluation, and supplies all the information needed to establish
the values of global variables.</p>
</li>
<li>
<p>Invoking a component (such as a template or function) causes
evaluation of that template or function to produce a result, which
is an arbitrary XDM value.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-raw-result" id="dt-raw-result" title="raw result"></a>The
result of invoking the selected component, after any required
conversion to the declared result type of the component, is
referred to as the <b>raw result</b>.<span class=
"definition">]</span></p>
<p>This raw result may optionally be post-processed to construct a
result tree, to serialize the result, or both, as described in
<a href="#post-processing"><i>2.3.6 Post-processing the Raw
Result</i></a>.</p>
</li>
</ul>
<p>Implementations <span class="verb">may</span> allow static
analysis and dynamic evaluation to be initiated independently, so
that the cost of static analysis can be amortized over multiple
transformations using the same stylesheet. <span>Implementations
<span class="verb">may</span> also allow priming of a stylesheet
and invocation of components to be initiated independently, in
which case a single act of priming the stylesheet may be followed
by a series of independent component invocations. Although this
specification does not require such a separation, this section
distinguishes information that is needed before static analysis can
proceed, information that is needed to prime the stylesheet, and
information that is needed when invoking components.</span></p>
<p>The language is designed to allow the static analysis of each
<a title="package" class="termref" href="#dt-package">package</a>
to be performed independently of other packages, with only basic
knowledge of the properties of components made available by used
packages. Beyond this, the specification leaves it to
implementations to decide how to organize this process. When
packages are not used explicitly, the entire stylesheet is treated
as a single package.</p>
<div class="div3">
<h4><a name="info-for-static-analysis" id=
"info-for-static-analysis"></a>2.3.1 <a href=
"#info-for-static-analysis" style=
"text-decoration: none">Information needed for Static
Analysis</a></h4>
<p>The following information is needed prior to static analysis
<span>of a package</span>:</p>
<ul>
<li>
<p>The location of the <a title="package manifest" class="termref"
href="#dt-package-manifest">package manifest</a>, or in the absence
of a package manifest, the <a title="stylesheet module" class=
"termref" href="#dt-stylesheet-module">stylesheet module</a> that
is to act as the <a title="principal stylesheet module" class=
"termref" href="#dt-principal-stylesheet-module">principal
stylesheet module</a> <span>of the <a title="package" class=
"termref" href="#dt-package">package</a></span>. The complete
<a title="package" class="termref" href="#dt-package">package</a>
is assembled by recursively expanding the <a href=
"#element-import"><code>xsl:import</code></a> and <a href=
"#element-include"><code>xsl:include</code></a> declarations in the
principal stylesheet module, as described in <a href=
"#include"><i>3.12.2 Stylesheet Inclusion</i></a> and <a href=
"#import"><i>3.12.3 Stylesheet Import</i></a>.</p>
</li>
<li>
<p>Information about the packages referenced from this package
using <a href=
"#element-use-package"><code>xsl:use-package</code></a>
declarations. The information needed will include the names and
signatures of public components exported by the referenced
package.</p>
</li>
<li>
<p>A set (possibly empty) of values for <a title="static parameter"
class="termref" href="#dt-static-parameter">static parameters</a>
(see <a href="#global-variables"><i>9.5 Global Variables and
Parameters</i></a>). These values are available for use within
<a title="static expression" class="termref" href=
"#dt-static-expression">static expressions</a> (notably in
<code>[xsl:]use-when</code> expressions and shadow attributes) as
well as non-static expressions in the <a title="stylesheet" class=
"termref" href="#dt-stylesheet">stylesheet</a>. As a minimum,
values <span class="verb">must</span> be supplied for any static
parameters declared with the attribute
<code>required="yes"</code>.</p>
</li>
</ul>
<p>Conceptually, the output of the static analysis of a package is
an object which might be referred to (without constraining the
implementation) as a compiled package. Prior to dynamic evaluation,
all the compiled packages needed for execution must be checked for
consistency, and component references must be resolved. This
process may be referred to, again without constraining the
implementation, as linking.</p>
</div>
<div class="div3">
<h4><a name="priming-stylesheet" id="priming-stylesheet"></a>2.3.2
<a href="#priming-stylesheet" style="text-decoration: none">Priming
a Stylesheet</a></h4>
<p>The information needed when priming a stylesheet is as
follows:</p>
<ul>
<li>
<p>A set (possibly empty) of values for <span>non-static</span>
<a title="stylesheet parameter" class="termref" href=
"#dt-stylesheet-parameter">stylesheet parameters</a> (see <a href=
"#global-variables"><i>9.5 Global Variables and
Parameters</i></a>). These values are available for use within
<a title="expression" class="termref" href=
"#dt-expression">expressions</a> in the <a title="stylesheet"
class="termref" href="#dt-stylesheet">stylesheet</a>. As a minimum,
values <span class="verb">must</span> be supplied for any
parameters declared with the attribute
<code>required="yes"</code>.</p>
<p>A supplied value is converted if necessary to the declared type
of the stylesheet parameter using the <a title=
"function conversion rules" class="termref" href=
"#dt-function-conversion-rules">function conversion rules</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Non-static stylesheet parameters must be <code>public</code>,
<code>final</code>, or <code>abstract</code>, which ensures that
all the parameters in the stylesheet for which values can be
supplied externally have distinct names. Static parameters, by
contrast, can have names that are duplicated across different
packages.</p>
</div>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-global-context-item" id="dt-global-context-item" title=
"global context item"></a><span>An item that acts as the <b>global
context item</b> for the transformation.</span> This item is
accessible as the initial value of the XPath <a title="expression"
class="termref" href="#dt-expression">expressions</a>
<code>.</code> (dot) and <code>self::node()</code> <span>appearing
within the <code>select</code> expression or sequence constructor
of a <a title="global variable" class="termref" href=
"#dt-global-variable">global variable</a> declaration</span>
<span>within the <a title="top-level package" class="termref" href=
"#dt-top-level-package">top-level package</a></span>, as described
in <a href="#focus"><i>5.4.3.1 Maintaining Position: the
Focus</i></a>. <span class="definition">]</span></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In previous releases of this specification, a single node was
typically supplied to represent the source document for the
transformation. This node was used as the target node for the
implicit call on <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
used to start the transformation process (now called the <a title=
"initial match selection" class="termref" href=
"#dt-initial-match-selection">initial match selection</a>), and the
root node of the containing tree was used as the context item for
evaluation of global variables (now called the <a title=
"global context item" class="termref" href=
"#dt-global-context-item">global context item</a>). This
relationship between the <a title="initial match selection" class=
"termref" href="#dt-initial-match-selection">initial match
selection</a> and the <a title="global context item" class=
"termref" href="#dt-global-context-item">global context item</a> is
likely to be found for compatibility reasons in a transformation
API designed to work with earlier versions of this specification,
but it is no longer a necessary relationship; the two values can in
principle be completely independent of each other.</p>
<p>Stylesheet authors wanting to write code that can be invoked
using legacy APIs should not rely on the caller being able to
supply different values for the <a title="initial match selection"
class="termref" href="#dt-initial-match-selection">initial match
selection</a> and the <a title="global context item" class=
"termref" href="#dt-global-context-item">global context
item</a>.</p>
</div>
<p>The <a title="global context item" class="termref" href=
"#dt-global-context-item">global context item</a> is potentially
used when initializing global variables and parameters. If the
initialization of any <a title="global variable" class="termref"
href="#dt-global-variable">global variables</a> or <a title=
"stylesheet parameter" class="termref" href=
"#dt-stylesheet-parameter">parameter</a> depends on the context
item, a dynamic error can occur if the context item is absent. It
is <a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> whether
this error occurs during priming of the stylesheet or subsequently
when the variable is referenced; and it is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> whether the
error occurs at all if the variable or parameter is never
referenced. The error can be suppressed by use of <a href=
"#element-try"><code>xsl:try</code></a> and <a href=
"#element-catch"><code>xsl:catch</code></a> within the
<span>sequence constructor used to initialize the variable or
parameter. It cannot be suppressed by use of <a href=
"#element-try"><code>xsl:try</code></a> around a reference to the
global variable.</span></p>
<p><span>In a <a title="library package" class="termref" href=
"#dt-library-package">library package</a>, the <a title=
"context item" class="termref" href="#dt-context-item">context
item</a>, <a title="context position" class="termref" href=
"#dt-context-position">context position</a>, and <a title=
"context size" class="termref" href="#dt-context-size">context
size</a> used for evaluation of global variables will be <a title=
"absent" class="termref" href="#dt-absent">absent</a>, and the
evaluation of any expression that references these values will
result in a dynamic error.</span> <span>This will also be the case
in the <a title="top-level package" class="termref" href=
"#dt-top-level-package">top-level package</a> if no <a title=
"global context item" class="termref" href=
"#dt-global-context-item">global context item</a> is
supplied.</span></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>If a context item is available within a global variable
declaration, then the <a title="context position" class="termref"
href="#dt-context-position">context position</a> and <a title=
"context size" class="termref" href="#dt-context-size">context
size</a> will always be 1 (one).</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>For maximum reusability of code, it is best to avoid use of the
context item when initializing global variables and parameters.
Instead, all external information should be supplied using named
<a title="stylesheet parameter" class="termref" href=
"#dt-stylesheet-parameter">stylesheet parameters</a>. Especially
when these use namespaces to avoid conflicts, there is then no risk
of confusion between the information supplied externally to
different packages.</p>
<p>When a stylesheet parameter is defined in a library package, it
is possible for a using package to supply a value for the parameter
by overriding the parameter declaration within an <a href=
"#element-override"><code>xsl:override</code></a> element. If the
using package is the <a title="top-level package" class="termref"
href="#dt-top-level-package">top-level package</a> then the
overriding declaration can refer to the <a title=
"global context item" class="termref" href=
"#dt-global-context-item">global context item</a>.</p>
</div>
</li>
<li>
<p>A mechanism for obtaining a document node and a media type,
given an absolute URI. The total set of available documents
(modeled as a mapping from URIs to document nodes) forms part of
the context for evaluating XPath expressions, specifically the
<a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>
function. The XSLT <a href=
"#func-document"><code>document</code></a> function additionally
requires the media type of the resource representation, for use in
interpreting any fragment identifier present within a URI
Reference.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The set of documents that are available to the stylesheet is
<a title="implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a>, as is
the processing that is carried out to construct a tree representing
the resource retrieved using a given URI. Some possible ways of
constructing a document (specifically, rules for constructing a
document from an Infoset or from a PSVI) are described in <a href=
"#xpath-datamodel-30">[Data Model]</a>.</p>
</div>
</li>
</ul>
<p>Once a stylesheet is primed, the values of global variables
remain stable through all component invocations. In addition,
priming a stylesheet creates an <a href=
"http://www.w3.org/TR/xpath-functions-30/#execution-scope">execution
scope</a><sup><small>FO30</small></sup> during which the dynamic
context and all <span>calls on <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>
functions</span> remain stable; for example two calls on the
<a href=
"http://www.w3.org/TR/xpath-functions-30/#func-current-dateTime"><code>
current-dateTime</code></a><sup><small>FO30</small></sup> function
within an execution scope are defined to return the same
result.</p>
<p>Parameters passed to the transformation by the client
application <span>when a stylesheet is primed</span> are matched
against <a title="stylesheet parameter" class="termref" href=
"#dt-stylesheet-parameter">stylesheet parameters</a> (see <a href=
"#global-variables"><i>9.5 Global Variables and
Parameters</i></a>), not against the <a title="template parameter"
class="termref" href="#dt-template-parameter">template
parameters</a> of any template executed during the course of the
transformation.</p>
<p><a name="err-XTDE0050" id="err-XTDE0050"><span class=
"error">[ERR XTDE0050]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if a
stylesheet declares a visible <a title="stylesheet parameter"
class="termref" href="#dt-stylesheet-parameter">stylesheet
parameter</a> with <code>required="yes"</code> and no value for
this parameter is supplied when the stylesheet is primed. A
stylesheet parameter is visible if it is not masked by another
global variable or parameter with the same name and higher
<a title="import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a>. <span>If the
parameter is a <a title="static parameter" class="termref" href=
"#dt-static-parameter">static parameter</a> then the value
<span class="verb">must</span> be supplied prior to the static
analysis phase.</span></p>
</div>
<div class="div3">
<h4><a name="invoking-initial-mode" id=
"invoking-initial-mode"></a>2.3.3 <a href="#invoking-initial-mode"
style="text-decoration: none">Apply-Templates Invocation</a></h4>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-initial-match-selection" id="dt-initial-match-selection" title=
"initial match selection"></a>A stylesheet may be evaluated by
supplying a value to be processed, together with an <a title=
"initial mode" class="termref" href="#dt-initial-mode">initial
mode</a>. The value (which can be any sequence of items) is
referred to as the <b>initial match selection</b>. The processing
then corresponds to the effect of the <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction.<span class="definition">]</span></p>
<p>The <a title="initial match selection" class="termref" href=
"#dt-initial-match-selection">initial match selection</a> will
often be a single document node, traditionally called the source
document of the transformation; but in general, it can be any
sequence.</p>
<p>Processing proceeds by finding the <a title="template rule"
class="termref" href="#dt-template-rule">template rules</a> that
match the items in the <a title="initial match selection" class=
"termref" href="#dt-initial-match-selection">initial match
selection</a>, and evaluating these template rules with a <a title=
"focus" class="termref" href="#dt-focus">focus</a> based on the
<a title="initial match selection" class="termref" href=
"#dt-initial-match-selection">initial match selection</a>. The
template rules are evaluated in <a title="final output state"
class="termref" href="#dt-final-output-state">final output
state</a>.</p>
<p>The following information is needed when dynamic evaluation is
to start with a <a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a>:</p>
<ul>
<li>
<p>The <a title="initial match selection" class="termref" href=
"#dt-initial-match-selection">initial match selection</a>. An API
that chooses to maintain compatibility with previous versions of
this specification <span class="verb">should</span> allow a
singleton node to be provided, which is then used in two ways: the
node itself acts as the <a title="initial match selection" class=
"termref" href="#dt-initial-match-selection">initial match
selection</a>, and the document node of the containing document
acts as the <a title="global context item" class="termref" href=
"#dt-global-context-item">global context item</a>.</p>
</li>
<li>
<p>Optionally, an initial <a title="mode" class="termref" href=
"#dt-mode">mode</a>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-initial-mode" id="dt-initial-mode" title="initial mode"></a>The
initial mode, if specified, <span class="verb">must</span> either
be the <span>unnamed</span> mode, or a mode that is explicitly
named <span>either in an <a href=
"#element-mode"><code>xsl:mode</code></a> declaration, or</span> in
the <code>mode</code> attribute of an <a href=
"#element-template"><code>xsl:template</code></a> declaration
within the stylesheet. If an initial mode is supplied, then in
searching for the <a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a> that best matches the
<span>items in the <a title="initial match selection" class=
"termref" href="#dt-initial-match-selection">initial match
selection</a></span>, the processor considers only those rules that
apply to the initial mode. If no initial mode is supplied, then the
mode used is that named in the <code>default-mode</code> attribute
of the <span>(explicit or implicit) <a href=
"#element-package"><code>xsl:package</code></a> element of the
<a title="top-level package" class="termref" href=
"#dt-top-level-package">top-level package</a></span> or in the
absence of such an attribute, the <a title="unnamed mode" class=
"termref" href="#dt-unnamed-mode">unnamed mode</a>.<span class=
"definition">]</span></p>
</li>
<li>
<p>Parameters, which will be passed to the template rules used to
process items in the input sequence. The parameters consist of two
sets of (QName, value) pairs, one set for <a title=
"tunnel parameter" class="termref" href=
"#dt-tunnel-parameter">tunnel parameters</a> and one for non-tunnel
parameters, in which the QName identifies the name of a parameter
and the value provides the value of the parameter. Either or both
sets of parameters may be empty. The effect is the same as when a
template is invoked using <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
with an <a href=
"#element-with-param"><code>xsl:with-param</code></a> child
specifying <code>tunnel="yes"</code> or <code>tunnel="no"</code> as
appropriate. If a parameter is supplied that is not declared or
used, the value is simply ignored. These parameters are
<em>not</em> used to set <a title="stylesheet parameter" class=
"termref" href="#dt-stylesheet-parameter">stylesheet
parameters</a>.</p>
<p>A supplied value is converted if necessary to the declared type
of the template parameter using the <a title=
"function conversion rules" class="termref" href=
"#dt-function-conversion-rules">function conversion rules</a>.</p>
</li>
</ul>
<p>The <a title="raw result" class="termref" href=
"#dt-raw-result">raw result</a> of the invocation is the result of
processing the supplied input sequence as if by a call on <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a> in
the specified mode: specifically, each item in the input sequence
is processed by selecting and evaluating the best matching template
rule, and converting the result (if necessary) to the type declared
in the <code>as</code> attribute of that template using the
<a title="function conversion rules" class="termref" href=
"#dt-function-conversion-rules">function conversion rules</a>; and
the results of processing each item are then concatenated into a
single sequence, respecting the order of items in the input
sequence.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>If the initial mode is a <a title="streamable mode" class=
"termref" href="#dt-streamable-mode">streamable mode,</a> then
streaming will only be possible if nodes in the input sequence are
supplied in a form that allows such processing: for example, as a
reference to a stream of parsing events.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The design of the API for invoking a transformation should
provide some means for users to designate the <a title=
"unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed
mode</a> as the <a title="initial mode" class="termref" href=
"#dt-initial-mode">initial mode</a> in cases where it is not the
default mode.</p>
</div>
<p><a name="err-XTDE0044" id="err-XTDE0044"><span class=
"error">[ERR XTDE0044]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
invocation of the <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> specifies an initial <a title=
"mode" class="termref" href="#dt-mode">mode</a> and if no
<span><a title="initial match selection" class="termref" href=
"#dt-initial-match-selection">initial match selection</a> is
supplied (either explicitly, or defaulted to the <a title=
"global context item" class="termref" href=
"#dt-global-context-item">global context item</a>)</span>.</p>
<p><a name="err-XTDE0045" id="err-XTDE0045"><span class=
"error">[ERR XTDE0045]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
invocation of the <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> specifies an initial <a title=
"mode" class="termref" href="#dt-mode">mode</a> (other than the
unnamed mode) that does not match <span>either the <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a> in the <code>name</code> attribute of an <a href=
"#element-mode"><code>xsl:mode</code></a> declaration, or</span>
the <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> in the <code>mode</code>
attribute of any template defined in the <a title="stylesheet"
class="termref" href="#dt-stylesheet">stylesheet</a>.</p>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> <span class="error">[see
<a href="#err-XTDE0700">ERR XTDE0700</a>]</span> if the <a title=
"template rule" class="termref" href="#dt-template-rule">template
rule</a> selected for processing any item in the <a title=
"initial match selection" class="termref" href=
"#dt-initial-match-selection">initial match selection</a> defines a
<a title="template parameter" class="termref" href=
"#dt-template-parameter">template parameter</a> that specifies
<code>required="yes"</code> <span>and no value is supplied for that
parameter.</span></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>A <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> can process further source
documents in addition to those supplied when the transformation is
invoked. These additional documents can be loaded using the
functions <a href="#func-document"><code>document</code></a> (see
<a href="#func-document"><i>20.1 fn:document</i></a>) or <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>
or <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-collection"><code>collection</code></a><sup><small>FO30</small></sup>
(see <a href="#xpath-functions-30">[Functions and Operators]</a>),
<span>or using the <a href=
"#element-stream"><code>xsl:stream</code></a> instruction</span>;
alternatively, they can be supplied as <a title=
"stylesheet parameter" class="termref" href=
"#dt-stylesheet-parameter">stylesheet parameters</a> (see <a href=
"#global-variables"><i>9.5 Global Variables and
Parameters</i></a>), or returned as the result of an <a title=
"extension function" class="termref" href=
"#dt-extension-function">extension function</a> (see <a href=
"#extension-functions"><i>23.1 Extension Functions</i></a>).</p>
</div>
</div>
<div class="div3">
<h4><a name="invoking-initial-template" id=
"invoking-initial-template"></a>2.3.4 <a href=
"#invoking-initial-template" style=
"text-decoration: none">Call-Template Invocation</a></h4>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-initial-named-template" id="dt-initial-named-template" title=
"initial named template"></a>A stylesheet may be evaluated by
selecting a named template to be evaluated; this is referred to as
the <b>initial named template</b>.<span class="definition">]</span>
The effect is analogous to the effect of executing an <a href=
"#element-call-template"><code>xsl:call-template</code></a>
instruction. The following information is needed in this case:</p>
<ul>
<li>
<p>Optionally, the name of the <a title="initial named template"
class="termref" href="#dt-initial-named-template">initial named
template</a> which is to be executed as the entry point to the
transformation. <span>If no template name is supplied, the default
template name is <code>xsl:initial-template</code>.</span> The
selected template <span class="verb">must</span> exist within the
<a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a>.</p>
</li>
<li>
<p>Optionally, a context item for evaluation of this named
template, defaulting to the <a title="global context item" class=
"termref" href="#dt-global-context-item">global context item</a> if
it exists. <span>This is constrained by any <a href=
"#element-context-item"><code>xsl:context-item</code></a> element
appearing within the selected <a href=
"#element-template"><code>xsl:template</code></a> element. The
initial named template is evaluated with a <a title=
"singleton focus" class="termref" href=
"#dt-singleton-focus">singleton focus</a> based on this context
item if it exists, or with an <a title="absent" class="termref"
href="#dt-absent">absent</a> focus otherwise.</span></p>
</li>
<li>
<p>Parameters, which will be passed to the selected template rule.
The parameters consist of two sets of (QName, value) pairs, one set
for <a title="tunnel parameter" class="termref" href=
"#dt-tunnel-parameter">tunnel parameters</a> and one for non-tunnel
parameters, in which the QName identifies the name of a parameter
and the value provides the value of the parameter. Either or both
sets of parameters may be empty. The effect is the same as when a
template is invoked using <a href=
"#element-call-template"><code>xsl:call-template</code></a> with an
<a href="#element-with-param"><code>xsl:with-param</code></a> child
specifying <code>tunnel="yes"</code> or <code>tunnel="no"</code> as
appropriate. If a parameter is supplied that is not declared or
used, the value is simply ignored. These parameters are
<em>not</em> used to set <a title="stylesheet parameter" class=
"termref" href="#dt-stylesheet-parameter">stylesheet
parameters</a>.</p>
<p>A supplied value is converted if necessary to the declared type
of the template parameter using the <a title=
"function conversion rules" class="termref" href=
"#dt-function-conversion-rules">function conversion rules</a>.</p>
</li>
</ul>
<p>The <a title="raw result" class="termref" href=
"#dt-raw-result">raw result</a> of the invocation is the result of
evaluating the <a title="initial named template" class="termref"
href="#dt-initial-named-template">initial named template</a>, after
conversion of the result to the type declared in the
<code>as</code> attribute of that template using the <a title=
"function conversion rules" class="termref" href=
"#dt-function-conversion-rules">function conversion rules</a>, if
such conversion is necessary.</p>
<p>The <a title="initial named template" class="termref" href=
"#dt-initial-named-template">initial named template</a> is
evaluated in <a title="final output state" class="termref" href=
"#dt-final-output-state">final output state</a>.</p>
<p><a name="err-XTDE0040" id="err-XTDE0040"><span class=
"error">[ERR XTDE0040]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
invocation of the <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> specifies a template name that does
not match the <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> of a named template defined
in the <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a>, <span>whose visibility is
<code>public</code> or <code>final</code></span>.</p>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> <span><span class=
"error">[see <a href="#err-XTDE0700">ERR
XTDE0700</a>]</span></span> if the <a title=
"initial named template" class="termref" href=
"#dt-initial-named-template">initial named template</a>, or any of
the template rules invoked to process items in the <a title=
"initial match selection" class="termref" href=
"#dt-initial-match-selection">initial match selection</a>, defines
a <a title="template parameter" class="termref" href=
"#dt-template-parameter">template parameter</a> that specifies
<code>required="yes"</code> <span>and no value is supplied for that
parameter.</span></p>
</div>
<div class="div3">
<h4><a name="invoking-initial-function" id=
"invoking-initial-function"></a>2.3.5 <a href=
"#invoking-initial-function" style="text-decoration: none">Function
Call Invocation</a></h4>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-initial-function" id="dt-initial-function" title=
"initial function"></a>A stylesheet may be evaluated by calling a
named <a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet function</a>, referred to as
the <b>initial function</b>.<span class="definition">]</span> The
following additional information is needed in this case:</p>
<ul>
<li>
<p>The name and arity of a <a title="stylesheet function" class=
"termref" href="#dt-stylesheet-function">stylesheet function</a>
which is to be executed as the entry point to the
transformation.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In the design of a concrete API, the arity may be inferred from
the length of the parameter list.</p>
</div>
</li>
<li>
<p>A list of values to act as parameters to the <a title=
"initial function" class="termref" href=
"#dt-initial-function">initial function</a>. The number of values
in the list must be the same as the arity of the function.</p>
<p>A supplied value is converted if necessary to the declared type
of the function parameter using the <a title=
"function conversion rules" class="termref" href=
"#dt-function-conversion-rules">function conversion rules</a>.</p>
</li>
</ul>
<p>The <a title="raw result" class="termref" href=
"#dt-raw-result">raw result</a> of the invocation is the result of
evaluating the <a title="initial function" class="termref" href=
"#dt-initial-function">initial function</a>, after conversion of
the result to the type declared in the <code>as</code> attribute of
that function using the <a title="function conversion rules" class=
"termref" href="#dt-function-conversion-rules">function conversion
rules</a>, if such conversion is necessary.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The <a title="initial function" class="termref" href=
"#dt-initial-function">initial function</a> (like all stylesheet
functions) is evaluated with an <a title="absent" class="termref"
href="#dt-absent">absent</a> <a title="focus" class="termref" href=
"#dt-focus">focus</a>.</p>
</div>
<p><a name="err-XTDE0041" id="err-XTDE0041"><span class=
"error">[ERR XTDE0041]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
invocation of the <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> specifies a function name and arity
that does not match the <a title="expanded QName" class="termref"
href="#dt-expanded-qname">expanded QName</a> and arity of a named
<a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet function</a> defined in the
<a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a>, whose visibility is
<code>public</code> or <code>final</code>.</p>
<p>When a transformation is invoked by calling an <a title=
"initial function" class="termref" href=
"#dt-initial-function">initial function</a>, the entire
transformation executes in <a title="temporary output state" class=
"termref" href="#dt-temporary-output-state">temporary output
state</a>, which means that calls on <a href=
"#element-result-document"><code>xsl:result-document</code></a> are
not permitted.</p>
</div>
<div class="div3">
<h4><a name="post-processing" id="post-processing"></a>2.3.6
<a href="#post-processing" style=
"text-decoration: none">Post-processing the Raw Result</a></h4>
<p>At user option, the <a title="raw result" class="termref" href=
"#dt-raw-result">raw result</a> of a component invocation may
either be returned to the calling application unchanged, or it may
be post-processed. Two stages of post-processing are defined, both
of which are optional:</p>
<ol class="enumar">
<li>
<p><b>Result tree construction</b></p>
<p>If the raw result is non-empty, then it is used to construct an
implicit <a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a>, following the rules
described in <a href="#constructing-complex-content"><i>5.8.1
Constructing Complex Content</i></a>: the effect is as if the raw
result <var>R</var> were processed by the following function:</p>
<div class="exampleInner">
<pre>
&lt;xsl:function name="construct-result-tree" as="document-node()"&gt;
  &lt;xsl:param name="R" as="item()*"&gt;
  &lt;xsl:document validation="preserve"&gt;
    &lt;xsl:sequence select="$R"/&gt;
  &lt;/xsl:document&gt;  
&lt;/xsl:function&gt;
</pre></div>
<p>An implicit result tree is also created when the raw result is
empty, provided that no <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction has been evaluated during the course of the
transformation <span>(which will always be the case if the
stylesheet is invoked by calling an initial function)</span>. In
this situation the implicit result tree will consist of a document
node with no children.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This means that there is always at least one result tree. It
also means that <span>when stylesheet invocation is by supplying an
<a title="initial mode" class="termref" href=
"#dt-initial-mode">initial mode</a> (see <a href=
"#invoking-initial-mode"><i>2.3.3 Apply-Templates
Invocation</i></a>) or a named template (see <a href=
"#invoking-initial-template"><i>2.3.4 Call-Template
Invocation</i></a>), and</span> the content of the <a title=
"initial named template" class="termref" href=
"#dt-initial-named-template">initial named template</a> is a single
<a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction, as in the example <span>template with
<code>name="IMPLICIT"</code> shown in <a href=
"#executing-a-transformation"><i>2.4 Executing a
Transformation</i></a></span>, then only one result tree is
produced, not two. It is useful to make the result document
explicit as this is a convenient way of invoking document-level
validation. (Validation of the implicit result document can also be
achieved by adding an <a href=
"#element-document"><code>xsl:document</code></a> instruction to
the initial template.)</p>
<p>If the result of the <a title="initial named template" class=
"termref" href="#dt-initial-named-template">initial named
template</a> is non-empty, and an explicit <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction has been evaluated with the empty attribute
<code>href=""</code>, then an error will occur <span class=
"error">[see <a href="#err-XTDE1490">ERR XTDE1490</a>]</span>,
since it is not possible to create two final result trees with the
same URI.</p>
</div>
</li>
<li>
<p><b>Serialization</b></p>
<p>See <a href="#parsing-and-serialization"><i>2.6 Parsing and
Serialization</i></a>.</p>
<p>Either the raw result, or a result tree produced as described
above, may optionally be serialized as described in <a href=
"#serialization"><i>25 Serialization</i></a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The first phase of serialization, called <b>sequence
normalization</b>, has no effect if the supplied value is a single
document node, which will be the case if serialization is preceded
by result tree construction. In the case of any other supplied
value, the effect of sequence normalization is very similar to the
effect of result tree construction, except where an
<code>item-separator</code> serialization parameter is present. Use
of <code>item-separator</code> allows, for example, a sequence of
strings returned by invoking a stylesheet function to be output
with newline separators.</p>
</div>
</li>
</ol>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-base-output-uri" id="dt-base-output-uri" title=
"base output URI"></a> The <b>base output URI</b> is a URI to be
used as the base URI when resolving a relative URI
<span>reference</span> allocated to a <a title="final result tree"
class="termref" href="#dt-final-result-tree">final result tree</a>.
If the transformation generates more than one final result tree,
then typically each one will be allocated a URI relative to this
base URI.<span class="definition">]</span> The way in which a base
output URI is established is <a title="implementation-defined"
class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. Each
invocation of the stylesheet may supply a different base output
URI. It is acceptable for the base output URI to be <a title=
"absent" class="termref" href="#dt-absent">absent</a>, provided no
constructs (such as <a href=
"#element-result-document"><code>xsl:result-document</code></a>)
are evaluated that depend on the value of the base output URI.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>It will often be convenient for the base output URI to be the
same as the location to which the principal result document is
serialized, but this relationship is not a necessary one.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This specification does not constrain the design of application
programming interfaces or the choice of defaults. In previous
versions of this specification, result tree construction was a
mandatory process, while serialization was optional. When invoking
stylesheet functions directly, however, result tree construction
and serialization may be inappropriate as defaults. These
considerations may affect the design of APIs.</p>
</div>
</div>
</div>
<div class="div2">
<h3><a name="executing-a-transformation" id=
"executing-a-transformation"></a>2.4 <a href=
"#executing-a-transformation" style=
"text-decoration: none">Executing a Transformation</a></h3>
<p>The classic method of executing an XSLT transformation is to
apply template rules to an input document (see <a href=
"#invoking-initial-mode"><i>2.3.3 Apply-Templates
Invocation</i></a>), and then delivering the result as a result
tree which is then optionally serialized (see <a href=
"#post-processing"><i>2.3.6 Post-processing the Raw
Result</i></a>). This processing model is described in this
section. Other ways of invoking a transformation or processing the
result are outlined in the previous section.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-template-rule" id="dt-template-rule" title=
"template rule"></a>A stylesheet contains a set of <b>template
rules</b> (see <a href="#rules"><i>6 Template Rules</i></a>). A
template rule has three parts: a <a title="pattern" class="termref"
href="#dt-pattern">pattern</a> that is matched against nodes, a
(possibly empty) set of <a title="template parameter" class=
"termref" href="#dt-template-parameter">template parameters</a>,
and a <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> that is
evaluated to produce a sequence of items.<span class=
"definition">]</span> In many cases these items are newly
constructed nodes, which are then written to a <a title=
"result tree" class="termref" href="#dt-result-tree">result
tree</a>.</p>
<p>A source document is typically processed by finding the template
rule that best matches its root (document) node, and evaluating the
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> contained in
this template rule, as described in <a href=
"#sequence-constructors"><i>5.8 Sequence Constructors</i></a>.</p>
<p>The raw result sequence produced by evaluating this initial
template is handled as follows:</p>
<ol class="enumar">
<li>
<p>If the template has an <code>as</code> attribute, then the raw
result sequence is checked against the required type in the same
way as for any other template, and is converted if necessary to the
required type by applying the <a title="function conversion rules"
class="termref" href="#dt-function-conversion-rules">function
conversion rules</a>.</p>
</li>
<li>
<p>If the result sequence is non-empty, then it is
<span>typically</span> post-processed (as described in <a href=
"#post-processing"><i>2.3.6 Post-processing the Raw Result</i></a>)
to construct an implicit <a title="final result tree" class=
"termref" href="#dt-final-result-tree">final result tree</a>,
following the rules described in <a href=
"#constructing-complex-content"><i>5.8.1 Constructing Complex
Content</i></a>: the effect is as if the initial template
<var>T</var> were called by an implicit template of the form:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template name="IMPLICIT"&gt;
  &lt;xsl:result-document href=""&gt;
    &lt;xsl:call-template name="T"/&gt;
  &lt;/xsl:result-document&gt;
&lt;/xsl:template&gt;
</pre></div>
</li>
</ol>
<p>The process of generating a result tree from the raw result of
the initial template <span class="verb">may</span> be replaced with
the very similar sequence normalization process described in
<a href="#serialization"><i>25 Serialization</i></a>. In the latter
case the serialization parameter <code>item-separator</code> may be
used to separate items in the raw result with a string other than
space (for example, newlines).</p>
<p>An implicit result tree is also created when the result sequence
is empty, provided that no <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction has been evaluated during the course of the
transformation. In this situation the implicit result tree will
consist of a document node with no children.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This means that (unless raw output is requested) there is always
at least one result tree. It also means that if the content of the
initial template is a single <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction, as in the example above, then only one result tree is
produced, not two. It is useful to make the result document
explicit as this is the only way of invoking document-level
validation.</p>
<p>If the result of the initial template is non-empty, and an
explicit <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction has been evaluated with the empty attribute
<code>href=""</code>, then an error will occur <span class=
"error">[see <a href="#err-XTDE1490">ERR XTDE1490</a>]</span>,
since it is not possible to create two final result trees with the
same URI.</p>
</div>
<p>A <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> is a sequence
of sibling nodes in the stylesheet, each of which is either an
<a title="XSLT instruction" class="termref" href=
"#dt-xslt-instruction">XSLT instruction</a>, a <a title=
"literal result element" class="termref" href=
"#dt-literal-result-element">literal result element</a>, a text
node, or an <a title="extension instruction" class="termref" href=
"#dt-extension-instruction">extension instruction</a>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-instruction" id="dt-instruction" title="instruction"></a>An
<b>instruction</b> is either an <a title="XSLT instruction" class=
"termref" href="#dt-xslt-instruction">XSLT instruction</a> or an
<a title="extension instruction" class="termref" href=
"#dt-extension-instruction">extension instruction</a>.<span class=
"definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-xslt-instruction" id="dt-xslt-instruction" title=
"XSLT instruction"></a>An <b>XSLT instruction</b> is an <a title=
"XSLT element" class="termref" href="#dt-xslt-element">XSLT
element</a> whose syntax summary in this specification contains the
annotation <code>&lt;!-- category: instruction
--&gt;</code>.<span class="definition">]</span></p>
<p><a title="extension instruction" class="termref" href=
"#dt-extension-instruction">Extension instructions</a> are
described in <a href="#extension-instruction"><i>23.2 Extension
Instructions</i></a>.</p>
<p>The main categories of <a title="XSLT instruction" class=
"termref" href="#dt-xslt-instruction">XSLT instruction</a> are as
follows:</p>
<ul>
<li>
<p>instructions that create new nodes: <a href=
"#element-document"><code>xsl:document</code></a>, <a href=
"#element-element"><code>xsl:element</code></a>, <a href=
"#element-attribute"><code>xsl:attribute</code></a>, <a href=
"#element-processing-instruction"><code>xsl:processing-instruction</code></a>,
<a href="#element-comment"><code>xsl:comment</code></a>, <a href=
"#element-value-of"><code>xsl:value-of</code></a>, <a href=
"#element-text"><code>xsl:text</code></a>, <a href=
"#element-namespace"><code>xsl:namespace</code></a>;</p>
</li>
<li>
<p>an instruction that returns an arbitrary sequence by evaluating
an XPath expression: <a href=
"#element-sequence"><code>xsl:sequence</code></a>;</p>
</li>
<li>
<p>instructions that cause conditional or repeated evaluation of
nested instructions: <a href="#element-if"><code>xsl:if</code></a>,
<a href="#element-choose"><code>xsl:choose</code></a>,
<span><a href="#element-try"><code>xsl:try</code></a>,</span>
<a href="#element-for-each"><code>xsl:for-each</code></a>, <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>,
<span><a href="#element-fork"><code>xsl:fork</code></a>, <a href=
"#element-iterate"><code>xsl:iterate</code></a> and its subordinate
instructions <a href=
"#element-next-iteration"><code>xsl:next-iteration</code></a> and
<a href="#element-break"><code>xsl:break</code></a></span>;</p>
</li>
<li>
<p>instructions that invoke templates: <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a>,
<a href=
"#element-call-template"><code>xsl:call-template</code></a>,
<a href="#element-next-match"><code>xsl:next-match</code></a>;</p>
</li>
<li>
<p>Instructions that declare variables: <a href=
"#element-variable"><code>xsl:variable</code></a>, <a href=
"#element-param"><code>xsl:param</code></a>;</p>
</li>
<li>
<p>other specialized instructions: <a href=
"#element-number"><code>xsl:number</code></a>, <a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a>,
<span><a href="#element-assert"><code>xsl:assert</code></a>,</span>
<a href="#element-message"><code>xsl:message</code></a>, <a href=
"#element-result-document"><code>xsl:result-document</code></a>,
<span><a href="#element-stream"><code>xsl:stream</code></a>,
<a href="#element-perform-sort"><code>xsl:perform-sort</code></a>,
<a href="#element-merge"><code>xsl:merge</code></a></span>.</p>
</li>
</ul>
<p>Often, a <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> will include an
<a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction, which selects a sequence of nodes to be processed.
Each of the selected nodes is processed by searching the stylesheet
for a matching <a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a> and evaluating the <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> of that
template rule. The resulting sequences of items are concatenated,
in order, to give the result of the <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction, as described in <a href="#applying-templates"><i>6.3
Applying Template Rules</i></a>; this sequence is often added to a
<a title="result tree" class="termref" href=
"#dt-result-tree">result tree</a>. Since the <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructors</a> of the
selected <a title="template rule" class="termref" href=
"#dt-template-rule">template rules</a> may themselves contain
<a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instructions, this results in a cycle of selecting nodes,
identifying <a title="template rule" class="termref" href=
"#dt-template-rule">template rules</a>, constructing sequences, and
constructing <a title="result tree" class="termref" href=
"#dt-result-tree">result trees</a>, that recurses through a
<a title="source tree" class="termref" href=
"#dt-source-tree">source tree</a>.</p>
</div>
<div class="div2">
<h3><a name="context" id="context"></a>2.5 <a href="#context"
style="text-decoration: none">The Evaluation Context</a></h3>
<p>The results of some expressions and instructions in a stylesheet
may depend on information provided contextually. This context
information is divided into two categories: the static context,
which is known during static analysis of the stylesheet, and the
dynamic context, which is not known until the stylesheet is
evaluated. Although information in the static context is known at
analysis time, it is sometimes used during stylesheet
evaluation.</p>
<p>Some context information can be set by means of declarations
within the stylesheet itself. For example, the namespace bindings
used for any XPath expression are determined by the namespace
declarations present in containing elements in the stylesheet.
Other information may be supplied externally or implicitly: an
example is the current date and time.</p>
<p>The context information used in processing an XSLT stylesheet
includes as a subset all the context information required when
evaluating XPath expressions. The <span>XPath 3.0</span>
specification defines a static and dynamic context that the host
language (in this case, XSLT) may initialize, which affects the
results of XPath expressions used in that context. XSLT augments
the context with additional information: this additional
information is used firstly by XSLT constructs outside the scope of
XPath (for example, the <a href=
"#element-sort"><code>xsl:sort</code></a> element), and secondly,
by functions that are defined in the XSLT specification (such as
<a href="#func-key"><code>key</code></a> and <a href=
"#func-current-group"><code>current-group</code></a>) that are
available for use in XPath expressions appearing within a
stylesheet.</p>
<p>The static context for an expression or other construct in a
stylesheet is determined by the place in which it appears
lexically. The details vary for different components of the static
context, but in general, elements within a stylesheet module affect
the static context for their descendant elements within the same
stylesheet module.</p>
<p>The dynamic context is maintained as a stack. When an
instruction or expression is evaluated, it may add dynamic context
information to the stack; when evaluation is complete, the dynamic
context reverts to its previous state. An expression that accesses
information from the dynamic context always uses the value at the
top of the stack.</p>
<p>The most commonly used component of the dynamic context is the
<a title="context item" class="termref" href=
"#dt-context-item">context item</a>. This is an implicit variable
whose value is the item currently being processed (it may be a
node, an atomic value, <span>or a function item</span>). The value
of the context item can be referenced within an XPath expression
using the expression <code>.</code> (dot).</p>
<p>Full details of the static and dynamic context are provided in
<a href="#static-and-dynamic-context"><i>5.4 The Static and Dynamic
Context</i></a>.</p>
</div>
<div class="div2">
<h3><a name="parsing-and-serialization" id=
"parsing-and-serialization"></a>2.6 <a href=
"#parsing-and-serialization" style="text-decoration: none">Parsing
and Serialization</a></h3>
<p>An XSLT <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> describes a process that constructs
a set of <a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result trees</a> from a set of
<a title="source tree" class="termref" href=
"#dt-source-tree">source trees</a>.</p>
<p>The <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> does not describe how a <a title=
"source tree" class="termref" href="#dt-source-tree">source
tree</a> is constructed. Some possible ways of constructing source
trees are described in <a href="#xpath-datamodel-30">[Data
Model]</a>. Frequently an <a title="implementation" class="termref"
href="#dt-implementation">implementation</a> will operate in
conjunction with an XML parser (or more strictly, in the
terminology of <a href="#REC-xml">[XML 1.0]</a>, an <em>XML
processor</em>), to build a source tree from an input XML document.
An implementation <span class="verb">may</span> also provide an
application programming interface allowing the tree to be
constructed directly, or allowing it to be supplied in the form of
a DOM Document object (see <a href="#DOM-Level-2-Core">[DOM Level
2]</a>). This is outside the scope of this specification. Users
should be aware, however, that since the input to the
transformation is a tree conforming to the XDM data model as
described in <a href="#xpath-datamodel-30">[Data Model]</a>,
constructs that might exist in the original XML document, or in the
DOM, but which are not within the scope of the data model, cannot
be processed by the <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> and cannot be guaranteed to remain
unchanged in the transformation output. Such constructs include
CDATA section boundaries, the use of entity references, and the
DOCTYPE declaration and internal DTD subset.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-serialization" id="dt-serialization" title=
"serialization"></a>A frequent requirement is to output a <a title=
"final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a> as an XML document
(or in other formats such as HTML). This process is referred to as
<b>serialization</b>.<span class="definition">]</span></p>
<p>Like parsing, serialization is not part of the transformation
process, and it is not <span class="verb">required</span> that an
XSLT processor <span class="verb">must</span> be able to perform
serialization. However, for pragmatic reasons, this specification
describes declarations (the <a href=
"#element-output"><code>xsl:output</code></a> element and the
<a href="#element-character-map"><code>xsl:character-map</code></a>
declarations, see <a href="#serialization"><i>25
Serialization</i></a>), and attributes on the <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction, that allow a <a title="stylesheet" class="termref"
href="#dt-stylesheet">stylesheet</a> to specify the desired
properties of a serialized output file. When serialization is not
being performed, either because the implementation does not support
the serialization option, or because the user is executing the
transformation in a way that does not invoke serialization, then
the content of the <a href=
"#element-output"><code>xsl:output</code></a> and <a href=
"#element-character-map"><code>xsl:character-map</code></a>
declarations has no effect. Under these circumstances the processor
<span class="verb">may</span> report any errors in an <a href=
"#element-output"><code>xsl:output</code></a> or <a href=
"#element-character-map"><code>xsl:character-map</code></a>
declaration, or in the serialization attributes of <a href=
"#element-result-document"><code>xsl:result-document</code></a>,
but is not <span class="verb">required</span> to do so.</p>
</div>
<div class="div2">
<h3><a name="packages-and-modules" id=
"packages-and-modules"></a>2.7 <a href="#packages-and-modules"
style="text-decoration: none">Packages and Modules</a></h3>
<p>In previous versions of the XSLT language, it has been possible
to structure a stylesheet as a collection of modules, using the
<a href="#element-include"><code>xsl:include</code></a> and
<a href="#element-import"><code>xsl:import</code></a> declarations
to express the dependency of on module on others.</p>
<p>In XSLT 3.0 an additional layer of modularization of stylesheet
code is enabled through the introduction of <a title="package"
class="termref" href="#dt-package">packages</a>. A package is a
collection of stylesheet modules with a controlled interface to the
packages that use it: for example, it defines which functions and
templates defined in the package are visible to callers, which are
purely internal, and which are not only public but capable of being
overridden by other functions and templates supplied by the using
package.</p>
<p>Packages are introduced with several motivations, which broadly
divide into two categories:</p>
<ol class="enumar">
<li>
<p>Software engineering benefits: greater re-use of code, greater
robustness through ease of testing, controlled evolution of code in
response to new requirements, ability to deliver code that users
cannot see or modify.</p>
</li>
<li>
<p>Efficiency benefits: the ability to avoid compiling libraries
repeatedly when they are used in multiple stylesheets, and to avoid
holding multiple copies of the same library in memory
simultaneously.</p>
</li>
</ol>
<p>Packages are designed to allow separate compilation: that is, a
package can be compiled independently of the packages that use it.
This specification does not define a process model for compilation,
or expand on what it means to compile different packages
independently. Nor does it mandate that implementations offer any
feature along these lines. It merely defines language features that
are designed to make separate compilation of packages possible.</p>
<p>To achieve this, packages (unlike modules):</p>
<ul>
<li>
<p>Must not contain unresolved references to functions, templates,
or variables declared in other packages;</p>
</li>
<li>
<p>Have strict rules governing the ability to override declarations
in a <a title="library package" class="termref" href=
"#dt-library-package">library package</a> with declarations in a
package that uses the library;</p>
</li>
<li>
<p>Constrain the visibility of component names and of context
declarations such as the declarations of keys and decimal
formats;</p>
</li>
<li>
<p>Can declare a mode (a collection of template rules) as final,
which disallows the addition of new overriding template rules in a
using package;</p>
</li>
<li>
<p>Require explicit disambiguation where naming conflicts arise,
for example when a package uses two other packages that both export
like-named components;</p>
</li>
<li>
<p>Allow multiple specializations of library components to coexist
in the same application.</p>
</li>
</ul>
<p>A package is defined by means of an XML document whose outermost
element is an <a href=
"#element-package"><code>xsl:package</code></a> element. This is
referred to as the <a title="package manifest" class="termref"
href="#dt-package-manifest">package manifest</a>. The <a href=
"#element-package"><code>xsl:package</code></a> element has
optional child elements <a href=
"#element-use-package"><code>xsl:use-package</code></a>, <a href=
"#element-expose"><code>xsl:expose</code></a>, and <a href=
"#element-global-context-item"><code>xsl:global-context-item</code></a>
describing properties of the package. The package manifest may
refer to an external top-level stylesheet module using an <a href=
"#element-include"><code>xsl:include</code></a> or <a href=
"#element-import"><code>xsl:import</code></a> declaration, or it
may contain the body of a stylesheet module inline (the two
approaches can also be mixed).</p>
<p>When no packages are explicitly defined, the entire stylesheet
is treated as a single package; the effect is as if the <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href=
"#element-transform"><code>xsl:transform</code></a> element of the
<a title="principal stylesheet module" class="termref" href=
"#dt-principal-stylesheet-module">principal stylesheet module</a>
were replaced by an <a href=
"#element-package"><code>xsl:package</code></a> element with no
other information in the package manifest.</p>
</div>
<div class="div2">
<h3><a name="extensibility" id="extensibility"></a>2.8 <a href=
"#extensibility" style=
"text-decoration: none">Extensibility</a></h3>
<p>XSLT defines a number of features that allow the language to be
extended by implementers, or, if implementers choose to provide the
capability, by users. These features have been designed, so far as
possible, so that they can be used without sacrificing
interoperability. Extensions other than those explicitly defined in
this specification are not permitted.</p>
<p>These features are all based on XML namespaces; namespaces are
used to ensure that the extensions provided by one implementer do
not clash with those of a different implementer.</p>
<p>The most common way of extending the language is by providing
additional functions, which can be invoked from XPath expressions.
These are known as <a title="extension function" class="termref"
href="#dt-extension-function">extension functions</a>, and are
described in <a href="#extension-functions"><i>23.1 Extension
Functions</i></a>.</p>
<p>It is also permissible to extend the language by providing new
<a title="instruction" class="termref" href=
"#dt-instruction">instructions</a>. These are referred to as
<a title="extension instruction" class="termref" href=
"#dt-extension-instruction">extension instructions</a>, and are
described in <a href="#extension-instruction"><i>23.2 Extension
Instructions</i></a>. A stylesheet that uses extension instructions
in a particular namespace must declare that it is doing so by using
the <code>[xsl:]extension-element-prefixes</code> attribute.</p>
<p>Extension instructions and extension functions defined according
to these rules <span class="verb">may</span> be provided by the
implementer of the XSLT processor, and the implementer <span class=
"verb">may</span> also provide facilities to allow users to create
further extension instructions and extension functions.</p>
<p>This specification defines how extension instructions and
extension functions are invoked, but the facilities for creating
new extension instructions and extension functions are <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. For
further details, see <a href="#extension"><i>23 Extensibility and
Fallback</i></a>.</p>
<p>The XSLT language can also be extended by the use of <a title=
"extension attribute" class="termref" href=
"#dt-extension-attribute">extension attributes</a> (see <a href=
"#extension-attributes"><i>3.3 Extension Attributes</i></a>), and
by means of <a title="user-defined data element" class="termref"
href="#dt-data-element">user-defined data elements</a> (see
<a href="#user-defined-top-level"><i>3.8.3 User-defined Data
Elements</i></a>).</p>
</div>
<div class="div2">
<h3><a name="stylesheets-and-schemas" id=
"stylesheets-and-schemas"></a>2.9 <a href=
"#stylesheets-and-schemas" style=
"text-decoration: none">Stylesheets and XML Schemas</a></h3>
<p>An XSLT <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> can make use of information from a
schema. An XSLT transformation can take place in the absence of a
schema (and, indeed, in the absence of a DTD), but where the source
document has undergone schema validity assessment, the XSLT
processor has access to the type information associated with
individual nodes, not merely to the untyped text.</p>
<p>Information from a schema can be used both statically (when the
<a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> is compiled), and dynamically
(during evaluation of the stylesheet to transform a source
document).</p>
<p>There are places within a <a title="stylesheet" class="termref"
href="#dt-stylesheet">stylesheet</a>, and within XPath <a title=
"expression" class="termref" href="#dt-expression">expressions</a>
and <a title="pattern" class="termref" href=
"#dt-pattern">patterns</a> in a <a title="stylesheet" class=
"termref" href="#dt-stylesheet">stylesheet</a>, where it is
possible to refer to named type definitions in a schema, or to
element and attribute declarations. For example, it is possible to
declare the types expected for the parameters of a function. This
is done using the <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-SequenceType">SequenceType</a><sup><small>XP30</small></sup>
syntax defined in <a href="#xpath-30">[XPath 3.0]</a>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-schema-component" id="dt-schema-component" title=
"schema component"></a>Type definitions and element and attribute
declarations are referred to collectively as <b>schema
components</b>.<span class="definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-in-scope-schema-component" id="dt-in-scope-schema-component"
title="in-scope schema component"></a>The <a title=
"schema component" class="termref" href=
"#dt-schema-component">schema components</a> that may be referenced
by name in a <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> are referred to as the <b>in-scope
schema components</b>. This set is the same throughout all the
modules of a stylesheet.<span class="definition">]</span></p>
<p>The conformance rules for XSLT <span>3.0</span>, defined in
<a href="#conformance"><i>26 Conformance</i></a>, distinguish
between a <a title="basic XSLT processor" class="termref" href=
"#dt-basic-xslt-processor">basic XSLT processor</a> and a <a title=
"schema-aware XSLT processor" class="termref" href=
"#dt-schema-aware-xslt-processor">schema-aware XSLT processor</a>.
As the names suggest, a basic XSLT processor does not support the
features of XSLT that require access to schema information, either
statically or dynamically. A <a title="stylesheet" class="termref"
href="#dt-stylesheet">stylesheet</a> that works with a basic XSLT
processor will produce the same results with a schema-aware XSLT
processor provided that the source documents are untyped (that is,
they are not validated against a schema). However, if source
documents are validated against a schema then the results may be
different from the case where they are not validated. Some
constructs that work on untyped data may fail with typed data (for
example, an attribute of type <code>xs:date</code> cannot be used
as an argument of the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-substring"><code>substring</code></a><sup><small>FO30</small></sup>
function) and other constructs may produce different results
depending on the datatype (for example, given the element
<code>&lt;product price="10.00" discount="2.00"/&gt;</code>, the
expression <code>@price gt @discount</code> will return true if the
attributes have type <code>xs:decimal</code>, but will return false
if they are untyped).</p>
<p>There is a standard set of type definitions that are always
available as <a title="in-scope schema component" class="termref"
href="#dt-in-scope-schema-component">in-scope schema components</a>
in every stylesheet. These are defined in <a href=
"#built-in-types"><i>3.15 Built-in Types</i></a>.</p>
<p>The remainder of this section describes facilities that are
available only with a <a title="schema-aware XSLT processor" class=
"termref" href="#dt-schema-aware-xslt-processor">schema-aware XSLT
processor</a>.</p>
<p>Additional <a title="schema component" class="termref" href=
"#dt-schema-component">schema components</a> (type definitions,
element declarations, and attribute declarations) may be added to
the <a title="in-scope schema component" class="termref" href=
"#dt-in-scope-schema-component">in-scope schema components</a> by
means of the <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>
declaration in a stylesheet.</p>
<p>The <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>
declaration may reference an external schema document by means of a
URI, or it may contain an inline <code>xs:schema</code>
element.</p>
<p>It is only necessary to import a schema explicitly if one or
more of its <a title="schema component" class="termref" href=
"#dt-schema-component">schema components</a> are referenced
explicitly by name in the <a title="stylesheet" class="termref"
href="#dt-stylesheet">stylesheet</a>; it is not necessary to import
a schema merely because the stylesheet is used to process a source
document that has been assessed against that schema. It is possible
to make use of the information resulting from schema assessment
(for example, the fact that a particular attribute holds a date)
even if no schema has been imported by the stylesheet.</p>
<p>Importing a schema does not of itself say anything about the
type of the source document that the <a title="stylesheet" class=
"termref" href="#dt-stylesheet">stylesheet</a> is expected to
process. The imported type definitions can be used for temporary
nodes or for nodes on a <a title="result tree" class="termref"
href="#dt-result-tree">result tree</a> just as much as for nodes in
source documents. It is possible to make assertions about the type
of an input document by means of tests within the <a title=
"stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>.
For example:</p>
<div class="example">
<div class="exampleHeader"><a name="d7e3172" id=
"d7e3172"></a>Example: Asserting the Required Type of the Source
Document</div>
<div class="exampleInner">
<pre>
&lt;xsl:mode typed="lax"&gt;
  &lt;xsl:context-item use="required"
                    as="document-node(schema-element(my:invoice))"/&gt;
&lt;/xsl:mode&gt;
</pre></div>
<p>This example will cause the transformation to fail with an error
message when the <a title="initial mode" class="termref" href=
"#dt-initial-mode">initial mode</a> is the unnamed mode, unless the
document element of the source document is valid against the
top-level element declaration <code>my:invoice</code>, and has been
annotated as such.</p>
<p>The setting <code>typed="lax"</code> further ensures that in any
match pattern for a template rule in this mode, an element name
that corresponds to the name of an element declaration in the
schema is taken as referring to elements validated against that
declaration: for example, <code>match="employee"</code> will only
match a validated <code>employee</code> element. Selecting this
option enables the XSLT processor to do more compile-time
type-checking against the schema, for example it allows the
processor to produce warning or error messages when path
expressions contain misspelt element names, or confuse an element
with an attribute.</p>
</div>
<p>It is also true that importing a schema does not of itself say
anything about the structure of the result tree. It is possible to
request validation of a result tree against the schema by using the
<a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction, for example:</p>
<div class="example">
<div class="exampleHeader"><a name="d7e3200" id=
"d7e3200"></a>Example: Requesting Validation of the Result
Document</div>
<div class="exampleInner">
<pre>
&lt;xsl:template match="/"&gt;
  &lt;xsl:result-document validation="strict"&gt;
    &lt;xhtml:html&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/xhtml:html&gt;
  &lt;/xsl:result-document&gt;
&lt;/xsl:template&gt;
               
</pre></div>
<p>This example will cause the transformation to fail with an error
message unless the document element of the result document is valid
against the top-level element declaration
<code>xhtml:html</code>.</p>
</div>
<p>It is possible that a source document may contain nodes whose
<a title="type annotation" class="termref" href=
"#dt-type-annotation">type annotation</a> is not one of the types
imported by the stylesheet. This creates a potential problem
because in the case of an expression such as <code>data(.) instance
of xs:integer</code> the system needs to know whether the type
named in the type annotation of the context node is derived by
restriction from the type <code>xs:integer</code>. This information
is not explicitly available in an XDM tree, as defined in <a href=
"#xpath-datamodel-30">[Data Model]</a>. The implementation may
choose one of several strategies for dealing with this
situation:</p>
<ol class="enumar">
<li>
<p>The processor may signal a <a title="dynamic error" class=
"termref" href="#dt-dynamic-error">dynamic error</a> if a source
document is found to contain a <a title="type annotation" class=
"termref" href="#dt-type-annotation">type annotation</a> that is
not known to the processor.</p>
</li>
<li>
<p>The processor may maintain additional metadata, beyond that
described in <a href="#xpath-datamodel-30">[Data Model]</a>, that
allows the source document to be processed as if all the necessary
schema information had been imported using <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>. Such
metadata might be held in the data structure representing the
source document itself, or it might be held in a system catalog or
repository.</p>
</li>
<li>
<p>The processor may be configured to use a fixed set of schemas,
which are automatically used to validate all source documents
before they can be supplied as input to a transformation. In this
case it is impossible for a source document to have a <a title=
"type annotation" class="termref" href="#dt-type-annotation">type
annotation</a> that the processor is not aware of.</p>
</li>
<li>
<p>The processor may be configured to treat the source document as
if no schema processing had been performed, that is, effectively to
strip all type annotations from elements and attributes on input,
marking them instead as having type <code>xs:untyped</code> and
<code>xs:untypedAtomic</code> respectively.</p>
</li>
</ol>
<p>Where a stylesheet author chooses to make assertions about the
types of nodes or of <a title="variable" class="termref" href=
"#dt-variable">variables</a> and <a title="parameter" class=
"termref" href="#dt-parameter">parameters</a>, it is possible for
an XSLT processor to perform static analysis of the <a title=
"stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>
(that is, analysis in the absence of any source document). Such
analysis <span class="verb">may</span> reveal errors that would
otherwise not be discovered until the transformation is actually
executed. An XSLT processor is not <span class=
"verb">required</span> to perform such static type-checking. Under
some circumstances (see <a href="#errors"><i>2.11 Error
Handling</i></a>) type errors that are detected early <span class=
"verb">may</span> be reported as static errors. In addition an
implementation <span class="verb">may</span> report any condition
found during static analysis as a warning, provided that this does
not prevent the stylesheet being evaluated as described by this
specification.</p>
<p>A <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> can also control the <a title=
"type annotation" class="termref" href="#dt-type-annotation">type
annotations</a> of nodes that it constructs in a <a title=
"final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a>, or in <a title=
"temporary tree" class="termref" href=
"#dt-temporary-tree">temporary trees</a>. This can be done in a
number of ways.</p>
<ul>
<li>
<p>It is possible to request explicit validation of a complete
document, that is, a tree rooted at a document node. This applies
both to temporary trees constructed using the <a href=
"#element-document"><code>xsl:document</code></a> (or <a href=
"#element-copy"><code>xsl:copy</code></a>) instruction and also to
<a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result trees</a> constructed using
<a href=
"#element-result-document"><code>xsl:result-document</code></a>.
Validation is either strict or lax, as described in <a href=
"#xmlschema-1">[XML Schema Part 1]</a>. If validation of a
<a title="result tree" class="termref" href=
"#dt-result-tree">result tree</a> fails (strictly speaking, if the
outcome of the validity assessment is <code>invalid</code>), then
the transformation fails, but in all other cases, the element and
attribute nodes of the tree will be annotated with the names of the
types to which these nodes conform. These <a title=
"type annotation" class="termref" href="#dt-type-annotation">type
annotations</a> will be discarded if the result tree is serialized
as an XML document, but they remain available when the result tree
is passed to an application (perhaps another <a title="stylesheet"
class="termref" href="#dt-stylesheet">stylesheet</a>) for further
processing.</p>
</li>
<li>
<p>It is also possible to validate individual element and attribute
nodes as they are constructed. This is done using the
<code>type</code> and <code>validation</code> attributes of the
<a href="#element-element"><code>xsl:element</code></a>, <a href=
"#element-attribute"><code>xsl:attribute</code></a>, <a href=
"#element-copy"><code>xsl:copy</code></a>, and <a href=
"#element-copy-of"><code>xsl:copy-of</code></a> instructions, or
the <code>xsl:type</code> and <code>xsl:validation</code>
attributes of a literal result element.</p>
</li>
<li>
<p>When elements, attributes, or document nodes are copied, either
explicitly using the <a href=
"#element-copy"><code>xsl:copy</code></a> or <a href=
"#element-copy-of"><code>xsl:copy-of</code></a> instructions, or
implicitly when nodes in a sequence are attached to a new parent
node, the options <code>validation="strip"</code> and
<code>validation="preserve"</code> are available, to control
whether existing <a title="type annotation" class="termref" href=
"#dt-type-annotation">type annotations</a> are to be retained or
not.</p>
</li>
</ul>
<p>When nodes in a <a title="temporary tree" class="termref" href=
"#dt-temporary-tree">temporary tree</a> are validated, type
information is available for use by operations carried out on the
temporary tree, in the same way as for a source document that has
undergone schema assessment.</p>
<p>For details of how validation of element and attribute nodes
works, see <a href="#validation"><i>24.4 Validation</i></a>.</p>
</div>
<div class="div2">
<h3><a name="streaming-concepts" id="streaming-concepts"></a>2.10
<a href="#streaming-concepts" style=
"text-decoration: none">Streaming</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-streaming" id="dt-streaming" title="streaming"></a>The term
<b>streaming</b> refers to a manner of processing in which
documents (such as source and result documents) are not represented
by a complete tree of nodes occupying memory proportional to
document size, but instead are processed "on the fly" as a sequence
of events, similar in concept to the stream of events notified by
an XML parser to represent markup in lexical XML.<span class=
"definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-streamed-document" id="dt-streamed-document" title=
"streamed document"></a>A <b>streamed document</b> is a <a title=
"source tree" class="termref" href="#dt-source-tree">source
tree</a> that is processed using streaming, that is, without
constructing a complete tree of nodes in memory.<span class=
"definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-streamed-document-node" id="dt-streamed-document-node" title=
"streamed node"></a>A <b>streamed node</b> is a node in a <a title=
"streamed document" class="termref" href=
"#dt-streamed-document">streamed document</a>.<span class=
"definition">]</span></p>
<p>Many processors implementing earlier versions of this
specification have adopted an architecture that allows streaming of
the <a title="result tree" class="termref" href=
"#dt-result-tree">result tree</a> directly to a serializer, without
first materializing the complete result tree in memory. Streaming
of the <a title="source tree" class="termref" href=
"#dt-source-tree">source tree</a>, however, has proved to be more
difficult without subsetting the language. This has created a
situation where documents exceeding the capacity of virtual memory
could not be transformed. XSLT 3.0 therefore introduces facilities
allowing stylesheets to be written in a way that makes streaming of
source documents possible, without excessive reliance on
processor-specific optimization techniques.</p>
<p>Streaming achieves two important objectives: it allows large
documents to be transformed without requiring correspondingly large
amounts of memory; and it allows the processor to start producing
output before it has finished receiving its input, thus reducing
latency.</p>
<p>This specification does not attempt to legislate precisely which
implementation techniques fall under the definition of streaming,
and which do not. A number of techniques are available that reduce
memory requirements, while still requiring a degree of buffering,
or allocation of memory to partial results. A stylesheet that
requests streaming of a source document is indicating that the
processor should avoid assuming that the entire source document
will fit in memory; in return, the stylesheet must be written in a
way that makes streaming possible. This specification does not
attempt to describe the algorithms that the processor should
actually use, or to impose quantitative constraints on the
resources that these algorithms should consume.</p>
<p>Nothing in this specification, nor in its predecessors <a href=
"#xslt">[XSLT 1.0]</a> and <a href="#xslt20">[XSLT 2.0]</a>,
prevents a processor using streaming whenever it sees an
opportunity to do so. However, experience has shown that in order
to achieve streaming, it is often necessary to write stylesheet
code in such a way as to make this possible. Therefore, XSLT 3.0
provides explicit constructs allowing the stylesheet author to
request streaming, and defines explicit static constraints on the
structure of the code which are designed to make streaming
possible.</p>
<p>A processor that claims conformance with the streaming option
offers a guarantee that when streaming is requested for a source
document, and when the stylesheet conforms to the rules that make
the processing <a title="guaranteed-streamable" class="termref"
href="#dt-guaranteed-streamable">guaranteed-streamable</a>, then an
algorithm will be adopted in which memory consumption is either
completely independent of document size, or increases only very
slowly as document size increases, allowing documents to be
processed that are orders-of-magnitude larger than the physical
memory available. A processor that does not claim conformance with
the streaming option must still process a stylesheet and deliver
the correct results, but is not required to use streaming
algorithms, and may therefore fail with out-of-memory errors when
presented with large source documents.</p>
<p>Apart from the fact that there are constructs to request
streaming, and rules that must be followed to guarantee that
streaming is possible, the language has been designed so there are
as few differences as possible between streaming and non-streaming
evaluation. The semantics of the language continue to be expressed
in terms of the XDM data model, which is substantively unchanged;
but readers must take care to observe that when terms like "node"
and "axis" are used, the concepts are completely abstract and may
have no direct representation in the run-time execution
environment.</p>
<p>Streamed processing of a document can be initiated in one of
<span>three</span> ways:</p>
<ul>
<li>
<p>The <a title="initial mode" class="termref" href=
"#dt-initial-mode">initial mode</a> can be declared as a <a title=
"streamable mode" class="termref" href=
"#dt-streamable-mode">streamable mode</a>. In this case the
<span><a title="initial match selection" class="termref" href=
"#dt-initial-match-selection">initial match selection</a> will
generally be a document node (or sequence of document
nodes),</span> supplied by the calling application in a form that
allows streaming (that is, in some form other than a tree in
memory; for example, as a reference to a push or pull XML parser
primed to deliver a stream of events). <span>The type of these
nodes can be constrained by using the attribute
<code>on-no-match="fail"</code> on the <a title="initial mode"
class="termref" href="#dt-initial-mode">initial mode</a>, and using
this mode only for processing the top-level nodes.</span></p>
</li>
<li>
<p>Streamed processing of any document can be initiated using the
<a href="#element-stream"><code>xsl:stream</code></a> instruction.
This has an attribute <code>href</code> whose value is the URI of a
document to be processed using streaming, and the actual processing
to be applied is defined by the instructions written as children of
the <a href="#element-stream"><code>xsl:stream</code></a>
instruction.</p>
</li>
<li>
<p>Streamed merging of a set of input documents can be initiated
using the <a href="#element-merge"><code>xsl:merge</code></a>
instruction.</p>
</li>
</ul>
<p>The rules for streamability, which are defined in detail in
<a href="#streamability"><i>19 Streamability</i></a>, impose two
main constraints:</p>
<ul>
<li>
<p>The only nodes reachable from the node that is currently being
processed are its attributes and namespaces, its ancestors and
their attributes and namespaces, and its descendants and their
attributes and namespaces. The siblings of the node, and the
siblings of its ancestors, are not reachable in the tree, and any
attempt to use their values is a <a title="static error" class=
"termref" href="#dt-static-error">static error</a>.</p>
</li>
<li>
<p>When processing a given node in the tree, each descendant node
can only be visited once. Essentially this allows two styles of
processing: either visit each of the children once, and then
process that child with the same restrictions applied; or process
all the descendants in a single pass, in which case it is not
possible while processing a descendant to make any further downward
selection.</p>
</li>
</ul>
<p>The second restriction, that only one visit to the children is
allowed, means that XSLT code that was not designed with streaming
in mind will often need to be rewritten to make it streamable. In
many cases it is possible to do this using a technique sometimes
called <em>windowing</em> or <em>burst-mode streaming</em> (note
this is not quite the same meaning as <em>windowing</em> in XQuery
3.0). Many XML documents consist of a large number of elements,
each of manageable size, representing transactions or business
objects where each such element can be processed independently: in
such cases, an effective design pattern is to write a streaming
transformation that takes a snapshot of each element in turn,
processing the snapshot using the full power of the XSLT language.
Each snapshot is a tree built in memory and is therefore fully
navigable. For details see the <a href=
"#func-snapshot"><code>snapshot</code></a> and <a href=
"#func-copy-of"><code>copy-of</code></a> functions.</p>
<p>The new facility of <em>accumulators</em> allows applications
complete control over how much information is retained (and by
implication, how much memory is required) in the course of a pass
over a <a title="streamed document" class="termref" href=
"#dt-streamed-document">streamed document</a>. An accumulator
computes a value for every node in a streamed document: or more
accurately, two values, one for the first visit to a node (before
visiting its descendants), and a second value for the second visit
to the node (after visiting the descendants). The computation is
structured in such a way that the value for a given node can depend
only on the value for the previous node in document order together
with the data available when positioned at the current node (for
example, the attribute values). Based on the well-established fold
operation of functional programming languages, accumulators provide
the convenience and economy of mutable variables while remaining
within the constraints of a purely declarative processing
model.</p>
<p>Streaming applications often fall into one of the following
categories:</p>
<ul>
<li>
<p>Aggregation applications, where a single aggregation operation
(perhaps <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-count"><code>count</code></a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#func-sum"><code>sum</code></a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#func-exists"><code>exists</code></a><sup><small>FO30</small></sup>,
or <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-distinct-values"><code>
distinct-values</code></a><sup><small>FO30</small></sup>) is
applied to a set of elements selected from the streamed source
document by means of a path expression.</p>
</li>
<li>
<p>Record-at-a-time applications, where the source document
consists of a long sequence of elements with similar structure
("records"), and each "record" is processed using the same logic,
independently of any other "records". This kind of processing is
facilitated using the <a href=
"#func-snapshot"><code>snapshot</code></a> and <a href=
"#func-copy-of"><code>copy-of</code></a> function mentioned
earlier.</p>
</li>
<li>
<p>Grouping applications, where the output follows the structure of
the input, except that an extra layer of hierarchy is added. For
example, the input might be a flat series of banking transactions
in date/time order, and the output might contain the same
transactions grouped by date.</p>
</li>
<li>
<p>Accumulator applications, which are the same as record-at-a-time
applications, except that the processing of one "record" might
depend on data encountered earlier in the document. A classic
example is processing a sequence of banking transactions in which
the input transaction contains a debit or credit amount, and the
output adds a running total (the account balance). The <a href=
"#element-iterate"><code>xsl:iterate</code></a> instruction has
been introduced to facilitate this style of processing.</p>
</li>
<li>
<p>Isomorphic transformations, in which there is an ordered (often
largely one-to-one) relationship between the nodes of the source
tree and the nodes of the result tree: for example, transformations
that involve only the renaming or selective deletion of nodes, or
scalar manipulations of the values held in the leaf nodes. Such
transformations are most conveniently expressed using recursive
application of template rules. This is possible with a streamed
input document only if all the template rules adhere to the
constraints required for streamability. To enforce these rules,
while still allowing unrestricted processing of other documents
within the same transformation, all streaming evaluation must be
carried out using a specific <a title="mode" class="termref" href=
"#dt-mode">mode</a>, which is declared to be a streaming mode by
means of an <a href="#element-mode"><code>xsl:mode</code></a>
declaration in the stylesheet.</p>
</li>
</ul>
<p>There are important classes of application in which streaming is
possible only if multiple streams can be processed in parallel.
This specification therefore provides facilities:</p>
<ol class="enumar">
<li>
<p>allowing multiple sorted input sequences to be merged into one
sorted output sequence (the <a href=
"#element-merge"><code>xsl:merge</code></a> instruction)</p>
</li>
<li>
<p>allowing multiple output sequences to be generated during a
single pass of an input sequence (the <a href=
"#element-fork"><code>xsl:fork</code></a> instruction).</p>
</li>
</ol>
<p>These facilities have been designed in such a way that they can
readily be implemented using streaming, that is, without
materializing the input or output sequences in memory.</p>
</div>
<div class="div2">
<h3><a name="errors" id="errors"></a>2.11 <a href="#errors" style=
"text-decoration: none">Error Handling</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-static-error" id="dt-static-error" title="static error"></a>An
error that can be detected by examining a <a title="stylesheet"
class="termref" href="#dt-stylesheet">stylesheet</a> before
execution starts (that is, before the source document and values of
stylesheet parameters are available) is referred to as a <b>static
error</b>.<span class="definition">]</span></p>
<p>Errors classified in this specification as static errors
<span class="verb">must</span> be signaled by all implementations:
that is, the <a title="processor" class="termref" href=
"#dt-processor">processor</a> <span class="verb">must</span>
indicate that the error is present. A static error <span class=
"verb">must</span> be signaled even if it occurs in a part of the
<a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> that is never evaluated. Static
errors are never recoverable. After signaling a static error, a
processor <span class="verb">may</span> continue for the purpose of
signaling additional errors, but it <span class="verb">must</span>
eventually terminate abnormally without producing any <a title=
"final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a>.</p>
<p>There is an exception to this rule when the stylesheet specifies
<a title="forwards compatible behavior" class="termref" href=
"#dt-forwards-compatible-behavior">forwards compatible behavior</a>
(see <a href="#forwards"><i>3.11 Forwards Compatible
Processing</i></a>).</p>
<p>Generally, errors in the structure of the <a title="stylesheet"
class="termref" href="#dt-stylesheet">stylesheet</a>, or in the
syntax of XPath <a title="expression" class="termref" href=
"#dt-expression">expressions</a> contained in the stylesheet, are
classified as <a title="static error" class="termref" href=
"#dt-static-error">static errors</a>. Where this specification
states that an element in the stylesheet <span class=
"verb">must</span> or <span class="verb">must not</span> appear in
a certain position, or that it <span class="verb">must</span> or
<span class="verb">must not</span> have a particular attribute, or
that an attribute <span class="verb">must</span> or <span class=
"verb">must not</span> have a value satisfying specified
conditions, then any contravention of this rule is a static error
unless otherwise specified.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-dynamic-error" id="dt-dynamic-error" title=
"dynamic error"></a>An error that is not detected until a source
document is being transformed is referred to as a <b>dynamic
error</b>.<span class="definition">]</span></p>
<p>When a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> occurs, and is not caught
using <a href="#element-catch"><code>xsl:catch</code></a>, the
<a title="processor" class="termref" href=
"#dt-processor">processor</a> <span class="verb">must</span> signal
the error, and the transformation fails.</p>
<p>Because different implementations may optimize execution of the
<a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> in different ways, the detection of
dynamic errors is to some degree <a title=
"implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a>. In
cases where an implementation is able to produce the <a title=
"final result tree" class="termref" href=
"#dt-final-result-tree">final result trees</a> without evaluating a
particular construct, the implementation is never <span class=
"verb">required</span> to evaluate that construct solely in order
to determine whether doing so causes a dynamic error. For example,
if a <a title="variable" class="termref" href=
"#dt-variable">variable</a> is declared but never referenced, an
implementation <span class="verb">may</span> choose whether or not
to evaluate the variable declaration, which means that if
evaluating the variable declaration causes a dynamic error, some
implementations will signal this error and others will not.</p>
<p>There are some cases where this specification requires that a
construct <span class="verb">must not</span> be evaluated: for
example, the content of an <a href=
"#element-if"><code>xsl:if</code></a> instruction <span class=
"verb">must not</span> be evaluated if the test condition is false.
This means that an implementation <span class="verb">must
not</span> signal any dynamic errors that would arise if the
construct were evaluated.</p>
<p>An implementation <span class="verb">may</span> signal a
<a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> before any source document is
available, but only if it can determine that the error would be
signaled for every possible source document and every possible set
of parameter values. For example, some <a title="circularity"
class="termref" href="#dt-circularity">circularity</a> errors fall
into this category: see <a href="#circularity"><i>9.11 Circular
Definitions</i></a>.</p>
<p>There are also some <a title="dynamic error" class="termref"
href="#dt-dynamic-error">dynamic errors</a> where the specification
gives a processor license to signal the error during the analysis
phase even if the construct might never be executed; an example is
the use of an invalid QName as a literal argument to a function
such as <a href="#func-key"><code>key</code></a>, or the use of an
invalid regular expression in the <code>regex</code> attribute of
the <a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a>
instruction.</p>
<p>A <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> may also be signaled during
the static analysis phase if the error occurs during evaluation of
a <a title="static expression" class="termref" href=
"#dt-static-expression">static expression</a>.</p>
<p>The XPath specification states (see <a href=
"http://www.w3.org/TR/xpath-30/#id-kinds-of-errors">Section 2.3.1
Kinds of Errors</a> <sup><small>XP30</small></sup>) that if any
expression (at any level) can be evaluated during the analysis
phase (because all its explicit operands are known and it has no
dependencies on the dynamic context), then any error in performing
this evaluation <span class="verb">may</span> be reported as a
static error. For XPath expressions used in an XSLT stylesheet,
however, any such errors <span class="verb">must not</span> be
reported as static errors in the stylesheet unless they would occur
in every possible evaluation of that stylesheet; instead, they must
be signaled as dynamic errors, and signaled only if the XPath
expression is actually evaluated.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e3846" id=
"d7e3846"></a>Example: Errors in Constant Subexpressions</div>
<p>An XPath processor may report statically that the expression
<code>1 div 0</code> fails with a "divide by zero" error. But
suppose this XPath expression occurs in an XSLT construct such
as:</p>
<div class="exampleInner">
<pre>
&lt;xsl:choose&gt;
  &lt;xsl:when test="system-property('xsl:version') = '1.0'"&gt;
    &lt;xsl:value-of select="1 div 0"/&gt;
  &lt;/xsl:when&gt;
  &lt;xsl:otherwise&gt;
    &lt;xsl:value-of select="xs:double('INF')"/&gt;
  &lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;
</pre></div>
<p>Then the XSLT processor must not report an error, because the
relevant XPath construct appears in a context where it will never
be executed by an XSLT 2.0 <span>or 3.0</span> processor. (An XSLT
1.0 processor will execute this code successfully, returning
positive infinity, because it uses double arithmetic rather than
decimal arithmetic.)</p>
</div>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-type-error" id="dt-type-error" title="type error"></a>Certain
errors are classified as <b>type errors</b>. A type error occurs
when the value supplied as input to an operation is of the wrong
type for that operation, for example when an integer is supplied to
an operation that expects a node.<span class="definition">]</span>
If a type error occurs in an instruction that is actually
evaluated, then it <span class="verb">must</span> be signaled in
the same way as a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a>. Alternatively, an
implementation <span class="verb">may</span> signal a type error
during the analysis phase in the same way as a <a title=
"static error" class="termref" href="#dt-static-error">static
error</a>, even if it occurs in part of the stylesheet that is
never evaluated, provided it can establish that execution of a
particular construct would never succeed.</p>
<p>It is <a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> whether
type errors are signaled statically.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e3892" id=
"d7e3892"></a>Example: A Type Error</div>
<p>The following construct contains a type error, because
<code>42</code> is not allowed as the value of the
<code>select</code> expression of the <a href=
"#element-number"><code>xsl:number</code></a> instruction (it must
be a node). An implementation <span class="verb">may</span>
optionally signal this as a static error, even though the offending
instruction will never be evaluated, and the type error would
therefore never be signaled as a dynamic error.</p>
<div class="exampleInner">
<pre>
&lt;xsl:if test="false()"&gt;
  &lt;xsl:number select="42"/&gt;
&lt;/xsl:if&gt;
</pre></div>
<p>On the other hand, in the following example it is not possible
to determine statically whether the operand of <span><a href=
"#element-number"><code>xsl:number</code></a></span> will have a
suitable dynamic type. An implementation <span class=
"verb">may</span> produce a warning in such cases, but it
<span class="verb">must not</span> treat it as an error.</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="para"&gt;
  &lt;xsl:param name="p" as="item()"/&gt;
  &lt;xsl:number select="$p"/&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
<p>If more than one error arises, an implementation is not
<span class="verb">required</span> to signal any errors other than
the first one that it detects. It is <a title=
"implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a> which
of the several errors is signaled. This applies both to static
errors and to dynamic errors. An implementation is allowed to
signal more than one error, but if any errors have been signaled,
it <span class="verb">must not</span> finish as if the
transformation were successful.</p>
<p>When a transformation signals one or more dynamic errors, the
final state of any persistent resources updated by the
transformation is <a title="implementation-dependent" class=
"termref" href=
"#dt-implementation-dependent">implementation-dependent</a>.
Implementations are not <span class="verb">required</span> to
restore such resources to their initial state. In particular, where
a transformation produces multiple result documents, it is possible
that one or more serialized result documents <span class=
"verb">may</span> be written successfully before the transformation
terminates, but the application cannot rely on this behavior.</p>
<p>Everything said above about error handling applies equally to
errors in evaluating XSLT instructions, and errors in evaluating
XPath <a title="expression" class="termref" href=
"#dt-expression">expressions</a>. Static errors and dynamic errors
may occur in both cases.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-serialization-error" id="dt-serialization-error" title=
"serialization error"></a>If a transformation has successfully
produced a <a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a>, it is still possible
that errors may occur in serializing the result tree. For example,
it may be impossible to serialize the result tree using the
encoding selected by the user. Such an error is referred to as a
<b>serialization error</b>.<span class="definition">]</span> If the
processor performs serialization, then it <span class=
"verb">must</span> do so as specified in <a href=
"#serialization"><i>25 Serialization</i></a>, and in particular it
<span class="verb">must</span> signal any serialization errors that
occur.</p>
<p>Errors are identified by a QName. For errors defined in this
specification, the namespace of the QName is always
<code>http://www.w3.org/2005/xqt-errors</code> (and is therefore
not given explicitly), while the local part is an 8-character code
in the form <var>PPSSNNNN</var>. Here <var>PP</var> is always
<code>XT</code> (meaning XSLT), and <var>SS</var> is one of
<code>SE</code> (static error), <code>DE</code> (dynamic error),
<code>RE</code> (recoverable dynamic error), or <code>TE</code>
(type error). Note that the allocation of an error to one of these
categories is purely for convenience and carries no normative
implications about the way the error is handled. Many errors, for
example, can be reported either dynamically or statically. These
error codes are used to label error conditions in this
specification, and are summarized in <a href="#error-summary"><i>E
Summary of Error Conditions</i></a>.</p>
<p>Errors defined in related specifications (<a href=
"#xpath-30">[XPath 3.0]</a>, <a href=
"#xpath-functions-30">[Functions and Operators]</a> <a href=
"#xslt-xquery-serialization-30">[XSLT and XQuery
Serialization]</a>) use QNames with a similar structure, in the
same namespace. When errors occur in processing XPath expressions,
an XSLT processor <span class="verb">should</span> use the original
error code reported by the XPath processor, unless a more specific
XSLT error code is available.</p>
<p><span>Implementations <span class="verb">must</span> use the
codes defined in these specifications when signaling errors, to
ensure that <a href="#element-catch"><code>xsl:catch</code></a>
behaves in an interoperable way across implementations. Stylesheet
authors should note, however, that there are many examples of
errors where more than one rule in this specification is violated,
and where the processor therefore has discretion in deciding which
error code to associate with the condition: there is therefore no
guarantee that different processors will always use the same error
code for the same erroneous input.</span></p>
<p>Additional errors defined by an implementation (or by an
application) <span class="verb">may</span> use QNames in an
implementation-defined (or user-defined) namespace without risk of
collision.</p>
</div>
</div>
<div class="div1">
<h2><a name="stylesheet-structure" id="stylesheet-structure"></a>3
<a href="#stylesheet-structure" style=
"text-decoration: none">Stylesheet Structure</a></h2>
<p>This section describes the overall structure of a stylesheet as
a collection of XML documents.</p>
<div class="div2">
<h3><a name="xslt-namespace" id="xslt-namespace"></a>3.1 <a href=
"#xslt-namespace" style="text-decoration: none">XSLT
Namespace</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-xslt-namespace" id="dt-xslt-namespace" title=
"XSLT namespace"></a>The <b>XSLT namespace</b> has the URI
<code>http://www.w3.org/1999/XSL/Transform</code>. It is used to
identify elements, attributes, and other names that have a special
meaning defined in this specification.<span class=
"definition">]</span></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The <code>1999</code> in the URI indicates the year in which the
URI was allocated by the W3C. It does not indicate the version of
XSLT being used, which is specified by attributes (see <a href=
"#stylesheet-element"><i>3.8 Stylesheet Element</i></a> and
<a href="#simplified-stylesheet"><i>3.9 Simplified Stylesheet
Modules</i></a>).</p>
</div>
<p>XSLT <a title="processor" class="termref" href=
"#dt-processor">processors</a> <span class="verb">must</span> use
the XML namespaces mechanism <a href="#xml-names">[Namespaces in
XML]</a> to recognize elements and attributes from this namespace.
Elements from the XSLT namespace are recognized only in the
<a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> and not in the source document. The
complete list of XSLT-defined elements is specified in <a href=
"#element-syntax-summary"><i>D Element Syntax Summary</i></a>.
<a title="implementation" class="termref" href=
"#dt-implementation">Implementations</a> <span class="verb">must
not</span> extend the XSLT namespace with additional elements or
attributes. Instead, any extension <span class="verb">must</span>
be in a separate namespace. Any namespace that is used for
additional instruction elements <span class="verb">must</span> be
identified by means of the <a title="extension instruction" class=
"termref" href="#dt-extension-instruction">extension
instruction</a> mechanism specified in <a href=
"#extension-instruction"><i>23.2 Extension
Instructions</i></a>.</p>
<p>This specification uses a prefix of <code>xsl:</code> for
referring to elements in the XSLT namespace. However, XSLT
stylesheets are free to use any prefix, provided that there is a
namespace declaration that binds the prefix to the URI of the XSLT
namespace.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Throughout this specification, an element or attribute that is
in no namespace, or an <a title="expanded QName" class="termref"
href="#dt-expanded-qname">expanded QName</a> whose namespace part
is an empty sequence, is referred to as having a <b>null namespace
URI</b>.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The conventions used for the names of <a title="XSLT element"
class="termref" href="#dt-xslt-element">XSLT elements</a>,
attributes and functions are that names are all lower-case, use
hyphens to separate words, and use abbreviations only if they
already appear in the syntax of a related language such as XML or
HTML. Names of types defined in XML Schema are regarded as single
words and are capitalized exactly as in XML Schema. This sometimes
leads to composite function names such as <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-current-dateTime"><code>
current-dateTime</code></a><sup><small>FO30</small></sup>.</p>
</div>
</div>
<div class="div2">
<h3><a name="reserved-namespaces" id="reserved-namespaces"></a>3.2
<a href="#reserved-namespaces" style=
"text-decoration: none">Reserved Namespaces</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-reserved-namespace" id="dt-reserved-namespace" title=
"reserved namespace"></a>The XSLT namespace, together with certain
other namespaces recognized by an XSLT processor, are classified as
<b>reserved namespaces</b> and <span class="verb">must</span> be
used only as specified in this and related
specifications.<span class="definition">]</span> The reserved
namespaces are those listed below.</p>
<ul>
<li>
<p>The <a title="XSLT namespace" class="termref" href=
"#dt-xslt-namespace">XSLT namespace</a>, described in <a href=
"#xslt-namespace"><i>3.1 XSLT Namespace</i></a>, is reserved.</p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-standard-function-namespace" id=
"dt-standard-function-namespace" title=
"standard function namespace"></a>The <b>standard function
namespace</b> <code>http://www.w3.org/2005/xpath-functions</code>
is used for functions in the function library defined in <a href=
"#xpath-functions-30">[Functions and Operators]</a> and for
standard functions defined in this specification.<span class=
"definition">]</span></p>
</li>
<li>
<p>The namespace
<code>http://www.w3.org/2005/xpath-functions/math</code> is used
for mathematical functions in the function library defined in
<a href="#xpath-functions-30">[Functions and Operators]</a>.</p>
</li>
<li>
<p>The namespace
<code>http://www.w3.org/2005/xpath-functions/map</code> is used for
functions defined in this specification relating to the
manipulation of <a title="map" class="termref" href=
"#dt-map">maps</a>.</p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"xml-namespace" id="xml-namespace" title="XML namespace"></a>The
<b>XML namespace</b>, defined in <a href="#xml-names">[Namespaces
in XML]</a> as <code>http://www.w3.org/XML/1998/namespace</code>,
is used for attributes such as <code>xml:lang</code>,
<code>xml:space</code>, and <code>xml:id</code>.<span class=
"definition">]</span></p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-schema-namespace" id="dt-schema-namespace" title=
"schema namespace"></a>The <b>schema namespace</b>
<code>http://www.w3.org/2001/XMLSchema</code> is used as defined in
<a href="#xmlschema-1">[XML Schema Part 1]</a><span class=
"definition">]</span>. In a <a title="stylesheet" class="termref"
href="#dt-stylesheet">stylesheet</a> this namespace may be used to
refer to built-in schema datatypes and to the constructor functions
associated with those datatypes.</p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-schema-instance-namespace" id="dt-schema-instance-namespace"
title="schema instance namespace"></a>The <b>schema instance
namespace</b>
<code>http://www.w3.org/2001/XMLSchema-instance</code> is used as
defined in <a href="#xmlschema-1">[XML Schema Part
1]</a><span class="definition">]</span>. Attributes in this
namespace, if they appear in a <a title="stylesheet" class=
"termref" href="#dt-stylesheet">stylesheet</a>, are treated by the
XSLT processor in the same way as any other attributes.</p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-standard-error-namespace" id="dt-standard-error-namespace"
title="standard error namespace"></a>The <b>standard error
namespace</b> <code>http://www.w3.org/2005/xqt-errors</code> is
used for error codes defined in this specification and related
specifications. It is also used for the names of certain predefined
variables accessible within the scope of an <a href=
"#element-catch"><code>xsl:catch</code></a> element.<span class=
"definition">]</span></p>
</li>
<li>
<p>The namespace <code>http://www.w3.org/2000/xmlns/</code> is
reserved for use as described in <a href="#xml-names">[Namespaces
in XML]</a>. No element or attribute node can have a name in this
namespace, and although the prefix <code>xmlns</code> is implicitly
bound to this namespace, no namespace node will ever define this
binding.</p>
</li>
</ul>
<p>Reserved namespaces may be used without restriction to refer to
the names of elements and attributes in source documents and result
documents. As far as the XSLT processor is concerned, reserved
namespaces other than the XSLT namespace may be used without
restriction in the names of <a title="literal result element"
class="termref" href="#dt-literal-result-element">literal result
elements</a> and <a title="user-defined data element" class=
"termref" href="#dt-data-element">user-defined data elements</a>,
and in the names of attributes of literal result elements or of
<a title="XSLT element" class="termref" href=
"#dt-xslt-element">XSLT elements</a>: but other processors
<span class="verb">may</span> impose restrictions or attach special
meaning to them. Reserved namespaces <span class="verb">must
not</span> be used, however, in the names of stylesheet-defined
objects such as <a title="variable" class="termref" href=
"#dt-variable">variables</a> and <a title="stylesheet function"
class="termref" href="#dt-stylesheet-function">stylesheet
functions</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>With the exception of the XML namespace, any of the above
namespaces that are used in a stylesheet must be explicitly
declared with a namespace declaration. Although conventional
prefixes are used for these namespaces in this specification, any
prefix may be used in a user stylesheet.</p>
</div>
<p><a name="err-XTSE0080" id="err-XTSE0080"><span class=
"error">[ERR XTSE0080]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> to use a
<a title="reserved namespace" class="termref" href=
"#dt-reserved-namespace">reserved namespace</a> in the name of a
<a title="named template" class="termref" href=
"#dt-named-template">named template</a>, a <a title="mode" class=
"termref" href="#dt-mode">mode</a>, an <a title="attribute set"
class="termref" href="#dt-attribute-set">attribute set</a>, a
<a title="key" class="termref" href="#dt-key">key</a>, a <a title=
"decimal format" class="termref" href=
"#dt-decimal-format">decimal-format</a>, a <a title="variable"
class="termref" href="#dt-variable">variable</a> or <a title=
"parameter" class="termref" href="#dt-parameter">parameter</a>, a
<a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet function</a>, a named
<a title="output definition" class="termref" href=
"#dt-output-definition">output definition</a>, <span>an
accumulator,</span> or a <a title="character map" class="termref"
href="#dt-character-map">character map</a><span>; except that the
name <code>xsl:initial-template</code> is permitted as a template
name.</span></p>
</div>
<div class="div2">
<h3><a name="extension-attributes" id=
"extension-attributes"></a>3.3 <a href="#extension-attributes"
style="text-decoration: none">Extension Attributes</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-extension-attribute" id="dt-extension-attribute" title=
"extension attribute"></a>An element from the XSLT namespace may
have any attribute not from the XSLT namespace, provided that the
<a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> (see <a href=
"#xpath-30">[XPath 3.0]</a>) of the attribute has a non-null
namespace URI. These attributes are referred to as <b>extension
attributes</b>.<span class="definition">]</span> The presence of an
extension attribute <span class="verb">must not</span> cause the
<a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result trees</a> produced by the
transformation to be different from the result trees that a
conformant XSLT <span>3.0</span> processor might produce. They
<span class="verb">must not</span> cause the processor to fail to
signal an error that a conformant processor is required to signal.
This means that an extension attribute <span class="verb">must
not</span> change the effect of any <a title="instruction" class=
"termref" href="#dt-instruction">instruction</a> except to the
extent that the effect is <a title="implementation-defined" class=
"termref" href=
"#dt-implementation-defined">implementation-defined</a> or
<a title="implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a>.</p>
<p>Furthermore, if serialization is performed using one of the
serialization methods <code>xml</code>, <code>xhtml</code>,
<code>html</code>, or <code>text</code> described in <a href=
"#xslt-xquery-serialization-30">[XSLT and XQuery
Serialization]</a>, the presence of an extension attribute must not
cause the serializer to behave in a way that is inconsistent with
the mandatory provisions of that specification.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p><a title="extension attribute" class="termref" href=
"#dt-extension-attribute">Extension attributes</a> may be used to
modify the behavior of <a title="extension function" class=
"termref" href="#dt-extension-function">extension functions</a> and
<a title="extension instruction" class="termref" href=
"#dt-extension-instruction">extension instructions</a>. They may be
used to select processing options in cases where the specification
leaves the behavior <a title="implementation-defined" class=
"termref" href=
"#dt-implementation-defined">implementation-defined</a> or
<a title="implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a>. They
may also be used for optimization hints, for diagnostics, or for
documentation.</p>
<p><a title="extension attribute" class="termref" href=
"#dt-extension-attribute">Extension attributes</a> may also be used
to influence the behavior of the serialization methods
<code>xml</code>, <code>xhtml</code>, <code>html</code>, or
<code>text</code>, to the extent that the behavior of the
serialization method is <a title="implementation-defined" class=
"termref" href=
"#dt-implementation-defined">implementation-defined</a> or
<a title="implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a>. For
example, an extension attribute might be used to define the amount
of indentation to be used when <code>indent="yes"</code> is
specified. If a serialization method other than one of these four
is requested (using a prefixed QName in the method parameter) then
extension attributes may influence its behavior in arbitrary ways.
Extension attributes must not be used to cause the four standard
serialization methods to behave in a non-conformant way, for
example by failing to report serialization errors that a serializer
is required to report. An implementation that wishes to provide
such options must create a new serialization method for the
purpose.</p>
<p>An implementation that does not recognize the name of an
extension attribute, or that does not recognize its value, must
perform the transformation as if the extension attribute were not
present. As always, it is permissible to produce warning
messages.</p>
<p>The namespace used for an extension attribute will be copied to
the <a title="result tree" class="termref" href=
"#dt-result-tree">result tree</a> in the normal way if it is in
scope for a <a title="literal result element" class="termref" href=
"#dt-literal-result-element">literal result element</a>. This can
be prevented using the <code>[xsl:]exclude-result-prefixes</code>
attribute.</p>
</div>
<div class="example">
<div class="exampleHeader"><a name="d7e4448" id=
"d7e4448"></a>Example: An Extension Attribute for
<code>xsl:message</code></div>
<p>The following code might be used to indicate to a particular
implementation that the <a href=
"#element-message"><code>xsl:message</code></a> instruction is to
ask the user for confirmation before continuing with the
transformation:</p>
<div class="exampleInner">
<pre>
&lt;xsl:message abc:pause="yes"
    xmlns:abc="http://vendor.example.com/xslt/extensions"&gt;
       Phase 1 complete
&lt;/xsl:message&gt;
</pre></div>
<p>Implementations that do not recognize the namespace
<code>http://vendor.example.com/xslt/extensions</code> will simply
ignore the extra attribute, and evaluate the <a href=
"#element-message"><code>xsl:message</code></a> instruction in the
normal way.</p>
</div>
<p><a name="err-XTSE0090" id="err-XTSE0090"><span class=
"error">[ERR XTSE0090]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> for an
element from the XSLT namespace to have an attribute whose
namespace is either null (that is, an attribute with an unprefixed
name) or the XSLT namespace, other than attributes defined for the
element in this document.</p>
</div>
<div class="div2">
<h3><a name="xslt-media-type" id="xslt-media-type"></a>3.4 <a href=
"#xslt-media-type" style="text-decoration: none">XSLT Media
Type</a></h3>
<p>The media type <code>application/xslt+xml</code> <span>has
been</span> registered for XSLT stylesheet modules.</p>
<p>The definition of the media type is at <a href=
"#XSLT-Mime-Type">[XSLT Media Type]</a>.</p>
<p>This media type <span class="verb">should</span> be used for an
XML document containing a <a title="standard stylesheet module"
class="termref" href="#dt-standard-stylesheet-module">standard
stylesheet module</a> at its top level, and it <span class=
"verb">may</span> also be used for a <a title=
"simplified stylesheet" class="termref" href=
"#dt-simplified-stylesheet-module">simplified stylesheet
module</a>. It <span class="verb">should not</span> be used for an
XML document containing an <a title="embedded stylesheet module"
class="termref" href="#dt-embedded-stylesheet-module">embedded
stylesheet module</a>.</p>
</div>
<div class="div2">
<h3><a name="standard-attributes" id="standard-attributes"></a>3.5
<a href="#standard-attributes" style=
"text-decoration: none">Standard Attributes</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-standard-attributes" id="dt-standard-attributes" title=
"standard attributes"></a>There are a number of <b>standard
attributes</b> that may appear on any <a title="XSLT element"
class="termref" href="#dt-xslt-element">XSLT element</a>:
specifically <code>default-collation</code>,
<code>default-mode</code>, <code>default-validation</code>,
<code>exclude-result-prefixes</code>,
<span><code>expand-text</code>,</span>
<code>extension-element-prefixes</code>, <code>use-when</code>,
<code>version</code>, and
<code>xpath-default-namespace</code>.<span class=
"definition">]</span></p>
<p>These attributes may also appear on a <a title=
"literal result element" class="termref" href=
"#dt-literal-result-element">literal result element</a>, but in
this case, to distinguish them from user-defined attributes, the
names of the attributes are in the <a title="XSLT namespace" class=
"termref" href="#dt-xslt-namespace">XSLT namespace</a>. They are
thus typically written as <code>xsl:default-collation</code>,
<code>xsl:default-mode</code>, <code>xsl:default-validation</code>,
<code>xsl:exclude-result-prefixes</code>,
<span><code>xsl:expand-text</code>,</span>
<code>xsl:extension-element-prefixes</code>,
<code>xsl:use-when</code>, <code>xsl:version</code>, or
<code>xsl:xpath-default-namespace</code>.</p>
<p>It is <span class="verb">recommended</span> that all these
attributes should also be permitted on <a title=
"extension instruction" class="termref" href=
"#dt-extension-instruction">extension instructions</a>, but this is
at the discretion of the implementer of each extension instruction.
They <span class="verb">may</span> also be permitted on <a title=
"user-defined data element" class="termref" href=
"#dt-data-element">user-defined data elements</a>, though they will
only have any useful effect in the case of data elements that are
designed to behave like XSLT declarations or instructions.</p>
<p>In the following descriptions, these attributes are referred to
generically as <code>[xsl:]version</code>, and so on.</p>
<p>These attributes all affect the element they appear on, together
with any elements and attributes that have that element as an
ancestor. The two forms with and without the XSLT namespace have
the same effect; the XSLT namespace is used for the attribute if
and only if its parent element is <em>not</em> in the XSLT
namespace.</p>
<p>In the case of <code>[xsl:]default-collation</code>,
<span><code>[xsl:]expand-text</code>,</span>
<code>[xsl:]version</code>, and
<code>[xsl:]xpath-default-namespace</code>, the value can be
overridden by a different value for the same attribute appearing on
a descendant element. The effective value of the attribute for a
particular stylesheet element is determined by the innermost
ancestor-or-self element on which the attribute appears.</p>
<p>In an <a title="embedded stylesheet module" class="termref"
href="#dt-embedded-stylesheet-module">embedded stylesheet
module</a>, <a title="standard attributes" class="termref" href=
"#dt-standard-attributes">standard attributes</a> appearing on
ancestors of the outermost element of the stylesheet module have no
effect.</p>
<p>In the case of <code>[xsl:]exclude-result-prefixes</code> and
<code>[xsl:]extension-element-prefixes</code> the values are
cumulative. For these attributes, the value is given as a
whitespace-separated list of namespace prefixes, and the effective
value for an element is the combined set of namespace URIs
designated by the prefixes that appear in this attribute for that
element and any of its ancestor elements. Again, the two forms with
and without the XSLT namespace are equivalent.</p>
<p>The effect of the <code>[xsl:]use-when</code> attribute is
described in <a href="#conditional-inclusion"><i>3.14.1 Conditional
Element Inclusion</i></a>.</p>
<p>Because these attributes may appear on any <a title=
"XSLT element" class="termref" href="#dt-xslt-element">XSLT
element</a>, they are not listed in the syntax summary of each
individual element. Instead they are listed and described in the
entry for the <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a>, <a href=
"#element-transform"><code>xsl:transform</code></a>, <span>and
<a href="#element-package"><code>xsl:package</code></a></span>
elements only. This reflects the fact that these attributes are
often used on the <span>outermost element of the stylesheet</span>,
in which case they apply to the entire <a title="stylesheet module"
class="termref" href="#dt-stylesheet-module">stylesheet module</a>
<span>or <a title="package manifest" class="termref" href=
"#dt-package-manifest">package manifest</a></span>.</p>
<p>Note that the effect of these attributes does <em>not</em>
extend to <a title="stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet modules</a> referenced by
<a href="#element-include"><code>xsl:include</code></a> or <a href=
"#element-import"><code>xsl:import</code></a> declarations,
<span>nor to packages referenced using <a href=
"#element-use-package"><code>xsl:use-package</code></a></span>.</p>
<p>For the detailed effect of each attribute, see the following
sections:</p>
<dl>
<dt class="label"><code>[xsl:]default-collation</code></dt>
<dd>
<p>see <a href="#default-collation-attribute"><i>3.8.1 The
default-collation Attribute</i></a></p>
</dd>
<dt class="label"><code>[xsl:]default-mode</code></dt>
<dd>
<p>see <a href="#default-mode"><i>3.8.2 The [xsl:]default-mode
Attribute</i></a></p>
</dd>
<dt class="label"><code>[xsl:]default-validation</code></dt>
<dd>
<p>see <a href="#validation"><i>24.4 Validation</i></a></p>
</dd>
<dt class="label"><code>[xsl:]exclude-result-prefixes</code></dt>
<dd>
<p>see <a href="#lre-namespaces"><i>11.1.3 Namespace Nodes for
Literal Result Elements</i></a></p>
</dd>
<dt class="label"><code>[xsl:]expand-text</code></dt>
<dd>
<p>see <a href="#text-value-templates"><i>5.7.2 Text Value
Templates</i></a></p>
</dd>
<dt class="label">
<code>[xsl:]extension-element-prefixes</code></dt>
<dd>
<p>see <a href="#extension-instruction"><i>23.2 Extension
Instructions</i></a></p>
</dd>
<dt class="label"><code>[xsl:]use-when</code></dt>
<dd>
<p>see <a href="#conditional-inclusion"><i>3.14.1 Conditional
Element Inclusion</i></a></p>
</dd>
<dt class="label"><code>[xsl:]version</code></dt>
<dd>
<p>see <a href="#backwards"><i>3.10 Backwards Compatible
Processing</i></a> and <a href="#forwards"><i>3.11 Forwards
Compatible Processing</i></a></p>
</dd>
<dt class="label"><code>[xsl:]xpath-default-namespace</code></dt>
<dd>
<p>see <a href="#unprefixed-qnames"><i>5.2 Unprefixed Lexical
QNames in Expressions and Patterns</i></a></p>
</dd>
</dl>
</div>
<div class="div2">
<h3><a name="packages" id="packages"></a>3.6 <a href="#packages"
style="text-decoration: none">Packages</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-package" id="dt-package" title="package"></a>An explicit
<b>package</b> is represented by an <a href=
"#element-package"><code>xsl:package</code></a> element, which will
generally be the outermost element of an XML document. <span>When
the <a href="#element-package"><code>xsl:package</code></a> element
is not used explicitly, the entire stylesheet comprises a single
implicit package.</span><span class="definition">]</span> (This
specification does not preclude the <a href=
"#element-package"><code>xsl:package</code></a> being embedded in
another XML document, but it will never have any other XSLT element
as an ancestor).</p>
<p class="element-syntax"><a name="element-package" id=
"element-package"></a><code>&lt;xsl:package<br />
&#160;&#160;name? = <var>uri</var><br />
&#160;&#160;package-version? = <var>string</var><br />
&#160;&#160;<b>version</b> = <var>decimal</var><br />
&#160;&#160;input-type-annotations? = "preserve" | "strip" |
"unspecified"<br />
&#160;&#160;declared-modes? = <var>boolean</var><br />
&#160;&#160;default-mode? = <var>eqname</var> | "#unnamed"<br />
&#160;&#160;default-validation? = "preserve" | "strip"<br />
&#160;&#160;default-collation? = <var>uris</var><br />
&#160;&#160;extension-element-prefixes? = <var>prefixes</var><br />
&#160;&#160;exclude-result-prefixes? = <var>prefixes</var><br />
&#160;&#160;expand-text? = <var>boolean</var><br />
&#160;&#160;use-when? = <var>expression</var><br />
&#160;&#160;xpath-default-namespace? =
<var>uri</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: ((<a href=
"#element-use-package">xsl:use-package</a> | <a href=
"#element-expose">xsl:expose</a> | <a href=
"#element-global-context-item">xsl:global-context-item</a> |
<var>declarations</var>)*) --&gt;<br />
&lt;/xsl:package&gt;</code></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-package-manifest" id="dt-package-manifest" title=
"package manifest"></a>The content of the <a href=
"#element-package"><code>xsl:package</code></a> element is referred
to as the <b>package manifest</b><span class=
"definition">]</span>.</p>
<p>The <span><code>version</code></span> attribute indicates the
version of the XSLT language specification to which the package
manifest conforms. <span>The value <span class="verb">should</span>
normally be <code>3.0</code>. If the value is numerically less than
<code>3.0</code>, the content of the <a href=
"#element-package"><code>xsl:package</code></a> element is
processed using the rules for <a title=
"backwards compatible behavior" class="termref" href=
"#dt-backwards-compatible-behavior">backwards compatible
behavior</a> (see <a href="#backwards"><i>3.10 Backwards Compatible
Processing</i></a>). If the value is numerically greater than
<code>3.0</code>, it is processed using the rules for <a title=
"forwards compatible behavior" class="termref" href=
"#dt-forwards-compatible-behavior">forwards compatible behavior</a>
(see <a href="#forwards"><i>3.11 Forwards Compatible
Processing</i></a>).</span></p>
<p>A package typically has a name, given in its <code>name</code>
attribute, which <span class="verb">must</span> be an absolute URI.
Unnamed packages are allowed, but they can only be used as the "top
level" of an application; they cannot be the target of an <a href=
"#element-use-package"><code>xsl:use-package</code></a> declaration
in another package.</p>
<p><span>A package may have</span> a version identifier, given in
its <code>package-version</code> attribute. This is used to
distinguish different versions of a package. <span>The value of the
version attribute, after trimming leading and trailing whitespace,
<span class="verb">must</span> conform to the syntax given in
<a href="#package-versions"><i>3.6.1 Versions of a Package</i></a>.
If no version number is specified for a package, version
<code>1</code> is assumed.</span></p>
<p>The attributes <code>default-collation</code>,
<code>default-mode</code>, <code>default-validation</code>,
<code>exclude-result-prefixes</code>, <code>expand-text</code>,
<code>extension-element-prefixes</code>, <code>use-when</code>,
<code>version</code>, and <code>xpath-default-namespace</code> are
standard attributes that can appear on any XSLT element, and
potentially affect all descendant elements. Their meaning is
described in <a href="#standard-attributes"><i>3.5 Standard
Attributes</i></a>.</p>
<p>The package manifest <span>contains the following elements,
arbitrarily ordered</span>:</p>
<ol class="enumar">
<li>
<p>Zero or more <a href=
"#element-use-package"><code>xsl:use-package</code></a> elements
which identify the packages used by this package, including
subsidiary elements that constrain the way in which the components
contained in those packages are used.</p>
</li>
<li>
<p>An optional <a href=
"#element-global-context-item"><code>xsl:global-context-item</code></a>
element; if present this element defines constraints on the
existence and type of the <a title="global context item" class=
"termref" href="#dt-global-context-item">global context
item</a>.</p>
</li>
<li>
<p>Zero or more <a href=
"#element-expose"><code>xsl:expose</code></a> declarations that
define the interface offered by this package to the outside
world.</p>
</li>
<li>
<p>Zero or more <a title="declaration" class="termref" href=
"#dt-declaration">declarations</a>, that is, elements that are
permitted as children of <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href=
"#element-transform"><code>xsl:transform</code></a>. One possible
coding style is to include in the package manifest just a single
<a href="#element-import"><code>xsl:import</code></a> or <a href=
"#element-include"><code>xsl:include</code></a> declaration as a
reference to the effective top-level stylesheet module; this
approach is particularly suitable when writing code that is
required to run under earlier releases of XSLT as well as under
XSLT 3.0. Another approach is to include the substance of the
top-level stylesheet module inline within the package manifest.</p>
</li>
</ol>
<div class="example">
<div class="exampleHeader"><a name="d7e5014" id=
"d7e5014"></a>Example: An example package</div>
<p>The following example shows a package that offers a number of
functions for manipulating complex numbers. A complex number is
represented as a map with two entries, the keys being 0 for the
real part, and 1 for the imaginary part.</p>
<div class="exampleInner">
<pre>
&lt;xsl:package
  name="http://example.org/complex-arithmetic.xsl"
  package-version="1.0"
  version="3.0"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:f="http://example.org/complex-arithmetic.xsl"&gt;
  
  &lt;xsl:function name="f:complex-number" 
                as="map(xs:integer, xs:double)" visibility="public"&gt;
    &lt;xsl:param name="real" as="xs:double"/&gt;
    &lt;xsl:param name="imaginary" as="xs:double"/&gt;
    &lt;xsl:sequence select="map{ 0:$real, 1:$imaginary }"/&gt;
  &lt;/xsl:function&gt;
  
  &lt;xsl:function name="f:real" 
                as="xs:double" visibility="public"&gt;
    &lt;xsl:param name="complex" as="map(xs:integer, xs:double)"/&gt;
    &lt;xsl:sequence select="$complex(0)"/&gt;
  &lt;/xsl:function&gt;
  
  &lt;xsl:function name="f:imag" 
                as="xs:double" visibility="public"&gt;
    &lt;xsl:param name="complex" as="map(xs:integer, xs:double)"/&gt;
    &lt;xsl:sequence select="$complex(1)"/&gt;
  &lt;/xsl:function&gt;
  
  &lt;xsl:function name="f:add" 
                as="map(xs:integer, xs:double)" visibility="public"&gt;
    &lt;xsl:param name="x" as="map(xs:integer, xs:double)"/&gt;
    &lt;xsl:param name="y" as="map(xs:integer, xs:double)"/&gt;
    &lt;xsl:sequence select="
         f:complex-number(
           f:real($x) + f:real($y), 
           f:imag($x) + f:imag($y)"/&gt;
  &lt;/xsl:function&gt;
  
  &lt;xsl:function name="f:multiply" 
                as="map(xs:integer, xs:double)" visibility="public"&gt;
    &lt;xsl:param name="x" as="map(xs:integer, xs:double)"/&gt;
    &lt;xsl:param name="y" as="map(xs:integer, xs:double)"/&gt;
    &lt;xsl:sequence select="
         f:complex-number(
           f:real($x)*f:real($y) - f:imag($x)*f:imag($y),
           f:real($x)*f:imag($y) + f:imag($x)*f:real($y))"/&gt;
  &lt;/xsl:function&gt;
  
  &lt;!-- etc. --&gt;
  
&lt;/xsl:package&gt;
</pre></div>
<p>A more complex package might include private or abstract
functions as well as public functions; it might expose components
other than functions (for example, templates or global variables),
and it might contain <a href=
"#element-use-package"><code>xsl:use-package</code></a> elements to
allow it to call on the services of other packages.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In this example, the way in which complex numbers are
represented is exposed to users of the package. It would be
possible to hide the representation by declaring the types on
public functions simply as <code>item()</code>; but this would be
at the cost of type safety.</p>
</div>
</div>
<p>A package that does not itself expose any components or use any
<a title="library package" class="termref" href=
"#dt-library-package">library packages</a> may be written using a
simplified syntax: the <a href=
"#element-package"><code>xsl:package</code></a> element is omitted,
and the <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href=
"#element-transform"><code>xsl:transform</code></a> element is now
the outermost element of the stylesheet module. For compatibility
reasons, all the named templates and modes declared in the package
are made public. More formally, the principal stylesheet module of
the <a title="top-level package" class="termref" href=
"#dt-top-level-package">top-level package</a> may be expressed as
an <code>xsl:stylesheet</code> or <code>xsl:transform</code>
element, which is equivalent to the package represented by the
output of the following transformation, preserving the base URI of
the source:</p>
<div class="exampleInner">
<pre>
 &lt;xsl:transform version="3.0" 
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:t="http://www.w3.org/1999/XSL/TransformAlias"&gt;
 
    &lt;xsl:namespace-alias stylesheet-prefix="t" result-prefix="xsl"/&gt;
    
    &lt;xsl:template match="xsl:stylesheet|xsl:transform"&gt;
      &lt;t:package declared-modes="no"&gt;
        &lt;xsl:copy-of select="@*"/&gt;
        &lt;t:expose component="mode" names="*" visibility="public"/&gt;
        &lt;t:expose component="template" names="*" visibility="public"/&gt;
        &lt;xsl:copy-of select="node()"/&gt;
      &lt;/t:package&gt;
    &lt;/xsl:template&gt;
 &lt;/xsl:transform&gt;
       
</pre></div>
<p>The effect of the <code>input-type-annotations</code> attribute
is defined in <a href="#stripping-annotations"><i>4.3 Stripping
Type Annotations from a Source Tree</i></a>.</p>
<div class="div3">
<h4><a name="package-versions" id="package-versions"></a>3.6.1
<a href="#package-versions" style="text-decoration: none">Versions
of a Package</a></h4>
<p>If a package has a version number, the version number must
conform to the grammar:</p>
<div class="exampleInner">
<pre>
PackageVersion   ::= NumericPart ( "-" NamePart )?
NumericPart      ::= IntegerLiteral ( "." IntegerLiteral )*
NamePart         ::= NCName
               
</pre></div>
<p>Here <span><a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-IntegerLiteral">IntegerLiteral</a><sup><small>XP30</small></sup>
and <code>NCName</code> are as defined in the XPath 3.0 grammar
productions of the same name (including rules on limits)</span>.
Leading and trailing whitespace is ignored; no other whitespace is
allowed.</p>
<p>Examples of valid version numbers are <code>2.0.5</code> or
<code>3.10-alpha</code>.</p>
<p>The integers and optional <code>NCName</code> within the version
number are referred to as the components of the version number.</p>
<p>Versions are ordered. When comparing two versions:</p>
<ol class="enumar">
<li>
<p>Trailing zero components (that is, any zero-valued integer that
is not followed by another integer) are discarded.</p>
</li>
<li>
<p>Comparison proceeds by comparing components pairwise from the
left.</p>
</li>
<li>
<p>If both versions have the same number of components and all
components compare equal <span>(under the rules of the XPath
<code>eq</code> operator using the Unicode codepoint
collation)</span>, then the versions compare equal.</p>
</li>
<li>
<p>If the number of components in the two versions <var>V1</var>
and <var>V2</var> is <var>N1</var> and <var>N2</var>, with
<var>N1&lt;N2</var>, and if all components in positions 1 to
<var>N</var> compare equal, then <var>V1</var> is less than
<var>V2</var> if the component of <var>V2</var> in position
<var>N1+1</var> is an integer, and is greater than <var>V2</var> if
this component is an <code>NCName</code>. For example,
<code>1.2</code> is less than <code>1.2.5</code>, while
<code>2.0</code> is greater than <code>2.0-rc1</code>.</p>
</li>
<li>
<p>Components are compared as follows:</p>
<ol class="enumla">
<li>
<p>If both components are integers, they are compared <span>using
the rules of XPath value comparisons</span>.</p>
</li>
<li>
<p>If both components are NCNames, they are compared <span>using
the rules of XPath value comparisons</span>, using the Unicode
Codepoint Collation.</p>
</li>
<li>
<p>If one component is an integer and the other is an NCName, the
NCName comes first.</p>
</li>
</ol>
</li>
</ol>
<p>For example, the following shows a possible ordered sequence of
version numbers:</p>
<div class="exampleInner">
<pre>
0-rc1 &lt; 0-rc2 &lt; 0 &lt; 1 = 1.0 &lt; 1.0.2 &lt; 1.0.3-rc1 &lt; 1.0.3 &lt; 1.0.3.2 &lt; 1.0.10
</pre></div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The version number format defined here is designed to be general
enough to accommodate a variety of conventions in common use, and
to allow useful semantics for matching of versions and ranges of
versions, without being over-prescriptive. It is influenced by
<a href="#SemVer">[SemVer]</a>, but is not as prescriptive, and it
imposes no assumptions about backwards compatibility of packages
between successive versions.</p>
</div>
<p>Dependencies between packages may specify a version range (see
<a href="#package-dependencies"><i>3.6.2 Dependencies between
Packages</i></a>). A version range represents a set of accepted
versions. <span>The syntax of a version range is shown below.
Whitespace is permitted only where indicated, using the terminal
symbol <var>S</var>.</span></p>
<div class="exampleInner">
<pre>
        PackageVersionRange    ::=  AnyVersion | VersionRanges
        AnyVersion             ::=  "*"
        VersionRanges          ::=  VersionRange S? "," S? VersionRange
        VersionRange           ::=  VersionPrefix | VersionFrom | VersionTo | VersionFromTo
        VersionPrefix          ::=  PackageVersion ".*"
        VersionFrom            ::=  PackageVersion "+"
        VersionTo              ::=  "to" S VersionPrefix
        VersionFromTo          ::=  PackageVersion S "to" S VersionPrefix     
               
</pre></div>
<p>The meanings of the various forms of version range are defined
below:</p>
<ul>
<li>
<p>The range <code>AnyVersion</code> matches any version.</p>
</li>
<li>
<p>The range <code>VersionRanges</code> matches a version if any
constituent <code>VersionRange</code> matches that version.</p>
</li>
<li>
<p>The range <code>VersionPrefix</code> matches any version whose
leading components are the same as the components listed. For
example, <code>1.3.*</code> matches <code>1.3</code>,&#160;
<code>1.3.5</code>,&#160; <code>1.3.10.2</code>,&#160; and
<code>1.3-beta</code>.</p>
</li>
<li>
<p>The range <code>VersionFrom</code> matches any version that is
greater than or equal to the version supplied. For example
<code>1.3+</code> matches <code>1.3</code>,&#160;
<code>1.3.2</code>,&#160; <code>1.4</code>,&#160; or
<code>2.1</code>.</p>
</li>
<li>
<p>The range <code>VersionTo</code> matches any version that is
less than or equal to some version that matches the
<code>VersionPrefix</code>. For example, <code>to 4.0</code>
matches <code>1.5</code>,&#160; <code>2.3</code>,&#160;
<code>3.8</code>,&#160; <code>4.0</code>,&#160; and
<code>4.0-beta</code> (but not <code>4.0.1</code>), while <code>to
3.3.*</code> matches <code>1.5</code> or <code>2.0.6</code> or
<code>3.3.4621</code>, but not <code>3.4.0</code> or
<code>3.4.0-beta</code>.</p>
</li>
<li>
<p>The range <code>VersionFromTo</code> matches any version that is
greater than or equal to the starting <code>PackageVersion</code>,
and less than or equal to some version that matches the
<code>VersionPrefix</code>. For example, <code>1 to 5</code>
matches <code>1.1</code>,&#160; <code>2.1</code>,&#160;
<code>3.1</code>,&#160; or <code>5.0</code> (but not
<code>5.1</code>), while <code>1 to 5.*</code> matches all of
these, plus versions such as <code>5.7.2</code> (but not
<code>6.0</code> or <code>6.0-beta</code>).</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="package-dependencies" id=
"package-dependencies"></a>3.6.2 <a href="#package-dependencies"
style="text-decoration: none">Dependencies between
Packages</a></h4>
<p>When components in one package reference components in another,
the dependency of the first package on the second must be
represented by an <a href=
"#element-use-package"><code>xsl:use-package</code></a> element in
the <a title="package manifest" class="termref" href=
"#dt-package-manifest">package manifest</a> of the first
package.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-use" id="dt-use" title="use"></a>If a package <var>Q</var>
contains an <a href=
"#element-use-package"><code>xsl:use-package</code></a> element
that references package <var>P</var>, then package <var>Q</var> is
said to <b>use</b> package <var>P</var>. In this relationship
package <var>Q</var> is referred to as the <b>using</b> package,
package <var>P</var> as the <b>used</b> package.<span class=
"definition">]</span></p>
<p>The phrase <b>directly uses</b> is synonymous with <b>uses</b>
as defined above, while <b>directly or indirectly uses</b> refers
to the transitive closure of this relationship.</p>
<p class="element-syntax"><a name="element-use-package" id=
"element-use-package"></a><code>&lt;xsl:use-package<br />
&#160;&#160;<b>name</b> = <var>uri</var><br />
&#160;&#160;package-version? = <var>string</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-accept">xsl:accept</a> | <a href=
"#element-override">xsl:override</a>)* --&gt;<br />
&lt;/xsl:use-package&gt;</code></p>
<p>A <a title="package" class="termref" href=
"#dt-package">package</a> may be <a title="use" class="termref"
href="#dt-use">used</a> by more than one other package, but the
relationship must not be cyclic. It is possible, but by no means
inevitable, that using the same package in more than one place
within a stylesheet will cause static errors due to the presence of
conflicting components according to the above rules. Where a
package is successfully used by more than one other package, its
components may be overridden in different ways by different using
packages.</p>
<p>The <code>name</code> and <code>package-version</code>
attributes together identify the used package. <span>The value of
the <code>package-version</code> attribute, if present, must
conform to the rules for a version range given in <a href=
"#package-versions"><i>3.6.1 Versions of a Package</i></a>; if
omitted the value <code>*</code> is assumed, which matches any
version. The used package must have a name that is an exact match
for the name in the <code>name</code> attribute (using codepoint
comparison), and its explicit or implicit
<code>package-version</code> must match the version range given in
the <code>package-version</code> attribute</span>.</p>
<p>This specification does not define how the implementation
locates a package given its name and version. <span>If several
matching versions of a package are available, it does not define
which of them is chosen.</span> Nor does it define whether this
process locates source code or some other representation of the
package contents. Such mechanisms are <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. Use of the
package name as a dereferenceable URI is <span class="verb">not
recommended</span>, because the intent of the packaging feature is
to allow a package to be distributed as reusable code and therefore
to exist in many different locations.</p>
<p><a name="err-XTSE3000" id="err-XTSE3000"><span class=
"error">[ERR XTSE3000]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if no
package matching the package name and version specified in an
<a href="#element-use-package"><code>xsl:use-package</code></a>
declaration can be located.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Depending on the implementation architecture, there may be a
need to locate used packages both during static analysis (for
example, to get information about the names and type signatures of
the components exposed by the used package), and also at evaluation
time (to link to the implementation of these components so they can
be invoked). A failure to locate a package may cause an error at
either stage.</p>
</div>
<p>The <a href="#element-accept"><code>xsl:accept</code></a> and
<a href="#element-override"><code>xsl:override</code></a> elements
are used to modify the visibility or behavior of components
acquired from the used package; they are described in <a href=
"#accepting-components"><i>3.6.3.2 Accepting Components</i></a>
below.</p>
</div>
<div class="div3">
<h4><a name="named-components" id="named-components"></a>3.6.3
<a href="#named-components" style="text-decoration: none">Named
Components in Packages</a></h4>
<p>This section discusses the use of named components in packages:
specifically <a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">functions</a>, <a title="named template"
class="termref" href="#dt-named-template">named templates</a>,
<a title="attribute set" class="termref" href=
"#dt-attribute-set">attribute sets</a>, <span><a title="mode"
class="termref" href="#dt-mode">modes</a>, <a title="accumulator"
class="termref" href="#dt-accumulator">accumulators</a>,</span>
<span><a title="key" class="termref" href=
"#dt-key">keys</a></span>, <a title="mode" class="termref" href=
"#dt-mode">modes</a>, and <a title="global variable" class=
"termref" href="#dt-global-variable">global variables</a> and
<a title="stylesheet parameter" class="termref" href=
"#dt-stylesheet-parameter">parameters</a>. Some of the provisions
in this section also apply to named modes, but there are
differences noted in <a href="#modes-and-packages"><i>3.6.4
Overriding Template Rules from a Used Package</i></a>. The section
is largely concerned with details of the rules that affect
references from one component to another by name, whether the
components are in the same package or in different packages. The
rules are designed to meet a number of requirements:</p>
<ul>
<li>
<p>A component defined in one package can be overridden by a
component in another package, provided the signatures are
type-compatible.</p>
</li>
<li>
<p>The author of a package can declare whether the components in
the package are public or private (that is, whether or not they can
be used from outside the package) and whether they are final,
overridable, or abstract (that is whether they can or must be
overridden by the using package).</p>
</li>
<li>
<p>Within an application, two packages can make use of a common
library and override its components in different ways.</p>
</li>
<li>
<p>Visibility of components can be defined either as part of the
declaration of the component, or in the package manifest.</p>
</li>
<li>
<p>An application that wishes to make use of a <a title=
"library package" class="termref" href=
"#dt-library-package">library package</a> can be selective about
which components from the library it acquires, perhaps to avoid
name clashes between components acquired from different
libraries.</p>
</li>
</ul>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-component" id="dt-component" title="component"></a>The term
<b>component</b> is used to refer to any of the following: a
<a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet function</a>, a <a title=
"named template" class="termref" href="#dt-named-template">named
template</a>, a <a title="mode" class="termref" href=
"#dt-mode">mode</a>, <span>an <a title="accumulator function"
class="termref" href=
"#dt-accumulator-function">accumulator</a></span> an <a title=
"attribute set" class="termref" href="#dt-attribute-set">attribute
set</a>, a <span><a title="key" class="termref" href=
"#dt-key">key</a></span>, <a title="global variable" class=
"termref" href="#dt-global-variable">global variable</a>, or a
<a title="mode" class="termref" href=
"#dt-mode">mode</a>.<span class="definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-symbolic-identifier" id="dt-symbolic-identifier" title=
"symbolic identifier"></a>The <b>symbolic identifier</b> of a
<a title="component" class="termref" href=
"#dt-component">component</a> is a composite name used to identify
the component uniquely within a package. The symbolic identifier
comprises the kind of component (stylesheet function, named
template, <span>accumulator</span>, attribute set, global variable,
or mode), the <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> of the component (namespace
URI plus local name), and in the case of stylesheet functions, the
<a title="arity" class="termref" href=
"#dt-arity">arity</a>.<span class="definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-homonymous" id="dt-homonymous" title="homonymous"></a>Two
<a title="component" class="termref" href=
"#dt-component">components</a> are said to be <b>homonymous</b> if
they have the same <a title="symbolic identifier" class="termref"
href="#dt-symbolic-identifier">symbolic identifier</a>.<span class=
"definition">]</span></p>
<p>Every <a title="component" class="termref" href=
"#dt-component">component</a> has a <a title="declaration" class=
"termref" href="#dt-declaration">declaration</a> in some <a title=
"stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet module</a> and therefore within
some <a title="package" class="termref" href=
"#dt-package">package</a>. <span>In the case of <a title=
"attribute set" class="termref" href="#dt-attribute-set">attribute
sets</a>, there may be several declarations.</span> The declaration
is an element in an XDM tree representing the stylesheet module.
Declarations therefore have identity, based on XDM node
identity.</p>
<p>Not all <a title="declaration" class="termref" href=
"#dt-declaration">declarations</a> result in <a title="component"
class="termref" href="#dt-component">components</a>:</p>
<ul>
<li>
<p>Some declarations, such as <a href=
"#element-decimal-format"><code>xsl:decimal-format</code></a> and
<a href="#element-strip-space"><code>xsl:strip-space</code></a>,
declare aspects of the processing context which are not considered
to be components as defined here.</p>
</li>
<li>
<p><a title="template rule" class="termref" href=
"#dt-template-rule">Template rules</a> (<a href=
"#element-template"><code>xsl:template</code></a> with a
<code>match</code> attribute) are also not considered to be
components for the purposes of this section, which is concerned
only with components that are bound by name. However, when an
<a href="#element-template"><code>xsl:template</code></a> has both
a <code>match</code> attribute and a <code>name</code> attribute,
then it establishes both a template rule and a <a title=
"named template" class="termref" href="#dt-named-template">named
template</a>, and in its role as a named template it comes within
the scope of this discussion.</p>
</li>
<li>
<p>A named declaration, for example a named template, a function,
<span>an accumulator,</span> or a global variable, may be
overridden within the same package by another like-named
declaration having higher <a title="import precedence" class=
"termref" href="#dt-import-precedence">import precedence</a>. When
a declaration is overridden in this way it can never be referenced
or invoked either from within its containing package or from
outside that package; it is effectively dead code, and it therefore
does not result in the creation of any component, which means that
it plays no part in the component binding process.</p>
</li>
<li>
<p>In the case of <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a> and
<a href="#element-key"><code>xsl:key</code></a> declarations,
several declarations combine to form a single component.</p>
</li>
</ul>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-declaring-package" id="dt-declaring-package" title=
"declaring package"></a>The <b>declaring package</b> of a <a title=
"component" class="termref" href="#dt-component">component</a> is
the package that contains the declaration <span>(or, in the case of
<a href="#element-attribute-set"><code>xsl:attribute-set</code></a>
and <a href="#element-key"><code>xsl:key</code></a>, multiple
declarations)</span> of the component.<span class=
"definition">]</span></p>
<p>When a <a title="component" class="termref" href=
"#dt-component">component</a> declared in one <a title="package"
class="termref" href="#dt-package">package</a> is made available in
another, the using package will contain a separate component that
can be regarded as a modified copy of the original. The new
component shares the same <a title="symbolic identifier" class=
"termref" href="#dt-symbolic-identifier">symbolic identifier</a> as
the original, and it has the same <a title="declaration" class=
"termref" href="#dt-declaration">declaration</a>, but it has other
properties such as its <a title="visibility" class="termref" href=
"#dt-visibility">visibility</a> that may differ from the
original.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-containing-package" id="dt-containing-package" title=
"containing package"></a>A component declaration results in
multiple components, one in the package in which the declaration
appears, and potentially one in each package that uses the
declaring package, directly or indirectly, subject to the
visibility of the component. Each of these multiple components has
the same <a title="declaring package" class="termref" href=
"#dt-declaring-package">declaring package</a>, but each has a
different <b>containing package</b>. For the original component,
the declaring package and the containing package are the same; for
a copy of a component made as a result of an <a href=
"#element-use-package"><code>xsl:use-package</code></a>
declaration, the declaring package will be the original package,
and the containing package will be the package in which the
<a href="#element-use-package"><code>xsl:use-package</code></a>
declaration appears.<span class="definition">]</span></p>
<p>The properties of a <a title="component" class="termref" href=
"#dt-component">component</a> are as follows:</p>
<ul>
<li>
<p>The original <a title="declaration" class="termref" href=
"#dt-declaration">declaration</a> of the component.</p>
</li>
<li>
<p>The <a title="package" class="termref" href=
"#dt-package">package</a> to which the component belongs (called
its <b>containing</b> package, not to be confused with the
<a title="declaring package" class="termref" href=
"#dt-declaring-package">declaring package</a>).</p>
</li>
<li>
<p>The <a title="symbolic identifier" class="termref" href=
"#dt-symbolic-identifier">symbolic identifier</a> of the
component.</p>
</li>
<li>
<p>The <a title="visibility" class="termref" href=
"#dt-visibility">visibility</a> of the component, which determines
the way in which the component is seen by other components within
the same package and within using packages. This is one of
<code>public</code>, <code>private</code>, <code>abstract</code>,
<code>final</code>, or <code>hidden</code>. The visibility of
components is discussed further in <a href="#visibility"><i>3.6.3.1
Visibility of Components</i></a>.</p>
</li>
<li>
<p>A set of bindings for the <a title="symbolic reference" class=
"termref" href="#dt-symbolic-reference">symbolic references</a> in
the component. The way in which these bindings are established is
discussed further in <a href="#component-references"><i>3.6.3.4
Binding References to Components</i></a>.</p>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>When a function <var>F</var> defined in a package <var>P</var>
is acquired by two using packages <var>Q</var> and <var>R</var>, we
may think of <var>P</var>, <var>Q</var>, and <var>R</var> as all
providing access to the "same" function. The detailed semantics,
however, demand an understanding that there is one function
declaration, but three components. The three components
representing the function <var>F</var> within packages
<var>P</var>, <var>Q</var>, and <var>R</var> have some properties
in common (the same symbolic identifier, the same declaration), but
other properties (the visibility and the bindings of symbolic
references) that may vary from one of these components to
another.</p>
</div>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-symbolic-reference" id="dt-symbolic-reference" title=
"symbolic reference"></a>The <a title="declaration" class="termref"
href="#dt-declaration">declaration</a> of a component includes
constructs that can be interpreted as references to other <a title=
"component" class="termref" href="#dt-component">components</a> by
means of their <a title="symbolic identifier" class="termref" href=
"#dt-symbolic-identifier">symbolic identifiers</a>. These
constructs are generically referred to as <b>symbolic
references</b>. Examples of constructs that give rise to symbolic
references are the <code>name</code> attribute of <a href=
"#element-call-template"><code>xsl:call-template</code></a>; the
<code>[xsl:]use-attribute-sets</code> attribute of <a href=
"#element-copy"><code>xsl:copy</code></a>, <a href=
"#element-element"><code>xsl:element</code></a>, and <a title=
"literal result element" class="termref" href=
"#dt-literal-result-element">literal result elements</a>; the
<code>mode</code> attribute of <a href=
"#element-template"><code>xsl:template</code></a> and <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>;
XPath variable references referring to global variables; and XPath
function calls referring to <a title="stylesheet function" class=
"termref" href="#dt-stylesheet-function">stylesheet functions</a>
<span>or <a title="accumulator function" class="termref" href=
"#dt-accumulator-function">accumulator
functions</a></span>.<span class="definition">]</span></p>
<p>Symbolic references exist as properties of the <a title=
"declaration" class="termref" href=
"#dt-declaration">declaration</a> of a <a title="component" class=
"termref" href="#dt-component">component</a>. The <a title=
"symbolic identifier" class="termref" href=
"#dt-symbolic-identifier">symbolic identifier</a> being referred to
can be determined straightforwardly from the syntactic form and
context of the reference: for example, the instruction
<code>&lt;xsl:value-of select="f:price($o)"
xmlns:f="http://f.com/"/&gt;</code> contains a symbolic reference
to a function with expanded name <code>{http://f.com/}price</code>
and with arity=1. However, because there may be several
(homonymous) function components with this symbolic identifier,
translating this symbolic reference into a reference to a specific
component (a process called "binding") is less straightforward, and
is described in the text that follows.</p>
<p>The process of assembling a stylesheet from its constituent
packages is primarily a process of binding these symbolic
references to actual components. Within any <a title="component"
class="termref" href="#dt-component">component</a> whose <a title=
"declaration" class="termref" href=
"#dt-declaration">declaration</a> is <var>D</var>, there is a set
of bindings; each binding is an association between a <a title=
"symbolic reference" class="termref" href=
"#dt-symbolic-reference">symbolic reference</a> in <var>D</var> and
a <a title="component" class="termref" href=
"#dt-component">component</a> whose <a title="symbolic identifier"
class="termref" href="#dt-symbolic-identifier">symbolic
identifier</a> matches the outward reference. Outward references
for which a component <var>C</var> contains a binding are said to
be <b>bound</b> in <var>C</var>; those for which <var>C</var>
contains no binding are said to be <b>unbound</b>.</p>
<p>For example, suppose that in some package <var>P</var>, function
<var>A</var> calls <var>B</var>, which in turn calls <var>C</var>,
and that <var>B</var> is <code>private</code>. Now suppose that in
some package <var>Q</var> which uses <var>P</var>, <var>C</var> is
overridden. The effect of the binding process is that <var>Q</var>
will contain three components corresponding to <var>A</var>,
<var>B</var>, and <var>C</var>, which we might call
<var>A(Q)</var>, <var>B(Q)</var>, and <var>C(Q)</var>. The
<a title="declaration" class="termref" href=
"#dt-declaration">declarations</a> of <var>A(Q)</var> and
<var>B(Q)</var> are in package <var>P</var>, but the declaration of
<var>C(Q)</var> is in <var>Q</var>. The internal visibility of
<var>B(Q)</var> will be <code>hidden</code> (meaning that it cannot
be referenced from within <var>Q</var>), and <var>B(Q)</var> will
contain a binding for the component <var>C(Q)</var> that
corresponds to the outward reference from <var>B</var> to
<var>C</var>. The effect is that when <var>A</var> calls
<var>B</var> and <var>B</var> calls <var>C</var>, it is the
overriding version of <var>C</var> that is executed. In another
package <var>R</var> that uses <var>P</var> without overriding
<var>C</var>, there will be three different components
<var>A(R)</var>, <var>B(R)</var>, and <var>C(R)</var>. This time
the declaration of all three components is in the original package
<var>P</var>. Component <var>B(R)</var> will contain a binding to
<var>C(R)</var>, so in this package, the original version of
<var>C</var> is executed. The fact that one package <var>Q</var>
overrides <var>C</var> thus has no effect on <var>R</var>, which
does not override it.</p>
<p>Template rules are not components in their own right; unlike
named templates, they are never referenced by name. Component
references within a template rule (for example, references to
functions, global variables, or named templates) are treated as
occurring within the component that represents the containing mode.
If a template rule lists several modes, it is treated as if there
were multiple template rules one in each mode.</p>
<p><a title="key" class="termref" href="#dt-key">Keys</a> behave
rather differently from other components. Their visibility is
always private, which means they can only be used within their
declaring package. In addition, the component binding (the
reference to a key definition from a call on the <a href=
"#func-key"><code>key</code></a> function) is in the general case
made dynamically rather than statically. However, outward
references from key definitions to other components (such as global
variables and functions) behave in the same way as component
references contained in any other private component, in that they
may be rebound to an overriding declaration of the target
component.</p>
<div class="div4">
<h5><a name="visibility" id="visibility"></a>3.6.3.1 <a href=
"#visibility" style="text-decoration: none">Visibility of
Components</a></h5>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-visibility" id="dt-visibility" title="visibility"></a>The
<b>visibility</b> of a <a title="component" class="termref" href=
"#dt-component">component</a> is one of: <code>private</code>,
<code>public</code>, <code>abstract</code>, <code>final</code>, or
<code>hidden</code>.<span class="definition">]</span></p>
<p>The meanings of these visibility values is as follows:</p>
<table border="1" cellpadding="5" summary=
"Values of the visibility attribute, and their meaning" width=
"100%">
<thead>
<tr>
<th colspan="1" align="left" valign="top">Visibility</th>
<th colspan="1" align="left" valign="top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top">public</td>
<td align="left" valign="top">The component can be referenced from
other components in this package or in any using package; it can be
overridden by a different component in any using package.</td>
</tr>
<tr>
<td align="left" valign="top">private</td>
<td align="left" valign="top">The component can be referenced from
other components in this package; it cannot be referenced or
overridden within a using package.</td>
</tr>
<tr>
<td align="left" valign="top">abstract</td>
<td align="left" valign="top">The component can be referenced from
other components in this package or in any using package; in a
using package it can either remain abstract or be overridden by a
different component.</td>
</tr>
<tr>
<td align="left" valign="top">final</td>
<td align="left" valign="top">The component can be referenced from
other components in this package or in any using package; it cannot
be overridden by a different component in any using package.</td>
</tr>
<tr>
<td align="left" valign="top">hidden</td>
<td align="left" valign="top">The component cannot be referenced
from other components in this package; it cannot be referenced or
overridden within a using package.</td>
</tr>
</tbody>
</table>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The visibility of a component in a package <var>P</var>
primarily affects how the component can be used in other packages,
specifically, packages that use <var>P</var>. There is one
exception: if the visibility is <code>hidden</code>, it also
affects how the component can be used within <var>P</var>.</p>
</div>
<p>When a component is declared within a particular package, its
<a title="visibility" class="termref" href=
"#dt-visibility">visibility</a>, which affects how it can be used
in other (using) packages, depends on two factors: the value of the
<code>visibility</code> declaration on the declaration itself (if
present), and the rules given in the <a href=
"#element-expose"><code>xsl:expose</code></a> declarations of the
package manifest.</p>
<p>The <a href="#element-function"><code>xsl:function</code></a>,
<a href="#element-template"><code>xsl:template</code></a>, <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a>,
<a href="#element-variable"><code>xsl:variable</code></a>, <a href=
"#element-accumulator"><code>xsl:accumulator</code></a> and
<a href="#element-mode"><code>xsl:mode</code></a> <a title=
"declaration" class="termref" href=
"#dt-declaration">declarations</a> each have an optional
<code>visibility</code> attribute. The value is one of
<code>private</code>, <code>public</code>, <code>abstract</code>,
or <code>final</code> (never <code>hidden</code>).</p>
<p>Any <a href="#element-expose"><code>xsl:expose</code></a>
declarations that appear as children of <a href=
"#element-package"><code>xsl:package</code></a> define the
visibility of components whose declaration has no explicit
<code>visibility</code> attribute, and can also be used to reduce
the visibility of components where this attribute is present.</p>
<p class="element-syntax"><a name="element-expose" id=
"element-expose"></a><code>&lt;xsl:expose<br />
&#160;&#160;<b>component</b> = "template" | "function" |
"accumulator" | "attribute-set" | "variable" | "mode"<br />
&#160;&#160;<b>names</b> = <var>tokens</var><br />
&#160;&#160;<b>visibility</b> = "public" | "private" | "final" |
"abstract"&#160;/&gt;</code></p>
<p>The <a href="#element-expose"><code>xsl:expose</code></a>
element allows the <a title="visibility" class="termref" href=
"#dt-visibility">visibility</a> of selected components within a
package to be defined.</p>
<p>The components in question are identified using their <a title=
"symbolic identifier" class="termref" href=
"#dt-symbolic-identifier">symbolic identifiers</a>. The
<code>component</code> attribute defines the kind of component that
is selected. The <code>names</code> attribute selects a subset of
those components by name (and in the case of functions, arity); its
value is a whitespace-separated sequence of tokens each of which is
either a <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-NameTest">NameTest</a><sup><small>XP30</small></sup>
or a <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-NamedFunctionRef">NamedFunctionRef</a><sup><small>XP30</small></sup>.
(Examples are <code>*</code>, <code>p:*</code>,
<code>*:local</code>, <code>p:local</code>, and
<code>p:local#2</code>.)</p>
<p>The value may be a <code>NamedFunctionRef</code> only in the
case of stylesheet functions, and distinguishes functions with the
same name and different arity.</p>
<p>The visibility of a component declared within a package is the
first of the following that applies, subject to consistency
constraints which are defined below:</p>
<ol class="enumar">
<li>
<p>If the package manifest contains an <a href=
"#element-expose"><code>xsl:expose</code></a> element that matches
this component by virtue of an explicit <code>EQName</code> or
<code>NamedFunctionRef</code> (that is, not by virtue of a wildcard
match), then the value of the <code>visibility</code> attribute of
the last such <a href="#element-expose"><code>xsl:expose</code></a>
element in document order (call this the <b>explicit exposed
visibility</b>).</p>
</li>
<li>
<p>If the declaration of the component has a
<code>visibility</code> attribute, then the value of this attribute
(call this the <b>declared visibility</b>).</p>
</li>
<li>
<p>If the package manifest contains an <a href=
"#element-expose"><code>xsl:expose</code></a> element that matches
this component by virtue of a wildcard match that specifies either
the namespace part of the component name or the local part of the
name (for example, <code>prefix:*</code> or <code>*:local</code> or
<code>Q{uri}*</code>), then the value of the
<code>visibility</code> attribute of the last such <a href=
"#element-expose"><code>xsl:expose</code></a> element in document
order.</p>
</li>
<li>
<p>If the package manifest contains an <a href=
"#element-expose"><code>xsl:expose</code></a> element that matches
this component by virtue of a wildcard match that matches all names
(that is, <code>*</code>), then the value of the
<code>visibility</code> attribute of the last such <a href=
"#element-expose"><code>xsl:expose</code></a> element in document
order.</p>
</li>
<li>
<p>Otherwise, <code>private</code>.</p>
</li>
</ol>
<p>If both a declared visibility and an explicit exposed visibility
exist for the same component, then as mentioned above, they must be
consistent. This is determined by reference to the following table,
where the entry N/P means "not permitted". (In cases where the
combination is permitted, the actual visibility is always the same
as the visibility determined by <a href=
"#element-expose"><code>xsl:expose</code></a>.)</p>
<table border="1" cellpadding="5" summary=
"relationship of exposed visibility to potential visibility" width=
"100%">
<thead>
<tr>
<th rowspan="2" colspan="1" align="left" valign="top">Explicit
exposed visibility</th>
<th colspan="4" align="left" valign="top">Declared visibility</th>
</tr>
<tr>
<th colspan="1" align="left" valign="top">public</th>
<th colspan="1" align="left" valign="top">private</th>
<th colspan="1" align="left" valign="top">final</th>
<th colspan="1" align="left" valign="top">abstract</th>
</tr>
</thead>
<tbody>
<tr>
<th colspan="1" align="left" valign="top">public</th>
<td align="left" valign="top">public</td>
<td align="left" valign="top">N/P</td>
<td align="left" valign="top">N/P</td>
<td align="left" valign="top">N/P</td>
</tr>
<tr>
<th colspan="1" align="left" valign="top">private</th>
<td align="left" valign="top">private</td>
<td align="left" valign="top">private</td>
<td align="left" valign="top">private</td>
<td align="left" valign="top">N/P</td>
</tr>
<tr>
<th colspan="1" align="left" valign="top">final</th>
<td align="left" valign="top">final</td>
<td align="left" valign="top">N/P</td>
<td align="left" valign="top">final</td>
<td align="left" valign="top">N/P</td>
</tr>
<tr>
<th colspan="1" align="left" valign="top">abstract</th>
<td align="left" valign="top">N/P</td>
<td align="left" valign="top">N/P</td>
<td align="left" valign="top">N/P</td>
<td align="left" valign="top">abstract</td>
</tr>
</tbody>
</table>
<p><a name="err-XTSE3010" id="err-XTSE3010"><span class=
"error">[ERR XTSE3010]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
explicit exposed visibility of a component is inconsistent with its
declared visibility, as defined in the above table. (This error
occurs only when the component declaration has an explicit
<code>visibility</code> attribute, and the component is also listed
explicitly by name in an <a href=
"#element-expose"><code>xsl:expose</code></a> declaration.)</p>
<p><a name="err-XTSE3020" id="err-XTSE3020"><span class=
"error">[ERR XTSE3020]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if a token
in the <code>names</code> attribute of <code>xsl:expose</code>,
other than a wildcard, matches no component in the containing
package.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>There is no ambiguity, and no error, if several tokens within
the same <a href="#element-expose"><code>xsl:expose</code></a>
element match the same component.</p>
</div>
<p>For a component accepted into a package <var>Q</var> from
another package <var>P</var>, the <a title="visibility" class=
"termref" href="#dt-visibility">visibility</a> of the component in
<var>Q</var> (which primarily affects how it can be used in a
package <var>R</var> that uses <var>Q</var>) depends on the
visibility declared in the relevant <a href=
"#element-accept"><code>xsl:accept</code></a> or <a href=
"#element-override"><code>xsl:override</code></a> element in
<var>Q</var> (see <a href="#accepting-components"><i>3.6.3.2
Accepting Components</i></a>); this in turn has a default that
depends on the visibility of the corresponding component in
<var>P</var>. In this case the visibility is unaffected by any
<a href="#element-expose"><code>xsl:expose</code></a> declaration
in <var>Q</var>.</p>
</div>
<div class="div4">
<h5><a name="accepting-components" id=
"accepting-components"></a>3.6.3.2 <a href="#accepting-components"
style="text-decoration: none">Accepting Components</a></h5>
<p>When a package <var>Q</var> uses a package <var>P</var>, by
virtue of an <a href=
"#element-use-package"><code>xsl:use-package</code></a> element in
the <a title="package manifest" class="termref" href=
"#dt-package-manifest">package manifest</a> of <var>Q</var>, then
<var>Q</var> will contain a <a title="component" class="termref"
href="#dt-component">component</a> corresponding to every component
in <var>P</var>. The <a title="visibility" class="termref" href=
"#dt-visibility">visibility</a> of the component within
<var>Q</var> depends on the <a title="visibility" class="termref"
href="#dt-visibility">visibility</a> of the component in
<var>P</var>, optionally modified by two elements that may appear
as children of the <a href=
"#element-use-package"><code>xsl:use-package</code></a> element,
namely <a href="#element-accept"><code>xsl:accept</code></a> and
<a href="#element-override"><code>xsl:override</code></a>.</p>
<p>For every component <var>C(P)</var> in package <var>P</var> that
is not matched by any <a href=
"#element-override"><code>xsl:override</code></a> or <a href=
"#element-accept"><code>xsl:accept</code></a> element in the
package manifest of <var>Q</var>, there will be a corresponding
component <var>C(Q)</var> in package <var>Q</var> that has the same
<a title="symbolic identifier" class="termref" href=
"#dt-symbolic-identifier">symbolic identifier</a> and <a title=
"declaration" class="termref" href=
"#dt-declaration">declaration</a> as <var>C(P)</var>. The <a title=
"visibility" class="termref" href="#dt-visibility">visibility</a>
of <var>C(Q)</var> will be the same as the <a title="visibility"
class="termref" href="#dt-visibility">visibility</a> of
<var>C(P)</var>, except that where the <a title="visibility" class=
"termref" href="#dt-visibility">visibility</a> of <var>C(P)</var>
is <code>private</code>, the <a title="visibility" class="termref"
href="#dt-visibility">visibility</a> of <var>C(Q)</var> will be
<code>hidden</code>.</p>
<p>A component <var>C(P)</var> in package <var>P</var> whose
<a title="visibility" class="termref" href=
"#dt-visibility">visibility</a> is <code>hidden</code> will never
be matched by an <a href=
"#element-override"><code>xsl:override</code></a> or <a href=
"#element-accept"><code>xsl:accept</code></a> element in the
package manifest of <var>Q</var>, and therefore <var>Q</var> will
contain a <code>hidden</code> component <var>C(Q)</var>
corresponding to <var>C(P)</var>.</p>
<p class="element-syntax"><a name="element-accept" id=
"element-accept"></a><code>&lt;xsl:accept<br />
&#160;&#160;<b>component</b> = "template" | "function" |
"accumulator" | "attribute-set" | "variable" | "mode"<br />
&#160;&#160;<b>names</b> = <var>tokens</var><br />
&#160;&#160;<b>visibility</b> = "public" | "private" | "final" |
"abstract" | "hidden" | "absent"&#160;/&gt;</code></p>
<p>The <a href="#element-accept"><code>xsl:accept</code></a>
element has very similar syntax and semantics to <a href=
"#element-expose"><code>xsl:expose</code></a>. Whereas <a href=
"#element-expose"><code>xsl:expose</code></a> allows a package to
restrict the visibility of its own components to other (using)
packages, <a href="#element-accept"><code>xsl:accept</code></a>
allows a package to restrict the visibility of components exposed
by a package that it uses. This may be necessary if, for example,
it uses two different packages whose component names conflict. It
may also simply be good practice if the package author knows that
only a small subset of the functionality of a used package is
required.</p>
<p>The rules for determining whether an <a href=
"#element-accept"><code>xsl:accept</code></a> element matches a
particular component, and for which element to use if there are
several matches, are the same as the rules for the <a href=
"#element-expose"><code>xsl:expose</code></a> element.</p>
<p><a name="err-XTSE3030" id="err-XTSE3030"><span class=
"error">[ERR XTSE3030]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if a token
in the <code>names</code> attribute of <code>xsl:accept</code>,
other than a wildcard, matches no component in the used
package.</p>
<p>In the absence of a matching <a href=
"#element-override"><code>xsl:override</code></a> element (see
<a href="#package-overriding-components"><i>3.6.3.3 Overriding
Named Components from a Used Package</i></a>), the <a title=
"visibility" class="termref" href="#dt-visibility">visibility</a>
of a component that matches an <a href=
"#element-accept"><code>xsl:accept</code></a> element depends both
on the <code>visibility</code> attribute of the best-matching
<a href="#element-accept"><code>xsl:accept</code></a> element and
on the <a title="visibility" class="termref" href=
"#dt-visibility">visibility</a> of the corresponding component in
the used package, according to the following table. In this table
the entry "N/P" means "not permitted".</p>
<table border="1" cellpadding="5" summary=
"relationship of the visibility given in xsl:accept to visibility in the used package"
width="100%">
<thead>
<tr>
<th rowspan="2" colspan="1" align="left" valign="top">Visibility in
<a href="#element-accept"><code>xsl:accept</code></a> element</th>
<th colspan="4" align="left" valign="top">Visibility in used
package</th>
</tr>
<tr>
<th colspan="1" align="left" valign="top">public</th>
<th colspan="1" align="left" valign="top">private</th>
<th colspan="1" align="left" valign="top">final</th>
<th colspan="1" align="left" valign="top">abstract</th>
</tr>
</thead>
<tbody>
<tr>
<th colspan="1" align="left" valign="top">public</th>
<td align="left" valign="top">public</td>
<td align="left" valign="top">N/P</td>
<td align="left" valign="top">N/P</td>
<td align="left" valign="top">N/P</td>
</tr>
<tr>
<th colspan="1" align="left" valign="top">private</th>
<td align="left" valign="top">private</td>
<td align="left" valign="top">N/P</td>
<td align="left" valign="top">private</td>
<td align="left" valign="top">N/P</td>
</tr>
<tr>
<th colspan="1" align="left" valign="top">final</th>
<td align="left" valign="top">final</td>
<td align="left" valign="top">N/P</td>
<td align="left" valign="top">final</td>
<td align="left" valign="top">N/P</td>
</tr>
<tr>
<th colspan="1" align="left" valign="top">abstract</th>
<td align="left" valign="top">N/P</td>
<td align="left" valign="top">N/P</td>
<td align="left" valign="top">N/P</td>
<td align="left" valign="top">abstract</td>
</tr>
<tr>
<th colspan="1" align="left" valign="top">hidden</th>
<td align="left" valign="top">hidden</td>
<td align="left" valign="top">N/P</td>
<td align="left" valign="top">hidden</td>
<td align="left" valign="top">N/P</td>
</tr>
<tr>
<th colspan="1" align="left" valign="top">absent</th>
<td align="left" valign="top">N/P</td>
<td align="left" valign="top">N/P</td>
<td align="left" valign="top">N/P</td>
<td align="left" valign="top">absent</td>
</tr>
</tbody>
</table>
<p><a name="err-XTSE3040" id="err-XTSE3040"><span class=
"error">[ERR XTSE3040]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
visibility assigned to a component by an <a href=
"#element-accept"><code>xsl:accept</code></a> element is
incompatible with the visibility of the corresponding component in
the used package, as defined by the above table, unless the token
that matches the component name is a wildcard, in which case the
<a href="#element-accept"><code>xsl:accept</code></a> element is
treated as not matching that component.</p>
<p><a name="err-XTSE3050" id="err-XTSE3050"><span class=
"error">[ERR XTSE3050]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
<a href="#element-use-package"><code>xsl:use-package</code></a>
elements in a <a title="package manifest" class="termref" href=
"#dt-package-manifest">package manifest</a> cause two or more
<a title="homonymous" class="termref" href=
"#dt-homonymous">homonymous</a> components to be accepted with a
visibility other than <code>hidden</code>.</p>
<p>Conflicts between the components accepted from used packages and
those declared within the package itself are handled as
follows:</p>
<ol class="enumar">
<li>
<p>If the conflict is between two components both declared within
the package itself, then it is resolved by the rules relating to
<a title="import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a> defined for each kind
of component.</p>
</li>
<li>
<p>If the conflict is between two components both accepted from
used packages, or between a component declared within the package
and an accepted component, then a static error occurs.</p>
</li>
</ol>
<p>The value <code>visibility="absent"</code> may be used only in
the case of a component that is present in the used package with
exposed visibility <code>abstract</code>. It is used to indicate
that the using package does not intend to provide an implementation
of the abstract component, and that any invocation of the abstract
component is therefore to result in an error. Specifically:</p>
<ol class="enumar">
<li>
<p>Any component reference to the component within the using
package is a static error, as if the component were hidden: in
effect, the name of the component is not in scope in the using
package.</p>
</li>
<li>
<p>Any invocation of the absent component (typically from within
its declaring package) causes a dynamic error, as if the component
were overridden by a component that unconditionally raises a
dynamic error.</p>
<p><a name="err-XTDE3052" id="err-XTDE3052"><span class=
"error">[ERR XTDE3052]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if an
invocation of an absent component (that is, an abstract component
accepted into a using package with
<code>visibility="absent"</code>) is evaluated.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>To override a component accepted from a used package, the
overriding declaration must appear as a child of the <a href=
"#element-override"><code>xsl:override</code></a> element.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>There is no rule that prevents a function (say) being declared
in the using package with the same name as a <code>private</code>
function in the used package. This does not create a conflict,
since all references in the used package are bound to one function
and all those in the using package are bound to another.</p>
</div>
</div>
<div class="div4">
<h5><a name="package-overriding-components" id=
"package-overriding-components"></a>3.6.3.3 <a href=
"#package-overriding-components" style=
"text-decoration: none">Overriding</a> <a href=
"#package-overriding-components" style=
"text-decoration: none">Components from a Used Package</a></h5>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-override" id="dt-override" title="override"></a>A component in
a using package may <b>override</b> a component in a used package,
provided that the <a title="visibility" class="termref" href=
"#dt-visibility">visibility</a> of the component in the used
package is either <code>abstract</code> or <code>public</code>. The
overriding declaration is written as a child of the <a href=
"#element-override"><code>xsl:override</code></a> element, which in
turn appears as a child of <a href=
"#element-use-package"><code>xsl:use-package</code></a>.<span class="definition">]</span></p>
<p class="element-syntax"><a name="element-override" id=
"element-override"></a><code>&lt;xsl:override&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-template">xsl:template</a> | <a href=
"#element-function">xsl:function</a> | <a href=
"#element-accumulator">xsl:accumulator</a> | <a href=
"#element-variable">xsl:variable</a> | <a href=
"#element-param">xsl:param</a> | <a href=
"#element-attribute-set">xsl:attribute-set</a>)* --&gt;<br />
&lt;/xsl:override&gt;</code></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This mechanism is distinct from the mechanism for overriding
declarations within the same package by relying on <a title=
"import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a>. It imposes stricter
rules: the overriding component is required to be type-compatible
with the component that it overrides.</p>
</div>
<p>If the used package <var>P</var> contains a <a title="component"
class="termref" href="#dt-component">component</a> <var>C(P)</var>
and the <a href=
"#element-use-package"><code>xsl:use-package</code></a> element
contains an <a href=
"#element-override"><code>xsl:override</code></a> element which
contains a declaration <var>D</var> whose <a title=
"symbolic identifier" class="termref" href=
"#dt-symbolic-identifier">symbolic identifier</a> matches the
symbolic identifier of <var>C(P)</var>, then the using package
<var>Q</var> will contain a component whose declaration is D, whose
symbolic identifier is that of D, and whose <a title="visibility"
class="termref" href="#dt-visibility">visibility</a> is equal to
the value of the <code>visibility</code> attribute of <var>D</var>,
or <code>private</code> if this is absent.</p>
<p>If the overridden component <var>C(P)</var> has visibility
<code>public</code> then the using package <var>Q</var> will also
contain a component <var>C′(Q)</var> whose declaration is the same
as the declaration of <var>C(P)</var> and whose <a title=
"visibility" class="termref" href="#dt-visibility">visibility</a>
is <code>hidden</code>. This component is used as the target of a
binding for the symbolic reference <code>xsl:original</code>
described below.</p>
<p>Other than its appearance as a child of <a href=
"#element-override"><code>xsl:override</code></a>, the overriding
declaration is a normal <a href=
"#element-function"><code>xsl:function</code></a>, <a href=
"#element-template"><code>xsl:template</code></a>, <span><a href=
"#element-accumulator"><code>xsl:accumulator</code></a></span>,
<a href="#element-variable"><code>xsl:variable</code></a>, <a href=
"#element-param"><code>xsl:param</code></a>, or <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a>
element. In the case of <a href=
"#element-variable"><code>xsl:variable</code></a> and <a href=
"#element-param"><code>xsl:param</code></a>, the variable that is
declared is a <a title="global variable" class="termref" href=
"#dt-global-variable">global variable</a>.</p>
<p>The rules in the remainder of this section apply to components
having a <code>name</code> attribute (<b>named components</b>). The
only element with no <code>name</code> attribute that can appear as
a child of <a href=
"#element-override"><code>xsl:override</code></a> is an <a href=
"#element-template"><code>xsl:template</code></a> declaration
having a <code>match</code> attribute (that is, a <a title=
"template rule" class="termref" href="#dt-template-rule">template
rule</a>). The rules for overriding of template rules appear in
<a href="#modes-and-packages"><i>3.6.4 Overriding Template Rules
from a Used Package</i></a>. If an <a href=
"#element-template"><code>xsl:template</code></a> element has both
a <code>name</code> attribute and a <code>match</code> attribute,
then it defines both a named component and a template rule, and
both sections apply.</p>
<p>The <a title="visibility" class="termref" href=
"#dt-visibility">visibility</a> of the overriding component in the
using package is defined by the <code>visibility</code> attribute
appearing on the overriding declaration.</p>
<p><a name="err-XTSE3055" id="err-XTSE3055"><span class=
"error">[ERR XTSE3055]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if a
component declaration appearing as a child of <a href=
"#element-override"><code>xsl:override</code></a> is <a title=
"homonymous" class="termref" href="#dt-homonymous">homonymous</a>
with any other declaration in the using package, regardless of
<a title="import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a>, including any other
overriding declaration in the package manifest of the using
package.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>When an attribute set is overridden, the overriding attribute
set must be defined using a single <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a>
element. Attribute sets defined in different packages are never
merged by virtue of having the same name, though they may be merged
explicitly by using the <code>use-attribute-sets</code>
attribute.</p>
</div>
<p><a name="err-XTSE3058" id="err-XTSE3058"><span class=
"error">[ERR XTSE3058]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if a
component declaration appearing as a child of <a href=
"#element-override"><code>xsl:override</code></a> does not match
(is not <a title="homonymous" class="termref" href=
"#dt-homonymous">homonymous</a> with) some component in the used
package.</p>
<p><a name="err-XTSE3060" id="err-XTSE3060"><span class=
"error">[ERR XTSE3060]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
component referenced by an <a href=
"#element-override"><code>xsl:override</code></a> declaration has
<a title="visibility" class="termref" href=
"#dt-visibility">visibility</a> other than <code>public</code> or
<code>abstract</code></p>
<p>A package is executable if and only if it contains no <a title=
"component" class="termref" href="#dt-component">component</a>
whose <a title="visibility" class="termref" href=
"#dt-visibility">visibility</a> is <code>abstract</code>. A package
that is not executable is not a <a title="stylesheet" class=
"termref" href="#dt-stylesheet">stylesheet</a>, and therefore
cannot be nominated as the stylesheet to be used when initiating a
transformation.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In other words, if a component is declared as abstract, then
some package that uses the declaring package of that component
directly or indirectly must override that component with one that
is not abstract. It is not necessary for the override to happen in
the immediately using package.</p>
</div>
<p><a name="err-XTSE3070" id="err-XTSE3070"><span class=
"error">[ERR XTSE3070]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
signature of an overriding component is not <a title="compatible"
class="termref" href="#dt-compatible">compatible</a> with the
signature of the component that it is overriding.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-compatible" id="dt-compatible" title="compatible"></a>The
signatures of two <a title="component" class="termref" href=
"#dt-component">components</a> are <b>compatible</b> if they
present the same interface to the user of the component. The
additional rules depend on the kind of component.<span class=
"definition">]</span></p>
<p>Compatibility is only relevant when comparing two components
that have the same <a title="symbolic identifier" class="termref"
href="#dt-symbolic-identifier">symbolic identifier</a>. The
compatibility rules for each kind of component are as follows:</p>
<ul>
<li>
<p>Two attribute sets with the same name are compatible if and only
if they satisfy the following rule:</p>
<ol class="enumar">
<li>
<p>If the overridden attribute set specifies
<code>streamable="yes"</code> then the overriding attribute set
also specifies <code>streamable="yes"</code>.</p>
</li>
</ol>
</li>
<li>
<p>Two functions with the same name and arity are compatible if and
only if they satisfy all the following rules:</p>
<ol class="enumar">
<li>
<p>The types of the arguments are pairwise <a title=
"identical (types)" class="termref" href=
"#dt-identical-types">identical</a>.</p>
</li>
<li>
<p>The return types are <a title="identical (types)" class=
"termref" href="#dt-identical-types">identical</a>.</p>
</li>
<li>
<p>If the overridden function specifies
<code>identity-sensitive="no"</code> then the overriding function
also specifies <code>identity-sensitive="no"</code>.</p>
</li>
<li>
<p>If the overridden function specifies
<code>override-extension-functions="no"</code> (or the equivalent
using the deprecated <code>override</code> attribute) then the
overriding function also specifies
<code>override-extension-functions="no"</code> (or the
equivalent).</p>
</li>
<li>
<p>If the overridden function specifies
<code>streamable="yes"</code> then the overriding function also
specifies <code>streamable="yes"</code>, and in addition, it has
the same <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> as the function that it overrides.</p>
</li>
</ol>
</li>
<li>
<p>Two accumulators with the same name are compatible if and only
if they satisfy all the following rules:</p>
<ol class="enumar">
<li>
<p>The types (defined in the <code>as</code> attribute) are
<a title="identical (types)" class="termref" href=
"#dt-identical-types">identical</a>.</p>
</li>
<li>
<p>If the overridden accumulator specifies
<code>streamable="yes"</code> then the overriding accumulator also
specifies <code>streamable="yes"</code>.</p>
</li>
</ol>
</li>
<li>
<p>Two named templates with the same name are compatible if and
only if they satisfy all the following rules:</p>
<ol class="enumar">
<li>
<p>Their return types are <a title="identical (types)" class=
"termref" href="#dt-identical-types">identical</a>.</p>
</li>
<li>
<p>For every parameter on the overridden template, there is a
parameter on the overriding template that has the same name, an
<a title="identical (types)" class="termref" href=
"#dt-identical-types">identical</a> required type, and the same
effective values for the <code>tunnel</code> and
<code>required</code> attributes.</p>
</li>
<li>
<p>Any parameter on the overriding template for which there is no
corresponding parameter on the overridden template specifies
<code>required="no"</code>.</p>
</li>
<li>
<p>The two templates have equivalent <a href=
"#element-context-item"><code>xsl:context-item</code></a> children,
where equivalence means that the <code>use</code> attributes are
the same and the required types are <a title="identical (types)"
class="termref" href="#dt-identical-types">identical</a>; an absent
<a href="#element-context-item"><code>xsl:context-item</code></a>
is equivalent to one that specifies <code>use="optional"</code> and
<code>as="item()"</code>.</p>
</li>
</ol>
</li>
<li>
<p>Two variables (including parameters) with the same name are
compatible if and only if they satisfy all the following rules:</p>
<ol class="enumar">
<li>
<p>Their declared types are <a title="identical (types)" class=
"termref" href="#dt-identical-types">identical</a>.</p>
</li>
<li>
<p>If the overridden variable is a parameter that specifies
<code>required="yes"</code> then the overriding variable is either
a non-parameter variable, or a parameter that specifies
<code>required="yes"</code></p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>A variable may override a parameter or vice-versa, and the
initial value may differ.</p>
<p>Because static variables and parameters are constrained to have
visibility <code>private</code> , they cannot be overridden in
another package. The compatibility rules therefore do not arise.
The reason that such variables cannot be overridden is that they
are typically used during stylesheet compilation (for example, in
<code>[xsl:]use-when</code> expressions and shadow attributes) and
it is a design goal that packages should be capable of independent
compilation.</p>
</div>
</li>
</ul>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-identical-types" id="dt-identical-types" title=
"identical (types)"></a>Types S and T are considered
<b>identical</b> for the purpose of these rules if and only if
<code>subtype(S, T)</code> and <code>subtype(T, S)</code> both
hold, where the subtype relation is defined in <a href=
"http://www.w3.org/TR/xpath-30/#id-seqtype-subtype">Section 2.5.6.1
The judgement subtype(A, B)</a>
<sup><small>XP30</small></sup>.<span class=
"definition">]</span></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<ol class="enumar">
<li>
<p>One consequence of this rule is that two plain union types are
considered identical if they have the same set of member types,
even if the union types have different names or the ordering of the
member types is different.</p>
</li>
<li>
<p>While this rule may appear formal, it is not as straightforward
as might be supposed, because the subtype relation in XPath has a
dependency on the "Type derivation OK (Simple)" relation in XML
Schema, which itself appeals to a judgement as to whether the two
type definitions being compared "are the same type definition".
Both XSD 1.0 and XSD 1.1 add the note "The wording of [this rule]
appeals to a notion of component identity which is only
incompletely defined by this version of this specification."
However, they go on to say that component identity is well defined
if the components are named simple type definitions, which will
always apply in this case. For named atomic types, the final result
of these rules is that two atomic types are identical if and only
if they have the same name.</p>
</li>
</ol>
</div>
<p>Modes are not overridable, so the <a href=
"#element-mode"><code>xsl:mode</code></a> declaration cannot appear
as a child of <a href=
"#element-override"><code>xsl:override</code></a>.</p>
<p>Within the declaration of an overriding component (that is, a
component whose declaration is a child of <a href=
"#element-override"><code>xsl:override</code></a>), where the
overridden component has <code>public</code> visibility, it is
possible to use the name <code>xsl:original</code> as a <a title=
"symbolic reference" class="termref" href=
"#dt-symbolic-reference">symbolic reference</a> to the overridden
component:</p>
<ul>
<li>
<p>Within an overriding named template, <code>&lt;xsl:call-template
name="xsl:original"/&gt;</code> may be used to call the overridden
named template.</p>
</li>
<li>
<p>Within an overriding stylesheet function,
<code>xsl:original()</code> may be used to call the overridden
stylesheet function.</p>
</li>
<li>
<p>Within an overriding global variable or parameter,
<code>$xsl:original</code> may be used to reference the overridden
global variable or parameter.</p>
</li>
<li>
<p>Within an overriding attribute set,
<code>[xsl:]use-attribute-set="xsl:original"</code> may be used to
reference the overridden attribute set.</p>
</li>
<li>
<p>Within an overriding accumulator, however, it is not possible to
refer to the overridden accumulator.</p>
</li>
</ul>
<p>Within the overriding component <var>C(Q)</var>, this symbolic
reference is bound to the hidden component <var>C′(Q)</var>
described earlier, whose declaration is that of the component
<var>C(P)</var> in the used package. The static context for the
overriding declaration is augmented to include a component of the
relevant kind (function, named template, attribute set, or
variable) with the name <code>xsl:original</code>.</p>
</div>
<div class="div4">
<h5><a name="component-references" id=
"component-references"></a>3.6.3.4 <a href="#component-references"
style="text-decoration: none">Binding References to
Components</a></h5>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-reference-resolution" id="dt-reference-resolution" title=
"reference resolution"></a>The process of identifying the <a title=
"component" class="termref" href="#dt-component">component</a> to
which a <a title="symbolic reference" class="termref" href=
"#dt-symbolic-reference">symbolic reference</a> applies (possibly
chosen from several <a title="homonymous" class="termref" href=
"#dt-homonymous">homonymous</a> alternatives) is called
<b>reference binding</b>.<span class="definition">]</span> A
reference is called <b>bound</b> if the component to which it
applies has been identified and fixed, and is <b>unbound</b>
otherwise (that is, if it exists only in the form of a <a title=
"symbolic identifier" class="termref" href=
"#dt-symbolic-identifier">symbolic identifier</a>).</p>
<p>Reference resolution for the components in a package occurs
conceptually after a package has been fully defined and before the
processing of any other package that uses it.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>If packages are separately compiled, then reference resolution
is likely to form part of the compilation process.</p>
</div>
<p>When reference resolution is performed for a <a title=
"component" class="termref" href="#dt-component">component</a>
<var>C</var>, each symbolic reference <var>R</var> that is present
in the <a title="declaration" class="termref" href=
"#dt-declaration">declaration</a> of <var>C</var> is processed as
follows:</p>
<ol class="enumar">
<li>
<p>If <var>C</var> already contains a binding for <var>R</var> then
this binding is retained.</p>
</li>
<li>
<p>If <var>C</var> contains no binding for <var>R</var> then the
processor attempts to locate a component in the containing package
of <var>C</var> whose visibility is not <code>hidden</code> and
whose symbolic name matches <var>R</var>. If there is no such
component, then a static error is reported as described elsewhere
in this specification. There can never be more than one. Call the
located component <var>D</var>. If <var>D</var> has <a title=
"visibility" class="termref" href="#dt-visibility">visibility</a>
<code>private</code> or <code>final</code>, then <var>C</var>
acquires a binding that associates the symbolic reference
<var>R</var> with the component <var>D</var>. Otherwise, the
reference remains unbound.</p>
</li>
</ol>
<p>When a package <var>P</var> is used by another package
<var>Q</var>, then <var>Q</var> will accept components
corresponding to the components in <var>P</var>, as described in
previous sections. Until reference resolution is performed for
<var>Q</var>, these components will have the same bindings as their
corresponding components from <var>P</var>: a symbolic reference
that was bound for a component in <var>P</var> will retain the same
binding, and a symbolic reference that was unbound in <var>P</var>
will remain unbound in the corresponding component in <var>Q</var>.
Subsequently, when reference resolution is performed for package
<var>Q</var>, these symbolic references may become bound, perhaps
to components whose declaration is in <var>Q</var> or in some other
package.</p>
<p>When reference resolution is performed on a package that is
intended to be used as a <a title="stylesheet" class="termref"
href="#dt-stylesheet">stylesheet</a> (that is, for the <a title=
"top-level package" class="termref" href=
"#dt-top-level-package">top-level package</a>), symbolic references
to components whose visibility is <code>public</code> are bound in
the same way as references to components whose visibility is
<code>private</code> or <code>final</code>. At this stage there
must be no symbolic references referring to components whose
visibility is <code>abstract</code> (that is, an implementation
must be provided for every abstract component).</p>
<p><a name="err-XTSE3080" id="err-XTSE3080"><span class=
"error">[ERR XTSE3080]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if a
<a title="top-level package" class="termref" href=
"#dt-top-level-package">top-level package</a> (as distinct from a
<a title="library package" class="termref" href=
"#dt-library-package">library package</a>) contains symbolic
references referring to components whose visibility is
<code>abstract</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Unresolved references are allowed at the module level but not at
the package level. A stylesheet module can contain references to
components that are satisfied only when the module is imported into
another module that declares the missing component.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The process of resolving references (or linking) is critical to
an implementation that uses separate compilation. One of the aims
of these rules is to ensure that when compiling a package, it is
always possible to determine the signature of called functions,
templates, and other components. A further aim is to establish
unambiguously in what circumstances components can be overridden,
so that compilers know when it is possible to perform optimizations
such as inlining of function and variable references.</p>
<p>Suppose a public template <var>T</var> calls a private function
<var>F</var>. When the package containing these two components is
referenced by a using package, the template remains public, while
the function becomes hidden. Because the function becomes hidden,
it can no longer conflict with any other function of the same name,
or be overridden by any other function; at this stage the compiler
knows exactly which function <var>T</var> will be calling, and can
perform optimizations based on this knowledge.</p>
</div>
<p>The mechanism for resolving component references described in
this section is consistent with the mechanism used for binding
function and variable references described in the XPath
specification. XPath requires these variable and function names to
be present in the static context for an XPath expression. XSLT
ensures that all the non-hidden functions, global variables, and
global parameters in a package are present in the static context
for every XPath expression that appears in that package, along with
required information such as the type of a variable and the
signature of a function.</p>
</div>
</div>
<div class="div3">
<h4><a name="modes-and-packages" id="modes-and-packages"></a>3.6.4
<a href="#modes-and-packages" style=
"text-decoration: none">Overriding Template Rules from a Used
Package</a></h4>
<p>The rules in the previous section apply to named components
including functions, named templates, global variables, and named
attribute sets. The rules for <a title="mode" class="termref" href=
"#dt-mode">modes</a>, and the <a title="template rule" class=
"termref" href="#dt-template-rule">template rules</a> appearing
within a mode, are slightly different.</p>
<p>The unnamed mode is local to a package: in effect, each package
has its own private unnamed mode, and the unnamed mode of one
package does not interact with the unnamed mode of any other
package.</p>
<p>A named mode may be declared in an <a href=
"#element-mode"><code>xsl:mode</code></a> declaration as being
either <code>public</code>, <code>private</code>, or
<code>final</code>. The values of the <code>visibility</code>
attribute are interpreted as follows:</p>
<table border="1" cellspacing="2" summary=
"visibility values for named modes, and their meaning" cellpadding=
"5" width="100%">
<thead>
<tr>
<th colspan="1" align="left" valign="top">Value</th>
<th colspan="1" align="left" valign="top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td valign="top" align="left">public</td>
<td align="left" valign="top">A <b>using</b> package may use
<a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a> to
invoke templates in this mode; it may also declare additional
template rules in this mode, which are selected in preference to
template rules in the used package. These may appear only as
children of the <a href=
"#element-override"><code>xsl:override</code></a> element within
the <a href="#element-use-package"><code>xsl:use-package</code></a>
element.</td>
</tr>
<tr>
<td valign="top" align="left">private</td>
<td align="left" valign="top">A <b>using</b> package may neither
reference the mode nor provide additional templates in this mode;
the name of the mode is not even visible in the using package, so
no such attempt is possible. The using package can use the same
name for its own modes without risk of conflict.</td>
</tr>
<tr>
<td valign="top" align="left">final</td>
<td align="left" valign="top">A <b>using</b> package may use
<a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a> to
invoke templates in this mode, but it must not provide additional
template rules in this mode.</td>
</tr>
</tbody>
</table>
<p>As with other named components, an <a href=
"#element-use-package"><code>xsl:use-package</code></a> declaration
may contain an <a href=
"#element-expose"><code>xsl:expose</code></a> element to control
the visibility of a mode acquired from the <b>used</b> package. The
allowed values of its <code>visibility</code> attribute are
<code>public</code>, <code>private</code>, and
<code>final</code>.</p>
<p>The <a href="#element-mode"><code>xsl:mode</code></a>
declaration itself must not be overridden. A using package must not
contain an <a href="#element-mode"><code>xsl:mode</code></a>
declaration whose name matches that of a <code>public</code> or
<code>final</code> <a href=
"#element-mode"><code>xsl:mode</code></a> component accepted from a
used package.</p>
<p>The <a href="#element-expose"><code>xsl:expose</code></a> and
<a href="#element-accept"><code>xsl:accept</code></a> elements may
be used to reduce the visibility of a mode in a using package; the
same rules apply in general, though some of the rules are not
applicable because, for example, modes cannot be
<code>abstract</code>.</p>
<p>It is not possible for a package to combine the template rules
from two other packages into a single mode. When <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a> is
used without specifying a mode, the chosen template rules will
always come from the same package; when it is used with a named
mode, then they will come from the package where the mode is
defined, or any package that uses that package and adds template
rules to the mode. If two template rules defined in different
packages match the same node, then the rule in the using package
wins over any rule in the used package; this decision is made
before taking other factors such as import precedence and priority
into account.</p>
<p>A static error occurs if two modes with the same name are
visible within a package, either because they are both declared
within the package, or because one is declared within the package
and the other is acquired from a used package, or because both are
accepted from different used packages.</p>
<p>The rules for matching template rules by precedence and priority
operate as normal, with the addition that template rules declared
within an <a href=
"#element-use-package"><code>xsl:use-package</code></a> element
have higher precedence than any template rule declared in the used
package.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>If existing XSLT code has been written to use template rules in
the unnamed mode, a convenient way to incorporate this code into a
<a title="library package" class="termref" href=
"#dt-library-package">library package</a> is to add a stub module
that defines a new named <code>public</code> or <code>final</code>
mode, in which there is a single template rule whose content is the
single instruction <code>&lt;xsl:apply-templates/&gt;</code>. This
in effect redirects <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instructions using the named mode to the rules defined in the
unnamed mode.</p>
</div>
<div class="div4">
<h5><a name="requiring-explicit-modes" id=
"requiring-explicit-modes"></a>3.6.4.1 <a href=
"#requiring-explicit-modes" style="text-decoration: none">Requiring
Explicit Mode Declarations</a></h5>
<p>In previous versions of XSLT, modes were implicitly declared by
simply using a mode name in the <code>mode</code> attribute of
<a href="#element-template"><code>xsl:template</code></a> or
<a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>.
XSLT 3.0 introduces the ability to declared a mode explicitly using
an <a href="#element-mode"><code>xsl:mode</code></a> declaration
(see <a href="#declaring-modes"><i>6.6.1 Declaring
Modes</i></a>).</p>
<p>By default, within a package that is defined using an explicit
<a href="#element-package"><code>xsl:package</code></a> element,
all modes must be explicitly declared. In an implicit package,
however (that is, one rooted at an <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href=
"#element-transform"><code>xsl:transform</code></a> element), modes
can be implicitly declared as in previous XSLT versions.</p>
<p>The <code>declare-modes</code> attribute of <a href=
"#element-package"><code>xsl:package</code></a> determines whether
or not modes that are referenced within the package must be
explicitly declared. If the value is <code>yes</code> (the
default), then it is an error to use a mode name in <a href=
"#element-template"><code>xsl:template</code></a> or <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>, or
to use the unnamed mode, unless the package contains an explicit
<a href="#element-mode"><code>xsl:mode</code></a> declaration for
that mode. If the value is <code>no</code>, then this is not an
error.</p>
<p>This attribute affects all modules making up the package, it is
not confined to declarations appearing as children of the <a href=
"#element-package"><code>xsl:package</code></a> element.</p>
<p><a name="err-XTSE3085" id="err-XTSE3085"><span class=
"error">[ERR XTSE3085]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a>, unless
the value of the <code>declared-modes</code> attribute of an
<a href="#element-package"><code>xsl:package</code></a> element is
<code>no</code>, if the <code>mode</code> attribute of an <a href=
"#element-template"><code>xsl:template</code></a> or <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction within the package contains, either explicitly or
implicitly (for example, by virtue of a relevant
<code>default-mode</code> attribute), a mode name that is not the
subject of an <a href="#element-mode"><code>xsl:mode</code></a>
declaration appearing within the package nor a <code>public</code>
or <code>final</code> <code>xsl:mode</code> declaration accepted
from a used package. For this purpose the <a title="unnamed mode"
class="termref" href="#dt-unnamed-mode">unnamed mode</a> behaves in
the same way as a named mode, so that a reference to the unnamed
mode is allowed only if the unnamed mode is declared.</p>
</div>
</div>
<div class="div3">
<h4><a name="package-local-declarations" id=
"package-local-declarations"></a>3.6.5 <a href=
"#package-local-declarations" style=
"text-decoration: none">Declarations Local to a Package</a></h4>
<p>The <a href="#element-import"><code>xsl:import</code></a> and
<a href="#element-include"><code>xsl:include</code></a>
declarations are local to a package.</p>
<p>Declarations of <a title="key" class="termref" href=
"#dt-key">keys</a>, <a title="decimal format" class="termref" href=
"#dt-decimal-format">decimal formats</a>, namespace aliases (see
<a href="#namespace-aliasing"><i>11.1.5 Namespace
Aliasing</i></a>), <a title="output definition" class="termref"
href="#dt-output-definition">output definitions</a>, and <a title=
"character map" class="termref" href="#dt-character-map">character
maps</a> within a package have local scope within that package —
they are all effectively private. The elements that declare these
constructs do not have a <code>visibility</code> attribute. The
unnamed decimal format and the unnamed output format are also local
to a package.</p>
<p>If <a href=
"#element-strip-space"><code>xsl:strip-space</code></a> or <a href=
"#element-preserve-space"><code>xsl:preserve-space</code></a>
declarations appear within a <a title="library package" class=
"termref" href="#dt-library-package">library package</a>, they only
affect calls to the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>
or <a href="#func-document"><code>document</code></a> functions
appearing within that package. <span>Such a declaration within the
<a title="top-level package" class="termref" href=
"#dt-top-level-package">top-level package</a> additionally affects
stripping of whitespace in the document that contains the <a title=
"global context item" class="termref" href=
"#dt-global-context-item">global context item</a></span>.</p>
<p>An <a href=
"#element-decimal-format"><code>xsl:decimal-format</code></a>
declaration within a package applies only to calls on <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-number"><code>
format-number</code></a><sup><small>FO30</small></sup> appearing
within that package.</p>
<p>An <a href=
"#element-namespace-alias"><code>xsl:namespace-alias</code></a>
declaration within a package applies only to literal result
elements within the same package.</p>
<p>An <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>
declaration within a package adds the names of the imported schema
components to the static context for that package only; these names
are effectively private, in the sense that they do not become
available for use in any other packages. However, the names of
schema components must be consistent across the stylesheet as a
whole: it is not possible for two different packages within a
stylesheet to use a type-name such as "part-number" to refer to
different schema-defined simple or complex types.</p>
<p>Type names used in the interface of public components in a
package (for example, in the arguments of a function) must be
respected by callers of those components, in the sense that the
caller must supply values of the correct type. Often this will mean
that the using component, if it contains calls on such interfaces,
must itself import the necessary schema components. However, the
requirement for an explicit schema import applies only where the
package contains explicit use of the names of schema components
required to call such interfaces.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>For example, suppose a <a title="library package" class=
"termref" href="#dt-library-package">library package</a> contains a
function which requires an argument of type
<code>mfg:part-number</code>. The caller of this function must
supply an argument of the correct type, but does not need to import
the schema unless it explicitly uses the schema type name
<code>mfg:part-number</code>. If it obtains an instance of this
type from outside the package, for example as the result of another
function call, then it can supply this instance to the acquired
function even though it has not imported a schema that defines this
type.</p>
</div>
<p>At execution time, the schema available for validating instance
documents contains (at least) the union of the schema components
imported into all constituent packages of the stylesheet.</p>
</div>
<div class="div3">
<h4><a name="declaring-global-context-item" id=
"declaring-global-context-item"></a>3.6.6 <a href=
"#declaring-global-context-item" style=
"text-decoration: none">Declaring the Global Context Item</a></h4>
<p>The <a href=
"#element-global-context-item"><code>xsl:global-context-item</code></a>
element is used to declare whether a <a title="global context item"
class="termref" href="#dt-global-context-item">global context
item</a> is required, and if so, what its <a title="required type"
class="termref" href="#dt-required-type">required type</a> is.</p>
<p>The element appears as a child of <a href=
"#element-package"><code>xsl:package</code></a> and can only appear
once for a package. If there is no <a href=
"#element-global-context-item"><code>xsl:global-context-item</code></a>
declaration for a package (which will always be the case for an
implicit package), this is equivalent to specifying the empty
element <code>&lt;xsl:global-context-item/&gt;</code>, which
imposes no constraints.</p>
<p class="element-syntax"><a name="element-global-context-item" id=
"element-global-context-item"></a><code>&lt;xsl:global-context-item<br />

&#160;&#160;as? = <var>sequence-type</var><br />
&#160;&#160;use? = "required" | "optional" | "prohibited"<br />
&#160;&#160;streamable? = <var>boolean</var>&#160;/&gt;</code></p>
<p>The <code>use</code> attribute takes the value
<code>required</code>, <code>optional</code>, or
<code>prohibited</code>. The default is <code>optional</code>. If
the value <code>required</code> is specified, then there must be a
global context item. If the value <code>optional</code> is
specified, or if the attribute is omitted, or if the <a href=
"#element-global-context-item"><code>xsl:global-context-item</code></a>
element is omitted, then there may or may not be a global context
item. If the value <code>prohibited</code> is specified, then the
global context item must be <a title="absent" class="termref" href=
"#dt-absent">absent</a>.</p>
<p>If the <code>as</code> attribute is present then its value must
be an <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-ItemType">ItemType</a><sup><small>XP30</small></sup>.
If the attribute is omitted this is equivalent to specifying
<code>as="item()"</code>.</p>
<p>The <code>as</code> attribute defines the required type of the
global context item. The default value is <code>as="item()"</code>.
If a global context item is supplied then it must conform to the
required type, after conversion (if necessary) using the <a title=
"function conversion rules" class="termref" href=
"#dt-function-conversion-rules">function conversion rules</a>.</p>
<p>If the <code>streamable</code> attribute is present with the
value <code>yes</code>, then the <code>select</code> expression or
contained sequence constructor of every global <a href=
"#element-variable"><code>xsl:variable</code></a> and <a href=
"#element-param"><code>xsl:param</code></a> declaration in the
containing package <span class="verb">must</span> be <a title=
"grounded" class="termref" href="#dt-grounded">grounded</a> and
<a title="motionless" class="termref" href=
"#dt-motionless">motionless</a>, when assessed with a <a title=
"context posture" class="termref" href=
"#dt-context-posture">context posture</a> of <a title="striding"
class="termref" href="#dt-striding">striding</a>, and a <a title=
"context item type" class="termref" href=
"#dt-context-item-type">context item type</a> based on the declared
type of the global context item. The consequences of violating this
rule depend on the conformance level of the processor, as described
in <a href="#streamability-guarantees"><i>19.10 Streamability
Guarantees</i></a>.</p>
<p>If the <code>streamable</code> attribute is absent or has the
value <code>no</code>, or if there is no <a href=
"#element-global-context-item"><code>xsl:global-context-item</code></a>
declaration, then when the transformation is primed, the item
supplied as the global context item cannot be a node in a streamed
document (the transformation API may handle this either by
disallowing such an input, or by building the corresponding tree in
memory and supplying the global context item as an unstreamed
node.)</p>
<p>The global context item is available only within the <a title=
"top-level package" class="termref" href=
"#dt-top-level-package">top-level package</a>. If an <a href=
"#element-global-context-item"><code>xsl:global-context-item</code></a>
declaration appears within a <a title="library package" class=
"termref" href="#dt-library-package">library package</a>, then it
is ignored, unless it specifies <code>use="required"</code>, in
which case an error is signaled: <span class="error">[see <a href=
"#err-XTTE0590">ERR XTTE0590</a>]</span>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Use of a global context item is not encouraged, especially in a
complex stylesheet made up of several packages. There is only one
global context item shared between all packages, which does not
work well when multiple packages are developed independently. Named
stylesheet parameters, perhaps in distinct namespaces, are more
flexible.</p>
</div>
<p>A <a title="type error" class="termref" href=
"#dt-type-error">type error</a> is signaled if there is a <a title=
"package" class="termref" href="#dt-package">package</a> with an
<a href=
"#element-global-context-item"><code>xsl:global-context-item</code></a>
declaration specifying a required type that does not match the
supplied <a title="global context item" class="termref" href=
"#dt-global-context-item">global context item</a>. The error code
is the same as for <a href=
"#element-param"><code>xsl:param</code></a>: <span class=
"error">[see <a href="#err-XTTE0590">ERR XTTE0590</a>]</span>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>If the <code>ItemType</code> is one that can only be satisfied
by a schema-validated input document, for example
<code>as="schema-element(invoice)"</code>, the <a title="processor"
class="termref" href="#dt-processor">processor</a> may interpret
this as a request to apply schema validation to the input.
Similarly, if the <code>KindTest</code> indicates that an element
node is required, the processor may interpret this as a request to
supply the document element rather than the document node of a
supplied input document.</p>
</div>
</div>
<div class="div3">
<h4><a name="xquery-packages" id="xquery-packages"></a>3.6.7
<a href="#xquery-packages" style="text-decoration: none">Using an
XQuery Library Package</a></h4>
<p><em>The capability described in this section is an optional
feature that processors are not <span class="verb">required</span>
to provide.</em></p>
<p>A processor <span class="verb">may</span> recognize the URI
supplied in the <code>name</code> attribute of an <a href=
"#element-use-package"><code>xsl:use-package</code></a> element as
the module URI of an XQuery library module.</p>
<p>In this case all public functions and global variables declared
in the XQuery library module become available for use in the using
package as if they were declared as public functions or global
variables in an XSLT 3.0 package. XQuery external variables are
treated as if they were XSLT stylesheet parameters.</p>
<p>There are some minor differences in semantics between XSLT and
XQuery, for example XSLT uses the function conversion rules when
initializing a global variable (in XSLT, a node will be atomized if
the required type is atomic) whereas XQuery requires the computed
value to match the declared type precisely. The way in which such
differences are handled is <a title="implementation-defined" class=
"termref" href=
"#dt-implementation-defined">implementation-defined</a>; a
conformant implementation may use either the XQuery semantics or
the XSLT semantics.</p>
<p>It is <a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> whether an
XQuery expression that is evaluated in the course of a
transformation is evaluated within the same <a href=
"http://www.w3.org/TR/xpath-functions-30/#execution-scope">execution
scope</a><sup><small>FO30</small></sup> as the calling XSLT code.
(It if is, then, for example, calls to
<code>current-dateTime</code> will deliver the same result whether
called from the XSLT code or the XQuery code.)</p>
<p>It is <a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> whether
node identity is preserved when calling XQuery code from XSLT
code.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Where the XSLT implementation invokes an XQuery processor
developed by a third party, it may be necessary to convert nodes to
a different internal representation as part of the calling
mechanism, and it may be difficult to do this conversion in a way
that retains node identity. It is required, however, that nodes
passed to the XQuery processor, or returned in the result, retain
all their relationships to other nodes in the same tree.
Furthermore, this specification provides no license to drop type
annotations.</p>
</div>
<p>As when using multiple XSLT packages, it is required that any
schema imported by the XQuery library module must be consistent
with the schema imported by the using package, and that any
<a title="type annotation" class="termref" href=
"#dt-type-annotation">type annotation</a> on a node passed from one
package to another must refer unambiguously to the same type.</p>
<p>The effect of using an XQuery library module in which there are
functions that are updating or nondeterministic is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
<p>Processors <span class="verb">may</span> impose additional
restrictions on the use of XQuery library modules; for example they
may treat variables and functions declared in the library module as
<code>final</code>, or they may require that the module uses a
particular version of XQuery.</p>
</div>
</div>
<div class="div2">
<h3><a name="stylesheet-modules" id="stylesheet-modules"></a>3.7
<a href="#stylesheet-modules" style=
"text-decoration: none">Stylesheet Modules</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-stylesheet-module" id="dt-stylesheet-module" title=
"stylesheet module"></a>A <span><a title="package" class="termref"
href="#dt-package">package</a></span> consists of one or more
<b>stylesheet modules</b>, each one forming all or part of an XML
document.<span class="definition">]</span></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>A stylesheet module is represented by an XDM element node (see
<a href="#xpath-datamodel-30">[Data Model]</a>). In the case of a
standard stylesheet module, this will be an <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href=
"#element-transform"><code>xsl:transform</code></a> element. In the
case of a simplified stylesheet module, it can be any element (not
in the <a title="XSLT namespace" class="termref" href=
"#dt-xslt-namespace">XSLT namespace</a>) that has an
<code>xsl:version</code> attribute.</p>
<p>Although stylesheet modules will commonly be maintained in the
form of documents conforming to XML 1.0 or XML 1.1, this
specification does not mandate such a representation. As with
<a title="source tree" class="termref" href=
"#dt-source-tree">source trees</a>, the way in which stylesheet
modules are constructed, from textual XML or otherwise, is outside
the scope of this specification.</p>
</div>
<p>The principal stylesheet module of a package may take one of
three forms:</p>
<ul>
<li>
<p>A package manifest, as described in <a href="#packages"><i>3.6
Packages</i></a>, which is a subtree rooted at an <a href=
"#element-package"><code>xsl:package</code></a> element</p>
</li>
<li>
<p>An implicit package, which is a subtree rooted at an <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href=
"#element-transform"><code>xsl:transform</code></a> element. This
is transformed automatically to a package as described in <a href=
"#packages"><i>3.6 Packages</i></a>.</p>
</li>
<li>
<p>A simplified stylesheet, which is a subtree rooted at a literal
result element, as described in <a href=
"#simplified-stylesheet"><i>3.9 Simplified Stylesheet
Modules</i></a>. This is first converted to an implicit package by
wrapping it in an <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> element using
the transformation described in <a href=
"#simplified-stylesheet"><i>3.9 Simplified Stylesheet
Modules</i></a>, and then to an explicit package (rooted at an
<a href="#element-package"><code>xsl:package</code></a> element)
using the transformation described in <a href="#packages"><i>3.6
Packages</i></a>.</p>
</li>
</ul>
<p>A stylesheet module other than the principal stylesheet module
of a package may take either of two forms:</p>
<ul>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-standard-stylesheet-module" id="dt-standard-stylesheet-module"
title="standard stylesheet module"></a>A <b>standard stylesheet
module</b>, which is a subtree rooted at an <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href=
"#element-transform"><code>xsl:transform</code></a>
element.<span class="definition">]</span></p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-simplified-stylesheet-module" id=
"dt-simplified-stylesheet-module" title=
"simplified stylesheet"></a>A <b>simplified stylesheet</b>, which
is a subtree rooted at a <a title="literal result element" class=
"termref" href="#dt-literal-result-element">literal result
element</a>, as described in <a href=
"#simplified-stylesheet"><i>3.9 Simplified Stylesheet
Modules</i></a>. This is first converted to a <a title=
"standard stylesheet module" class="termref" href=
"#dt-standard-stylesheet-module">standard stylesheet module</a> by
wrapping it in an xsl:stylesheet element using the transformation
described in <a href="#simplified-stylesheet"><i>3.9 Simplified
Stylesheet Modules</i></a>.<span class="definition">]</span></p>
</li>
</ul>
<p>Whichever of the above forms a module takes, the outermost
element (<a href="#element-package"><code>xsl:package</code></a>,
<a href="#element-stylesheet"><code>xsl:stylesheet</code></a>, or a
<a title="literal result element" class="termref" href=
"#dt-literal-result-element">literal result element</a>)
<span class="verb">may</span> either be the outermost element of an
XML document, or it <span class="verb">may</span> be a child of
some (non-XSLT) element in a host document.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-embedded-stylesheet-module" id="dt-embedded-stylesheet-module"
title="embedded stylesheet module"></a>A stylesheet module whose
outermost element is the child of a non-XSLT element in a host
document is referred to as an <b>embedded stylesheet module</b>.
See <a href="#embedded"><i>3.13 Embedded Stylesheet
Modules</i></a>.<span class="definition">]</span></p>
</div>
<div class="div2">
<h3><a name="stylesheet-element" id="stylesheet-element"></a>3.8
<a href="#stylesheet-element" style=
"text-decoration: none">Stylesheet Element</a></h3>
<p class="element-syntax"><a name="element-stylesheet" id=
"element-stylesheet"></a><code>&lt;xsl:stylesheet<br />
&#160;&#160;id? = <var>id</var><br />
&#160;&#160;<b>version</b> = <var>decimal</var><br />
&#160;&#160;default-mode? = <var>eqname</var> | "#unnamed"<br />
&#160;&#160;default-validation? = "preserve" | "strip"<br />
&#160;&#160;input-type-annotations? = "preserve" | "strip" |
"unspecified"<br />
&#160;&#160;default-collation? = <var>uris</var><br />
&#160;&#160;extension-element-prefixes? = <var>prefixes</var><br />
&#160;&#160;exclude-result-prefixes? = <var>prefixes</var><br />
&#160;&#160;expand-text? = <var>boolean</var><br />
&#160;&#160;use-when? = <var>expression</var><br />
&#160;&#160;xpath-default-namespace? =
<var>uri</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<var>declarations</var>) --&gt;<br />
&lt;/xsl:stylesheet&gt;</code></p>
<p class="element-syntax"><a name="element-transform" id=
"element-transform"></a><code>&lt;xsl:transform<br />
&#160;&#160;id? = <var>id</var><br />
&#160;&#160;<b>version</b> = <var>decimal</var><br />
&#160;&#160;default-mode? = <var>eqname</var> | "#unnamed"<br />
&#160;&#160;default-validation? = "preserve" | "strip"<br />
&#160;&#160;input-type-annotations? = "preserve" | "strip" |
"unspecified"<br />
&#160;&#160;default-collation? = <var>uris</var><br />
&#160;&#160;extension-element-prefixes? = <var>prefixes</var><br />
&#160;&#160;exclude-result-prefixes? = <var>prefixes</var><br />
&#160;&#160;expand-text? = <var>boolean</var><br />
&#160;&#160;use-when? = <var>expression</var><br />
&#160;&#160;xpath-default-namespace? =
<var>uri</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<var>declarations</var>) --&gt;<br />
&lt;/xsl:transform&gt;</code></p>
<p>A stylesheet module is represented by an <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> element in an
XML document. <a href=
"#element-transform"><code>xsl:transform</code></a> is allowed as a
synonym for <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a>; everything
this specification says about the <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> element
applies equally to <a href=
"#element-transform"><code>xsl:transform</code></a>.</p>
<p>The <code>version</code> attribute indicates the version of XSLT
that the stylesheet module requires. The attribute is <span class=
"verb">required</span>.</p>
<p><a name="err-XTSE0110" id="err-XTSE0110"><span class=
"error">[ERR XTSE0110]</span></a> The value of the
<code>version</code> attribute <span class="verb">must</span> be a
number: specifically, it <span class="verb">must</span> be a valid
instance of the type <code>xs:decimal</code> as defined in <a href=
"#xmlschema-2">[XML Schema Part 2]</a>.</p>
<p>The <code>version</code> attribute is intended to indicate the
version of the XSLT specification against which the stylesheet is
written. In a stylesheet written to use XSLT 3.0, the value
<span class="verb">should</span> normally be set to
<code>3.0</code>. If the value is numerically less than
<code>3.0</code>, the stylesheet is processed using the rules for
<a title="backwards compatible behavior" class="termref" href=
"#dt-backwards-compatible-behavior">backwards compatible
behavior</a> (see <a href="#backwards"><i>3.10 Backwards Compatible
Processing</i></a>). If the value is numerically greater than
<code>3.0</code>, the stylesheet is processed using the rules for
<a title="forwards compatible behavior" class="termref" href=
"#dt-forwards-compatible-behavior">forwards compatible behavior</a>
(see <a href="#forwards"><i>3.11 Forwards Compatible
Processing</i></a>).</p>
<p>The effect of the <code>input-type-annotations</code> attribute
is described in <a href="#stripping-annotations"><i>4.3 Stripping
Type Annotations from a Source Tree</i></a>.</p>
<p>The <code>[xsl:]default-validation</code> attribute defines the
default value of the <code>validation</code> attribute of all
relevant instructions appearing within its scope. For details of
the effect of this attribute, see <a href="#validation"><i>24.4
Validation</i></a>.</p>
<p><a name="err-XTSE0120" id="err-XTSE0120"><span class=
"error">[ERR XTSE0120]</span></a> An <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> element
<span class="verb">must not</span> have any text node children.
(This rule applies after stripping of <a title=
"whitespace text node" class="termref" href=
"#dt-whitespace-text-node">whitespace text nodes</a> as described
in <a href="#stylesheet-stripping"><i>4.2 Stripping Whitespace from
the Stylesheet</i></a>.)</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-top-level" id="dt-top-level" title="top-level"></a>An element
occurring as a child of an <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a><span>,
<a href="#element-transform"><code>xsl:transform</code></a>, or
<a href="#element-override"><code>xsl:override</code></a></span>
element is called a <b>top-level</b> element.<span class=
"definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-declaration" id="dt-declaration" title=
"declaration"></a>Top-level elements fall into two categories:
declarations, and user-defined data elements. Top-level elements
whose names are in the <a title="XSLT namespace" class="termref"
href="#dt-xslt-namespace">XSLT namespace</a> are
<b>declarations</b>. Top-level elements in any other namespace are
<a title="user-defined data element" class="termref" href=
"#dt-data-element">user-defined data elements</a> (see <a href=
"#user-defined-top-level"><i>3.8.3 User-defined Data
Elements</i></a>)<span class="definition">]</span>.</p>
<p>The <a title="declaration" class="termref" href=
"#dt-declaration">declaration</a> elements permitted in the
<a href="#element-stylesheet"><code>xsl:stylesheet</code></a>
element are:</p>
<blockquote>
<p><br />
<a href="#element-import"><code>xsl:import</code></a><br />
<a href="#element-include"><code>xsl:include</code></a><br />
<a href=
"#element-accumulator"><code>xsl:accumulator</code></a><br />
<a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a><br />
<a href=
"#element-character-map"><code>xsl:character-map</code></a><br />
<a href=
"#element-decimal-format"><code>xsl:decimal-format</code></a><br />
<a href="#element-function"><code>xsl:function</code></a><br />
<a href=
"#element-import-schema"><code>xsl:import-schema</code></a><br />
<a href="#element-key"><code>xsl:key</code></a><br />
<span><a href=
"#element-mode"><code>xsl:mode</code></a></span><br />
<a href=
"#element-namespace-alias"><code>xsl:namespace-alias</code></a><br />

<a href="#element-output"><code>xsl:output</code></a><br />
<a href="#element-param"><code>xsl:param</code></a><br />
<a href=
"#element-preserve-space"><code>xsl:preserve-space</code></a><br />
<a href=
"#element-strip-space"><code>xsl:strip-space</code></a><br />
<a href="#element-template"><code>xsl:template</code></a><br />
<a href="#element-variable"><code>xsl:variable</code></a></p>
</blockquote>
<p>Note that the <a href=
"#element-variable"><code>xsl:variable</code></a> and <a href=
"#element-param"><code>xsl:param</code></a> elements can act either
as <a title="declaration" class="termref" href=
"#dt-declaration">declarations</a> or as <a title="instruction"
class="termref" href="#dt-instruction">instructions</a>. A global
variable or parameter is defined using a declaration; a local
variable or parameter using an instruction.</p>
<p>The child elements of the <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> element may
appear in any order. In most cases, the ordering of these elements
does not affect the results of the transformation; however:</p>
<ul>
<li>
<p>As described in <a href="#conflict"><i>6.4 Conflict Resolution
for Template Rules</i></a>, when two template rules with the same
<a title="priority" class="termref" href=
"#dt-priority">priority</a> match the same nodes, there are
situations where the order of the template rules will affect which
is chosen.</p>
</li>
<li>
<p>Forwards references to <a title="static variable" class=
"termref" href="#dt-static-variable">static variables</a> are not
allowed in <a title="static expression" class="termref" href=
"#dt-static-expression">static expressions</a>.</p>
</li>
</ul>
<div class="div3">
<h4><a name="default-collation-attribute" id=
"default-collation-attribute"></a>3.8.1 <a href=
"#default-collation-attribute" style=
"text-decoration: none">The</a> <code>default-collation</code>
<a href="#default-collation-attribute" style=
"text-decoration: none">Attribute</a></h4>
<p>The <code>default-collation</code> attribute is a <a title=
"standard attributes" class="termref" href=
"#dt-standard-attributes">standard attribute</a> that may appear on
any element in the XSLT namespace, or (as
<code>xsl:default-collation</code>) on a <a title=
"literal result element" class="termref" href=
"#dt-literal-result-element">literal result element</a>.</p>
<p>The attribute, <span>when it appears on an element <var>E</var>,
is used to specify the default collation used by all XPath
expressions appearing in attributes or <a title=
"text value template" class="termref" href=
"#dt-text-value-template">text value templates</a> that have
<var>E</var> as an ancestor</span>, unless overridden by another
<code>default-collation</code> attribute on an inner element. It
also determines the collation used by certain XSLT constructs (such
as <a href="#element-key"><code>xsl:key</code></a> and <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>)
within its scope.</p>
<p>The value of the attribute is a whitespace-separated list of
collation URIs. If any of these URIs is a relative URI
<span>reference</span>, then it is resolved relative to the base
URI of the attribute's parent element. If the implementation
recognizes one or more of the resulting absolute collation URIs,
then it uses the first one that it recognizes as the default
collation.</p>
<p><a name="err-XTSE0125" id="err-XTSE0125"><span class=
"error">[ERR XTSE0125]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
value of an <code>[xsl:]default-collation</code> attribute, after
resolving against the base URI, contains no URI that the
implementation recognizes as a collation URI.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The reason the attribute allows a list of collation URIs is that
collation URIs will often be meaningful only to one particular XSLT
implementation. Stylesheets designed to run with several different
implementations can therefore specify several different collation
URIs, one for use with each. To avoid the above error condition, it
is possible to include as the last collation URI in the list either
the Unicode Codepoint Collation <span>or a collation in the UCA
family (see <a href="#uca-collations"><i>13.4 The Unicode Collation
Algorithm</i></a>) with the parameter
<code>fallback=yes</code></span>.</p>
</div>
<p>The <code>[xsl:]default-collation</code> attribute does not
affect the collation used by <code>xsl:sort</code>.</p>
<p>In the absence of an <code>[xsl:]default-collation</code>
attribute, the default collation <span class="verb">may</span> be
set by the calling application in an <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> way. The
recommended default, unless the user chooses otherwise, is to use
the Unicode codepoint collation.</p>
</div>
<div class="div3">
<h4><a name="default-mode" id="default-mode"></a>3.8.2 <a href=
"#default-mode" style="text-decoration: none">The</a>
<code>[xsl:]default-mode</code> <a href="#default-mode" style=
"text-decoration: none">Attribute</a></h4>
<p>The <code>default-mode</code> attribute defines the default
value for the <a title="mode" class="termref" href=
"#dt-mode">mode</a> attribute of all <a href=
"#element-template"><code>xsl:template</code></a> and <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
elements <span>within its scope</span>. <span>When the
<code>mode</code> attribute of these elements is omitted, or when
it contains the value <code>#default</code>, then the mode is taken
from the <code>[xsl:]default-mode</code> attribute of the innermost
ancestor element that has such an attribute. If there is no such
element, then the default is the <a title="unnamed mode" class=
"termref" href="#dt-unnamed-mode">unnamed mode</a>. This is
equivalent to specifying <code>#unnamed</code>.</span></p>
<p>The value <span class="verb">must</span> either be <span>an
<a title="EQName" class="termref" href=
"#dt-eqname">EQName</a></span>, or the token <code>#unnamed</code>
which refers to the <a title="unnamed mode" class="termref" href=
"#dt-unnamed-mode">unnamed mode</a>. It is not necessary for the
referenced mode to be explicitly declared in an <a href=
"#element-mode"><code>xsl:mode</code></a> declaration.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This attribute is provided to support an approach to stylesheet
modularity in which all the template rules for one <a title="mode"
class="termref" href="#dt-mode">mode</a> are collected together
into a single <a title="stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet module</a>. Using this attribute
reduces the risk of forgetting to specify the mode in one or more
places where it is needed, and it also makes it easier to reuse an
existing stylesheet module that does not use modes in an
application where modes are needed to avoid conflicts with existing
template rules.</p>
</div>
</div>
<div class="div3">
<h4><a name="user-defined-top-level" id=
"user-defined-top-level"></a>3.8.3 <a href=
"#user-defined-top-level" style=
"text-decoration: none">User-defined Data Elements</a></h4>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-data-element" id="dt-data-element" title=
"user-defined data element"></a>In addition to <a title=
"declaration" class="termref" href=
"#dt-declaration">declarations</a>, the <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> element may
contain among its children any element not from the <a title=
"XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT
namespace</a>, provided that the <a title="expanded QName" class=
"termref" href="#dt-expanded-qname">expanded QName</a> of the
element has a non-null namespace URI. Such elements are referred to
as <b>user-defined data elements</b>.<span class=
"definition">]</span></p>
<p><a name="err-XTSE0130" id="err-XTSE0130"><span class=
"error">[ERR XTSE0130]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
<a href="#element-stylesheet"><code>xsl:stylesheet</code></a>
element has a child element whose name has a null namespace
URI.</p>
<p>An implementation <span class="verb">may</span> attach an
<a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> meaning to
user-defined data elements that appear in particular namespaces.
The set of namespaces that are recognized for such data elements is
<a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. The
presence of a user-defined data element <span class="verb">must
not</span> change the behavior of <a title="XSLT element" class=
"termref" href="#dt-xslt-element">XSLT elements</a> and functions
defined in this document; for example, it is not permitted for a
user-defined data element to specify that <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
should use different rules to resolve conflicts. The constraints on
what user-defined data elements can and cannot do are exactly the
same as the constraints on <a title="extension attribute" class=
"termref" href="#dt-extension-attribute">extension attributes</a>,
described in <a href="#extension-attributes"><i>3.3 Extension
Attributes</i></a>. Thus, an implementation is always free to
ignore user-defined data elements, and <span class=
"verb">must</span> ignore such data elements without giving an
error if it does not recognize the namespace URI.</p>
<p>User-defined data elements can provide, for example,</p>
<ul>
<li>
<p>information used by <a title="extension instruction" class=
"termref" href="#dt-extension-instruction">extension
instructions</a> or <a title="extension function" class="termref"
href="#dt-extension-function">extension functions</a> (see <a href=
"#extension"><i>23 Extensibility and Fallback</i></a>),</p>
</li>
<li>
<p>information about what to do with any <a title=
"final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a>,</p>
</li>
<li>
<p>information about how to construct <a title="source tree" class=
"termref" href="#dt-source-tree">source trees</a>,</p>
</li>
<li>
<p>optimization hints for the <a title="processor" class="termref"
href="#dt-processor">processor</a>,</p>
</li>
<li>
<p>metadata about the stylesheet,</p>
</li>
<li>
<p>structured documentation for the stylesheet.</p>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a name="simplified-stylesheet" id=
"simplified-stylesheet"></a>3.9 <a href="#simplified-stylesheet"
style="text-decoration: none">Simplified Stylesheet
Modules</a></h3>
<p>A simplified syntax is allowed for a <a title=
"stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet module</a> that defines only a
single template rule for the document node. The stylesheet module
may consist of just a <a title="literal result element" class=
"termref" href="#dt-literal-result-element">literal result
element</a> (see <a href="#literal-result-element"><i>11.1 Literal
Result Elements</i></a>) together with its contents. The literal
result element must have an <code>xsl:version</code> attribute (and
it must therefore also declare the XSLT namespace). Such a
stylesheet module is equivalent to a standard stylesheet module
whose <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>
element contains a <a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a> containing the literal result
element, minus its <code>xsl:version</code> attribute; the template
rule has a match <a title="pattern" class="termref" href=
"#dt-pattern">pattern</a> of <code>/</code>.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e9230" id=
"d7e9230"></a>Example: A Simplified Stylesheet</div>
<p>For example:</p>
<div class="exampleInner">
<pre>
&lt;html xsl:version="3.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
      xmlns="http://www.w3.org/1999/xhtml"&gt;
  &lt;head&gt;
    &lt;title&gt;Expense Report Summary&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Total Amount: &lt;xsl:value-of select="expense-report/total"/&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre></div>
<p>has the same meaning as</p>
<div class="exampleInner">
<pre>
&lt;xsl:stylesheet version="3.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns="http://www.w3.org/1999/xhtml"&gt;
&lt;xsl:template match="/"&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Expense Report Summary&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Total Amount: &lt;xsl:value-of select="expense-report/total"/&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</pre></div>
<p>Note that it is not possible, using a simplified stylesheet, to
request that the serialized output contains a <code>DOCTYPE</code>
declaration. This can only be done by using a standard stylesheet
module, and using the <a href=
"#element-output"><code>xsl:output</code></a> element.</p>
</div>
<p>More formally, a simplified stylesheet module is equivalent to
the standard stylesheet module that would be generated by applying
the following transformation to the simplified stylesheet module,
invoking the transformation by calling the <a title=
"named template" class="termref" href="#dt-named-template">named
template</a> <code>expand</code>, with the containing literal
result element as the <a title="context node" class="termref" href=
"#dt-context-node">context node</a>:</p>
<div class="exampleInner">
<pre>
&lt;xsl:stylesheet version="3.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:template name="expand"&gt;
  &lt;xsl:element name="xsl:stylesheet"&gt;
    &lt;xsl:attribute name="version" select="@xsl:version"/&gt;
    &lt;xsl:element name="xsl:template"&gt;
      &lt;xsl:attribute name="match" select="'/'"/&gt;
      &lt;xsl:copy-of select="."/&gt;
    &lt;/xsl:element&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;  

&lt;/xsl:stylesheet&gt;
</pre></div>
<p><a name="err-XTSE0150" id="err-XTSE0150"><span class=
"error">[ERR XTSE0150]</span></a> A <a title=
"literal result element" class="termref" href=
"#dt-literal-result-element">literal result element</a> that is
used as the outermost element of a simplified stylesheet module
<span class="verb">must</span> have an <code>xsl:version</code>
attribute. This indicates the version of XSLT that the stylesheet
requires. For this version of XSLT, the value will normally be
<code><span>3.0</span></code> ; the value <span class=
"verb">must</span> be a valid instance of the type
<code>xs:decimal</code> as defined in <a href="#xmlschema-2">[XML
Schema Part 2]</a>.</p>
<p>The allowed content of a literal result element when used as a
simplified stylesheet is the same as when it occurs within a
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>. Thus, a
literal result element used as the document element of a simplified
stylesheet cannot contain <a title="declaration" class="termref"
href="#dt-declaration">declarations</a>. Simplified stylesheets
therefore cannot use <a title="template rule" class="termref" href=
"#dt-template-rule">template rules</a>, <a title="global variable"
class="termref" href="#dt-global-variable">global variables</a>,
<a title="stylesheet parameter" class="termref" href=
"#dt-stylesheet-parameter">stylesheet parameters</a>, <a title=
"stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet functions</a>, <a title="key"
class="termref" href="#dt-key">keys</a>, <a title="attribute set"
class="termref" href="#dt-attribute-set">attribute-sets</a>, or
<a title="output definition" class="termref" href=
"#dt-output-definition">output definitions</a>. In turn this means
that the only useful way to initiate the transformation is to
supply a document node as the <span><a title=
"initial match selection" class="termref" href=
"#dt-initial-match-selection">initial match selection</a></span>,
to be matched by the implicit <code>match="/"</code> template rule
using the <a title="unnamed mode" class="termref" href=
"#dt-unnamed-mode">unnamed mode</a>.</p>
</div>
<div class="div2">
<h3><a name="backwards" id="backwards"></a>3.10 <a href=
"#backwards" style="text-decoration: none">Backwards Compatible
Processing</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-effective-version" id="dt-effective-version" title=
"effective version"></a>The <b>effective version</b> of an element
in a <span><a title="stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet module</a> or <a title=
"package manifest" class="termref" href=
"#dt-package-manifest">package manifest</a></span> is the decimal
value of the <code>[xsl:]version</code> attribute (see <a href=
"#standard-attributes"><i>3.5 Standard Attributes</i></a>) on that
element or on the innermost ancestor element that has such an
attribute, excluding the <code>version</code> attribute on an
<a href="#element-output"><code>xsl:output</code></a>
element.<span class="definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-backwards-compatible-behavior" id=
"dt-backwards-compatible-behavior" title=
"backwards compatible behavior"></a>An element is processed with
<b>backwards compatible behavior</b> if its <a title=
"effective version" class="termref" href=
"#dt-effective-version">effective version</a> is less than
<code>3.0</code>.<span class="definition">]</span></p>
<p>Specifically:</p>
<ul>
<li>
<p>If the <a title="effective version" class="termref" href=
"#dt-effective-version">effective version</a> is equal to 1.0, then
the element is processed with XSLT 1.0 behavior as described in
<a href="#backwards-1.0"><i>3.10.1 XSLT 1.0 Compatibility
Mode</i></a>.</p>
</li>
<li>
<p>If the <a title="effective version" class="termref" href=
"#dt-effective-version">effective version</a> is equal to 2.0, then
the element is processed with XSLT 2.0 behavior as described in
<a href="#backwards-2.0"><i>3.10.2 XSLT 2.0 Compatibility
Mode</i></a>.</p>
</li>
<li>
<p>If the <a title="effective version" class="termref" href=
"#dt-effective-version">effective version</a> is any other value
less than 3.0, the <span class="verb">recommended</span> action is
to report a static error; however, processors <span class=
"verb">may</span> recognize such values and process the element in
an <a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> way.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>XSLT 1.0 allowed the <code>version</code> attribute to take any
decimal value, and invoked forwards compatible processing for any
value other than 1.0. XSLT 2.0 allowed the attribute to take any
decimal value, and invoked backwards compatible (i.e.
1.0-compatible) processing for any value less than 2.0. Some
stylesheets may therefore be encountered that use values other than
1.0 or 2.0. In particular, the value 1.1 is sometimes encountered,
as it was used at one stage in a draft language proposal.</p>
</div>
</li>
</ul>
<p>These rules do not apply to the <a href=
"#element-output"><code>xsl:output</code></a> element, whose
<code>version</code> attribute has an entirely different purpose:
it is used to define the version of the output method to be used
for serialization.</p>
<p>It is <a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> whether a
particular XSLT 3.0 implementation supports backwards compatible
behavior for any XSLT version earlier than XSLT 3.0.</p>
<p><a name="err-XTDE0160" id="err-XTDE0160"><span class=
"error">[ERR XTDE0160]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if an
element has an <a title="effective version" class="termref" href=
"#dt-effective-version">effective version</a> of <var>V</var> (with
<var>V</var> &lt; 3.0) when the implementation does not support
backwards compatible behavior for XSLT version <var>V</var>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>By making use of backwards compatible behavior, it is possible
to write the stylesheet in a way that ensures that its results when
processed with an XSLT 3.0 processor are identical to the effects
of processing the same stylesheet using <span>a processor for an
earlier version of XSLT</span>. To assist with transition, some
parts of a stylesheet may be processed with backwards compatible
behavior enabled, and other parts with this behavior disabled.</p>
<p>All data values manipulated by an <span>XSLT 3.0</span>
processor are defined by the XDM data model, whether or not the
relevant expressions use backwards compatible behavior. Because the
same data model is used in both cases, expressions are fully
composable. The result of evaluating instructions or expressions
with backwards compatible behavior is fully defined in the
<span>XSLT 3.0</span> and <span>XPath 3.0</span> specifications, it
is not defined by reference to <span>earlier versions of the XSLT
and XPath specifications</span>.</p>
<p>To write a stylesheet that makes use of <span>features that are
new in version <var>N</var>, while also working with a processor
that only supports XSLT version <var>M</var> (<var>M</var> &lt;
<var>N</var>)</span>, it is necessary to understand both the rules
for backwards compatible behavior in <span>XSLT version
<var>N</var></span>, and the rules for forwards compatible behavior
in <span>XSLT version <var>M</var></span>. If the <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> element
specifies <code>version="2.0"</code> <span>or
<code>version="3.0"</code></span>, then an XSLT 1.0 processor will
ignore XSLT 2.0 <span>and XSLT 3.0</span> <a title="declaration"
class="termref" href="#dt-declaration">declarations</a> that were
not defined in XSLT 1.0, for example <a href=
"#element-function"><code>xsl:function</code></a> and <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>. If any
new <span>XSLT 3.0</span> instructions are used (for example
<a href="#element-evaluate"><code>xsl:evaluate</code></a> or
<a href="#element-stream"><code>xsl:stream</code></a>), or if new
<span>XPath 3.0</span> features are used (for example, new
functions, or <span>let</span> expressions), then the stylesheet
must provide fallback behavior that relies only on facilities
<span>available in the earliest XSLT version supported</span>. The
fallback behavior can be invoked by using the <a href=
"#element-fallback"><code>xsl:fallback</code></a> instruction, or
by testing the results of the <a href=
"#func-function-available"><code>function-available</code></a> or
<a href=
"#func-element-available"><code>element-available</code></a>
functions, or by testing the value of the <code>xsl:version</code>
property returned by the <a href=
"#func-system-property"><code>system-property</code></a>
function.</p>
</div>
<div class="div3">
<h4><a name="backwards-1.0" id="backwards-1.0"></a>3.10.1 <a href=
"#backwards-1.0" style="text-decoration: none">XSLT 1.0
Compatibility Mode</a></h4>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-xslt-10-behavior" id="dt-xslt-10-behavior" title=
"XSLT 1.0 behavior"></a>An element in the stylesheet is processed
with <b>XSLT 1.0 behavior</b> if its <a title="effective version"
class="termref" href="#dt-effective-version">effective version</a>
is equal to 1.0.<span class="definition">]</span></p>
<p>In this mode, if any attribute contains an XPath <a title=
"expression" class="termref" href="#dt-expression">expression</a>,
then the expression is evaluated with <a title=
"XPath 1.0 compatibility mode" class="termref" href=
"#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> set to
<code>true</code>. For details of this mode, see <a href=
"http://www.w3.org/TR/xpath-30/#static_context">Section 2.1.1
Static Context</a> <sup><small>XP30</small></sup>.
<span>Expressions contained in <a title="text value template"
class="termref" href="#dt-text-value-template">text value
templates</a> are always evaluated with <a title=
"XPath 1.0 compatibility mode" class="termref" href=
"#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> set to
<code>false</code>, since this construct was not available in XSLT
1.0.</span></p>
<p>Furthermore, in such an expression any function call for which
no implementation is available (unless it uses the <a title=
"standard function namespace" class="termref" href=
"#dt-standard-function-namespace">standard function namespace</a>)
is bound to a fallback error function whose effect when evaluated
is to raise a dynamic error <span class="error">[see <a href=
"#err-XTDE1425">ERR XTDE1425</a>]</span> . The effect is that with
backwards compatible behavior enabled, calls on <a title=
"extension function" class="termref" href=
"#dt-extension-function">extension functions</a> that are not
available in a particular implementation do not cause an error
unless the function call is actually evaluated. For further
details, see <a href="#extension-functions"><i>23.1 Extension
Functions</i></a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This might appear to contradict the specification of XPath
<span>3.0</span>, which states that a static error [XPST0017] is
raised when an expression contains a call to a function that is not
present (with matching name and arity) in the static context. This
apparent contradiction is resolved by specifying that the XSLT
processor constructs a static context for the expression in which
every possible function name and arity (other than names in the
<a title="standard function namespace" class="termref" href=
"#dt-standard-function-namespace">standard function namespace</a>)
is present; when no other implementation of the function is
available, the function call is bound to a fallback error function
whose run-time effect is to raise a dynamic error.</p>
</div>
<p>Certain XSLT constructs also produce different results when XSLT
1.0 compatibility mode is enabled. This is described separately for
each such construct.</p>
<p>Processing an <a title="instruction" class="termref" href=
"#dt-instruction">instruction</a> with XSLT 1.0 behavior is not
compatible with streaming. More specifically, and notwithstanding
anything stated in <a href="#streamability"><i>19
Streamability</i></a>, an instruction that is processed with XSLT
1.0 behavior is <a title="roaming" class="termref" href=
"#dt-roaming">roaming</a> and <a title="free-ranging" class=
"termref" href="#dt-free-ranging">free-ranging</a>, which has the
effect that any construct containing such an instruction is not
<a title="guaranteed-streamable" class="termref" href=
"#dt-guaranteed-streamable">guaranteed-streamable</a>.</p>
</div>
<div class="div3">
<h4><a name="backwards-2.0" id="backwards-2.0"></a>3.10.2 <a href=
"#backwards-2.0" style="text-decoration: none">XSLT 2.0
Compatibility Mode</a></h4>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-xslt-20-behavior" id="dt-xslt-20-behavior" title=
"XSLT 2.0 behavior"></a>An element is processed with <b>XSLT 2.0
behavior</b> if its <a title="effective version" class="termref"
href="#dt-effective-version">effective version</a> is equal to
2.0.<span class="definition">]</span></p>
<p>In this specification, no differences are defined for XSLT 2.0
behavior. An XSLT 3.0 processor will therefore produce the same
results whether the <a title="effective version" class="termref"
href="#dt-effective-version">effective version</a> of an element is
set to 2.0 or 3.0.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>An XSLT 2.0 processor, by contrast, will in some cases produce
different results in the two cases. For example, if the stylesheet
contains an <a href="#element-iterate"><code>xsl:iterate</code></a>
instruction with an <a href=
"#element-fallback"><code>xsl:fallback</code></a> child, an XSLT
3.0 processor will process the <a href=
"#element-iterate"><code>xsl:iterate</code></a> instruction
regardless whether the effective version is 2.0 or 3.0, while an
XSLT 2.0 processor will report a static error if the effective
version is 2.0, and will take the fallback action if the effective
version is 3.0.</p>
</div>
</div>
</div>
<div class="div2">
<h3><a name="forwards" id="forwards"></a>3.11 <a href="#forwards"
style="text-decoration: none">Forwards Compatible
Processing</a></h3>
<p>The intent of forwards compatible behavior is to make it
possible to write a stylesheet that takes advantage of features
introduced in some version of XSLT subsequent to <span>XSLT
3.0</span>, while retaining the ability to execute the stylesheet
with an <span>XSLT 3.0</span> processor using appropriate fallback
behavior.</p>
<p>It is always possible to write conditional code to run under
different XSLT versions by using the <code>use-when</code> feature
described in <a href="#conditional-inclusion"><i>3.14.1 Conditional
Element Inclusion</i></a>. The rules for forwards compatible
behavior supplement this mechanism in two ways:</p>
<ul>
<li>
<p>certain constructs in the stylesheet that mean nothing to an
<span>XSLT 3.0</span> processor are ignored, rather than being
treated as errors.</p>
</li>
<li>
<p>explicit fallback behavior can be defined for instructions
defined in a future XSLT release, using the <a href=
"#element-fallback"><code>xsl:fallback</code></a> instruction.</p>
</li>
</ul>
<p>The detailed rules follow.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-forwards-compatible-behavior" id=
"dt-forwards-compatible-behavior" title=
"forwards compatible behavior"></a>An element is processed with
<b>forwards compatible behavior</b> if its <a title=
"effective version" class="termref" href=
"#dt-effective-version">effective version</a> is greater than
<code>3.0</code>.<span class="definition">]</span></p>
<p>These rules do not apply to the <code>version</code> attribute
of the <a href="#element-output"><code>xsl:output</code></a>
element, which has an entirely different purpose: it is used to
define the version of the output method to be used for
serialization.</p>
<p>When an element is processed with forwards compatible
behavior:</p>
<ul>
<li>
<p>If the element is in the XSLT namespace and appears as a child
of the <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> element, and
XSLT <span>3.0</span> does not allow the element to appear as a
child of the <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> element, then
the element and its content <span class="verb">must</span> be
ignored.</p>
</li>
<li>
<p>If the element has an attribute that XSLT <span>3.0</span> does
not allow the element to have, then the attribute <span class=
"verb">must</span> be ignored.</p>
</li>
<li>
<p>If the element is in the XSLT namespace and appears as <span>a
child of an element whose content model requires a</span> <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>, and XSLT
<span>3.0</span> does not allow such elements to appear as part of
a sequence constructor, then:</p>
<ol class="enumar">
<li>
<p>If the element has one or more <a href=
"#element-fallback"><code>xsl:fallback</code></a> children, then no
error is reported either statically or dynamically, and the result
of evaluating the instruction is the concatenation of the sequences
formed by evaluating the sequence constructors within its <a href=
"#element-fallback"><code>xsl:fallback</code></a> children, in
document order. Siblings of the <a href=
"#element-fallback"><code>xsl:fallback</code></a> elements are
ignored, even if they are valid XSLT <span>3.0</span>
instructions.</p>
</li>
<li>
<p>If the element has no <a href=
"#element-fallback"><code>xsl:fallback</code></a> children, then a
static error is reported in the same way as if forwards compatible
behavior were not enabled.</p>
</li>
</ol>
</li>
</ul>
<div class="example">
<div class="exampleHeader"><a name="d7e9835" id=
"d7e9835"></a>Example: Forwards Compatible Behavior</div>
<p>For example, an XSLT <span>3.0</span> <a title="processor"
class="termref" href="#dt-processor">processor</a> will process the
following stylesheet without error, although the stylesheet
includes elements from the <a title="XSLT namespace" class=
"termref" href="#dt-xslt-namespace">XSLT namespace</a> that are not
defined in this specification:</p>
<div class="exampleInner">
<pre>
&lt;xsl:stylesheet version="17.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:template match="/"&gt;
    &lt;xsl:exciting-new-17.0-feature&gt;
      &lt;xsl:fly-to-the-moon/&gt;
      &lt;xsl:fallback&gt;
        &lt;html&gt;
          &lt;head&gt;
            &lt;title&gt;XSLT 17.0 required&lt;/title&gt;
          &lt;/head&gt;
          &lt;body&gt;
            &lt;p&gt;Sorry, this stylesheet requires XSLT 17.0.&lt;/p&gt;
          &lt;/body&gt;
        &lt;/html&gt;
      &lt;/xsl:fallback&gt;
    &lt;/xsl:exciting-new-17.0-feature&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</pre></div>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>If a stylesheet depends crucially on a <a title="declaration"
class="termref" href="#dt-declaration">declaration</a> introduced
by a version of XSLT after <span>3.0</span>, then the stylesheet
can use an <a href="#element-message"><code>xsl:message</code></a>
element with <code>terminate="yes"</code> (see <a href=
"#message"><i>22.1 Messages</i></a>) to ensure that implementations
that conform to an earlier version of XSLT will not silently ignore
the <a title="declaration" class="termref" href=
"#dt-declaration">declaration</a>.</p>
</div>
<div class="example">
<div class="exampleHeader"><a name="d7e9873" id=
"d7e9873"></a>Example: Testing the XSLT Version</div>
<p>For example,</p>
<div class="exampleInner">
<pre>
&lt;xsl:stylesheet version="18.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:important-new-17.0-declaration/&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="number(system-property('xsl:version')) lt 17.0"&gt;
        &lt;xsl:message terminate="yes"&gt;
          &lt;xsl:text&gt;Sorry, this stylesheet requires XSLT 17.0.&lt;/xsl:text&gt;
        &lt;/xsl:message&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        ...
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;
  ...
&lt;/xsl:stylesheet&gt;
</pre></div>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The XSLT 1.0 and XSLT 2.0 specifications did not anticipate the
introduction of the <a href=
"#element-package"><code>xsl:package</code></a> element. An XSLT
1.0 or 2.0 processor encountering this element will report a static
error, regardless of the <code>version</code> setting.</p>
<p>This problem can be circumvented by using the simplified package
syntax <span>(whereby an <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> element is
implicitly treated as <a href=
"#element-package"><code>xsl:package</code></a>)</span>, or by
writing the stylesheet code in a separate module from the package
manifest, and using the separate module as the version of the
stylesheet that is presented to a 2.0 processor.</p>
</div>
</div>
<div class="div2">
<h3><a name="combining-modules" id="combining-modules"></a>3.12
<a href="#combining-modules" style=
"text-decoration: none">Combining Stylesheet Modules</a></h3>
<p>XSLT provides two mechanisms to construct a <span><a title=
"package" class="termref" href="#dt-package">package</a></span>
from multiple <a title="stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet modules</a>:</p>
<ul>
<li>
<p>an inclusion mechanism that allows stylesheet modules to be
combined without changing the semantics of the modules being
combined, and</p>
</li>
<li>
<p>an import mechanism that allows stylesheet modules to override
each other.</p>
</li>
</ul>
<div class="div3">
<h4><a name="locating-modules" id="locating-modules"></a>3.12.1
<a href="#locating-modules" style="text-decoration: none">Locating
Stylesheet Modules</a></h4>
<p>The include and import mechanisms use two declarations, <a href=
"#element-include"><code>xsl:include</code></a> and <a href=
"#element-import"><code>xsl:import</code></a>, which are defined in
the sections that follow.</p>
<p>These declarations use an <code>href</code> attribute, whose
value is a <a title="URI Reference" class="termref" href=
"#dt-uri-reference">URI reference</a>, to identify the <a title=
"stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet module</a> to be included or
imported. If the value of this attribute is a relative URI
<span>reference</span>, it is resolved as described in <a href=
"#uri-references"><i>5.9 URI References</i></a>.</p>
<p>After resolving against the base URI, the way in which the URI
reference is used to locate a representation of a <a title=
"stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet module</a>, and the way in which
the stylesheet module is constructed from that representation, are
<a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. In
particular, it is implementation-defined which URI schemes are
supported, whether fragment identifiers are supported, and what
media types are supported. Conventionally, the URI is a reference
to a resource containing the stylesheet module as a source XML
document, or it may include a fragment identifier that selects an
embedded stylesheet module within a source XML document; but the
implementation is free to use other mechanisms to locate the
stylesheet module identified by the URI reference.</p>
<p>The referenced <a title="stylesheet module" class="termref"
href="#dt-stylesheet-module">stylesheet module</a> <span class=
"verb">must</span> be either a <a title=
"standard stylesheet module" class="termref" href=
"#dt-standard-stylesheet-module">standard stylesheet module</a> or
a <a title="simplified stylesheet" class="termref" href=
"#dt-simplified-stylesheet-module">simplified stylesheet</a>. It
<span class="verb">must not</span> be a <a title="package manifest"
class="termref" href="#dt-package-manifest">package manifest</a>.
If it is a simplified stylesheet module then it is transformed into
the equivalent standard stylesheet module by applying the
transformation described in <a href="#simplified-stylesheet"><i>3.9
Simplified Stylesheet Modules</i></a>.</p>
<p>Implementations <span class="verb">may</span> choose to accept
URI references containing a fragment identifier defined by
reference to the XPointer specification (see <a href=
"#xptr-framework">[XPointer Framework]</a>). Note that if the
implementation does not support the use of fragment identifiers in
the URI reference, then it will not be possible to include an
<a title="embedded stylesheet module" class="termref" href=
"#dt-embedded-stylesheet-module">embedded stylesheet
module</a>.</p>
<p><a name="err-XTSE0165" id="err-XTSE0165"><span class=
"error">[ERR XTSE0165]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
processor is not able to retrieve the resource identified by the
URI reference, or if the resource that is retrieved does not
contain a stylesheet module.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>It is appropriate to use this error code when the resource
cannot be retrieved, or when the retrieved resource is not well
formed XML. If the resource contains XML than can be parsed but
that violates the rules for stylesheet modules, then a more
specific error code may be more appropriate.</p>
</div>
</div>
<div class="div3">
<h4><a name="include" id="include"></a>3.12.2 <a href="#include"
style="text-decoration: none">Stylesheet Inclusion</a></h4>
<p class="element-syntax"><a name="element-include" id=
"element-include"></a><code>&lt;!-- Category: declaration
--&gt;<br />
&lt;xsl:include<br />
&#160;&#160;<b>href</b> = <var>uri</var>&#160;/&gt;</code></p>
<p>A stylesheet module may include another stylesheet module using
an <a href="#element-include"><code>xsl:include</code></a>
declaration.</p>
<p>The <a href="#element-include"><code>xsl:include</code></a>
declaration has a <span class="verb">required</span>
<code>href</code> attribute whose value is a URI reference
identifying the stylesheet module to be included. This attribute is
used as described in <a href="#locating-modules"><i>3.12.1 Locating
Stylesheet Modules</i></a>.</p>
<p><a name="err-XTSE0170" id="err-XTSE0170"><span class=
"error">[ERR XTSE0170]</span></a> An <a href=
"#element-include"><code>xsl:include</code></a> element
<span class="verb">must</span> be a <a title="top-level" class=
"termref" href="#dt-top-level">top-level</a> element.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-stylesheet-level" id="dt-stylesheet-level" title=
"stylesheet level"></a>A <b>stylesheet level</b> is a collection of
<a title="stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet modules</a> connected using
<a href="#element-include"><code>xsl:include</code></a>
declarations: specifically, two stylesheet modules <var>A</var> and
<var>B</var> are part of the same stylesheet level if one of them
includes the other by means of an <a href=
"#element-include"><code>xsl:include</code></a> declaration, or if
there is a third stylesheet module <var>C</var> that is in the same
stylesheet level as both <var>A</var> and <var>B</var>.<span class=
"definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-declaration-order" id="dt-declaration-order" title=
"declaration order"></a>The <a title="declaration" class="termref"
href="#dt-declaration">declarations</a> within a <a title=
"stylesheet level" class="termref" href=
"#dt-stylesheet-level">stylesheet level</a> have a total ordering
known as <b>declaration order</b>. The order of declarations within
a stylesheet level is the same as the document order that would
result if each stylesheet module were inserted textually in place
of the <a href="#element-include"><code>xsl:include</code></a>
element that references it.<span class="definition">]</span> In
other respects, however, the effect of <a href=
"#element-include"><code>xsl:include</code></a> is not equivalent
to the effect that would be obtained by textual inclusion.</p>
<p><a name="err-XTSE0180" id="err-XTSE0180"><span class=
"error">[ERR XTSE0180]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if a
stylesheet module directly or indirectly includes itself.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>It is not intrinsically an error for a <a title="stylesheet"
class="termref" href="#dt-stylesheet">stylesheet</a> to include the
same module more than once. However, doing so can cause errors
because of duplicate definitions. Such multiple inclusions are less
obvious when they are indirect. For example, if stylesheet
<var>B</var> includes stylesheet <var>A</var>, stylesheet
<var>C</var> includes stylesheet <var>A</var>, and stylesheet
<var>D</var> includes both stylesheet <var>B</var> and stylesheet
<var>C</var>, then <var>A</var> will be included indirectly by
<var>D</var> twice. If all of <var>B</var>, <var>C</var> and
<var>D</var> are used as independent stylesheets, then the error
can be avoided by separating everything in <var>B</var> other than
the inclusion of <var>A</var> into a separate stylesheet
<var>B'</var> and changing <var>B</var> to contain just inclusions
of <var>B'</var> and <var>A</var>, similarly for <var>C</var>, and
then changing <var>D</var> to include <var>A</var>, <var>B'</var>,
<var>C'</var>.</p>
</div>
</div>
<div class="div3">
<h4><a name="import" id="import"></a>3.12.3 <a href="#import"
style="text-decoration: none">Stylesheet Import</a></h4>
<p class="element-syntax"><a name="element-import" id=
"element-import"></a><code>&lt;!-- Category: declaration
--&gt;<br />
&lt;xsl:import<br />
&#160;&#160;<b>href</b> = <var>uri</var>&#160;/&gt;</code></p>
<p>A stylesheet module may import another <a title=
"stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet module</a> using an <a href=
"#element-import"><code>xsl:import</code></a> <a title=
"declaration" class="termref" href=
"#dt-declaration">declaration</a>. Importing a stylesheet module is
the same as including it (see <a href="#include"><i>3.12.2
Stylesheet Inclusion</i></a>) except that <a title="template rule"
class="termref" href="#dt-template-rule">template rules</a> and
other <a title="declaration" class="termref" href=
"#dt-declaration">declarations</a> in the importing module take
precedence over template rules and declarations in the imported
module; this is described in more detail below.</p>
<p>The <a href="#element-import"><code>xsl:import</code></a>
declaration has a <span class="verb">required</span>
<code>href</code> attribute whose value is a URI reference
identifying the stylesheet module to be included. This attribute is
used as described in <a href="#locating-modules"><i>3.12.1 Locating
Stylesheet Modules</i></a>.</p>
<p><a name="err-XTSE0190" id="err-XTSE0190"><span class=
"error">[ERR XTSE0190]</span></a> An <a href=
"#element-import"><code>xsl:import</code></a> element <span class=
"verb">must</span> be a <a title="top-level" class="termref" href=
"#dt-top-level">top-level</a> element.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e10289" id=
"d7e10289"></a>Example: Using <a href=
"#element-import"><code>xsl:import</code></a></div>
<p>For example,</p>
<div class="exampleInner">
<pre>
&lt;xsl:stylesheet version="3.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:import href="article.xsl"/&gt;
  &lt;xsl:import href="bigfont.xsl"/&gt;
  &lt;xsl:attribute-set name="note-style"&gt;
    &lt;xsl:attribute name="font-style"&gt;italic&lt;/xsl:attribute&gt;
  &lt;/xsl:attribute-set&gt;
&lt;/xsl:stylesheet&gt;
</pre></div>
</div>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-import-tree" id="dt-import-tree" title="import tree"></a>The
<a title="stylesheet level" class="termref" href=
"#dt-stylesheet-level">stylesheet levels</a> making up a <a title=
"stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>
are treated as forming an <b>import tree</b>. In the import tree,
each stylesheet level has one child for each <a href=
"#element-import"><code>xsl:import</code></a> declaration that it
contains.<span class="definition">]</span> The ordering of the
children is the <a title="declaration order" class="termref" href=
"#dt-declaration-order">declaration order</a> of the <a href=
"#element-import"><code>xsl:import</code></a> declarations within
their stylesheet level.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-import-precedence" id="dt-import-precedence" title=
"import precedence"></a>A <a title="declaration" class="termref"
href="#dt-declaration">declaration</a> <var>D</var> in the
stylesheet is defined to have lower <b>import precedence</b> than
another declaration <var>E</var> if the stylesheet level containing
<var>D</var> would be visited before the stylesheet level
containing <var>E</var> in a post-order traversal of the import
tree (that is, a traversal of the import tree in which a stylesheet
level is visited after its children). Two declarations within the
same stylesheet level have the same import precedence.<span class=
"definition">]</span></p>
<p>For example, suppose</p>
<ul>
<li>
<p>stylesheet module <var>A</var> imports stylesheet modules
<var>B</var> and <var>C</var> in that order;</p>
</li>
<li>
<p>stylesheet module <var>B</var> imports stylesheet module
<var>D</var>;</p>
</li>
<li>
<p>stylesheet module <var>C</var> imports stylesheet module
<var>E</var>.</p>
</li>
</ul>
<p>Then the import tree has the following structure:</p>
<object type="image/svg+xml" codetype="image/svg+xml" data=
"img/fig1.svg" width="274" height="130"><span style=
"background-color:#FFFF20;padding-top:1pt;padding-bottom:1pt;">This
browser can't display the SVG file img/fig1.svg. Please upgrade
your browser or install the Adobe SVG Viewer.</span></object>
<p><em>Here you should see a diagram. If it does not appear
correctly in your browser, you need to install an SVG
Plugin.</em></p>
<p>The order of import precedence (lowest first) is <var>D</var>,
<var>B</var>, <var>E</var>, <var>C</var>, <var>A</var>.</p>
<p>In general, a <a title="declaration" class="termref" href=
"#dt-declaration">declaration</a> with higher import precedence
takes precedence over a declaration with lower import precedence.
This is defined in detail for each kind of declaration.</p>
<p><a name="err-XTSE0210" id="err-XTSE0210"><span class=
"error">[ERR XTSE0210]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if a
stylesheet module directly or indirectly imports itself.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The case where a stylesheet module with a particular URI is
imported several times is not treated specially. The effect is
exactly the same as if several stylesheet modules with different
URIs but identical content were imported. This might or might not
cause an error, depending on the content of the stylesheet
module.</p>
</div>
</div>
</div>
<div class="div2">
<h3><a name="embedded" id="embedded"></a>3.13 <a href="#embedded"
style="text-decoration: none">Embedded Stylesheet Modules</a></h3>
<p>An <a title="embedded stylesheet module" class="termref" href=
"#dt-embedded-stylesheet-module">embedded stylesheet module</a> is
a <a title="stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet module</a> whose containing
element is not the outermost element of the containing XML
document. Both <a title="standard stylesheet module" class=
"termref" href="#dt-standard-stylesheet-module">standard stylesheet
modules</a> and <a title="simplified stylesheet" class="termref"
href="#dt-simplified-stylesheet-module">simplified stylesheet
modules</a> may be embedded in this way.</p>
<p>Two situations where embedded stylesheets may be useful are:</p>
<ul>
<li>
<p>The stylesheet may be embedded in the source document to be
transformed.</p>
</li>
<li>
<p>The stylesheet may be embedded in an XML document that describes
a sequence of processing of which the XSLT transformation forms
just one part.</p>
</li>
</ul>
<p>The <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> element
<span class="verb">may</span> have an <code>id</code> attribute to
facilitate reference to the stylesheet module within the containing
document.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In order for such an attribute value to be used as a fragment
identifier in a URI, the XDM attribute node must generally have the
<code>is-id</code> property: see <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dm-is-id">Section 5.5
is-id Accessor</a> <sup><small>DM30</small></sup>. This property
will typically be set if the attribute is defined in a DTD as being
of type <code>ID</code>, or if it is defined in a schema as being
of type <code>xs:ID</code>. It is also necessary that the media
type of the containing document should support the use of ID values
as fragment identifiers. <span>Such support is widespread in
existing products, and is endorsed in respect of the media type
<code>application/xml</code> by <a href=
"#rfc7303">[RFC7303]</a></span>.</p>
<p>An alternative, if the implementation supports it, is to use an
<code>xml:id</code> attribute. XSLT allows this attribute (like
other namespaced attributes) to appear on any <a title=
"XSLT element" class="termref" href="#dt-xslt-element">XSLT
element</a>.</p>
</div>
<div class="example">
<div class="exampleHeader"><a name="d7e10498" id=
"d7e10498"></a>Example: The <code>xml-stylesheet</code> Processing
Instruction</div>
<p>The following example shows how the <code>xml-stylesheet</code>
processing instruction (see <a href="#xml-stylesheet">[XML
Stylesheet]</a>) can be used to allow a source document to contain
its own stylesheet. The URI reference uses a fragment identifier to
locate the <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> element:</p>
<div class="exampleInner">
<pre>
&lt;?xml-stylesheet type="application/xslt+xml" href="#style1"?&gt;
&lt;!DOCTYPE doc SYSTEM "doc.dtd"&gt;
&lt;doc&gt;
  &lt;head&gt;
    &lt;xsl:stylesheet id="style1"
                    version="3.0"
                    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                    xmlns:fo="http://www.w3.org/1999/XSL/Format"&gt;
    &lt;xsl:import href="doc.xsl"/&gt;
    &lt;xsl:template match="id('foo')"&gt;
      &lt;fo:block font-weight="bold"&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="xsl:stylesheet"&gt;
      &lt;!-- ignore --&gt;
    &lt;/xsl:template&gt;
    &lt;/xsl:stylesheet&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;para id="foo"&gt;
    ...
    &lt;/para&gt;
  &lt;/body&gt;
&lt;/doc&gt;
</pre></div>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>A stylesheet module that is embedded in the document to which it
is to be applied typically needs to contain a <a title=
"template rule" class="termref" href="#dt-template-rule">template
rule</a> that specifies that <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> elements are
to be ignored.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The above example uses the pseudo-attribute
<code>type="application/xslt+xml"</code> in the
<code>xml-stylesheet</code> processing instruction to denote an
XSLT stylesheet. This is the officially registered media type for
XSLT: see <a href="#xslt-media-type"><i>3.4 XSLT Media
Type</i></a>. However, browsers developed before this media type
was registered are more likely to accept the unofficial designation
<code>type="text/xsl"</code>.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Support for the <code>xml-stylesheet</code> processing
instruction is not required for conformance with this
Recommendation. Implementations are not constrained in the
mechanisms they use to identify a stylesheet when a transformation
is initiated: see <a href="#initiating"><i>2.3 Initiating a
Transformation</i></a>.</p>
</div>
</div>
<div class="div2">
<h3><a name="preprocessing" id="preprocessing"></a>3.14 <a href=
"#preprocessing" style="text-decoration: none">Stylesheet
Preprocessing</a></h3>
<p>This specification provides two features that cause the raw
stylesheet to be preprocessed as the first stage of static
processing: elements may be conditionally included or excluded by
means of an <code>[xsl:]use-when</code> attribute as described in
<a href="#conditional-inclusion"><i>3.14.1 Conditional Element
Inclusion</i></a>, and attributes may be conditionally computed as
described in <a href="#shadow-attributes"><i>3.14.2 Shadow
Attributes</i></a>.</p>
<p>Note that many of the rules affecting the validity of stylesheet
documents apply to a stylesheet after this preprocessing phase has
been carried out.</p>
<div class="div3">
<h4><a name="conditional-inclusion" id=
"conditional-inclusion"></a>3.14.1 <a href="#conditional-inclusion"
style="text-decoration: none">Conditional Element
Inclusion</a></h4>
<p>Any element in the XSLT namespace may have a
<code>use-when</code> attribute whose value is an XPath expression
that can be evaluated statically. If the attribute is present and
the <a href="http://www.w3.org/TR/xpath-30/#dt-ebv">effective
boolean value</a><sup><small>XP30</small></sup> of the expression
is false, then the element, together with all the nodes having that
element as an ancestor, is effectively excluded from the <a title=
"stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet module</a>. When a node is
effectively excluded from a stylesheet module the stylesheet module
has the same effect as if the node were not there. Among other
things this means that no static or dynamic errors will be reported
in respect of the element and its contents, other than errors in
the <code>use-when</code> attribute itself.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This does not apply to XML parsing or validation errors, which
will be reported in the usual way. It also does not apply to
attributes that are necessarily processed before
<code>[xsl:]use-when</code>, examples being <code>xml:space</code>
and <code>[xsl:]xpath-default-namespace</code>.</p>
</div>
<p>A <a title="literal result element" class="termref" href=
"#dt-literal-result-element">literal result element</a>, or any
other element within a <a title="stylesheet module" class="termref"
href="#dt-stylesheet-module">stylesheet module</a> that is not in
the XSLT namespace, may similarly carry an
<code>xsl:use-when</code> attribute.</p>
<p>If the <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href=
"#element-transform"><code>xsl:transform</code></a> element itself
is effectively excluded, the effect is to exclude all the children
of the <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href=
"#element-transform"><code>xsl:transform</code></a> element, but
not the <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href=
"#element-transform"><code>xsl:transform</code></a> element or its
attributes.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This allows all the declarations that depend on the same
condition to be included in one stylesheet module, and for their
inclusion or exclusion to be controlled by a single
<code>use-when</code> attribute at the level of the module.</p>
</div>
<p>Conditional element exclusion happens after stripping of
whitespace text nodes from the stylesheet, as described in <a href=
"#stylesheet-stripping"><i>4.2 Stripping Whitespace from the
Stylesheet</i></a>.</p>
<p>The XPath expression used as the value of the
<code>xsl:use-when</code> attribute follows the rules for <a title=
"static expression" class="termref" href=
"#dt-static-expression">static expressions</a>.</p>
<p>The use of <code>[xsl:]use-when</code> is illustrated in the
following examples.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e10648" id=
"d7e10648"></a>Example: Using Conditional Exclusion to Achieve
Portability</div>
<p>This example demonstrates the use of the <code>use-when</code>
attribute to achieve portability of a stylesheet across
schema-aware and non-schema-aware processors.</p>
<div class="exampleInner">
<pre>
&lt;xsl:import-schema schema-location="http://example.com/schema"
              use-when="system-property('xsl:is-schema-aware')='yes'"/&gt;

&lt;xsl:template match="/" 
              use-when="system-property('xsl:is-schema-aware')='yes'" 
              priority="2"&gt;
  &lt;xsl:result-document validation="strict"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:result-document&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="/"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;
</pre></div>
<p>The effect of these declarations is that a non-schema-aware
processor ignores the <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>
declaration and the first template rule, and therefore generates no
errors in respect of the schema-related constructs in these
declarations.</p>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e10663" id=
"d7e10663"></a>Example: Including Variant Stylesheet Modules</div>
<p>This example includes different stylesheet modules depending on
which XSLT processor is in use.</p>
<div class="exampleInner">
<pre>
&lt;xsl:include href="module-A.xsl" 
     use-when="system-property('xsl:vendor')='vendor-A'"/&gt;
&lt;xsl:include href="module-B.xsl" 
     use-when="system-property('xsl:vendor')='vendor-B'"/&gt;
</pre></div>
</div>
</div>
<div class="div3">
<h4><a name="shadow-attributes" id="shadow-attributes"></a>3.14.2
<a href="#shadow-attributes" style="text-decoration: none">Shadow
Attributes</a></h4>
<p>Wherever a no-namespace attribute is defined for an element in
the <a title="XSLT namespace" class="termref" href=
"#dt-xslt-namespace">XSLT namespace</a>, instead of supplying the
attribute value explicitly in the stylesheet, a shadow attribute
may be supplied allowing the value of the attribute to be
statically computed during the preprocessing phase. The shadow
attribute has a name that is the same as the name of the target
attribute prefixed with an underscore, and the value of the shadow
attribute is a <a title="value template" class="termref" href=
"#dt-value-template">value template</a> in which all expressions
enclosed between curly braces must be <a title="static expression"
class="termref" href="#dt-static-expression">static
expressions</a>.</p>
<p>For example, an <a href=
"#element-include"><code>xsl:include</code></a> element might be
written:</p>
<div class="exampleInner">
<pre>
&lt;xsl:include _href="common{$VERSION}.xsl"/&gt;
</pre></div>
<p>allowing the stylesheet to include a specific version of a
library module based on the value of a <a title="static parameter"
class="termref" href="#dt-static-parameter">static
parameter</a>.</p>
<p>Similarly, a <a title="mode" class="termref" href=
"#dt-mode">mode</a> might be declared like this:</p>
<div class="exampleInner">
<pre>
&lt;xsl:param name="streamable" as="xs:boolean" required="yes" static="yes"/&gt;
&lt;xsl:mode _streamable="{$streamable}" on-no-match="shallow-skip"/&gt;
</pre></div>
<p>this allowing the streamability of the mode to be controlled
using a <a title="static parameter" class="termref" href=
"#dt-static-parameter">static parameter</a> <span>(Note: this
example relies on the fact that the <code>streamable</code>
attribute accepts a boolean value, which means that the values
<code>true</code> and <code>false</code> are accepted as synonyms
of <code>yes</code> and <code>no</code>)</span>.</p>
<p>This mechanism applies to all attributes in the stylesheet where
the attribute name is in no namespace and the name of the parent
element is in the <a title="XSLT namespace" class="termref" href=
"#dt-xslt-namespace">XSLT namespace</a>. This includes attributes
that have static significance such as the <code>use-when</code>
attribute, the <code>version</code> attribute, or the
<code>static</code> attribute on <a href=
"#element-variable"><code>xsl:variable</code></a>. The mechanism
does not apply to shadow attributes (that is, it is not possible to
invoke two stages of preprocessing by using two leading
underscores). It does not apply to attributes of literal result
elements, nor to attributes in a namespace such as the XML or XSLT
namespace, nor to namespace declarations.</p>
<p>If a shadow attribute and its corresponding target attribute are
both present in the stylesheet, the non-shadow attribute is
ignored.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This may be useful to make stylesheet code compatible across
XSLT versions; an XSLT 2.0 processor operating in forwards
compatible mode will ignore shadow attributes, and will require the
target attribute to be valid.</p>
</div>
<div class="example">
<div class="exampleHeader"><a name="d7e10743" id=
"d7e10743"></a>Example: Using Shadow Attributes to Parameterize
XPath Default Namespace</div>
<p>Although it is not usually considered good practice, it
sometimes happens that variants or versions of an XML vocabulary
exist in which the same local names are used, but in different
namespaces. There is then a requirement to write code that will
process source documents in a variety of different namespaces.</p>
<p>It is possible to define a static stylesheet parameter
containing the target namespace, for example:</p>
<div class="exampleInner">
<pre>
&lt;xsl:param name="NS" as="xs:string" static="yes" select="'http://example.com/ns/one'"/&gt;
</pre></div>
<p>And this can then be used to set the default namespace for XPath
expressions:</p>
<div class="exampleInner">
<pre>
_xpath-default-namespace="{$NS}"
</pre></div>
<p>However, it is not possible to put this shadow attribute on the
<a href="#element-stylesheet"><code>xsl:stylesheet</code></a> or
<a href="#element-package"><code>xsl:package</code></a> element of
the principal stylesheet module, because at that point the variable
<code>$NS</code> is not in scope. A workaround is to create a stub
stylesheet module which contains nothing but the static parameter
declaration and an <a href=
"#element-include"><code>xsl:include</code></a> of the stylesheet
module containing the real logic. The static stylesheet parameter
will then be in scope on the <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> element of
the included stylesheet module, and the shadow attribute
<code>_xpath-default-namespace="{$NS}"</code> can therefore appear
on this <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> element.</p>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e10780" id=
"d7e10780"></a>Example: Using Shadow Attributes to Parameterize
Selection of Elements</div>
<p>The following stylesheet produces a report giving information
about selected employees. The predicate defining which employees
are to be included in the report is supplied (as a string
containing an XPath expression) in a static stylesheet
parameter:</p>
<div class="exampleInner">
<pre>
          &lt;xsl:param name="filter" static="yes"
                     as="xs:string" select="'true()'"/&gt;
          &lt;xsl:function name="local:filter" as="xs:boolean"&gt;
            &lt;xsl:param name="e" as="element(employee)"/&gt;
            &lt;xsl:sequence _select="$e/({$filter})"/&gt;
          &lt;/xsl:function&gt;
          &lt;xsl:template match="/"&gt;
            &lt;report&gt;
              &lt;xsl:apply-templates mode="report" select="//employee[local:filter(.)]"/&gt;
            &lt;/report&gt;
          &lt;/xsl:template&gt;
                     
</pre></div>
<p>If the supplied value of the filter parameter is, say
<code>location = "UK"</code>, then the report will cover employees
based in the UK.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The stylesheet function <code>local:filter</code> is used here
in preference to direct use of the supplied predicate within the
<code>select</code> attribute of the <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction because it reduces exposure to code injection attacks.
It does not necessarily eliminate all such risks, however. For
example, it would be possible for a caller to supply an expression
that never terminates, thus creating a denial-of-service risk.</p>
</div>
</div>
</div>
</div>
<div class="div2">
<h3><a name="built-in-types" id="built-in-types"></a>3.15 <a href=
"#built-in-types" style="text-decoration: none">Built-in
Types</a></h3>
<p>Every XSLT <span>3.0</span> processor includes the following
named type definitions in the <a title="in-scope schema component"
class="termref" href="#dt-in-scope-schema-component">in-scope
schema components</a>:</p>
<ul>
<li>
<p><span>All built-in types defined in <a href="#xmlschema-2">[XML
Schema Part 2]</a>, including <code>xs:anyType</code> and
<code>xs:anySimpleType</code>.</span></p>
</li>
<li>
<p>The following types defined in <a href="#xpath-30">[XPath
3.0]</a>: <code>xs:yearMonthDuration</code>,
<code>xs:dayTimeDuration</code>, <code>xs:anyAtomicType</code>,
<code>xs:untyped</code>, and <code>xs:untypedAtomic</code>.</p>
</li>
</ul>
<p>XSLT 3.0 processors <span class="verb">may</span> optionally
include types defined in XSD 1.1 (see <a href="#xmlschema11-1">[XML
Schema 1.1 Part 1]</a>). XSD 1.1 adopts the types
<code>xs:yearMonthDuration</code>, <code>xs:dayTimeDuration</code>,
and <code>xs:anyAtomicType</code> previously defined in XPath 2.0,
and adds one new type: <code>xs:dateTimeStamp</code>. XSD 1.1 also
allows implementers to define additional primitive types, and XSLT
3.0 permits such types to be supported by an XSLT processor.</p>
<p>A <a title="schema-aware XSLT processor" class="termref" href=
"#dt-schema-aware-xslt-processor">schema-aware XSLT processor</a>
additionally supports:</p>
<ul>
<li>
<p>User-defined types, and element and attribute declarations, that
are imported using an <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>
declaration as described in <a href="#import-schema"><i>3.16
Importing Schema Components</i></a>. These may include both simple
and complex types.</p>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The names that are imported from the XML Schema namespace do not
include all the names of top-level types defined in either the
Schema for Schema Documents or the Schema for Schema Documents
(Datatypes). The Schema for Schema Documents, as well as defining
built-in types such as <code>xs:integer</code> and
<code>xs:double</code>, also defines types that are intended for
use only within that schema, such as
<code>xs:derivationControl</code>. A <a title="stylesheet" class=
"termref" href="#dt-stylesheet">stylesheet</a> that is designed to
process XML Schema documents as its input or output may import the
Schema for Schema Documents.</p>
</div>
<p>An implementation may define mechanisms that allow additional
<a title="schema component" class="termref" href=
"#dt-schema-component">schema components</a> to be added to the
<a title="in-scope schema component" class="termref" href=
"#dt-in-scope-schema-component">in-scope schema components</a> for
the stylesheet. For example, the mechanisms used to define
<a title="extension function" class="termref" href=
"#dt-extension-function">extension functions</a> (see <a href=
"#extension-functions"><i>23.1 Extension Functions</i></a>) may
also be used to import the types used in the interface to such
functions.</p>
<p>These <a title="schema component" class="termref" href=
"#dt-schema-component">schema components</a> are the only ones that
may be referenced in XPath expressions within the stylesheet, or in
the <code>[xsl:]type</code> and <code>as</code> attributes of those
elements that permit these attributes.</p>
</div>
<div class="div2">
<h3><a name="import-schema" id="import-schema"></a>3.16 <a href=
"#import-schema" style="text-decoration: none">Importing Schema
Components</a></h3>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The facilities described in this section are not available with
a <a title="basic XSLT processor" class="termref" href=
"#dt-basic-xslt-processor">basic XSLT processor</a>. They require a
<a title="schema-aware XSLT processor" class="termref" href=
"#dt-schema-aware-xslt-processor">schema-aware XSLT processor</a>,
as described in <a href="#conformance"><i>26
Conformance</i></a>.</p>
</div>
<p class="element-syntax"><a name="element-import-schema" id=
"element-import-schema"></a><code>&lt;!-- Category: declaration
--&gt;<br />
&lt;xsl:import-schema<br />
&#160;&#160;namespace? = <var>uri</var><br />
&#160;&#160;schema-location? = <var>uri</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: xs:schema? --&gt;<br />
&lt;/xsl:import-schema&gt;</code></p>
<p>The <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>
declaration is used to identify <a title="schema component" class=
"termref" href="#dt-schema-component">schema components</a> (that
is, top-level type definitions and top-level element and attribute
declarations) that need to be available statically, that is, before
any source document is available. Names of such components used
statically within the <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> must refer to an <a title=
"in-scope schema component" class="termref" href=
"#dt-in-scope-schema-component">in-scope schema component</a>,
which means they must either be built-in types as defined in
<a href="#built-in-types"><i>3.15 Built-in Types</i></a>, or they
must be imported using an <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>
declaration.</p>
<p>The <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>
declaration identifies a namespace containing the names of the
components to be imported (or indicates that components whose names
are in no namespace are to be imported). The effect is that the
names of top-level element and attribute declarations and type
definitions from this namespace (or non-namespace) become available
for use within XPath expressions in the <span><a title="package"
class="termref" href="#dt-package">package</a></span>, and within
other stylesheet constructs such as the <code>type</code> and
<code>as</code> attributes of various <a title="XSLT element"
class="termref" href="#dt-xslt-element">XSLT elements</a>.</p>
<p>The same schema components are available in all stylesheet
modules <span>within the <a title="declaring package" class=
"termref" href="#dt-declaring-package">declaring
package</a></span>; importing components in one stylesheet module
makes them available throughout the <a title="package" class=
"termref" href="#dt-package">package</a>.</p>
<p>The schema components imported into different <a title="package"
class="termref" href="#dt-package">packages</a> within a <a title=
"stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>
must be consistent. Specifically, it is not permitted to use the
same name in the same XSD symbol space to refer to different schema
components within different packages; and the union of the schema
components imported into the packages of a stylesheet must
constitute a valid schema (as well as the set of schema components
imported into each package forming a valid schema in its own
right).</p>
<p>The <code>namespace</code> and <code>schema-location</code>
attributes are both optional.</p>
<p>If the <a href=
"#element-import-schema"><code>xsl:import-schema</code></a> element
contains an <code>xs:schema</code> element, then the
<code>schema-location</code> attribute <span class=
"verb">must</span> be absent, and one of the following <span class=
"verb">must</span> be true:</p>
<ul>
<li>
<p>the <code>namespace</code> attribute of the <a href=
"#element-import-schema"><code>xsl:import-schema</code></a> element
and the <code>targetNamespace</code> attribute of the
<code>xs:schema</code> element are both absent (indicating a
no-namespace schema), or</p>
</li>
<li>
<p>the <code>namespace</code> attribute of the <a href=
"#element-import-schema"><code>xsl:import-schema</code></a> element
and the <code>targetNamespace</code> attribute of the
<code>xs:schema</code> element are both present and both have the
same value, or</p>
</li>
<li>
<p>the <code>namespace</code> attribute of the <a href=
"#element-import-schema"><code>xsl:import-schema</code></a> element
is absent and the <code>targetNamespace</code> attribute of the
<code>xs:schema</code> element is present, in which case the target
namespace is as given on the <code>xs:schema</code> element.</p>
</li>
</ul>
<p><a name="err-XTSE0215" id="err-XTSE0215"><span class=
"error">[ERR XTSE0215]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if an
<a href="#element-import-schema"><code>xsl:import-schema</code></a>
element that contains an <code>xs:schema</code> element has a
<code>schema-location</code> attribute, or if it has a
<code>namespace</code> attribute that conflicts with the target
namespace of the contained schema.</p>
<p>If two <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>
declarations specify the same namespace, or if both specify no
namespace, then only the one with highest <a title=
"import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a> is used. If this
leaves more than one, then all the declarations at the highest
import precedence are used (which may cause conflicts, as described
below).</p>
<p>After discarding any <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>
declarations under the above rule, the effect of the remaining
<a href="#element-import-schema"><code>xsl:import-schema</code></a>
declarations is defined in terms of a hypothetical document called
the synthetic schema document, which is constructed as follows. The
synthetic schema document defines an arbitrary target namespace
that is different from any namespace actually used by the
application, and it contains <code>xs:import</code> elements
corresponding one-for-one with the <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>
declarations in the <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a>, with the following
correspondence:</p>
<ul>
<li>
<p>The <code>namespace</code> attribute of the
<code>xs:import</code> element is copied from the
<code>namespace</code> attribute of the <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>
declaration if it is explicitly present, or is implied by the
<code>targetNamespace</code> attribute of a contained
<code>xs:schema</code> element, and is absent if it is absent.</p>
</li>
<li>
<p>The <code>schemaLocation</code> attribute of the
<code>xs:import</code> element is copied from the
<code>schema-location</code> attribute of the <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>
declaration if present, and is absent if it is absent. If there is
a contained <code>xs:schema</code> element, the effective value of
the <code>schemaLocation</code> attribute is a URI referencing a
document containing a copy of the <code>xs:schema</code>
element.</p>
</li>
<li>
<p>The base URI of the <code>xs:import</code> element is the same
as the base URI of the <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>
declaration.</p>
</li>
</ul>
<p>The schema components included in the <a title=
"in-scope schema component" class="termref" href=
"#dt-in-scope-schema-component">in-scope schema components</a>
(that is, the components whose names are available for use within
the stylesheet) are the top-level element and attribute
declarations and type definitions that are available for reference
within the synthetic schema document. See <a href=
"#xmlschema-1">[XML Schema Part 1]</a> (section 4.2.3,
<em>References to schema components across namespaces</em>).</p>
<p><a name="err-XTSE0220" id="err-XTSE0220"><span class=
"error">[ERR XTSE0220]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
synthetic schema document does not satisfy the constraints
described in <a href="#xmlschema-1">[XML Schema Part 1]</a>
(section 5.1, <em>Errors in Schema Construction and
Structure</em>). This includes, without loss of generality,
conflicts such as multiple definitions of the same name.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The synthetic schema document does not need to be constructed by
a real implementation. It is purely a mechanism for defining the
semantics of <a href=
"#element-import-schema"><code>xsl:import-schema</code></a> in
terms of rules that already exist within the XML Schema
specification. In particular, it implicitly defines the rules that
determine whether the set of <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>
declarations are mutually consistent.</p>
<p>These rules do not cause names to be imported transitively. The
fact that a name is available for reference within a schema
document A does not of itself make the name available for reference
in a stylesheet that imports the target namespace of schema
document A. (See <a href="#xmlschema-1">[XML Schema Part 1]</a>
section 3.15.3, Constraints on XML Representations of Schemas.) The
stylesheet must import all the namespaces containing names that it
actually references.</p>
<p>The <code>namespace</code> attribute indicates that a schema for
the given namespace is required by the <a title="stylesheet" class=
"termref" href="#dt-stylesheet">stylesheet</a>. This information
may be enough on its own to enable an implementation to locate the
required schema components. The <code>namespace</code> attribute
may be omitted to indicate that a schema for names in no namespace
is being imported. The zero-length string is not a valid namespace
URI, and is therefore not a valid value for the
<code>namespace</code> attribute.</p>
<p>The <code>schema-location</code> attribute is a <a title=
"URI Reference" class="termref" href="#dt-uri-reference">URI
Reference</a> that gives a hint indicating where a schema document
or other resource containing the required definitions may be found.
It is likely that a <a title="schema-aware XSLT processor" class=
"termref" href="#dt-schema-aware-xslt-processor">schema-aware XSLT
processor</a> will be able to process a schema document found at
this location.</p>
<p>The XML Schema specification gives implementations flexibility
in how to handle multiple imports for the same namespace. Multiple
imports do not cause errors if the definitions do not conflict.</p>
<p>A consequence of these rules is that it is not intrinsically an
error if no schema document can be located for a namespace
identified in an <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>
declaration. This will cause an error only if it results in the
stylesheet containing references to names that have not been
imported.</p>
<p>An inline schema document (using an <code>xs:schema</code>
element as a child of the <code>xsl:import-schema</code> element)
has the same status as an external schema document, in the sense
that it acts as a hint for a source of schema components in the
relevant namespace. To ensure that the inline schema document is
always used, it is advisable to use a target namespace that is
unique to this schema document.</p>
</div>
<p>The use of a namespace in an <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>
declaration does not by itself associate any namespace prefix with
the namespace. If names from the namespace are used within the
stylesheet module then a namespace declaration must be included in
the stylesheet module, in the usual way.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e11367" id=
"d7e11367"></a>Example: An Inline Schema Document</div>
<p>The following example shows an inline schema document. This
declares a simple type <code>local:yes-no</code>, which the
stylesheet then uses in the declaration of a variable.</p>
<p>The example assumes the namespace declaration
<code>xmlns:local="http://example.com/ns/yes-no"</code></p>
<div class="exampleInner">
<pre>
&lt;xsl:import-schema&gt;
  &lt;xs:schema targetNamespace="http://example.com/ns/yes-no"
             xmlns:xs="http://www.w3.org/2001/XMLSchema"
             xmlns:local="http://example.com/ns/yes-no"&gt;
    &lt;xs:simpleType name="yes-no"&gt;
      &lt;xs:restriction base="xs:string"&gt;
        &lt;xs:enumeration value="yes"/&gt;
        &lt;xs:enumeration value="no"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;
  &lt;/xs:schema&gt;
&lt;/xsl:import-schema&gt;

&lt;xsl:variable name="condition" select="local:yes-no('yes')" 
                               as="local:yes-no"/&gt;
</pre></div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="data-model" id="data-model"></a>4 <a href=
"#data-model" style="text-decoration: none">Data Model</a></h2>
<p>The data model used by XSLT is the <span>XPath 3.0 and XQuery
3.0</span> data model (XDM), as defined in <a href=
"#xpath-datamodel-30">[Data Model]</a>. XSLT operates on source,
result and stylesheet documents using the same data model.</p>
<p>This section elaborates on some particular features of XDM as it
is used by XSLT:</p>
<p>The rules in <a href="#stylesheet-stripping"><i>4.2 Stripping
Whitespace from the Stylesheet</i></a> and <a href="#strip"><i>4.4
Stripping Whitespace from a Source Tree</i></a> make use of the
concept of a whitespace text node.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-whitespace-text-node" id="dt-whitespace-text-node" title=
"whitespace text node"></a>A <b>whitespace text node</b> is a text
node whose content consists entirely of whitespace characters (that
is, #x09, #x0A, #x0D, or #x20).<span class=
"definition">]</span></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Features of a source XML document that are not represented in
the XDM tree will have no effect on the operation of an XSLT
stylesheet. Examples of such features are entity references, CDATA
sections, character references, whitespace within element tags, and
the choice of single or double quotes around attribute values.</p>
</div>
<div class="div2">
<h3><a name="xml-versions" id="xml-versions"></a>4.1 <a href=
"#xml-versions" style="text-decoration: none">XML Versions</a></h3>
<p>The XDM data model defined in <a href=
"#xpath-datamodel-30">[Data Model]</a> is capable of representing
either an XML 1.0 document (conforming to <a href="#REC-xml">[XML
1.0]</a> and <a href="#xml-names">[Namespaces in XML]</a>) or an
XML 1.1 document (conforming to <a href="#xml11">[XML 1.1]</a> and
<a href="#xml-names11">[Namespaces in XML 1.1]</a>), and it makes
no distinction between the two. In principle, therefore, XSLT
<span>3.0</span> can be used with either of these XML versions.</p>
<p>Construction of the XDM tree is outside the scope of this
specification, so XSLT <span>3.0</span> places no formal
requirements on an XSLT processor to accept input from either XML
1.0 documents or XML 1.1 documents or both. This specification does
define a serialization capability (see <a href=
"#serialization"><i>25 Serialization</i></a>), though from a
conformance point of view it is an optional feature. Although
facilities are described for serializing the XDM tree as either XML
1.0 or XML 1.1 (and controlling the choice), there is again no
formal requirement on an XSLT processor to support either or both
of these XML versions as serialization targets.</p>
<p>Because the XDM tree is the same whether the original document
was XML 1.0 or XML 1.1, the semantics of XSLT processing do not
depend on the version of XML used by the original document. There
is no reason in principle why all the input and output documents
used in a single transformation must conform to the same version of
XML.</p>
<p>Some of the syntactic constructs in XSLT <span>3.0</span> and
<span>XPath 3.0</span>, for example the productions <a href=
"http://www.w3.org/TR/REC-xml/#NT-Char">Char</a><sup><small>XML</small></sup>
and <a href=
"http://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a><sup><small>Names</small></sup>,
are defined by reference to the XML and XML Namespaces
specifications. There are slight variations between the XML 1.0 and
XML 1.1 versions of these productions <span>(and, indeed, between
different editions of XML 1.0)</span>. Implementations <span class=
"verb">may</span> support <span>any</span> version; it is
<span class="verb">recommended</span> that an XSLT <span>3.0</span>
processor that implements the 1.1 versions <span class=
"verb">should</span> also provide a mode that supports the 1.0
versions. It is thus <a title="implementation-defined" class=
"termref" href=
"#dt-implementation-defined">implementation-defined</a> which
versions and editions of XML and XML Namespaces are supported by
the implementation..</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The specification referenced as <a href="#xml-names">[Namespaces
in XML]</a> was actually published without a version number.</p>
</div>
<p><span>The current version of <a href="#xmlschema11-2">[XML
Schema 1.1 Part 2]</a> references the XML 1.1 specifications, but
the previous version (<a href="#xmlschema-2">[XML Schema Part
2]</a>) (that is, XSD 1.0) remains in widespread use, and only
references XML 1.0.</span> With processors lacking support for XSD
1.1, therefore, datatypes such as <code>xs:NCName</code> and
<code>xs:ID</code> may be constrained by the XML 1.0 rules, and not
allow the full range of values permitted by XML 1.1. It is
<span class="verb">recommended</span> that implementers wishing to
support XML 1.1 should consult <a href="#SCHEMA-AND-XML-1.1">[XML
Schema 1.0 and XML 1.1]</a> for guidance.</p>
</div>
<div class="div2">
<h3><a name="stylesheet-stripping" id=
"stylesheet-stripping"></a>4.2 <a href="#stylesheet-stripping"
style="text-decoration: none">Stripping Whitespace from the
Stylesheet</a></h3>
<p>The tree representing the stylesheet is preprocessed as
follows:</p>
<ol class="enumar">
<li>
<p>All comments and processing instructions are removed.</p>
</li>
<li>
<p>Any text nodes that are now adjacent to each other are
merged.</p>
</li>
<li>
<p>Any <a title="whitespace text node" class="termref" href=
"#dt-whitespace-text-node">whitespace text node</a> that satisfies
both the following conditions is removed from the tree:</p>
<ul>
<li>
<p>The parent of the text node is not an <a href=
"#element-text"><code>xsl:text</code></a> element</p>
</li>
<li>
<p>The text node does not have an ancestor element that has an
<code>xml:space</code> attribute with a value of
<code>preserve</code>, unless there is a closer ancestor element
having an <code>xml:space</code> attribute with a value of
<code>default</code>.</p>
</li>
</ul>
</li>
<li>
<p>Any <a title="whitespace text node" class="termref" href=
"#dt-whitespace-text-node">whitespace text node</a> whose parent is
one of the following elements is removed from the tree, regardless
of any <code>xml:space</code> attributes:</p>
<blockquote>
<p><span><a href=
"#element-accumulator"><code>xsl:accumulator</code></a></span><br />

<a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a><br />
<a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a><br />
<a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a><br />

<a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a><br />
<a href=
"#element-call-template"><code>xsl:call-template</code></a><br />
<a href=
"#element-character-map"><code>xsl:character-map</code></a><br />
<a href="#element-choose"><code>xsl:choose</code></a><br />
<span><a href=
"#element-evaluate"><code>xsl:evaluate</code></a></span><br />
<span><a href=
"#element-fork"><code>xsl:fork</code></a></span><br />
<span><a href=
"#element-merge"><code>xsl:merge</code></a></span><br />
<span><a href=
"#element-merge-source"><code>xsl:merge-source</code></a></span><br />

<span><a href=
"#element-mode"><code>xsl:mode</code></a></span><br />
<span><a href=
"#element-next-iteration"><code>xsl:next-iteration</code></a></span><br />

<a href="#element-next-match"><code>xsl:next-match</code></a><br />
<span><a href=
"#element-override"><code>xsl:override</code></a></span><br />
<span><a href=
"#element-package"><code>xsl:package</code></a></span><br />
<a href="#element-stylesheet"><code>xsl:stylesheet</code></a><br />
<a href="#element-transform"><code>xsl:transform</code></a><br />
<span><a href=
"#element-use-package"><code>xsl:use-package</code></a></span></p>
</blockquote>
</li>
<li>
<p>Any <a title="whitespace text node" class="termref" href=
"#dt-whitespace-text-node">whitespace text node</a> whose immediate
following-sibling node is an <a href=
"#element-param"><code>xsl:param</code></a> or <a href=
"#element-sort"><code>xsl:sort</code></a> <span>or <a href=
"#element-context-item"><code>xsl:context-item</code></a> or
<a href=
"#element-on-completion"><code>xsl:on-completion</code></a></span>
element is removed from the tree, regardless of any
<code>xml:space</code> attributes.</p>
</li>
<li>
<p>Any <a title="whitespace text node" class="termref" href=
"#dt-whitespace-text-node">whitespace text node</a> whose immediate
preceding-sibling node is an <a href=
"#element-catch"><code>xsl:catch</code></a> element is removed from
the tree, regardless of any <code>xml:space</code> attributes.</p>
</li>
</ol>
<p><a name="err-XTSE0260" id="err-XTSE0260"><span class=
"error">[ERR XTSE0260]</span></a> Within an <a title="XSLT element"
class="termref" href="#dt-xslt-element">XSLT element</a> that is
<span class="verb">required</span> to be empty, any content other
than comments or processing instructions, including any <a title=
"whitespace text node" class="termref" href=
"#dt-whitespace-text-node">whitespace text node</a> preserved using
the <code>xml:space="preserve"</code> attribute, is a <a title=
"static error" class="termref" href="#dt-static-error">static
error</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Using <code>xml:space="preserve"</code> in parts of the
stylesheet that contain <a title="sequence constructor" class=
"termref" href="#dt-sequence-constructor">sequence constructors</a>
will cause <span>whitespace text nodes in that part of the
stylesheet to be copied to the result of the sequence
constructor</span>. When the result of the sequence constructor is
used to form the content of an element, this can cause errors if
such text nodes are followed by attribute nodes generated using
<a href="#element-attribute"><code>xsl:attribute</code></a>.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>If an <code>xml:space</code> attribute is specified on a
<a title="literal result element" class="termref" href=
"#dt-literal-result-element">literal result element</a>, it will be
copied to the result tree in the same way as any other
attribute.</p>
</div>
</div>
<div class="div2">
<h3><a name="stripping-annotations" id=
"stripping-annotations"></a>4.3 <a href="#stripping-annotations"
style="text-decoration: none">Stripping Type Annotations from a
Source Tree</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-type-annotation" id="dt-type-annotation" title=
"type annotation"></a>The term <b>type annotation</b> is used in
this specification to refer to the value returned by the
<code>dm:type-name</code> accessor of a node: see <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dm-type-name">Section
5.14 type-name Accessor</a>
<sup><small>DM30</small></sup>.<span class=
"definition">]</span></p>
<p>There is sometimes a requirement to write stylesheets that
produce the same results whether or not the source documents have
been validated against a schema. To achieve this, an option is
provided to remove any <a title="type annotation" class="termref"
href="#dt-type-annotation">type annotations</a> on element and
attribute nodes in a <a title="source tree" class="termref" href=
"#dt-source-tree">source tree</a>, replacing them with an
annotation of <code>xs:untyped</code> in the case of element nodes,
and <code>xs:untypedAtomic</code> in the case of attribute
nodes.</p>
<p>Such stripping of <a title="type annotation" class="termref"
href="#dt-type-annotation">type annotations</a> can be requested by
specifying <code>input-type-annotations="strip"</code> on the
<span><a href=
"#element-package"><code>xsl:package</code></a></span> element.
This attribute has three permitted values: <code>strip</code>,
<code>preserve</code>, and <code>unspecified</code>. The default
value is <code>unspecified</code>.</p>
<p>The <code>input-type-annotations</code> attribute may also be
specified on the <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> element; if
it is specified at this level then it must be consistent for all
stylesheet modules within the same package.</p>
<p><a name="err-XTSE0265" id="err-XTSE0265"><span class=
"error">[ERR XTSE0265]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if there
is a <a title="stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet module</a> in a <a title=
"package" class="termref" href="#dt-package">package</a> that
specifies <code>input-type-annotations="strip"</code> and another
<a title="stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet module</a> that specifies
<code>input-type-annotations="preserve"</code>, <span>or if a
stylesheet module specifies the value <code>strip</code> or
<code>preserve</code> and the same value is not specified on the
<a href="#element-package"><code>xsl:package</code></a> element of
the containing package.</span></p>
<p>The <a title="source tree" class="termref" href=
"#dt-source-tree">source trees</a> to which this applies are the
same as those affected by <a href=
"#element-strip-space"><code>xsl:strip-space</code></a> and
<a href="#element-preserve-space"><code>xsl:preserve-space</code></a>:
see <a href="#strip"><i>4.4 Stripping Whitespace from a Source
Tree</i></a>. <span>As with whitespace stripping, the rules for
stripping of <a title="type annotation" class="termref" href=
"#dt-type-annotation">type annotations</a> may vary from one
package to another, and have the effect of modifying the mapping
from URIs to document nodes defined in the XPath dynamic context;
this means that two calls to the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>
function (for example) supplying the same URI may produce different
document nodes if the calls appear in different
packages.</span></p>
<p>When type annotations are stripped, the following changes are
made to the source tree:</p>
<ul>
<li>
<p>The type annotation of every element node is changed to
<code>xs:untyped</code></p>
</li>
<li>
<p>The type annotation of every attribute node is changed to
<code>xs:untypedAtomic</code></p>
</li>
<li>
<p>The typed value of every element and attribute node is set to be
the same as its string value, as an instance of
<code>xs:untypedAtomic</code>.</p>
</li>
<li>
<p>The <code>is-nilled</code> property of every element node is set
to <code>false</code>.</p>
</li>
</ul>
<p>The values of the <code>is-id</code> and <code>is-idrefs</code>
properties are not changed.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Stripping <a title="type annotation" class="termref" href=
"#dt-type-annotation">type annotations</a> does not necessarily
return the document to the state it would be in had validation not
taken place. In particular, any defaulted elements and attributes
that were added to the tree by the validation process will still be
present, and elements and attributes validated as IDs will still be
accessible using the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-id"><code>id</code></a><sup><small>FO30</small></sup>
function.</p>
</div>
</div>
<div class="div2">
<h3><a name="strip" id="strip"></a>4.4 <a href="#strip" style=
"text-decoration: none">Stripping Whitespace from a Source
Tree</a></h3>
<p>A <a title="source tree" class="termref" href=
"#dt-source-tree">source tree</a> supplied as input to the
transformation process may contain <a title="whitespace text node"
class="termref" href="#dt-whitespace-text-node">whitespace text
nodes</a> that are of no interest, and that do not need to be
retained by the transformation. Conceptually, an XSLT <a title=
"processor" class="termref" href="#dt-processor">processor</a>
makes a copy of the source tree from which unwanted <a title=
"whitespace text node" class="termref" href=
"#dt-whitespace-text-node">whitespace text nodes</a> have been
removed. This process is referred to as whitespace stripping.</p>
<p>For the purposes of this section, the term <b>source tree</b>
means the document containing the <span><a title=
"global context item" class="termref" href=
"#dt-global-context-item">global context item</a> if it is a node,
any documents containing nodes present in the <a title=
"initial match selection" class="termref" href=
"#dt-initial-match-selection">initial match selection</a>,</span>
any document returned by the functions <a href=
"#func-document"><code>document</code></a>, <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>,
or <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-collection"><code>collection</code></a><sup><small>FO30</small></sup>,
<span>and any document read using <a href=
"#element-stream"><code>xsl:stream</code></a></span>. It does not
include documents passed as the values of <a title=
"stylesheet parameter" class="termref" href=
"#dt-stylesheet-parameter">stylesheet parameters</a> <span>or
parameters of the initial template or function</span>, nor values
returned from <a title="extension function" class="termref" href=
"#dt-extension-function">extension functions</a>.</p>
<p>Each source tree is associated with a package: the relevant
package for the <a title="global context item" class="termref"
href="#dt-global-context-item">global context item</a> is the
<a title="top-level package" class="termref" href=
"#dt-top-level-package">top-level package</a>; the relevant package
for a call on <a href="#func-document"><code>document</code></a>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>,
or <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-collection"><code>collection</code></a><sup><small>FO30</small></sup>;
is the package in which that call appears; and the relevant package
for evaluation of <a href=
"#element-stream"><code>xsl:stream</code></a> is the package in
which that instruction appears.</p>
<p>The stripping process takes as input a set of element names
whose child <a title="whitespace text node" class="termref" href=
"#dt-whitespace-text-node">whitespace text nodes</a> are to be
preserved. The way in which this set of element names is
established using the <a href=
"#element-strip-space"><code>xsl:strip-space</code></a> and
<a href="#element-preserve-space"><code>xsl:preserve-space</code></a>
declarations is described later in this section.</p>
<p>Formally, the stripping process modifies the mapping from URIs
to document nodes defined in the XPath dynamic context. This
mapping can therefore vary from one package to another. The mapping
that applies to a particular call on <a href=
"#func-document"><code>document</code></a>, <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>,
or <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-collection"><code>collection</code></a><sup><small>FO30</small></sup>,
or a particular evaluation of <a href=
"#element-stream"><code>xsl:stream</code></a>, is affected by the
<a href="#element-strip-space"><code>xsl:strip-space</code></a> and
<a href=
"#element-preserve-space"><code>xsl:preserve-space</code></a>
declarations within the package in which that construct appears.
This means that two calls on the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>
function (for example) may return different nodes if the calls
appear in different packages.</p>
<p>A <a title="whitespace text node" class="termref" href=
"#dt-whitespace-text-node">whitespace text node</a> is preserved if
either of the following apply:</p>
<ul>
<li>
<p>The element name of the parent of the text node is in the set of
whitespace-preserving element names.</p>
</li>
<li>
<p>An ancestor element of the text node has an
<code>xml:space</code> attribute with a value of
<code>preserve</code>, and no closer ancestor element has
<code>xml:space</code> with a value of <code>default</code>.</p>
</li>
</ul>
<p>Otherwise, the <a title="whitespace text node" class="termref"
href="#dt-whitespace-text-node">whitespace text node</a> is
stripped.</p>
<p>The <code>xml:space</code> attributes are not removed from the
tree.</p>
<p class="element-syntax"><a name="element-strip-space" id=
"element-strip-space"></a><code>&lt;!-- Category: declaration
--&gt;<br />
&lt;xsl:strip-space<br />
&#160;&#160;<b>elements</b> =
<var>tokens</var>&#160;/&gt;</code></p>
<p class="element-syntax"><a name="element-preserve-space" id=
"element-preserve-space"></a><code>&lt;!-- Category: declaration
--&gt;<br />
&lt;xsl:preserve-space<br />
&#160;&#160;<b>elements</b> =
<var>tokens</var>&#160;/&gt;</code></p>
<p>The set of whitespace-preserving element names is specified by
<a href="#element-strip-space"><code>xsl:strip-space</code></a> and
<a href=
"#element-preserve-space"><code>xsl:preserve-space</code></a>
<a title="declaration" class="termref" href=
"#dt-declaration">declarations</a>. Whether an element name is
included in the set of whitespace-preserving names is determined by
the best match among all the <a href=
"#element-strip-space"><code>xsl:strip-space</code></a> or <a href=
"#element-preserve-space"><code>xsl:preserve-space</code></a>
declarations: it is included if and only if there is no match or
the best match is an <a href=
"#element-preserve-space"><code>xsl:preserve-space</code></a>
element. The <a href=
"#element-strip-space"><code>xsl:strip-space</code></a> and
<a href="#element-preserve-space"><code>xsl:preserve-space</code></a>
elements each have an <code>elements</code> attribute whose value
is a whitespace-separated list of <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-NameTest">NameTests</a><sup><small>XP30</small></sup>;
an element name matches an <a href=
"#element-strip-space"><code>xsl:strip-space</code></a> or <a href=
"#element-preserve-space"><code>xsl:preserve-space</code></a>
element if it matches one of the <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-NameTest">NameTests</a><sup><small>XP30</small></sup>.
An element matches a <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-NameTest">NameTest</a><sup><small>XP30</small></sup>
if and only if the <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-NameTest">NameTest</a><sup><small>XP30</small></sup>
would be true for the element as an XPath node test.</p>
<p>The effect of <a href=
"#element-strip-space"><code>xsl:strip-space</code></a> and
<a href="#element-preserve-space"><code>xsl:preserve-space</code></a>
is local to the <a title="package" class="termref" href=
"#dt-package">package</a> in which they appear. Declarations within
a library package only affect the handling of documents loaded
using a call on the <a href=
"#func-document"><code>document</code></a>, <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>,
or <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-collection"><code>collection</code></a><sup><small>FO30</small></sup>
functions <span>or an evaluation of an <a href=
"#element-stream"><code>xsl:stream</code></a> instruction</span>
appearing lexically within the same package. Declarations within
the <a title="top-level package" class="termref" href=
"#dt-top-level-package">top-level package</a> also affect the
processing of the main input document.</p>
<p><a name="err-XTSE0270" id="err-XTSE0270"><span class=
"error">[ERR XTSE0270]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if
<span>within any <a title="package" class="termref" href=
"#dt-package">package</a></span> the same <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-NameTest">NameTest</a><sup><small>XP30</small></sup>
appears in both an <a href=
"#element-strip-space"><code>xsl:strip-space</code></a> and an
<a href=
"#element-preserve-space"><code>xsl:preserve-space</code></a>
declaration if both have the same <a title="import precedence"
class="termref" href="#dt-import-precedence">import precedence</a>.
Two NameTests are considered the same if they match the same set of
names (which can be determined by comparing them after expanding
namespace prefixes to URIs).</p>
<p><span>Otherwise,</span> when more than one <a href=
"#element-strip-space"><code>xsl:strip-space</code></a> and
<a href="#element-preserve-space"><code>xsl:preserve-space</code></a>
element <span>within the relevant <a title="package" class=
"termref" href="#dt-package">package</a></span> matches, the best
matching element is determined by the best matching <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-NameTest">NameTest</a><sup><small>XP30</small></sup>.
<span>The rules are similar to those for</span> <a title=
"template rule" class="termref" href="#dt-template-rule">template
rules</a>:</p>
<ul>
<li>
<p>First, any match with lower <a title="import precedence" class=
"termref" href="#dt-import-precedence">import precedence</a> than
another match is ignored.</p>
</li>
<li>
<p>Next, any match that has a lower <a title="default priority"
class="termref" href="#dt-default-priority">default priority</a>
than the <a title="default priority" class="termref" href=
"#dt-default-priority">default priority</a> of another match is
ignored.</p>
</li>
<li>
<p>If several matches have the same <a title="default priority"
class="termref" href="#dt-default-priority">default priority</a>
(which can only happen if one of the NameTests takes the form
<code>*:local</code> and the other takes the form
<code>prefix:*</code>), then the declaration that appears last in
<a title="declaration order" class="termref" href=
"#dt-declaration-order">declaration order</a> is used.</p>
</li>
</ul>
<p>If an element in a source document has a <a title=
"type annotation" class="termref" href="#dt-type-annotation">type
annotation</a> that is a simple type or a complex type with simple
content, then any whitespace text nodes among its children are
preserved, regardless of any <a href=
"#element-strip-space"><code>xsl:strip-space</code></a>
declarations. The reason for this is that stripping a whitespace
text node from an element with simple content could make the
element invalid: for example, it could cause the
<code>minLength</code> facet to be violated.</p>
<p>Stripping of <a title="type annotation" class="termref" href=
"#dt-type-annotation">type annotations</a> happens before stripping
of whitespace text nodes, so this situation will not occur if
<code>input-type-annotations="strip"</code> is specified.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In <a href="#xpath-datamodel-30">[Data Model]</a>, processes are
described for constructing an XDM tree from an Infoset or from a
PSVI. Those processes deal with whitespace according to their own
rules, and the provisions in this section apply to the resulting
tree. In practice this means that elements that are defined in a
DTD or a Schema to contain element-only content will have <a title=
"whitespace text node" class="termref" href=
"#dt-whitespace-text-node">whitespace text nodes</a> stripped,
regardless of the <a href=
"#element-strip-space"><code>xsl:strip-space</code></a> and
<a href="#element-preserve-space"><code>xsl:preserve-space</code></a>
declarations in the stylesheet.</p>
<p>However, source trees are not necessarily constructed using
those processes; indeed, they are not necessarily constructed by
parsing XML documents. Nothing in the XSLT specification constrains
how the source tree is constructed, or what happens to <a title=
"whitespace text node" class="termref" href=
"#dt-whitespace-text-node">whitespace text nodes</a> during its
construction. The provisions in this section relate only to
whitespace text nodes that are present in the tree supplied as
input to the XSLT processor. The XSLT processor cannot preserve
whitespace text nodes unless they were actually present in the
supplied tree.</p>
</div>
</div>
<div class="div2">
<h3><a name="id-in-data-model" id="id-in-data-model"></a>4.5
<a href="#id-in-data-model" style="text-decoration: none">Attribute
Types and DTD Validation</a></h3>
<p>The mapping from the Infoset to the XDM data model, described in
<a href="#xpath-datamodel-30">[Data Model]</a>, does not retain
attribute types. This means, for example, that an attribute
described in the DTD as having attribute type <code>NMTOKENS</code>
will be annotated in the XDM tree as <code>xs:untypedAtomic</code>
rather than <code>xs:NMTOKENS</code>, and its typed value will
consist of a single <code>xs:untypedAtomic</code> value rather than
a sequence of <code>xs:NMTOKEN</code> values.</p>
<p>Attributes with a DTD-derived type of ID, IDREF, or IDREFS will
be marked in the XDM tree as having the <code>is-id</code> or
<code>is-idrefs</code> properties. It is these properties, rather
than any <a title="type annotation" class="termref" href=
"#dt-type-annotation">type annotation</a>, that are examined by the
functions <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-id"><code>id</code></a><sup><small>FO30</small></sup>
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-idref"><code>idref</code></a><sup><small>FO30</small></sup>
described in <a href="#xpath-functions-30">[Functions and
Operators]</a>.</p>
</div>
<div class="div2">
<h3><a name="model-for-streaming" id="model-for-streaming"></a>4.6
<a href="#model-for-streaming" style="text-decoration: none">Data
Model for Streaming</a></h3>
<p>The data model for nodes in a document that is being streamed is
no different from the standard XDM data model, in that it contains
the same objects (nodes) with the same properties and
relationships. The facilities for streaming do not change the data
model; instead they impose rules that limit the ability of
stylesheets to navigate the data model.</p>
<p>A useful way to visualize streaming is to suppose that at any
point in time, there is a current position in the streamed input
document which may be the start or end of the document, the start
or end tag of an element, or a text, comment, or processing
instruction node. From this position, the stylesheet has access to
the following information:</p>
<ul>
<li>
<p>Properties intrinsic to the node, such as its name, its base
URI, its type annotation, and its <code>is-id</code> and
<code>is-idref</code> properties.</p>
</li>
<li>
<p>The ancestors of the node (but navigation downwards from the
ancestors is not permitted).</p>
</li>
<li>
<p>The attributes of the node, and the attributes of its ancestors.
For each such attribute, all the properties of the node including
its string value and typed value are available, but there are
limitations that restrict navigation from the attribute node to
other nodes in the document.</p>
</li>
<li>
<p>The in-scope namespace bindings of the node.</p>
</li>
<li>
<p>In the case of attributes, text nodes, comments, and processing
instructions, the string value and typed value of the node.</p>
</li>
</ul>
<p>The children and other descendants of a node are not accessible
except as a by-product of changing the current position in the
document. The same applies to properties of an element or document
node that require examination of the node's descendants, that is,
the string value and typed value. This is enforced by means of a
rule that only one expression requiring downward navigation from a
node is permitted.</p>
<p>There is an assumption that information about unparsed entities
is available at all times during the processing of a document. This
has two implications: firstly, the processor may need to read ahead
at the start of the document to determine this information so that
it is available while processing the document root node; and
secondly, the information then needs to be retained for the
duration of the processing.</p>
<p>Expressions such as <code>(/) instance of
document-node(element(invoice))</code> also require look-ahead as
far as the start-tag of the first element.</p>
<p>A streaming processor is required to read only as much of the
source document as is needed to generate correct stylesheet output.
It is not required to read the full source document merely in order
to satisfy the requirement imposed by the XML Recommendation that
an XML Processor must report violations of well-formedness in the
input.</p>
<p>More detailed rules are defined in <a href=
"#streamability"><i>19 Streamability</i></a>.</p>
</div>
<div class="div2">
<h3><a name="limits" id="limits"></a>4.7 <a href="#limits" style=
"text-decoration: none">Limits</a></h3>
<p>The XDM data model (see <a href="#xpath-datamodel-30">[Data
Model]</a>) leaves it to the host language to define limits. This
section describes the limits that apply to XSLT.</p>
<p>Limits on some primitive datatypes are defined in <a href=
"#xmlschema-2">[XML Schema Part 2]</a>. Other limits, listed below,
are <a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. Note that
this does not necessarily mean that each limit must be a simple
constant: it may vary depending on environmental factors such as
available resources.</p>
<p>The following limits are <a title="implementation-defined"
class="termref" href=
"#dt-implementation-defined">implementation-defined</a>:</p>
<ol class="enumar">
<li>
<p>For the <code>xs:decimal</code> type, the maximum number of
decimal digits (the <code>totalDigits</code> facet). This must be
at least 18 digits. (Note, however, that support for the full value
range of <code>xs:unsignedLong</code> requires 20 digits.)</p>
</li>
<li>
<p>For the types <code>xs:date</code>, <code>xs:time</code>,
<code>xs:dateTime</code>, <code>xs:gYear</code>, and
<code>xs:gYearMonth</code>: the range of values of the year
component, which must be at least +0001 to +9999; and the maximum
number of fractional second digits, which must be at least 3.</p>
</li>
<li>
<p>For the <code>xs:duration</code> type: the maximum absolute
values of the years, months, days, hours, minutes, and seconds
components.</p>
</li>
<li>
<p>For the <code>xs:yearMonthDuration</code> type: the maximum
absolute value, expressed as an integer number of months.</p>
</li>
<li>
<p>For the <code>xs:dayTimeDuration</code> type: the maximum
absolute value, expressed as a decimal number of seconds.</p>
</li>
<li>
<p>For the types <code>xs:string</code>, <code>xs:hexBinary</code>,
<code>xs:base64Binary</code>, <code>xs:QName</code>,
<code>xs:anyURI</code>, <code>xs:NOTATION</code>, and types derived
from them: the maximum length of the value.</p>
</li>
<li>
<p>For sequences, the maximum number of items in a sequence.</p>
</li>
</ol>
</div>
<div class="div2">
<h3><a name="d-o-e-in-data-model" id="d-o-e-in-data-model"></a>4.8
<a href="#d-o-e-in-data-model" style=
"text-decoration: none">Disable Output Escaping</a></h3>
<p>For backwards compatibility reasons, XSLT <span>3.0</span>
continues to support the <code>disable-output-escaping</code>
feature introduced in XSLT 1.0. This is an optional feature and
implementations are not <span class="verb">required</span> to
support it. A new facility, that of named <a title="character map"
class="termref" href="#dt-character-map">character maps</a> (see
<a href="#character-maps"><i>25.1 Character Maps</i></a>)
<span>was</span> introduced in XSLT 2.0. It provides similar
capabilities to <code>disable-output-escaping</code>, but without
distorting the data model.</p>
<p>If an <a title="implementation" class="termref" href=
"#dt-implementation">implementation</a> supports the
<code>disable-output-escaping</code> attribute of <a href=
"#element-text"><code>xsl:text</code></a> and <a href=
"#element-value-of"><code>xsl:value-of</code></a>, (see <a href=
"#disable-output-escaping"><i>25.2 Disabling Output
Escaping</i></a>), then the data model for trees constructed by the
<a title="processor" class="termref" href=
"#dt-processor">processor</a> is augmented with a boolean value
representing the value of this property. This boolean value,
however, can be set only within a <a title="final result tree"
class="termref" href="#dt-final-result-tree">final result tree</a>
that is being passed to the serializer.</p>
<p>Conceptually, each character in a text node on such a result
tree has a boolean property indicating whether the serializer is to
disable the normal rules for escaping of special characters (for
example, outputting of <code>&amp;</code> as
<code>&amp;amp;</code>) in respect of this character.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In practice, the nodes in a <a title="final result tree" class=
"termref" href="#dt-final-result-tree">final result tree</a> will
often be streamed directly from the XSLT processor to the
serializer. In such an implementation,
<code>disable-output-escaping</code> can be viewed not so much a
property stored with nodes in the tree, but rather as additional
information passed across the interface between the XSLT processor
and the serializer.</p>
</div>
</div>
</div>
<div class="div1">
<h2><a name="constructs" id="constructs"></a>5 <a href=
"#constructs" style="text-decoration: none">Features of the XSLT
Language</a></h2>
<div class="div2">
<h3><a name="qname" id="qname"></a>5.1 <a href="#qname" style=
"text-decoration: none">Qualified Names</a></h3>
<p>The name of a stylesheet-defined object, specifically a
<a title="named template" class="termref" href=
"#dt-named-template">named template</a>, a <a title="mode" class=
"termref" href="#dt-mode">mode</a>, an <a title="attribute set"
class="termref" href="#dt-attribute-set">attribute set</a>, a
<a title="key" class="termref" href="#dt-key">key</a>, a <a title=
"decimal format" class="termref" href=
"#dt-decimal-format">decimal-format</a>, a <a title="variable"
class="termref" href="#dt-variable">variable</a> or <a title=
"parameter" class="termref" href="#dt-parameter">parameter</a>, a
<a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet function</a>, <span>an
<a title="accumulator" class="termref" href=
"#dt-accumulator">accumulator</a>,</span> a named <a title=
"output definition" class="termref" href=
"#dt-output-definition">output definition</a>, or a <a title=
"character map" class="termref" href="#dt-character-map">character
map</a> is a qualified name: that is, it consists of a local name
and an optional namespace URI.</p>
<p>In most cases where such names are written in a <a title=
"stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>,
the syntax for expressing the name is given by the production
<a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-EQName">EQName</a><sup><small>XP30</small></sup>
in the XPath specification. In practice, this means that three
forms are permitted:</p>
<ul>
<li>
<p>A simple <code>NCName</code> appearing on its own (without any
prefix). This represents the local name of the object. The
interpretation of unprefixed names is described below.</p>
</li>
<li>
<p>A <a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a> written in the form
<code>NCName ":" NCName</code> where the first part is a namespace
prefix and the second part is the local name. The namespace part of
the object's name is then derived from the prefix by examining the
in-scope namespace bindings of the element node in the stylesheet
where the name appears.</p>
</li>
<li>
<p>A <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-URIQualifiedName">URIQualifiedName</a><sup><small>XP30</small></sup>
in the form <code>"Q{" URI? "}" NCName</code> where the two parts
of the name, that is the namespace part and the local part, both
appear explicitly. If the URI part is omitted (for example
<code>Q{}local</code>), the resulting expanded QName is a QName
whose namespace part is absent.</p>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>There are a few places where the third form, a URIQualifiedName,
is not permitted. These include the <code>name</code> attribute of
<a href="#element-element"><code>xsl:element</code></a> and
<a href="#element-attribute"><code>xsl:attribute</code></a> (which
have a separate <code>namespace</code> attribute for the purpose),
and constructs defined by other specifications. For example, names
appearing within an embedded <code>xs:schema</code> element must
follow the XSD rules.</p>
</div>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-expanded-qname" id="dt-expanded-qname" title=
"expanded QName"></a>An <b>expanded QName</b> is a value in the
value space of the <code>xs:QName</code> datatype as defined in the
XDM data model (see <a href="#xpath-datamodel-30">[Data
Model]</a>): that is, a triple containing namespace prefix
(optional), namespace URI (optional), and local name. Two expanded
QNames are equal if the namespace URIs are the same (or both
absent) and the local names are the same. The prefix plays no part
in the comparison, but is used only if the expanded QName needs to
be converted back to a string.<span class="definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-eqname" id="dt-eqname" title="EQName"></a>An <b>EQName</b> is a
string representing an <a title="expanded QName" class="termref"
href="#dt-expanded-qname">expanded QName</a> where the string,
after removing leading and trailing whitespace, is in the form
defined by the <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-EQName">EQName</a><sup><small>XP30</small></sup>
production in the XPath specification.<span class=
"definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-lexical-qname" id="dt-lexical-qname" title=
"lexical QName"></a>A <b>lexical QName</b> is a string representing
an <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> where the string, after
removing leading and trailing whitespace, is within the lexical
space of the <code>xs:QName</code> datatype as defined in XML
Schema (see <a href="#xmlschema-2">[XML Schema Part 2]</a>): that
is, a local name optionally preceded by a namespace prefix and a
colon.<span class="definition">]</span></p>
<p>Note that every <a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a> is an <a title="EQName"
class="termref" href="#dt-eqname">EQName</a>, but the converse is
not true.</p>
<p>The following rules are used when interpreting a <a title=
"lexical QName" class="termref" href="#dt-lexical-qname">lexical
QName</a>:</p>
<ol class="enumar">
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-defining-element" id="dt-defining-element" title=
"defining element"></a>A string in the form of a lexical QName may
occur as the value of an attribute node in a stylesheet module, or
within an XPath <a title="expression" class="termref" href=
"#dt-expression">expression</a> contained in an attribute <span>or
text node within a stylesheet module</span>, or as the result of
evaluating an XPath expression contained in such a node. The
element containing this attribute <span>or text</span> node is
referred to as the <b>defining element</b> of the lexical
QName.<span class="definition">]</span></p>
</li>
<li>
<p>If the lexical QName has a prefix, then the prefix is expanded
into a URI reference using the namespace declarations in effect on
its <a title="defining element" class="termref" href=
"#dt-defining-element">defining element</a>. The <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a> consisting of the local part of the name and the possibly
null URI reference is used as the name of the object. The default
namespace of the defining element (see <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#ElementNode">Section 6.2
Element Nodes</a> <sup><small>DM30</small></sup>) is <em>not</em>
used for unprefixed names.</p>
<p><a name="err-XTSE0280" id="err-XTSE0280"><span class=
"error">[ERR XTSE0280]</span></a> In the case of a prefixed
<a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a> used as the value <span>(or
as part of the value)</span> of an attribute in the <a title=
"stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>,
or appearing within an XPath <a title="expression" class="termref"
href="#dt-expression">expression</a> in the stylesheet, it is a
<a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the <a title=
"defining element" class="termref" href=
"#dt-defining-element">defining element</a> has no namespace node
whose name matches the prefix of the <a title="lexical QName"
class="termref" href="#dt-lexical-qname">lexical QName</a>.</p>
<p><a name="err-XTDE0290" id="err-XTDE0290"><span class=
"error">[ERR XTDE0290]</span></a> Where the result of evaluating an
XPath expression (or an attribute value template) is required to be
a <a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a>, or if it is permitted to be
a <a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a> and the actual value takes
the form of a <a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a>, then unless otherwise
specified it is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the value has a prefix and
the <a title="defining element" class="termref" href=
"#dt-defining-element">defining element</a> has no namespace node
whose name matches that prefix. This error <span class=
"verb">may</span> be signaled as a <a title="static error" class=
"termref" href="#dt-static-error">static error</a> if the value of
the expression can be determined statically.</p>
</li>
<li>
<p>If the lexical QName has no prefix, then:</p>
<ol class="enumla">
<li>
<p>In the case of an unprefixed QName used as a
<code>NameTest</code> within an XPath <a title="expression" class=
"termref" href="#dt-expression">expression</a> (see <a href=
"#expressions"><i>5.3 Expressions</i></a>), and in certain other
contexts, the namespace to be used in expanding the QName may be
specified by means of the
<code>[xsl:]xpath-default-namespace</code> attribute, as specified
in <a href="#unprefixed-qnames"><i>5.2 Unprefixed Lexical QNames in
Expressions and Patterns</i></a>.</p>
</li>
<li>
<p>If the name is in one of the following categories, then the
default namespace of the <a title="defining element" class=
"termref" href="#dt-defining-element">defining element</a> is
used:</p>
<ol class="enumlr">
<li>
<p>Where a QName is used to define the name of an element being
constructed. This applies both to cases where the name is known
statically (that is, the name of a literal result element) and to
cases where it is computed dynamically (the value of the
<code>name</code> attribute of the <a href=
"#element-element"><code>xsl:element</code></a> instruction).</p>
</li>
<li>
<p>The default namespace is used when expanding the first argument
of the function <a href=
"#func-element-available"><code>element-available</code></a>.</p>
</li>
<li>
<p>The default namespace applies to any unqualified element names
appearing in the <code>cdata-section-elements</code> attribute of
<a href="#element-output"><code>xsl:output</code></a> or <a href=
"#element-result-document"><code>xsl:result-document</code></a></p>
</li>
</ol>
</li>
<li>
<p>In all other cases, a <a title="lexical QName" class="termref"
href="#dt-lexical-qname">lexical QName</a> with no prefix
represents an <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> in no namespace (that is,
an <code>xs:QName</code> value in which both the prefix and the
namespace URI are absent).</p>
</li>
</ol>
</li>
</ol>
</div>
<div class="div2">
<h3><a name="unprefixed-qnames" id="unprefixed-qnames"></a>5.2
<a href="#unprefixed-qnames" style=
"text-decoration: none">Unprefixed Lexical QNames in Expressions
and Patterns</a></h3>
<p>The attribute <code>[xsl:]xpath-default-namespace</code> (see
<a href="#standard-attributes"><i>3.5 Standard Attributes</i></a>)
may be used on an element in the <a title="stylesheet" class=
"termref" href="#dt-stylesheet">stylesheet</a> to define the
namespace that will be used for an unprefixed element name or type
name within an XPath expression, and in certain other contexts
listed below.</p>
<p>The value of the attribute is the namespace URI to be used.</p>
<p>For any element in the <a title="stylesheet" class="termref"
href="#dt-stylesheet">stylesheet</a>, this attribute has an
effective value, which is the value of the
<code>[xsl:]xpath-default-namespace</code> on that element or on
the innermost containing element that specifies such an attribute,
or the zero-length string if no containing element specifies such
an attribute.</p>
<p>For any element in the <a title="stylesheet" class="termref"
href="#dt-stylesheet">stylesheet</a>, the effective value of this
attribute determines the value of the <em>default namespace for
element and type names</em> in the static context of any XPath
expression contained in an attribute <span>or text node</span> of
that element (including XPath expressions in <a title=
"attribute value template" class="termref" href=
"#dt-attribute-value-template">attribute value templates</a>
<span>and <a title="text value template" class="termref" href=
"#dt-text-value-template">text value templates</a></span>). The
effect of this is specified in <a href="#xpath-30">[XPath 3.0]</a>;
in summary, it determines the namespace used for any unprefixed
type name in the <code>SequenceType</code> production, and for any
element name appearing in a path expression or in the
<code>SequenceType</code> production.</p>
<p>The effective value of this attribute similarly applies to any
of the following constructs appearing within its scope:</p>
<ul>
<li>
<p>any unprefixed element name or type name used in a <a title=
"pattern" class="termref" href="#dt-pattern">pattern</a></p>
</li>
<li>
<p>any unprefixed element name used in the <code>elements</code>
attribute of the <a href=
"#element-strip-space"><code>xsl:strip-space</code></a> or <a href=
"#element-preserve-space"><code>xsl:preserve-space</code></a>
instructions</p>
</li>
<li>
<p>any unprefixed element name or type name used in the
<code>as</code> attribute of an <a title="XSLT element" class=
"termref" href="#dt-xslt-element">XSLT element</a></p>
</li>
<li>
<p>any unprefixed type name used in the <code>type</code> attribute
of an <a title="XSLT element" class="termref" href=
"#dt-xslt-element">XSLT element</a></p>
</li>
<li>
<p>any unprefixed type name used in the <code>xsl:type</code>
attribute of a <a title="literal result element" class="termref"
href="#dt-literal-result-element">literal result element</a>.</p>
</li>
</ul>
<p>The <code>[xsl:]xpath-default-namespace</code> attribute
<span class="verb">must</span> be in the <a title="XSLT namespace"
class="termref" href="#dt-xslt-namespace">XSLT namespace</a> if and
only if its parent element is <em>not</em> in the XSLT
namespace.</p>
<p>If the effective value of the attribute is a zero-length string,
which will be the case if it is explicitly set to a zero-length
string or if it is not specified at all, then an unprefixed element
name or type name refers to a name that is in no namespace. The
default namespace of the parent element (see <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#ElementNode">Section 6.2
Element Nodes</a> <sup><small>DM30</small></sup>) is <em>not</em>
used.</p>
<p>The attribute does not affect other names, for example function
names, variable names, or template names, or strings that are
interpreted as <a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QNames</a> during stylesheet
evaluation, such as the <a title="effective value" class="termref"
href="#dt-effective-value">effective value</a> of the
<code>name</code> attribute of <a href=
"#element-element"><code>xsl:element</code></a> or the string
supplied as the first argument to the <a href=
"#func-key"><code>key</code></a> function.</p>
</div>
<div class="div2">
<h3><a name="expressions" id="expressions"></a>5.3 <a href=
"#expressions" style="text-decoration: none">Expressions</a></h3>
<p>XSLT uses the expression language defined by <span>XPath
3.0</span> <a href="#xpath-30">[XPath 3.0]</a>. Expressions are
used in XSLT for a variety of purposes including:</p>
<ul>
<li>
<p>selecting nodes for processing;</p>
</li>
<li>
<p>specifying conditions for different ways of processing a
node;</p>
</li>
<li>
<p>generating text to be inserted in a <a title="result tree"
class="termref" href="#dt-result-tree">result tree</a>.</p>
</li>
</ul>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-expression" id="dt-expression" title="expression"></a>Within
this specification, the term <b>XPath expression</b>, or simply
<b>expression</b>, means a string that matches the production
<a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-Expr">Expr</a><sup><small>XP30</small></sup>
defined in <a href="#xpath-30">[XPath 3.0]</a>.<span class=
"definition">]</span></p>
<p>An XPath expression may occur as the value of certain attributes
on XSLT-defined elements, and also within curly brackets in
<a title="attribute value template" class="termref" href=
"#dt-attribute-value-template">attribute value templates</a>
<span>and <a title="text value template" class="termref" href=
"#dt-text-value-template">text value templates</a></span>.</p>
<p>Except where <a title="forwards compatible behavior" class=
"termref" href="#dt-forwards-compatible-behavior">forwards
compatible behavior</a> is enabled (see <a href="#forwards"><i>3.11
Forwards Compatible Processing</i></a>), it is a <a title=
"static error" class="termref" href="#dt-static-error">static
error</a> if the value of such an attribute, or the text between
curly brackets in an <a title="attribute value template" class=
"termref" href="#dt-attribute-value-template">attribute value
template</a> <span>or <a title="text value template" class=
"termref" href="#dt-text-value-template">text value
template</a></span>, does not match the XPath production <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-Expr">Expr</a><sup><small>XP30</small></sup>,
or if it fails to satisfy other static constraints defined in the
XPath specification, for example that all variable references
<span class="verb">must</span> refer to <a title="variable" class=
"termref" href="#dt-variable">variables</a> that are in scope.
Error codes are defined in <a href="#xpath-30">[XPath 3.0]</a>.</p>
<p>The transformation fails with a <a title="dynamic error" class=
"termref" href="#dt-dynamic-error">dynamic error</a> if any XPath
<a title="expression" class="termref" href=
"#dt-expression">expression</a> is evaluated and raises a dynamic
error. Error codes are defined in <a href="#xpath-30">[XPath
3.0]</a>.</p>
<p>The transformation fails with a <a title="type error" class=
"termref" href="#dt-type-error">type error</a> if an XPath
<a title="expression" class="termref" href=
"#dt-expression">expression</a> raises a type error, or if the
result of evaluating the XPath <a title="expression" class=
"termref" href="#dt-expression">expression</a> is evaluated and
raises a type error, or if the XPath processor signals a type error
during static analysis of an <a title="expression" class="termref"
href="#dt-expression">expression</a>. Error codes are defined in
<a href="#xpath-30">[XPath 3.0]</a>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-required-type" id="dt-required-type" title=
"required type"></a>The context within a <a title="stylesheet"
class="termref" href="#dt-stylesheet">stylesheet</a> where an XPath
<a title="expression" class="termref" href=
"#dt-expression">expression</a> appears may specify the <b>required
type</b> of the expression. The required type indicates the type of
the value that the expression is expected to return.<span class=
"definition">]</span> If no required type is specified, the
expression may return any value: in effect, the required type is
then <code>item()*</code>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-function-conversion-rules" id="dt-function-conversion-rules"
title="function conversion rules"></a> When used in this
specification without further qualification, the term <b>function
conversion rules</b> means the function conversion rules defined in
<a href="#xpath-30">[XPath 3.0]</a>, applied with XPath 1.0
compatibility mode set to false.<span class=
"definition">]</span></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>These are the rules defined in <a href="#xpath-30">[XPath
3.0]</a> for converting the supplied argument of a function call to
the required type of that argument, as defined in the function
signature. The same rules are used in XSLT for converting the value
of a variable to the declared type of the variable, or the result
of evaluating a function or template body to the declared type of
the function or template. They are also used when parameters are
supplied to a template using <a href=
"#element-with-param"><code>xsl:with-param</code></a>. In all such
cases, the rules that apply are the XPath 3.0 rules without XPath
1.0 compatibility mode. The rules with XPath 1.0 compatibility mode
set to true are used only for XPath function calls, and for the
operands of certain XPath operators.</p>
</div>
<p>This specification also invokes the <span>XPath 3.0</span>
<a title="function conversion rules" class="termref" href=
"#dt-function-conversion-rules">function conversion rules</a> to
convert the result of evaluating an XSLT <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> to a required
type (for example, the sequence constructor enclosed in an <a href=
"#element-variable"><code>xsl:variable</code></a>, <a href=
"#element-template"><code>xsl:template</code></a>, or <a href=
"#element-function"><code>xsl:function</code></a> element).</p>
<p>Any <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> or <a title="type error"
class="termref" href="#dt-type-error">type error</a> that occurs
when applying the <a title="function conversion rules" class=
"termref" href="#dt-function-conversion-rules">function conversion
rules</a> to convert a value to a required type results in the
transformation failing, in the same way as if the error had
occurred while evaluating an expression.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Note the distinction between the two kinds of error that may
occur. Attempting to convert an integer to a date is a type error,
because such a conversion is never possible. Type errors can be
reported statically if they can be detected statically, whether or
not the construct in question is ever evaluated. Attempting to
convert the string <code>2003-02-29</code> to a date is a dynamic
error rather than a type error, because the problem is with this
particular value, not with its type. Dynamic errors are reported
only if the instructions or expressions that cause them are
actually evaluated.</p>
</div>
</div>
<div class="div2">
<h3><a name="static-and-dynamic-context" id=
"static-and-dynamic-context"></a>5.4 <a href=
"#static-and-dynamic-context" style="text-decoration: none">The
Static and Dynamic Context</a></h3>
<p>XPath defines the concept of an <a href=
"http://www.w3.org/TR/xpath-30/#dt-expression-context">expression
context</a><sup><small>XP30</small></sup> which contains all the
information that can affect the result of evaluating an <a title=
"expression" class="termref" href="#dt-expression">expression</a>.
The expression context has two parts, the <a href=
"http://www.w3.org/TR/xpath-30/#dt-static-context">static
context</a><sup><small>XP30</small></sup>, and the <a href=
"http://www.w3.org/TR/xpath-30/#dt-dynamic-context">dynamic
context</a><sup><small>XP30</small></sup>. The components that make
up the expression context are defined in the XPath specification
(see <a href="http://www.w3.org/TR/xpath-30/#context">Section 2.1
Expression Context</a> <sup><small>XP30</small></sup>). This
section describes the way in which these components are initialized
when an XPath expression is contained within an XSLT
stylesheet.</p>
<p>As well as providing values for the static and dynamic context
components defined in the XPath specification, XSLT defines
additional context components of its own. These context components
are used by XSLT instructions (for example, <a href=
"#element-next-match"><code>xsl:next-match</code></a> and <a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a>), and
also by the functions in the extended function library described in
this specification.</p>
<p>The following four sections describe:</p>
<blockquote>
<p><a href="#static-context"><i>5.4.1 Initializing the Static
Context</i></a><br />
<a href="#additional-static-context"><i>5.4.2 Additional Static
Context Components used by XSLT</i></a><br />
<a href="#xpath-dynamic-context"><i>5.4.3 Initializing the Dynamic
Context</i></a><br />
<a href="#additional-dynamic-context"><i>5.4.4 Additional Dynamic
Context Components used by XSLT</i></a></p>
</blockquote>
<div class="div3">
<h4><a name="static-context" id="static-context"></a>5.4.1 <a href=
"#static-context" style="text-decoration: none">Initializing the
Static Context</a></h4>
<p>The <a href=
"http://www.w3.org/TR/xpath-30/#dt-static-context">static
context</a><sup><small>XP30</small></sup> of an XPath expression
appearing in an XSLT stylesheet is initialized as follows. In these
rules, the term <b>containing element</b> means the element within
the stylesheet that is the parent of the attribute <span>or text
node</span> whose value contains the XPath expression in question,
and the term <b>enclosing element</b> means the containing element
or any of its ancestors.</p>
<ul>
<li>
<p><a title="XPath 1.0 compatibility mode" class="termref" href=
"#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is set to
true if and only if the containing element is processed with
<a title="XSLT 1.0 behavior" class="termref" href=
"#dt-xslt-10-behavior">XSLT 1.0 behavior</a> (see <a href=
"#backwards"><i>3.10 Backwards Compatible Processing</i></a>).</p>
</li>
<li>
<p>The <a href=
"http://www.w3.org/TR/xpath-30/#dt-static-namespaces">statically
known namespaces</a><sup><small>XP30</small></sup> are the
namespace declarations that are in scope for the containing
element.</p>
</li>
<li>
<p>The <a href=
"http://www.w3.org/TR/xpath-30/#dt-def-elemtype-ns">default
element/type namespace</a><sup><small>XP30</small></sup> is the
namespace defined by the <code>[xsl:]xpath-default-namespace</code>
attribute on the innermost enclosing element that has such an
attribute, as described in <a href="#unprefixed-qnames"><i>5.2
Unprefixed Lexical QNames in Expressions and Patterns</i></a>. The
value of this attribute is a namespace URI. If there is no
<code>[xsl:]xpath-default-namespace</code> attribute on an
enclosing element, the default namespace for element names and type
names is the null namespace.</p>
</li>
<li>
<p>The <a href=
"http://www.w3.org/TR/xpath-30/#dt-def-fn-ns">default function
namespace</a><sup><small>XP30</small></sup> is the <a title=
"standard function namespace" class="termref" href=
"#dt-standard-function-namespace">standard function namespace</a>,
defined in <a href="#xpath-functions-30">[Functions and
Operators]</a>. This means that it is not necessary to declare this
namespace in the <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a>, nor is it necessary to use the
prefix <code>fn</code> (or any other prefix) in calls to
<span>functions</span> <span>in this namespace</span>.</p>
</li>
<li>
<p>The <a href="http://www.w3.org/TR/xpath-30/#dt-issd">in-scope
schema definitions</a><sup><small>XP30</small></sup> for the XPath
expression are the same as the <a title="in-scope schema component"
class="termref" href="#dt-in-scope-schema-component">in-scope
schema components</a> for the <a title="stylesheet" class="termref"
href="#dt-stylesheet">stylesheet</a>, and are as specified in
<a href="#built-in-types"><i>3.15 Built-in Types</i></a>.</p>
</li>
<li>
<p>The <a href=
"http://www.w3.org/TR/xpath-30/#dt-in-scope-variables">in-scope
variables</a><sup><small>XP30</small></sup> are defined by the
<a title="variable-binding element" class="termref" href=
"#dt-variable-binding-element">variable binding elements</a> that
are in scope for the containing element (see <a href=
"#variables-and-parameters"><i>9 Variables and
Parameters</i></a>).</p>
</li>
<li>
<p>The <a href=
"http://www.w3.org/TR/xpath-30/#dt-context-item-static-type">context
item static type</a><sup><small>XP30</small></sup> may be
determined by an XSLT processor that performs static type
inferencing, using rules that are outside the scope of this
specification; if no static type inferencing is done, then the
context item static type for every XPath expression is
<code>item()</code>. <span>Note that some limited static type
inferencing is required in the case of a processor that performs
streamability analysis: see <a href=
"#determining-static-type"><i>19.2 Determining the Static Type of a
Construct</i></a>.</span></p>
</li>
<li>
<p>The <a href=
"http://www.w3.org/TR/xpath-30/#dt-known-func-signatures">Statically
known function signatures</a><sup><small>XP30</small></sup>
are:</p>
<ul>
<li>
<p>The functions defined in <a href=
"#xpath-functions-30">[Functions and Operators]</a> in namespaces
<code>http://www.w3.org/2005/xpath-functions</code> and
<code>http://www.w3.org/2005/xpath-functions/math</code>;</p>
</li>
<li>
<p>The functions defined in this specification in namespaces
<code>http://www.w3.org/2005/xpath-functions</code> and
<code>http://www.w3.org/2005/xpath-functions/map</code>;</p>
</li>
<li>
<p>Constructor functions for all the <span>simple</span> types in
the <a href="http://www.w3.org/TR/xpath-30/#dt-issd">in-scope
schema definitions</a><sup><small>XP30</small></sup>, including
both built-in types and user-defined types;</p>
</li>
<li>
<p>The <a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet functions</a> defined in the
containing <a title="package" class="termref" href=
"#dt-package">package</a>;</p>
</li>
<li>
<p>Stylesheet functions defined in used packages, subject to
visibility: see <a href="#package-dependencies"><i>3.6.2
Dependencies between Packages</i></a>;</p>
</li>
<li>
<p>any <a title="extension function" class="termref" href=
"#dt-extension-function">extension functions</a> bound using
<a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> mechanisms
(see <a href="#extension"><i>23 Extensibility and
Fallback</i></a>).</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The term <a title="extension function" class="termref" href=
"#dt-extension-function">extension function</a> includes both
vendor-supplied and user-written extension functions.</p>
</div>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>It follows from the above that a conformant XSLT processor must
implement the entire library of <a title="core function" class=
"termref" href="#dt-core-function">core functions</a>.</p>
</div>
</li>
<li>
<p>The <a href=
"http://www.w3.org/TR/xpath-30/#dt-static-collations">statically
known collations</a><sup><small>XP30</small></sup> are <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. However,
the set of in-scope collations <span class="verb">must</span>
always include the Unicode codepoint collation, defined in <a href=
"http://www.w3.org/TR/xpath-functions-30/#string-compare">Section
5.3 Comparison of strings</a> <sup><small>FO30</small></sup>.</p>
</li>
<li>
<p>The <a href=
"http://www.w3.org/TR/xpath-30/#dt-def-collation">default
collation</a><sup><small>XP30</small></sup> is defined by the value
of the <code>[xsl:]default-collation</code> attribute on the
innermost enclosing element that has such an attribute. For
details, see <a href="#default-collation-attribute"><i>3.8.1 The
default-collation Attribute</i></a>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-default-collation" id="dt-default-collation" title=
"default collation"></a>In this specification the term <b>default
collation</b> means the collation that is used by XPath operators
such as <code>eq</code> and <code>lt</code> appearing in XPath
expressions within the stylesheet.<span class=
"definition">]</span></p>
<p>This collation is also used by default when comparing strings in
the evaluation of the <a href=
"#element-key"><code>xsl:key</code></a> and <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
elements. This <span class="verb">may</span> also (but need not
necessarily) be the same as the default collation used for <a href=
"#element-sort"><code>xsl:sort</code></a> elements within the
stylesheet. Collations used by <a href=
"#element-sort"><code>xsl:sort</code></a> are described in <a href=
"#collating-sequences"><i>13.1.3 Sorting Using
Collations</i></a>.</p>
</li>
<li>
<p>The <b>base URI</b> is the base URI of the containing element in
the stylesheet. The concept of the base URI of a node is defined in
<a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dm-base-uri">Section 5.2
base-uri Accessor</a> <sup><small>DM30</small></sup></p>
</li>
<li>
<p>The set of <a href=
"http://www.w3.org/TR/xpath-30/#dt-known-docs">statically known
documents</a><sup><small>XP30</small></sup> is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
</li>
<li>
<p>The set of <a href=
"http://www.w3.org/TR/xpath-30/#dt-known-collections">statically
known collections</a><sup><small>XP30</small></sup> is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
</li>
<li>
<p>The <a href=
"http://www.w3.org/TR/xpath-30/#dt-known-default-collection">statically
known default collection type</a><sup><small>XP30</small></sup> is
<a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
</li>
<li>
<p>The set of <a href=
"http://www.w3.org/TR/xpath-30/#dt-static-decimal-formats">statically
known decimal formats</a><sup><small>XP30</small></sup> is the set
of decimal formats defined by <a href=
"#element-decimal-format"><code>xsl:decimal-format</code></a>
declarations in the stylesheet.</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="additional-static-context" id=
"additional-static-context"></a>5.4.2 <a href=
"#additional-static-context" style=
"text-decoration: none">Additional Static Context Components used
by XSLT</a></h4>
<p>Some of the components of the XPath static context are used also
by <a title="XSLT element" class="termref" href=
"#dt-xslt-element">XSLT elements</a>. For example, the <a href=
"#element-sort"><code>xsl:sort</code></a> element makes use of the
collations defined in the static context, and attributes such as
<code>type</code> and <code>as</code> may reference types defined
in the <a title="in-scope schema component" class="termref" href=
"#dt-in-scope-schema-component">in-scope schema components</a>.</p>
<p>Many top-level declarations in a stylesheet, and attributes on
the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>
element, affect the behavior of instructions within the stylesheet.
Each of these constructs is described in its appropriate place in
this specification.</p>
<p>A number of these constructs are of particular significance
because they are used by functions defined in XSLT, which are added
to the library of functions available for use in XPath expressions
within the stylesheet. These are:</p>
<ul>
<li>
<p>The set of named keys, used by the <a href=
"#func-key"><code>key</code></a> function</p>
</li>
<li>
<p>The values of system properties, used by the <a href=
"#func-system-property"><code>system-property</code></a>
function</p>
</li>
<li>
<p>The set of available instructions, used by the <a href=
"#func-element-available"><code>element-available</code></a>
function</p>
</li>
</ul>
<p>A dynamic function call clears the first of these components:
this means that a dynamic call to the <a href=
"#func-key"><code>key</code></a> function will always raise a
dynamic error (the key name is unknown). The values of system
properties and the set of available instructions, by contrast,
reflect the capabilities and configuration of the processor rather
than values specific to the stylesheet code itself; the result of a
dynamic call to <a href=
"#func-system-property"><code>system-property</code></a> or
<a href="#func-element-available"><code>element-available</code></a>
will reflect the information available to the processor at
evaluation time.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>If these functions are called within a <a title=
"static expression" class="termref" href=
"#dt-static-expression">static expression</a>, the results will
reflect the capabilities and configuration of the processor used to
perform static analysis, while if they are called elsewhere, the
results should reflect the capabilities and configuration of the
processor used to perform dynamic evaluation, which might give a
different result. These calls should not be pre-evaluated at
compile time unless it is known that this will give the same
result.</p>
</div>
</div>
<div class="div3">
<h4><a name="xpath-dynamic-context" id=
"xpath-dynamic-context"></a>5.4.3 <a href="#xpath-dynamic-context"
style="text-decoration: none">Initializing the Dynamic
Context</a></h4>
<p>For convenience, the dynamic context is described in two parts:
the <a title="focus" class="termref" href="#dt-focus">focus</a>,
which represents the place in the source document that is currently
being processed, and a collection of additional context
variables.</p>
<p>A number of functions specified in <a href=
"#xpath-functions-30">[Functions and Operators]</a> are defined to
be <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
meaning that if they are called twice during the same <a href=
"http://www.w3.org/TR/xpath-functions-30/#execution-scope">execution
scope</a><sup><small>FO30</small></sup>, with the same arguments,
then they return the same results (see <a href=
"http://www.w3.org/TR/xpath-functions-30/#terminology">Section 1.6
Terminology</a> <sup><small>FO30</small></sup>). In XSLT, the
execution of a stylesheet defines the execution scope. This means,
for example, that if the function <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-current-dateTime"><code>
current-dateTime</code></a><sup><small>FO30</small></sup> is called
repeatedly during a transformation, it produces the same result
each time. By implication, the components of the dynamic context on
which these functions depend are also stable for the duration of
the transformation. Specifically, the following components defined
in <a href="http://www.w3.org/TR/xpath-30/#eval_context">Section
2.1.2 Dynamic Context</a> <sup><small>XP30</small></sup> must be
stable: <em>function implementations</em>, <em>current
dateTime</em>, <em>implicit timezone</em>, <em>available
documents</em>, <em>available collections</em>, and <em>default
collection</em>. The values of global variables and stylesheet
parameters are also stable for the duration of a transformation.
The focus is <em>not</em> stable; the additional dynamic context
components defined in <a href=
"#additional-dynamic-context"><i>5.4.4 Additional Dynamic Context
Components used by XSLT</i></a> are also <em>not</em> stable.</p>
<p>As specified in <a href="#xpath-functions-30">[Functions and
Operators]</a>, implementations may provide user options that relax
the requirement for the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-collection"><code>collection</code></a><sup><small>FO30</small></sup>
functions (and therefore, by implication, the <a href=
"#func-document"><code>document</code></a> function) to return
stable results. By default, however, the functions must be stable.
The manner in which such user options are provided, if at all, is
<a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
<p>XPath expressions contained in <code>[xsl:]use-when</code>
attributes are not considered to be evaluated "during the
transformation" as defined above. For details see <a href=
"#conditional-inclusion"><i>3.14.1 Conditional Element
Inclusion</i></a>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-absent" id="dt-absent" title="absent"></a>A component of the
context that has no value is said to be <b>absent</b>.<span class=
"definition">]</span> This is a distinguishable state, and is not
the same as having the empty sequence as its value.</p>
<div class="div4">
<h5><a name="focus" id="focus"></a>5.4.3.1 <a href="#focus" style=
"text-decoration: none">Maintaining Position: the Focus</a></h5>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-focus" id="dt-focus" title="focus"></a>When a <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> is evaluated,
the <a title="processor" class="termref" href=
"#dt-processor">processor</a> keeps track of which items are being
processed by means of a set of implicit variables referred to
collectively as the <b>focus</b>.<span class="definition">]</span>
More specifically, the focus consists of the following three
values:</p>
<ul>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-context-item" id="dt-context-item" title="context item"></a>The
<b>context item</b> is the item currently being processed. An item
(see <a href="#xpath-datamodel-30">[Data Model]</a>) is either an
atomic value (such as an integer, date, or string), a node,
<span>or a function item</span>. It changes whenever instructions
such as <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a> and
<a href="#element-for-each"><code>xsl:for-each</code></a> are used
to process a sequence of items; each item in such a sequence
becomes the context item while that item is being
processed.<span class="definition">]</span> The context item is
returned by the XPath <a title="expression" class="termref" href=
"#dt-expression">expression</a> <code>.</code> (dot).</p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-context-position" id="dt-context-position" title=
"context position"></a>The <b>context position</b> is the position
of the context item within the sequence of items currently being
processed. It changes whenever the context item changes. When an
instruction such as <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a> or
<a href="#element-for-each"><code>xsl:for-each</code></a> is used
to process a sequence of items, the first item in the sequence is
processed with a context position of 1, the second item with a
context position of 2, and so on.<span class="definition">]</span>
The context position is returned by the XPath <a title="expression"
class="termref" href="#dt-expression">expression</a>
<code>position()</code>.</p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-context-size" id="dt-context-size" title="context size"></a>The
<b>context size</b> is the number of items in the sequence of items
currently being processed. It changes whenever instructions such as
<a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a> and
<a href="#element-for-each"><code>xsl:for-each</code></a> are used
to process a sequence of items; during the processing of each one
of those items, the context size is set to the count of the number
of items in the sequence (or equivalently, the position of the last
item in the sequence).<span class="definition">]</span> The context
size is returned by the XPath <a title="expression" class="termref"
href="#dt-expression">expression</a> <code>last()</code>.</p>
</li>
</ul>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-context-node" id="dt-context-node" title="context node"></a>If
the <a title="context item" class="termref" href=
"#dt-context-item">context item</a> is a node (as distinct from an
atomic value such as an integer), then it is also referred to as
the <b>context node</b>. The context node is not an independent
variable, it changes whenever the context item changes. When the
context item is an atomic value <span>or a function item</span>,
there is no context node.<span class="definition">]</span> The
context node is returned by the XPath <a title="expression" class=
"termref" href="#dt-expression">expression</a>
<code>self::node()</code>, and it is used as the starting node for
all relative path expressions.</p>
<p>Where the containing element of an XPath expression is an
<a title="instruction" class="termref" href=
"#dt-instruction">instruction</a> or a <a title=
"literal result element" class="termref" href=
"#dt-literal-result-element">literal result element</a>, the
initial context item, context position, and context size for the
XPath <a title="expression" class="termref" href=
"#dt-expression">expression</a> are the same as the <a title=
"context item" class="termref" href="#dt-context-item">context
item</a>, <a title="context position" class="termref" href=
"#dt-context-position">context position</a>, and <a title=
"context size" class="termref" href="#dt-context-size">context
size</a> for the evaluation of the containing instruction or
literal result element.</p>
<p><span>The context item for evaluating global variables in the
<a title="top-level package" class="termref" href=
"#dt-top-level-package">top-level package</a> is set to the
<span><a title="global context item" class="termref" href=
"#dt-global-context-item">global context item</a></span> supplied
when the transformation is invoked (see <a href=
"#initiating"><i>2.3 Initiating a Transformation</i></a>).</span>
<span>In <a title="library package" class="termref" href=
"#dt-library-package">library packages</a>, the context item for
evaluating global variables is <a title="absent" class="termref"
href="#dt-absent">absent</a></span>.</p>
<p>For an XPath expression contained in a <a title="value template"
class="termref" href="#dt-value-template">value template</a>, the
initial context item, context position, and context size for the
XPath <a title="expression" class="termref" href=
"#dt-expression">expression</a> are the same as the <a title=
"context item" class="termref" href="#dt-context-item">context
item</a>, <a title="context position" class="termref" href=
"#dt-context-position">context position</a>, and <a title=
"context size" class="termref" href="#dt-context-size">context
size</a> for the evaluation of the containing <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>.</p>
<p>In other cases (for example, where the containing element is
<a href="#element-sort"><code>xsl:sort</code></a>, <a href=
"#element-with-param"><code>xsl:with-param</code></a>, or <a href=
"#element-key"><code>xsl:key</code></a>), the rules are given in
the specification of the containing element.</p>
<p>The <a href="#func-current"><code>current</code></a> function
can be used within any XPath <a title="expression" class="termref"
href="#dt-expression">expression</a> to select the item that was
supplied as the context item to the XPath expression by the XSLT
processor. Unlike <code>.</code> (dot) this is unaffected by
changes to the context item that occur within the XPath expression.
The <a href="#func-current"><code>current</code></a> function is
described in <a href="#func-current"><i>20.3.1
fn:current</i></a>.</p>
<p>On completion of an instruction that changes the <a title=
"focus" class="termref" href="#dt-focus">focus</a> (such as
<a href="#element-apply-templates"><code>xsl:apply-templates</code></a>
or <a href="#element-for-each"><code>xsl:for-each</code></a>), the
focus reverts to its previous value.</p>
<p>When a <a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet function</a> is called, the
focus within the body of the function is initially <a title=
"absent" class="termref" href="#dt-absent">absent</a>.</p>
<p>When the focus is <a title="absent" class="termref" href=
"#dt-absent">absent</a>, evaluation of any <a title="expression"
class="termref" href="#dt-expression">expression</a> that
references the context item, context position, or context size
results in a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> <a href=
"http://www.w3.org/TR/xpath-30/#ERRXPDY0002" title=
"XPDY0002"><span class="error">[ERR XPDY0002]</span></a>
<sup><small>XP30</small></sup></p>
<p>The description above gives an outline of the way the <a title=
"focus" class="termref" href="#dt-focus">focus</a> works. Detailed
rules for the effect of each instruction are given separately with
the description of that instruction. In the absence of specific
rules, an instruction uses the same focus as its parent
instruction.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-singleton-focus" id="dt-singleton-focus" title=
"singleton focus"></a>A <b>singleton focus</b> based on an item
<var>J</var> has the <span><a title="context item" class="termref"
href="#dt-context-item">context item</a> (and therefore the
<a title="context node" class="termref" href=
"#dt-context-node">context node</a>, if <var>J</var> is a
node)</span> set to <var>J</var>, and the <a title=
"context position" class="termref" href=
"#dt-context-position">context position</a> and <a title=
"context size" class="termref" href="#dt-context-size">context
size</a> both set to 1 (one).<span class="definition">]</span></p>
</div>
<div class="div4">
<h5><a name="evaluation-context" id=
"evaluation-context"></a>5.4.3.2 <a href="#evaluation-context"
style="text-decoration: none">Other Components of the XPath Dynamic
Context</a></h5>
<p>The previous section explained how the <a title="focus" class=
"termref" href="#dt-focus">focus</a> for an XPath expression
appearing in an XSLT stylesheet is initialized. This section
explains how the other components of the <a href=
"http://www.w3.org/TR/xpath-30/#dt-dynamic-context">dynamic
context</a><sup><small>XP30</small></sup> of an XPath expression
are initialized.</p>
<ul>
<li>
<p>The <a href=
"http://www.w3.org/TR/xpath-30/#dt-variable-values">dynamic
variables</a><sup><small>XP30</small></sup> are the current values
of the in-scope <a title="variable-binding element" class="termref"
href="#dt-variable-binding-element">variable binding
elements</a>.</p>
</li>
<li>
<p>The <em>current date and time</em> represents an <a title=
"implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a> point
in time during processing of the transformation; it does not change
during the course of the transformation.</p>
</li>
<li>
<p>The <a href=
"http://www.w3.org/TR/xpath-30/#dt-timezone">implicit
timezone</a><sup><small>XP30</small></sup> is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
</li>
<li>
<p>The <a href=
"http://www.w3.org/TR/xpath-30/#dt-known-docs">available
documents</a><sup><small>XP30</small></sup>, and the <a href=
"http://www.w3.org/TR/xpath-30/#dt-known-collections">available
collections</a><sup><small>XP30</small></sup> are determined as
part of the process for initiating a transformation (see <a href=
"#initiating"><i>2.3 Initiating a Transformation</i></a>).</p>
<p>The <a href=
"http://www.w3.org/TR/xpath-30/#dt-known-docs">available
documents</a><sup><small>XP30</small></sup> are defined as part of
the <span>XPath 3.0</span> dynamic context to support the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>
function, but this component is also referenced by the similar XSLT
<a href="#func-document"><code>document</code></a> function: see
<a href="#func-document"><i>20.1 fn:document</i></a>. This variable
defines a mapping between URIs passed to the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>
or <a href="#func-document"><code>document</code></a> function and
the document nodes that are returned.</p>
<p>The mapping from URIs to document nodes is affected by <a href=
"#element-strip-space"><code>xsl:strip-space</code></a>
declarations and by the <code>input-type-annotations</code>
attribute, and may therefore vary from one package to another.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Defining this as part of the evaluation context is a formal way
of specifying that the way in which URIs get turned into document
nodes is outside the control of the language specification, and
depends entirely on the run-time environment in which the
transformation takes place.</p>
</div>
<p>The XSLT-defined <a href=
"#func-document"><code>document</code></a> function allows the use
of URI references containing fragment identifiers. The
interpretation of a fragment identifier depends on the media type
of the resource representation. Therefore, the information supplied
in <a href="http://www.w3.org/TR/xpath-30/#dt-known-docs">available
documents</a><sup><small>XP30</small></sup> for XSLT processing
must provide not only a mapping from URIs to document nodes as
required by XPath, but also a mapping from URIs to media types.</p>
</li>
<li>
<p>The <a href=
"http://www.w3.org/TR/xpath-30/#dt-default-collection">default
collection</a><sup><small>XP30</small></sup> is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. This
allows options such as setting the default collection to be an
empty sequence, or to be <a title="absent" class="termref" href=
"#dt-absent">absent</a>.</p>
</li>
</ul>
</div>
</div>
<div class="div3">
<h4><a name="additional-dynamic-context" id=
"additional-dynamic-context"></a>5.4.4 <a href=
"#additional-dynamic-context" style=
"text-decoration: none">Additional Dynamic Context Components used
by XSLT</a></h4>
<p>In addition to the values that make up the <a title="focus"
class="termref" href="#dt-focus">focus</a>, an XSLT processor
maintains a number of other dynamic context components that reflect
aspects of the evaluation context. These components are fully
described in the sections of the specification that maintain and
use them. They are:</p>
<ul>
<li>
<p>The <a title="current template rule" class="termref" href=
"#dt-current-template-rule">current template rule</a>, which is the
<a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a> most recently invoked by an
<a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a>, or
<a href="#element-next-match"><code>xsl:next-match</code></a>
instruction: see <a href="#apply-imports"><i>6.8 Overriding
Template Rules</i></a>;</p>
</li>
<li>
<p>The <a title="current mode" class="termref" href=
"#dt-current-mode">current mode</a>, which is the <a title="mode"
class="termref" href="#dt-mode">mode</a> set by the most recent
call of <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
(for a full definition see <a href="#modes"><i>6.6
Modes</i></a>);</p>
</li>
<li>
<p>The <a title="current group" class="termref" href=
"#dt-current-group">current group</a> and <a title=
"current grouping key" class="termref" href=
"#dt-current-grouping-key">current grouping key</a>, which provide
information about the collection of items currently being processed
by an <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction: see <a href="#func-current-group"><i>14.2.1
fn:current-group</i></a> and <a href=
"#func-current-grouping-key"><i>14.2.2
fn:current-grouping-key</i></a>;</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In XSLT 3.0 the initial value of these two properties is
"absent", which means that any reference to their values causes a
dynamic error. Previously, the initial value was an empty
sequence.</p>
</div>
</li>
<li>
<p>The <a title="current merge group" class="termref" href=
"#dt-current-merge-group">current merge group</a> and <a title=
"current merge key" class="termref" href=
"#dt-current-merge-key">current merge key</a>, which provide
information about the collection of items currently being processed
by an <a href="#element-merge"><code>xsl:merge</code></a>
instruction.</p>
</li>
<li>
<p>The <a title="current captured substrings" class="termref" href=
"#dt-current-captured-substrings">current captured substrings</a>:
this is a sequence of strings, which is maintained when a string is
matched against a regular expression using the <a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a>
instruction, and which is accessible using the <a href=
"#func-regex-group"><code>regex-group</code></a> function: see
<a href="#func-regex-group"><i>17.2 fn:regex-group</i></a>.</p>
</li>
<li>
<p>The <a title="output state" class="termref" href=
"#dt-output-state">output state</a>: this is a flag whose two
possible values are <a title="final output state" class="termref"
href="#dt-final-output-state">final output state</a> and <a title=
"temporary output state" class="termref" href=
"#dt-temporary-output-state">temporary output state</a>. This flag
indicates whether instructions are currently writing to a <a title=
"final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a> or to an internal
data structure. The initial setting <span>when the stylesheeet is
invoked by executing a template</span> is <a title=
"final output state" class="termref" href=
"#dt-final-output-state">final output state</a>, and it is switched
to <a title="temporary output state" class="termref" href=
"#dt-temporary-output-state">temporary output state</a> by
instructions such as <a href=
"#element-variable"><code>xsl:variable</code></a>. For more
details, see <a href="#result-document-restrictions"><i>24.2
Restrictions on the use of xsl:result-document</i></a>.</p>
</li>
<li>
<p>The <a title="current output URI" class="termref" href=
"#dt-current-output-uri">current output URI</a>: this is the URI
associated with the result tree to which instructions are currently
writing. The current output URI is initially the same as the
<a title="base output URI" class="termref" href=
"#dt-base-output-uri">base output URI</a>. During the evaluation of
an <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction, the current output URI is set to the absolute URI
identified by the <code>href</code> attribute of that
instruction.</p>
</li>
</ul>
<p>The following non-normative table summarizes the initial state
of each of the components in the evaluation context, and the
instructions which cause the state of the component to change.</p>
<table border="1" cellpadding="5" summary=
"Components of the dynamic evaluation context" width="100%">
<thead>
<tr>
<th align="left" colspan="1" valign="top">Component</th>
<th align="left" colspan="1" valign="top">Initial Setting</th>
<th align="left" colspan="1" valign="top">Set by</th>
<th align="left" colspan="1" valign="top">Cleared by</th>
</tr>
</thead>
<tbody>
<tr>
<td valign="top" align="left"><a title="focus" class="termref"
href="#dt-focus">focus</a></td>
<td valign="top" align="left">See <a href="#initiating"><i>2.3
Initiating a Transformation</i></a>.</td>
<td valign="top" align="left"><a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href="#element-for-each"><code>xsl:for-each</code></a>, <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>,
<a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a>,
<span>evaluation of <a title="pattern" class="termref" href=
"#dt-pattern">patterns</a></span></td>
<td valign="top" align="left"><span>Calls to <a title=
"stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet functions</a></span></td>
</tr>
<tr>
<td valign="top" align="left"><a title="current template rule"
class="termref" href="#dt-current-template-rule">current template
rule</a></td>
<td valign="top" align="left">If a <a title="named template" class=
"termref" href="#dt-named-template">named template</a> is supplied
as the entry point to the transformation, then <span><a title=
"absent" class="termref" href="#dt-absent">absent</a></span>;
otherwise the <a title="initial named template" class="termref"
href="#dt-initial-named-template">initial named template</a></td>
<td valign="top" align="left"><a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a>,
<a href="#element-next-match"><code>xsl:next-match</code></a></td>
<td valign="top" align="left"><a href=
"#element-for-each"><code>xsl:for-each</code></a>, <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>,
<a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a>,
<span><a href="#element-iterate"><code>xsl:iterate</code></a>,
<a href="#element-stream"><code>xsl:stream</code></a>, <a href=
"#element-merge"><code>xsl:merge</code></a>, <a href=
"#element-evaluate"><code>xsl:evaluate</code></a>,</span> and
<span>calls to <a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet functions</a>, and dynamic
function calls</span>. Also cleared while evaluating global
variables or default values of stylesheet parameters,
<span><a title="pattern" class="termref" href=
"#dt-pattern">patterns</a></span>, and the sequence constructors
contained in <a href="#element-key"><code>xsl:key</code></a> and
<a href="#element-sort"><code>xsl:sort</code></a>.</td>
</tr>
<tr>
<td valign="top" align="left"><a title="current mode" class=
"termref" href="#dt-current-mode">current mode</a></td>
<td valign="top" align="left">the initial <a title="mode" class=
"termref" href="#dt-mode">mode</a></td>
<td valign="top" align="left"><a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a></td>
<td valign="top" align="left"><span>Calls to <a title=
"stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet functions</a></span>. Also
cleared while evaluating global variables and stylesheet
parameters, <span><a title="pattern" class="termref" href=
"#dt-pattern">patterns</a></span>, and the sequence constructor
contained in <a href="#element-key"><code>xsl:key</code></a> or
<a href="#element-sort"><code>xsl:sort</code></a>. Clearing the
current mode causes the current mode to be set to the default
(unnamed) mode.</td>
</tr>
<tr>
<td valign="top" align="left"><a title="current group" class=
"termref" href="#dt-current-group">current group</a></td>
<td valign="top" align="left"><span>absent</span></td>
<td valign="top" align="left"><a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a></td>
<td valign="top" align="left"><span>See <a href=
"#func-current-group"><i>14.2.1
fn:current-group</i></a>.</span></td>
</tr>
<tr>
<td valign="top" align="left"><a title="current grouping key"
class="termref" href="#dt-current-grouping-key">current grouping
key</a></td>
<td valign="top" align="left"><span>absent</span></td>
<td valign="top" align="left"><a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a></td>
<td valign="top" align="left"><span>See <a href=
"#func-current-grouping-key"><i>14.2.2
fn:current-grouping-key</i></a>.</span></td>
</tr>
<tr>
<td valign="top" align="left"><a title="current merge group" class=
"termref" href="#dt-current-merge-group"><span>current merge
group</span></a></td>
<td valign="top" align="left"><span>absent</span></td>
<td valign="top" align="left"><span><a href=
"#element-merge"><code>xsl:merge</code></a></span></td>
<td valign="top" align="left"><span>See <a href=
"#func-current-merge-group"><i>15.6.1
fn:current-merge-group</i></a>.</span></td>
</tr>
<tr>
<td valign="top" align="left"><span><a title="current merge key"
class="termref" href="#dt-current-merge-key">current merge
key</a></span></td>
<td valign="top" align="left"><span>absent</span></td>
<td valign="top" align="left"><span><a href=
"#element-merge"><code>xsl:merge</code></a></span></td>
<td valign="top" align="left"><span>See <a href=
"#func-current-merge-key"><i>15.6.2
fn:current-merge-key</i></a>.</span></td>
</tr>
<tr>
<td valign="top" align="left"><a title=
"current captured substrings" class="termref" href=
"#dt-current-captured-substrings">current captured
substrings</a></td>
<td valign="top" align="left">empty sequence</td>
<td valign="top" align="left"><a href=
"#element-matching-substring"><code>xsl:matching-substring</code></a></td>
<td valign="top" align="left"><a href=
"#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>;
<span>Calls to <a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet functions</a>, dynamic
function calls</span>, <span>evaluation of global variables,
stylesheet parameters, and <a title="pattern" class="termref" href=
"#dt-pattern">patterns</a></span></td>
</tr>
<tr>
<td valign="top" align="left"><a title="output state" class=
"termref" href="#dt-output-state">output state</a></td>
<td valign="top" align="left"><a title="final output state" class=
"termref" href="#dt-final-output-state">final output state</a></td>
<td valign="top" align="left">Set to <a title=
"temporary output state" class="termref" href=
"#dt-temporary-output-state">temporary output state</a> by
instructions such as <a href=
"#element-variable"><code>xsl:variable</code></a>, <a href=
"#element-attribute"><code>xsl:attribute</code></a>, etc., and by
calls on <a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet functions</a></td>
<td valign="top" align="left">None</td>
</tr>
<tr>
<td valign="top" align="left"><a title="current output URI" class=
"termref" href="#dt-current-output-uri">current output URI</a></td>
<td valign="top" align="left"><a title="base output URI" class=
"termref" href="#dt-base-output-uri">base output URI</a></td>
<td valign="top" align="left"><a href=
"#element-result-document"><code>xsl:result-document</code></a></td>
<td valign="top" align="left">Calls to <a title=
"stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet functions</a>, dynamic
function calls, evaluation of <a title="global variable" class=
"termref" href="#dt-global-variable">global variables</a>,
<a title="stylesheet parameter" class="termref" href=
"#dt-stylesheet-parameter">stylesheet parameters</a>, and <a title=
"pattern" class="termref" href="#dt-pattern">patterns</a>.</td>
</tr>
</tbody>
</table>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-initial-setting" id="dt-initial-setting" title=
"initial setting"></a>The <b>initial setting</b> of a component of
the dynamic context is used when evaluating <a title=
"global variable" class="termref" href="#dt-global-variable">global
variables</a> and <a title="stylesheet parameter" class="termref"
href="#dt-stylesheet-parameter">stylesheet parameters</a>, when
evaluating the <code>use</code> and <code>match</code> attributes
of <a href="#element-key"><code>xsl:key</code></a>, when evaluating
the <code>initial-value</code> of <a href=
"#element-accumulator"><code>xsl:accumulator</code></a> and the
<code>select</code> expressions or contained sequence constructors
of <a href=
"#element-accumulator-rule"><code>xsl:accumulator-rule</code></a><span class="definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-non-contextual-function-call" id=
"dt-non-contextual-function-call" title=
"non-contextual function call"></a>The term <b>non-contextual
function call</b> is used to refer to function calls that do not
pass the dynamic context to the called function. This includes all
calls on <a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet functions</a> and all <a href=
"http://www.w3.org/TR/xpath-30/#dt-dynamic-function-invocation">dynamic
function invocations</a><sup><small>XP30</small></sup>, (that is
calls to function items as permitted by XPath 3.0). <span>It
excludes calls to some functions in the namespace
<code>http://www.w3.org/2005/xpath-functions</code></span>, in
particular those that explicitly depend on the context, such as the
<a href="#func-current-group"><code>current-group</code></a> and
<a href="#func-regex-group"><code>regex-group</code></a> functions.
It is <a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> whether,
and under what circumstances, calls to <a title=
"extension function" class="termref" href=
"#dt-extension-function">extension functions</a> are
non-contextual.<span class="definition">]</span></p>
<p>Named function references (such as <code>position#0</code>) and
calls on <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>
function-lookup</code></a><sup><small>FO30</small></sup> (for
example, <code>function-lookup("position", 0)</code>) are defined
to retain the XPath static and dynamic context at the point of
invocation as part of the closure of the resulting function item,
and to use this preserved context when a dynamic function call is
subsequently made using the function item. This rule does not
extend to the XSLT extensions to the dynamic context defined in
this section. If a dynamic function call is made that depends on
the XSLT part of the dynamic context (for example,
<code>regex-group#1(2)</code>), then the relevant components of the
context are cleared as described in the table above.</p>
</div>
</div>
<div class="div2">
<h3><a name="defining-decimal-format" id=
"defining-decimal-format"></a>5.5 <a href=
"#defining-decimal-format" style="text-decoration: none">Defining a
Decimal Format</a></h3>
<p>The definition of the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-number"><code>
format-number</code></a><sup><small>FO30</small></sup> function is
now in <a href="#xpath-functions-30">[Functions and Operators]</a>.
What remains here is the definition of the <a href=
"#element-decimal-format"><code>xsl:decimal-format</code></a>
declaration, which provides the context for this function when used
in an XSLT stylesheet.</p>
<p class="element-syntax"><a name="element-decimal-format" id=
"element-decimal-format"></a><code>&lt;!-- Category: declaration
--&gt;<br />
&lt;xsl:decimal-format<br />
&#160;&#160;name? = <var>eqname</var><br />
&#160;&#160;decimal-separator? = <var>char</var><br />
&#160;&#160;grouping-separator? = <var>char</var><br />
&#160;&#160;infinity? = <var>string</var><br />
&#160;&#160;minus-sign? = <var>char</var><br />
&#160;&#160;exponent-separator? = <var>char</var><br />
&#160;&#160;NaN? = <var>string</var><br />
&#160;&#160;percent? = <var>char</var><br />
&#160;&#160;per-mille? = <var>char</var><br />
&#160;&#160;zero-digit? = <var>char</var><br />
&#160;&#160;digit? = <var>char</var><br />
&#160;&#160;pattern-separator? =
<var>char</var>&#160;/&gt;</code></p>
<p>The <a href=
"#element-decimal-format"><code>xsl:decimal-format</code></a>
element <span>sets the <b>statically known decimal formats</b>
component of the static context for XPath expressions, which</span>
controls the interpretation of a <a title="picture string" class=
"termref" href="#dt-picture-string">picture string</a> used by the
<a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-number"><code>
format-number</code></a><sup><small>FO30</small></sup>
function.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-picture-string" id="dt-picture-string" title=
"picture string"></a>The <b>picture string</b> is the string
supplied as the second argument of the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-number"><code>
format-number</code></a><sup><small>FO30</small></sup>
function.<span class="definition">]</span></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-number"><code>
format-number</code></a><sup><small>FO30</small></sup> function,
previously defined in this specification, is now defined in
<a href="#xpath-functions-30">[Functions and Operators]</a>.</p>
</div>
<p>A <span><a title="package" class="termref" href=
"#dt-package">package</a></span> may contain multiple <a href=
"#element-decimal-format"><code>xsl:decimal-format</code></a>
declarations and may include or import <a title="stylesheet module"
class="termref" href="#dt-stylesheet-module">stylesheet modules</a>
that also contain <a href=
"#element-decimal-format"><code>xsl:decimal-format</code></a>
declarations. The name of an <a href=
"#element-decimal-format"><code>xsl:decimal-format</code></a>
declaration is the value of its <code>name</code> attribute, if
any.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-decimal-format" id="dt-decimal-format" title=
"decimal format"></a>All the <a href=
"#element-decimal-format"><code>xsl:decimal-format</code></a>
declarations in a <span>package</span> that share the same name are
grouped into a named <b>decimal format</b>; those that have no name
are grouped into a single unnamed decimal format.<span class=
"definition">]</span></p>
<p>The attributes of the <a href=
"#element-decimal-format"><code>xsl:decimal-format</code></a>
declaration define the value of the corresponding attribute in the
relevant decimal format in the <a href=
"http://www.w3.org/TR/xpath-30/#dt-static-decimal-formats">Statically
known decimal formats</a><sup><small>XP30</small></sup> component
of the static context for all XPath expressions in the package. The
attribute names used in the XSLT 3.0 syntax are the same as the
attribute names used in the definition of the static context,
except that the <code>digit</code> attribute of <a href=
"#element-decimal-format"><code>xsl:decimal-format</code></a>
corresponds to the <code>digit-sign</code> attribute in the static
context.</p>
<p>The <code>exponent-separator</code> attribute is provided for
future use. It currently has no effect.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The <code>exponent-separator</code> anticipates possible future
changes to the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-number"><code>
format-number</code></a><sup><small>FO30</small></sup> function to
permit formatting of numbers in exponential notation.</p>
</div>
<p>The scope of an <a href=
"#element-decimal-format"><code>xsl:decimal-format</code></a> name
is the package in which it is declared; the name is available for
use only in calls to <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-number"><code>
format-number</code></a><sup><small>FO30</small></sup> that appear
within the same package.</p>
<p>If a <a title="package" class="termref" href=
"#dt-package">package</a> does not contain a declaration of the
unnamed decimal format, a declaration equivalent to an <a href=
"#element-decimal-format"><code>xsl:decimal-format</code></a>
element with no attributes is implied.</p>
<p>The attributes of the <a href=
"#element-decimal-format"><code>xsl:decimal-format</code></a>
declaration establish values for a number of variables used as
input to the algorithm followed by the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-number"><code>
format-number</code></a><sup><small>FO30</small></sup> function. An
outline of the purpose of each attribute is given below; however,
the definitive explanations are given <span>as part of the
specification of <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-number"><code>
format-number</code></a><sup><small>FO30</small></sup></span>.</p>
<p>For any named <a title="decimal format" class="termref" href=
"#dt-decimal-format">decimal format</a>, the effective value of
each attribute is taken from an <a href=
"#element-decimal-format"><code>xsl:decimal-format</code></a>
declaration that has that name, and that specifies an explicit
value for the required attribute. If there is no such declaration,
the default value of the attribute is used. If there is more than
one such declaration, the one with highest <a title=
"import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a> is used.</p>
<p>For any unnamed <a title="decimal format" class="termref" href=
"#dt-decimal-format">decimal format</a>, the effective value of
each attribute is taken from an <a href=
"#element-decimal-format"><code>xsl:decimal-format</code></a>
declaration that is unnamed, and that specifies an explicit value
for the required attribute. If there is no such declaration, the
default value of the attribute is used. If there is more than one
such declaration, the one with highest <a title="import precedence"
class="termref" href="#dt-import-precedence">import precedence</a>
is used.</p>
<p><a name="err-XTSE1290" id="err-XTSE1290"><span class=
"error">[ERR XTSE1290]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if a named
or unnamed <a title="decimal format" class="termref" href=
"#dt-decimal-format">decimal format</a> contains two conflicting
values for the same attribute in different <a href=
"#element-decimal-format"><code>xsl:decimal-format</code></a>
declarations having the same <a title="import precedence" class=
"termref" href="#dt-import-precedence">import precedence</a>,
unless there is another definition of the same attribute with
higher import precedence.</p>
<p>The following attributes control the interpretation of
characters in the <a title="picture string" class="termref" href=
"#dt-picture-string">picture string</a> supplied to the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-number"><code>
format-number</code></a><sup><small>FO30</small></sup> function,
and also specify characters that may appear in the result of
formatting the number. In each case the value <span class=
"verb">must</span> be a single character <span class="error">[see
<a href="#err-XTSE0020">ERR XTSE0020</a>]</span>.</p>
<ul>
<li>
<p><code>decimal-separator</code> specifies the character used for
the <var>decimal-separator-sign</var>; the default value is the
period character (<code>.</code>)</p>
</li>
<li>
<p><code>grouping-separator</code> specifies the character used for
the <var>grouping-sign</var>, which is typically used as a
thousands separator; the default value is the comma character
(<code>,</code>)</p>
</li>
<li>
<p><code>percent</code> specifies the character used for the
<var>percent-sign</var>; the default value is the percent character
(<code>%</code>)</p>
</li>
<li>
<p><code>per-mille</code> specifies the character used for the
<var>per-mille-sign</var>; the default value is the Unicode
per-mille character (#x2030)</p>
</li>
<li>
<p><code>zero-digit</code> specifies the character used for the
<var>digit-zero-sign</var>; the default value is the digit zero
(<code>0</code>). This character <span class="verb">must</span> be
a digit (category Nd in the Unicode property database), and it
<span class="verb">must</span> have the numeric value zero. This
attribute implicitly defines the Unicode character that is used to
represent each of the values 0 to 9 in the final result string:
Unicode is organized so that each set of decimal digits forms a
contiguous block of characters in numerical sequence.</p>
</li>
</ul>
<p><a name="err-XTSE1295" id="err-XTSE1295"><span class=
"error">[ERR XTSE1295]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
character specified in the <code>zero-digit</code> attribute is not
a digit or is a digit that does not have the numeric value
zero.</p>
<p>The following attributes control the interpretation of
characters in the <a title="picture string" class="termref" href=
"#dt-picture-string">picture string</a> supplied to the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-number"><code>
format-number</code></a><sup><small>FO30</small></sup> function. In
each case the value <span class="verb">must</span> be a single
character <span class="error">[see <a href="#err-XTSE0020">ERR
XTSE0020</a>]</span>.</p>
<ul>
<li>
<p><code>digit</code> specifies the character used for the
<var>digit-sign</var> in the <a title="picture string" class=
"termref" href="#dt-picture-string">picture string</a>; the default
value is the number sign character (<code>#</code>)</p>
</li>
<li>
<p><code>pattern-separator</code> specifies the character used for
the <var>pattern-separator-sign</var>, which separates positive and
negative sub-pictures in a <a title="picture string" class=
"termref" href="#dt-picture-string">picture string</a>; the default
value is the semi-colon character (<code>;</code>)</p>
</li>
</ul>
<p>The following attributes specify characters or strings that may
appear in the result of formatting the number:</p>
<ul>
<li>
<p><code>infinity</code> specifies the string used for the
<var>infinity-symbol</var>; the default value is the string
<code>Infinity</code></p>
</li>
<li>
<p><code>NaN</code> specifies the string used for the
<var>NaN-symbol</var>, which is used to represent the value NaN
(not-a-number); the default value is the string
<code>NaN</code></p>
</li>
<li>
<p><code>minus-sign</code> specifies the character used for the
<var>minus-symbol</var>; the default value is the hyphen-minus
character (<code>-</code>, #x2D). The value <span class=
"verb">must</span> be a single character.</p>
</li>
</ul>
<p><a name="err-XTSE1300" id="err-XTSE1300"><span class=
"error">[ERR XTSE1300]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if, for
any named or unnamed decimal format, the variables representing
characters used in a <a title="picture string" class="termref"
href="#dt-picture-string">picture string</a> do not each have
distinct values. These variables are
<var>decimal-separator-sign</var>, <var>grouping-sign</var>,
<var>percent-sign</var>, <var>per-mille-sign</var>,
<var>digit-zero-sign</var>, <var>digit-sign</var>, and
<var>pattern-separator-sign</var>.</p>
<p>Every (named or unnamed) decimal format defined in a <a title=
"stylesheet" class="termref" href="#dt-stylesheet">package</a> is
added to the <a href=
"http://www.w3.org/TR/xpath-30/#dt-static-decimal-formats">statically
known decimal formats</a><sup><small>XP30</small></sup> in the
<a href="http://www.w3.org/TR/xpath-30/#dt-static-context">static
context</a><sup><small>XP30</small></sup> of every expression in
the <a title="package" class="termref" href=
"#dt-package">package</a>, excluding expressions appearing in
<code>[xsl:]use-when</code> attributes.</p>
</div>
<div class="div2">
<h3><a name="patterns" id="patterns"></a>5.6 <a href="#patterns"
style="text-decoration: none">Patterns</a></h3>
<p>In XSLT 3.0, patterns can match any kind of item: atomic values
and function items as well as nodes.</p>
<p>A <a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a> identifies the
<span>items</span> to which it applies by means of a pattern. As
well as being used in template rules, patterns are used for
numbering (see <a href="#number"><i>12 Numbering</i></a>), for
grouping (see <a href="#grouping"><i>14 Grouping</i></a>), and for
declaring <a title="key" class="termref" href="#dt-key">keys</a>
(see <a href="#key"><i>20.2 Keys</i></a>).</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-pattern" id="dt-pattern" title="pattern"></a>A <b>pattern</b>
specifies a set of conditions on an <span>item</span>. An
<span>item</span> that satisfies the conditions matches the
pattern; an <span>item</span> that does not satisfy the conditions
does not match the pattern.<span class="definition">]</span></p>
<p>There are two kinds of pattern: <a title="predicate pattern"
class="termref" href="#dt-predicate-pattern">predicate
patterns</a>, and <a title="selection pattern" class="termref"
href="#dt-selection-pattern">selection patterns</a>:</p>
<ul>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-predicate-pattern" id="dt-predicate-pattern" title=
"predicate pattern"></a>A <b>predicate pattern</b> is written as
<code>.</code> (dot) followed by zero or more predicates in square
brackets, and it matches any item for which each of the predicates
evaluates to <code>true</code>.<span class=
"definition">]</span></p>
<p>The detailed semantics are given in <a href=
"#pattern-semantics"><i>5.6.3 The Meaning of a Pattern</i></a>.
This construct can be used to match items of any kind (nodes,
atomic values, and function items). For example, the pattern
<code>.[starts-with(., '$')]</code> matches any string that starts
with the character "$", or a node whose atomized value starts with
"$". This example shows a predicate pattern with a single
predicate, but the grammar allows any number of predicates (zero or
more).</p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-selection-pattern" id="dt-selection-pattern" title=
"selection pattern"></a>A <b>selection pattern</b> uses a subset of
the syntax for path expressions, and is defined to match a node if
the corresponding path expression would select the node. Selection
patterns may also be formed by combining other patterns using
union, intersection, and difference operators.<span class=
"definition">]</span></p>
<p>The syntax for <span>selection</span> patterns
<span>(<code>UnionExprP</code> in the grammar: see <a href=
"#pattern-syntax"><i>5.6.2 Syntax of Patterns</i></a>)</span> is a
subset of the syntax for <a title="expression" class="termref"
href="#dt-expression">expressions</a>. <span><span>Selection</span>
patterns are used only for matching nodes; an item other than a
node will never match a <span>selection</span> pattern.</span> As
explained in detail below, a node matches a <span>selection</span>
pattern if the node can be selected by deriving an equivalent
expression, and evaluating this expression with respect to some
possible context.</p>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The specification uses the phrases <em>an item matches a
pattern</em> and <em>a pattern matches an item</em>
interchangeably. They are equivalent: an item matches a pattern if
and only if the pattern matches the item.</p>
</div>
<div class="div3">
<h4><a name="pattern-examples" id="pattern-examples"></a>5.6.1
<a href="#pattern-examples" style="text-decoration: none">Examples
of Patterns</a></h4>
<div class="example">
<div class="exampleHeader"><a name="d7e15313" id=
"d7e15313"></a>Example: Patterns</div>
<p>Here are some examples of patterns:</p>
<ul>
<li>
<p><code>.</code> matches any item.</p>
</li>
<li>
<p><code>*</code> matches any element.</p>
</li>
<li>
<p><code>para</code> matches any <code>para</code> element.</p>
</li>
<li>
<p><code>chapter|appendix</code> matches any <code>chapter</code>
element and any <code>appendix</code> element.</p>
</li>
<li>
<p><code>olist/entry</code> matches any <code>entry</code> element
with an <code>olist</code> parent.</p>
</li>
<li>
<p><code>appendix//para</code> matches any <code>para</code>
element with an <code>appendix</code> ancestor element.</p>
</li>
<li>
<p><code>schema-element(us:address)</code> matches any element that
is annotated as an instance of the type defined by the schema
element declaration <code>us:address</code>, and whose name is
either <code>us:address</code> or the name of another element in
its substitution group.</p>
</li>
<li>
<p><code>attribute(*, xs:date)</code> matches any attribute
annotated as being of type <code>xs:date</code>.</p>
</li>
<li>
<p><code>/</code> matches a document node.</p>
</li>
<li>
<p><code>document-node()</code> matches a document node.</p>
</li>
<li>
<p><code>document-node(schema-element(my:invoice))</code> matches
the document node of a document whose document element is named
<code>my:invoice</code> and matches the type defined by the global
element declaration <code>my:invoice</code>.</p>
</li>
<li>
<p><code>text()</code> matches any text node.</p>
</li>
<li>
<p><code>namespace-node()</code> matches any namespace node.</p>
</li>
<li>
<p><code>node()</code> matches any node other than an attribute
node, namespace node, or document node.</p>
</li>
<li>
<p><code>id("W33")</code> matches the element with unique ID
<code>W33</code>.</p>
</li>
<li>
<p><code>para[1]</code> matches any <code>para</code> element that
is the first <code>para</code> child element of its parent. It also
matches a parentless <code>para</code> element.</p>
</li>
<li>
<p><code>//para</code> matches any <code>para</code> element that
has a parent node.</p>
</li>
<li>
<p><code>bullet[position() mod 2 = 0]</code> matches any
<code>bullet</code> element that is an even-numbered
<code>bullet</code> child of its parent.</p>
</li>
<li>
<p><code>div[@class="appendix"]//p</code> matches any
<code>p</code> element with a <code>div</code> ancestor element
that has a <code>class</code> attribute with value
<code>appendix</code>.</p>
</li>
<li>
<p><code>@class</code> matches any <code>class</code> attribute
(<em>not</em> any element that has a <code>class</code>
attribute).</p>
</li>
<li>
<p><code>@*</code> matches any attribute node.</p>
</li>
<li>
<p><code>$xyz</code> matches any node that is present in the value
of the variable <code>$xyz</code>.</p>
</li>
<li>
<p><code>$xyz//*</code> matches any element that is a descendant of
a node that is present in the value of the variable
<code>$xyz</code>.</p>
</li>
<li>
<p><code>doc('product.xml')//*</code> matches any element within
the document whose document URI is 'product.xml'.</p>
</li>
<li>
<p><code>.[. instance of node()]</code> matches any node. (Note the
distinction from the pattern <code>node()</code>.)</p>
</li>
<li>
<p><code>.[. instance of xs:date]</code> matches any atomic value
of type <code>xs:date</code> (or a type derived by restriction from
<code>xs:date</code>).</p>
</li>
<li>
<p><code>.[. gt current-date()]</code> matches any date in the
future. It can match an atomic value of type <code>xs:date</code>
or <code>xs:untypedAtomic</code>, or a node whose atomized value is
an <code>xs:date</code> or <code>xs:untypedAtomic</code> value.</p>
</li>
<li>
<p><code>.[starts-with(., 'e')]</code> matches any node or atomic
value that after conversion to a string using the function
conversion rules starts with the letter 'e'.</p>
</li>
<li>
<p><code>.[. instance of function(*)]</code> matches any function
item.</p>
</li>
<li>
<p><code>.[$f(.)]</code> matches any item provided that the call on
the function bound to the variable <code>$f</code> returns a result
whose effective boolean value is true.</p>
</li>
</ul>
</div>
</div>
<div class="div3">
<h4><a name="pattern-syntax" id="pattern-syntax"></a>5.6.2 <a href=
"#pattern-syntax" style="text-decoration: none">Syntax of
Patterns</a></h4>
<p><a name="err-XTSE0340" id="err-XTSE0340"><span class=
"error">[ERR XTSE0340]</span></a> Where an attribute is defined to
contain a <a title="pattern" class="termref" href=
"#dt-pattern">pattern</a>, it is a <a title="static error" class=
"termref" href="#dt-static-error">static error</a> if the pattern
does not match the production <a href=
"#doc-xslt30-patterns-Pattern30">Pattern30</a>.</p>
<p>The grammar for patterns uses the notation defined in <a href=
"http://www.w3.org/TR/xpath-30/#EBNFNotation">Section A.1.1
Notation</a> <sup><small>XP30</small></sup>.</p>
<p>The lexical rules for patterns are the same as the lexical rules
for XPath expressions, as defined in <a href=
"http://www.w3.org/TR/xpath-30/#lexical-structure">Section A.2
Lexical structure</a> <sup><small>XP30</small></sup>. Comments are
permitted between tokens, using the syntax <code>(: ... :)</code>.
All other provisions of the XPath grammar apply where relevant, for
example the rules for whitespace handling and extra-grammatical
constraints.</p>
<h5><a name="d7e15667" id="d7e15667"></a>Patterns</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="doc-xslt30-patterns-Pattern30" id=
"doc-xslt30-patterns-Pattern30"></a>[1]&#160;&#160;&#160;</td>
<td><code>Pattern30</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xslt30-patterns-PredicatePattern">PredicatePattern</a> |
<a href=
"#doc-xslt30-patterns-UnionExprP">UnionExprP</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xslt30-patterns-PredicatePattern" id=
"doc-xslt30-patterns-PredicatePattern"></a>[2]&#160;&#160;&#160;</td>
<td><code>PredicatePattern</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"." <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-PredicateList">PredicateList</a><sup><small>XP30</small></sup></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xslt30-patterns-UnionExprP" id=
"doc-xslt30-patterns-UnionExprP"></a>[3]&#160;&#160;&#160;</td>
<td><code>UnionExprP</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xslt30-patterns-IntersectExceptExprP">IntersectExceptExprP</a>
(("union" | "|") <a href=
"#doc-xslt30-patterns-IntersectExceptExprP">IntersectExceptExprP</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xslt30-patterns-IntersectExceptExprP" id=
"doc-xslt30-patterns-IntersectExceptExprP"></a>[4]&#160;&#160;&#160;</td>
<td><code>IntersectExceptExprP</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xslt30-patterns-PathExprP">PathExprP</a>
(("intersect" | "except") <a href=
"#doc-xslt30-patterns-PathExprP">PathExprP</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xslt30-patterns-PathExprP" id=
"doc-xslt30-patterns-PathExprP"></a>[5]&#160;&#160;&#160;</td>
<td><code>PathExprP</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xslt30-patterns-RootedPath">RootedPath</a><br />
| ("/" <a href=
"#doc-xslt30-patterns-RelativePathExprP">RelativePathExprP</a>?)<br />

| ("//" <a href=
"#doc-xslt30-patterns-RelativePathExprP">RelativePathExprP</a>)<br />

| <a href=
"#doc-xslt30-patterns-RelativePathExprP">RelativePathExprP</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xslt30-patterns-RootedPath" id=
"doc-xslt30-patterns-RootedPath"></a>[6]&#160;&#160;&#160;</td>
<td><code>RootedPath</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-VarRef">VarRef</a><sup><small>XP30</small></sup>
| <a href="#doc-xslt30-patterns-FunctionCallP">FunctionCallP</a>)
<a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-PredicateList">PredicateList</a><sup><small>XP30</small></sup>
(("/" | "//") <a href=
"#doc-xslt30-patterns-RelativePathExprP">RelativePathExprP</a>)?</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xslt30-patterns-FunctionCallP" id=
"doc-xslt30-patterns-FunctionCallP"></a>[7]&#160;&#160;&#160;</td>
<td><code>FunctionCallP</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xslt30-patterns-OuterFunctionName">OuterFunctionName</a>
<a href=
"#doc-xslt30-patterns-ArgumentListP">ArgumentListP</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xslt30-patterns-OuterFunctionName" id=
"doc-xslt30-patterns-OuterFunctionName"></a>[8]&#160;&#160;&#160;</td>
<td><code>OuterFunctionName</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"doc" | "id" | "element-with-id" | "key" | <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-URIQualifiedName">URIQualifiedName</a><sup><small>XP30</small></sup></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xslt30-patterns-ArgumentListP" id=
"doc-xslt30-patterns-ArgumentListP"></a>[9]&#160;&#160;&#160;</td>
<td><code>ArgumentListP</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(" (<a href=
"#doc-xslt30-patterns-ArgumentP">ArgumentP</a> ("," <a href=
"#doc-xslt30-patterns-ArgumentP">ArgumentP</a>)*)? ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xslt30-patterns-ArgumentP" id=
"doc-xslt30-patterns-ArgumentP"></a>[10]&#160;&#160;&#160;</td>
<td><code>ArgumentP</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-VarRef">VarRef</a><sup><small>XP30</small></sup>
| <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-Literal">Literal</a><sup><small>XP30</small></sup></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xslt30-patterns-RelativePathExprP" id=
"doc-xslt30-patterns-RelativePathExprP"></a>[11]&#160;&#160;&#160;</td>
<td><code>RelativePathExprP</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href="#doc-xslt30-patterns-StepExprP">StepExprP</a>
(("/" | "//") <a href=
"#doc-xslt30-patterns-StepExprP">StepExprP</a>)*</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xslt30-patterns-StepExprP" id=
"doc-xslt30-patterns-StepExprP"></a>[12]&#160;&#160;&#160;</td>
<td><code>StepExprP</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xslt30-patterns-PostfixExprP">PostfixExprP</a> | <a href=
"#doc-xslt30-patterns-AxisStepP">AxisStepP</a></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xslt30-patterns-PostfixExprP" id=
"doc-xslt30-patterns-PostfixExprP"></a>[13]&#160;&#160;&#160;</td>
<td><code>PostfixExprP</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xslt30-patterns-ParenthesizedExprP">ParenthesizedExprP</a>
<a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-PredicateList">PredicateList</a><sup><small>XP30</small></sup></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xslt30-patterns-ParenthesizedExprP" id=
"doc-xslt30-patterns-ParenthesizedExprP"></a>[14]&#160;&#160;&#160;</td>
<td><code>ParenthesizedExprP</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"(" <a href=
"#doc-xslt30-patterns-UnionExprP">UnionExprP</a> ")"</code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xslt30-patterns-AxisStepP" id=
"doc-xslt30-patterns-AxisStepP"></a>[15]&#160;&#160;&#160;</td>
<td><code>AxisStepP</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"#doc-xslt30-patterns-ForwardStepP">ForwardStepP</a> <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-PredicateList">PredicateList</a><sup><small>XP30</small></sup></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xslt30-patterns-ForwardStepP" id=
"doc-xslt30-patterns-ForwardStepP"></a>[16]&#160;&#160;&#160;</td>
<td><code>ForwardStepP</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>(<a href=
"#doc-xslt30-patterns-ForwardAxisP">ForwardAxisP</a> <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-NodeTest">NodeTest</a><sup><small>XP30</small></sup>)
| <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-AbbrevForwardStep">AbbrevForwardStep</a><sup><small>XP30</small></sup></code></td>
</tr>
</tbody>
<tbody>
<tr valign="baseline">
<td><a name="doc-xslt30-patterns-ForwardAxisP" id=
"doc-xslt30-patterns-ForwardAxisP"></a>[17]&#160;&#160;&#160;</td>
<td><code>ForwardAxisP</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>("child" "::")<br />
| ("descendant" "::")<br />
| ("attribute" "::")<br />
| ("self" "::")<br />
| ("descendant-or-self" "::")<br />
| ("namespace" "::")</code></td>
</tr>
</tbody>
</table>
<p>The names of these constructs are chosen to align with the XPath
3.0 grammar. Constructs whose names are suffixed with
<code>P</code> are restricted forms of the corresponding XPath 3.0
construct without the suffix. Constructs labelled with the suffix
"XP30" are defined in <a href="#xpath-30">[XPath 3.0]</a>.</p>
<p>In a <a href=
"#doc-xslt30-patterns-FunctionCallP">FunctionCallP</a>, the
<code>EQName</code> used for the function name must have local part
<code>doc</code>, <code>id</code>, <code>element-with-id</code>, or
<code>key</code>, and must use the <a title=
"standard function namespace" class="termref" href=
"#dt-standard-function-namespace">standard function namespace</a>
either explicitly or implicitly.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>As with XPath expressions, the pattern <code>/ union /*</code>
can be parsed in two different ways, and the chosen interpretation
is to treat <code>union</code> as an element name rather than as an
operator. The other interpretation can be achieved by writing
<code>(/) union (/*)</code></p>
</div>
</div>
<div class="div3">
<h4><a name="pattern-semantics" id="pattern-semantics"></a>5.6.3
<a href="#pattern-semantics" style="text-decoration: none">The
Meaning of a Pattern</a></h4>
<p>The meaning of a pattern is defined formally as follows, where
"if" is to be read as "if and only if".</p>
<p>If the pattern is a <a href=
"#doc-xslt30-patterns-PredicatePattern">PredicatePattern</a>
<var>PP</var>, then it matches an item <var>J</var> if the XPath
expression taking the same form as <var>PP</var> returns a
non-empty sequence when evaluated with a <a title="singleton focus"
class="termref" href="#dt-singleton-focus">singleton focus</a>
based on <var>J</var>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The pattern <code>.</code>, which is a
<code>PredicatePattern</code> with an empty <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-PredicateList">PredicateList</a><sup><small>XP30</small></sup>,
matches every item.</p>
<p>A predicate with the numeric value 1 (one) always matches, and a
predicate with any other numeric value never matches. Numeric
predicates in a <code>PredicatePattern</code> are therefore not
useful, but are defined this way in the interests of consistency
with XPath.</p>
</div>
<p>Otherwise (the pattern is a <span>selection pattern</span>), the
pattern is converted to an <a title="expression" class="termref"
href="#dt-expression">expression</a>, called the <b>equivalent
expression</b>. The equivalent expression to a <a href=
"#doc-xslt30-patterns-Pattern30">Pattern</a> is the XPath
expression that takes the same lexical form as the
<code>Pattern</code> as written, with the following adjustment:</p>
<ul>
<li>
<p><span>If any <code>PathExprP</code> in the <code>Pattern</code>
is a <code>RelativePathExprP</code>, then the first
<code>StepExprP</code> <var>PS</var> of this
<code>RelativePathExprP</code></span> is adjusted to allow it to
match a parentless element, attribute, or namespace node. The
adjustment depends on the axis used in this step, whether it
appears explicitly or implicitly (according to the rules of
<a href="http://www.w3.org/TR/xpath-30/#abbrev">Section 3.3.5
Abbreviated Syntax</a> <sup><small>XP30</small></sup>), and is made
as follows:</p>
<ol class="enumar">
<li>
<p>If the <code>NodeTest</code> in <var>PS</var> is
<code>document-node()</code> (optionally with arguments), and if no
explicit axis is specified, then the axis in step <var>PS</var> is
taken as <code>self</code> rather than <code>child</code>.</p>
</li>
<li>
<p>If <var>PS</var> uses the child axis (explicitly or implicitly),
and if the <code>NodeTest</code> in <var>PS</var> is not
<code>document-node()</code> (optionally with arguments), then the
axis in step <var>PS</var> is replaced by
<code>child-or-top</code>, which is defined as follows. If the
context node is a parentless element, comment,
processing-instruction, or text node then the
<code>child-or-top</code> axis selects the context node; otherwise
it selects the children of the context node. It is a forwards axis
whose principal node kind is element.</p>
</li>
<li>
<p>If <var>PS</var> uses the attribute axis (explicitly or
implicitly), then the axis in step <var>PS</var> is replaced by
<code>attribute-or-top</code>, which is defined as follows. If the
context node is an attribute node with no parent, then the
<code>attribute-or-top</code> axis selects the context node;
otherwise it selects the attributes of the context node. It is a
forwards axis whose principal node kind is attribute.</p>
</li>
<li>
<p>If <var>PS</var> uses the namespace axis <span>(explicitly or
implicitly)</span>, then the axis in step <var>PS</var> is replaced
by <code>namespace-or-top</code>, which is defined as follows. If
the context node is a namespace node with no parent, then the
<code>namespace-or-top</code> axis selects the context node;
otherwise it selects the namespace nodes of the context node. It is
a forwards axis whose principal node kind is namespace.</p>
</li>
</ol>
<p>The axes <code>child-or-top</code>,
<code>attribute-or-top</code>, and <code>namespace-or-top</code>
are introduced only for definitional purposes. They cannot be used
explicitly in a user-written pattern or expression.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The purpose of this adjustment is to ensure that a pattern such
as <code>person</code> matches any element named
<code>person</code>, even if it has no parent; and similarly, that
the pattern <code>@width</code> matches any attribute named
<code>width</code>, even a parentless attribute. The rule also
ensures that a pattern using a <code>NodeTest</code> of the form
<code>document-node(...)</code> matches a document node. The
pattern <code>node()</code> will match any element, text node,
comment, or processing instruction, whether or not it has a parent.
For backwards compatibility reasons, the pattern
<code>node()</code>, when used without an explicit axis, does not
match document nodes, attribute nodes, or namespace nodes. The
rules are also phrased to ensure that positional patterns of the
form <code>para[1]</code> continue to count nodes relative to their
parent, if they have one. <span>To match any node at all, XSLT 3.0
allows the pattern <code>.[. instance of node()]</code> to be
used.</span></p>
</div>
</li>
</ul>
<p>The meaning of the pattern is then defined in terms of the
semantics of the equivalent expression, denoted below as
<code>EE</code>.</p>
<p>Specifically, an item <var>N</var> matches a pattern
<var>P</var> if the following applies, where <code>EE</code> is the
<b>equivalent expression</b> to <var>P</var>:</p>
<ol class="enumar">
<li>
<p><var>N</var> is a node, and the result of evaluating the
expression <code>root(.)//(EE)</code> with a <a title=
"singleton focus" class="termref" href=
"#dt-singleton-focus">singleton focus</a> based on <var>N</var> is
a sequence that includes the node <var>N</var></p>
</li>
</ol>
<p>If a pattern appears <span>in an attribute of an element that is
processed with <a title="XSLT 1.0 behavior" class="termref" href=
"#dt-xslt-10-behavior">XSLT 1.0 behavior</a></span> (see <a href=
"#backwards"><i>3.10 Backwards Compatible Processing</i></a>), then
the semantics of the pattern are defined on the basis that the
equivalent XPath expression is evaluated with <a title=
"XPath 1.0 compatibility mode" class="termref" href=
"#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> set to
true.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e16223" id=
"d7e16223"></a>Example: The Semantics of Selection Patterns</div>
<p>The <span><a title="selection pattern" class="termref" href=
"#dt-selection-pattern">selection pattern</a></span> <code>p</code>
matches any <code>p</code> element, because a <code>p</code>
element will always be present in the result of evaluating the
<a title="expression" class="termref" href=
"#dt-expression">expression</a>
<code>root(.)//(child-or-top::p)</code>. Similarly, <code>/</code>
matches a document node, and only a document node, because the
result of the <a title="expression" class="termref" href=
"#dt-expression">expression</a> <code>root(.)//(/)</code> returns
the root node of the tree containing the context node if and only
if it is a document node.</p>
<p>The <span><a title="selection pattern" class="termref" href=
"#dt-selection-pattern">selection pattern</a></span>
<code>node()</code> matches all nodes selected by the expression
<code>root(.)//(child-or-top::node())</code>, that is, all element,
text, comment, and processing instruction nodes, whether or not
they have a parent. It does not match attribute or namespace nodes
because the expression does not select nodes using the attribute or
namespace axes. It does not match document nodes because for
backwards compatibility reasons the <code>child-or-top</code> axis
does not match a document node.</p>
<p>The <span><a title="selection pattern" class="termref" href=
"#dt-selection-pattern">selection pattern</a></span>
<code>$V</code> matches all nodes selected by the expression
<code>root(.)//($V)</code>, that is, all nodes in the value of $V
(which will typically be a global variable, though when the pattern
is used in contexts such as the <a href=
"#element-number"><code>xsl:number</code></a> or <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instructions, it can also be a local variable).</p>
<p>The <span><a title="selection pattern" class="termref" href=
"#dt-selection-pattern">selection pattern</a></span>
<code>doc('product.xml')//product</code> matches all nodes selected
by the expression
<code>root(.)//(doc('product.xml')//product)</code>, that is, all
<code>product</code> elements in the document whose URI is
<code>product.xml</code>.</p>
</div>
<p>Although the semantics of <span><a title="selection pattern"
class="termref" href="#dt-selection-pattern">selection
patterns</a></span> are specified formally in terms of expression
evaluation, it is possible to understand pattern matching using a
different model. A <span><a title="selection pattern" class=
"termref" href="#dt-selection-pattern">selection pattern</a></span>
such as <code>book/chapter/section</code> can be examined from
right to left. A node will only match this pattern if it is a
<code>section</code> element; and then, only if its parent is a
<code>chapter</code>; and then, only if the parent of that
<code>chapter</code> is a <code>book</code>. When the pattern uses
the <code>//</code> operator, one can still read it from right to
left, but this time testing the ancestors of a node rather than its
parent. For example <code>appendix//section</code> matches every
<code>section</code> element that has an ancestor
<code>appendix</code> element.</p>
<p>The formal definition, however, is useful for understanding the
meaning of a pattern such as <code>para[1]</code>. This matches any
node selected by the expression
<code>root(.)//(child-or-top::para[1])</code>: that is, any
<code>para</code> element that is the first <code>para</code> child
of its parent, or a <code>para</code> element that has no
parent.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>An implementation, of course, may use any algorithm it wishes
for evaluating patterns, so long as the result corresponds with the
formal definition above. An implementation that followed the formal
definition by evaluating the equivalent expression and then testing
the membership of a specific node in the result would probably be
very inefficient.</p>
</div>
</div>
<div class="div3">
<h4><a name="pattern-errors" id="pattern-errors"></a>5.6.4 <a href=
"#pattern-errors" style="text-decoration: none">Errors in
Patterns</a></h4>
<p>A <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> or <a title="type error"
class="termref" href="#dt-type-error">type error</a> that occurs
during the evaluation of a <a title="pattern" class="termref" href=
"#dt-pattern">pattern</a> against a particular <span>item</span>
has the effect that the item being tested is treated as not
matching the pattern. The error does not cause the transformation
to fail, and cannot be caught by a try/catch expression surrounding
the instruction that causes the pattern to be evaluated.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The reason for this provision is that it is difficult for the
stylesheet author to predict which predicates in a pattern will
actually be evaluated. In the case of match patterns in template
rules, it is not even possible to predict which patterns will be
evaluated against a particular node.</p>
<p>There is a risk that ignoring errors in this way may make
programming mistakes harder to debug. Implementations may mitigate
this by providing warnings or other diagnostics when evaluation of
a pattern triggers an error condition.</p>
<p>Static errors in patterns, including dynamic and type errors
that are signaled statically as permitted by the specification, are
reported in the normal way and cause the transformation to
fail.</p>
</div>
<p>The requirement to detect and report a <a title="circularity"
class="termref" href="#dt-circularity">circularity</a> as a dynamic
error overrides this rule.</p>
</div>
</div>
<div class="div2">
<h3><a name="value-templates" id="value-templates"></a>5.7 <a href=
"#value-templates" style="text-decoration: none">Value
Templates</a></h3>
<p>The string value of an attribute or text node in the stylesheet
may in particular circumstances contain embedded expressions
enclosed between curly brackets. Attributes and text nodes that use
(or are permitted to use) this mechanism are referred to
respectively as <a title="attribute value template" class="termref"
href="#dt-attribute-value-template">attribute value templates</a>
and <a title="text value template" class="termref" href=
"#dt-text-value-template">text value templates.</a>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-value-template" id="dt-value-template" title=
"value template"></a>Collectively, attribute value templates and
text value templates are referred to as <b>value
templates</b>.<span class="definition">]</span></p>
<p>A value template is a string consisting of an alternating
sequence of fixed parts and variable parts. A variable part
consists of an XPath <a title="expression" class="termref" href=
"#dt-expression">expression</a> enclosed in curly brackets
(<code>{}</code>). A fixed part may contain any characters, except
that a left curly bracket <span class="verb">must</span> be written
as <code>{{</code> and a right curly bracket <span class=
"verb">must</span> be written as <code>}}</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>An expression within a variable part may contain an unescaped
curly bracket within a <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-StringLiteral">StringLiteral</a><sup><small>XP30</small></sup>
or within a comment.</p>
<p>Currently no XPath expression starts with an opening curly
bracket, so the use of <code>{{</code> creates no ambiguity. If an
enclosed expression ends with a closing curly bracket, no
whitespace is required between this and the closing delimiter.</p>
</div>
<p><a name="err-XTSE0350" id="err-XTSE0350"><span class=
"error">[ERR XTSE0350]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if an
unescaped left curly bracket appears in a fixed part of a value
template without a matching right curly bracket.</p>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the string contained between
matching curly brackets in a value template does not match the
XPath production <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-Expr">Expr</a><sup><small>XP30</small></sup>,
or if it contains other XPath static errors. The error is signaled
using the appropriate XPath error code.</p>
<p><a name="err-XTSE0370" id="err-XTSE0370"><span class=
"error">[ERR XTSE0370]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if an
unescaped right curly bracket occurs in a fixed part of a value
template.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-effective-value" id="dt-effective-value" title=
"effective value"></a>The result of evaluating a value template is
referred to as its <b>effective value</b>.<span class=
"definition">]</span> The effective value is the string obtained by
concatenating the expansions of the fixed and variable parts:</p>
<ul>
<li>
<p>The expansion of a fixed part is obtained by replacing any
double curly brackets (<code>{{</code> or <code>}}</code>) by the
corresponding single curly bracket.</p>
</li>
<li>
<p>The expansion of a variable part is obtained by evaluating the
enclosed XPath <a title="expression" class="termref" href=
"#dt-expression">expression</a> and converting the resulting value
to a string. This conversion is done using the rules given in
<a href="#constructing-simple-content"><i>5.8.2 Constructing Simple
Content</i></a>.</p>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This process can generate dynamic errors, for example if the
sequence contains an element with a complex content type (which
cannot be atomized).</p>
</div>
<p>In the case of an attribute value template, the effective value
becomes the string value of the new attribute node. In the case of
a text value template, the effective value becomes the string value
of the new text node.</p>
<div class="div3">
<h4><a name="attribute-value-templates" id=
"attribute-value-templates"></a>5.7.1 <a href=
"#attribute-value-templates" style=
"text-decoration: none">Attribute Value Templates</a></h4>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-attribute-value-template" id="dt-attribute-value-template"
title="attribute value template"></a>In an attribute that is
designated as an <b>attribute value template</b>, such as an
attribute of a <a title="literal result element" class="termref"
href="#dt-literal-result-element">literal result element</a>, an
<a title="expression" class="termref" href=
"#dt-expression">expression</a> can be used by surrounding the
expression with curly brackets (<code>{}</code>), following the
general rules for <a title="value template" class="termref" href=
"#dt-value-template">value templates</a><span class=
"definition">]</span>.</p>
<p>Curly brackets are not treated specially in an attribute value
in an XSLT <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> unless the attribute is
specifically designated as one that permits an attribute value
template; in an element syntax summary, the value of such
attributes is surrounded by curly brackets.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Not all attributes are designated as attribute value templates.
Attributes whose value is an <a title="expression" class="termref"
href="#dt-expression">expression</a> or <a title="pattern" class=
"termref" href="#dt-pattern">pattern</a>, attributes of <a title=
"declaration" class="termref" href=
"#dt-declaration">declaration</a> elements and attributes that
refer to named XSLT objects are generally not designated as
attribute value templates (an exception is the <code>format</code>
attribute of <a href=
"#element-result-document"><code>xsl:result-document</code></a>).
Namespace declarations are not XDM attribute nodes and are
therefore never treated as attribute value templates.</p>
</div>
<p><span>If the element containing the attribute is processed with
<a title="XSLT 1.0 behavior" class="termref" href=
"#dt-xslt-10-behavior">XSLT 1.0 behavior</a>, then the rules for
converting the value of the expression to a string (given in
<a href="#value-templates"><i>5.7 Value Templates</i></a>) are
modified as follows. After <a title="atomize" class="termref" href=
"#dt-atomization">atomizing</a> the result of the expression, all
items other than the first item in the resulting sequence are
discarded, and the effective value is obtained by converting the
first item in the sequence to a string. If the atomized sequence is
empty, the result is a zero-length string.</span></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The above rule applies to attribute value templates but not to
text value templates, since the latter were not available in XSLT
1.0.</p>
</div>
<div class="example">
<div class="exampleHeader"><a name="d7e16565" id=
"d7e16565"></a>Example: Attribute Value Templates</div>
<p>The following example creates an <code>img</code> result element
from a <code>photograph</code> element in the source; the value of
the <code>src</code> and <code>width</code> attributes are computed
using XPath expressions enclosed in attribute value templates:</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="image-dir" select="'/images'"/&gt;

&lt;xsl:template match="photograph"&gt;
  &lt;img src="{$image-dir}/{href}" width="{size/@width}"/&gt;
&lt;/xsl:template&gt;
</pre></div>
<p>With this source</p>
<div class="exampleInner">
<pre>
&lt;photograph&gt;
  &lt;href&gt;headquarters.jpg&lt;/href&gt;
  &lt;size width="300"/&gt;
&lt;/photograph&gt;
</pre></div>
<p>the result would be</p>
<div class="exampleInner">
<pre>
&lt;img src="/images/headquarters.jpg" width="300"/&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e16592" id=
"d7e16592"></a>Example: Producing a Space-Separated List</div>
<p>The following example shows how the values in a sequence are
output as a space-separated list. The following literal result
element:</p>
<div class="exampleInner">
<pre>
&lt;temperature readings="{10.32, 5.50, 8.31}"/&gt;
</pre></div>
<p>produces the output node:</p>
<div class="exampleInner">
<pre>
&lt;temperature readings="10.32 5.5 8.31"/&gt;
</pre></div>
</div>
<p>Curly brackets are <em>not</em> recognized recursively inside
expressions.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e16608" id=
"d7e16608"></a>Example: Curly Brackets cannot be Nested</div>
<p>For example:</p>
<div class="exampleInner">
<pre>
&lt;a href="#{id({@ref})/title}"&gt;
</pre></div>
<p>is <em>not</em> allowed. Instead, use simply:</p>
<div class="exampleInner">
<pre>
&lt;a href="#{id(@ref)/title}"&gt;
</pre></div>
</div>
</div>
<div class="div3">
<h4><a name="text-value-templates" id=
"text-value-templates"></a>5.7.2 <a href="#text-value-templates"
style="text-decoration: none">Text Value Templates</a></h4>
<p>The <a title="standard attributes" class="termref" href=
"#dt-standard-attributes">standard attribute</a>
<code>[xsl:]expand-text</code> may appear on any element in the
stylesheet, and determines whether descendant text nodes of that
element are treated as text value templates. A text node in the
stylesheet is treated as a text value template if (a) it is part of
a <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> <span>or a
child of an <a href="#element-text"><code>xsl:text</code></a>
instruction</span>, (b) there is an ancestor element with an
<code>[xsl:]expand-text</code> attribute, and (c) on the innermost
ancestor element that has such an attribute, the value of the
attribute is <code>yes</code>. <span>The attribute is boolean and
<span class="verb">must</span> therefore take one of the values
<code>yes</code> (synonyms <code>true</code> or <code>1</code>) or
<code>no</code> (synonyms <code>false</code> or
<code>0</code>)</span>.</p>
<p>This section describes how text nodes are processed when the
effective value is <code>yes</code>. Such text nodes are referred
to as text value templates.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-text-value-template" id="dt-text-value-template" title=
"text value template"></a>In a text node that is designated as a
<b>text value template</b>, <a title="expression" class="termref"
href="#dt-expression">expressions</a> can be used by surrounding
each expression with curly brackets (<code>{}</code>).<span class=
"definition">]</span></p>
<p>The rules for text value templates are given in <a href=
"#value-templates"><i>5.7 Value Templates</i></a>. A text node
whose value is a text value template results in the construction of
a text node in the result of the <span>containing sequence
constructor or <a href="#element-text"><code>xsl:text</code></a>
instruction</span>. The string value of that text node is obtained
by computing the effective value of the value template.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The result of evaluating a text value template is a (possibly
zero-length) text node. This text node becomes part of the result
of the containing sequence constructor or <a href=
"#element-text"><code>xsl:text</code></a> instruction, and is
thereafter handled exactly as if the value had appeared explicitly
as a text node in the stylesheet.</p>
<p>The way in which the effective value is computed does not depend
on any <code>separator</code> attribute on a containing <a href=
"#element-value-of"><code>xsl:value-of</code></a> or <a href=
"#element-attribute"><code>xsl:attribute</code></a> instruction.
The <code>separator</code> attribute only affects how the text node
is combined with adjacent items in the result of the containing
sequence constructor.</p>
<p>Fixed parts consisting entirely of whitespace are significant
and are handled in the same way as any other fixed part. This is
different from the default treatment of "boundary space" in
XQuery.</p>
</div>
<div class="example">
<div class="exampleHeader"><a name="d7e16735" id=
"d7e16735"></a>Example: Using a text value template to construct
message output</div>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="id" select="'A123'"/&gt;
&lt;xsl:variable name="step" select="5"/&gt;
&lt;xsl:message expand-text="yes"
     &gt;Processing id={$id}, step={$step}&lt;/xsl:message&gt;
</pre></div>
<p>This will typically output the message text <code>Processing
id=A123, step=5</code>.</p>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e16745" id=
"d7e16745"></a>Example: Using a text value template to define the
result of a function</div>
<div class="exampleInner">
<pre>
&lt;xsl:function name="f:sum" expand-text="yes" as="xs:integer"&gt;
&lt;xsl:param name="x" as="xs:integer"/&gt;
&lt;xsl:param name="y" as="xs:integer"/&gt;
  {$x + $y}
&lt;/xsl:function&gt;
</pre></div>
<p>Note that although this is a very readable way of expressing the
computation performed by the function, the semantics are somewhat
complex, and this could mean that execution is inefficient. The
function computes the value of <code>$x + $y</code> as an integer,
and then constructs a text node containing the string
representation of this integer (preceded and followed by
whitespace). Because the declared result type of the function is
<code>xs:integer</code>, this text node is then atomized, giving an
<code>xs:untypedAtomic</code> value, and the
<code>xs:untypedAtomic</code> value is then cast to an
<code>xs:integer</code>.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The main motivations for adding text value templates to the XSLT
language are firstly, to make it easier to construct parameterized
text in contexts such as <a href=
"#element-value-of"><code>xsl:value-of</code></a> and <a href=
"#element-message"><code>xsl:message</code></a>, and secondly, to
allow use of complex multi-line XPath expressions where maintaining
correct indentation is important for readability. The fact that XML
processors are required to normalize whitespace in attribute values
means that writing such expressions within a <code>select</code>
attribute is not ideal.</p>
<p>The facility is only present if enabled using the
<code>[xsl:]expand-text</code> attribute. This is partly for
backwards compatibility, and partly to avoid creating difficulties
when constructing content that is rich in curly brackets, for
example JavaScript code or CSS style sheets.</p>
</div>
</div>
</div>
<div class="div2">
<h3><a name="sequence-constructors" id=
"sequence-constructors"></a>5.8 <a href="#sequence-constructors"
style="text-decoration: none">Sequence Constructors</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-sequence-constructor" id="dt-sequence-constructor" title=
"sequence constructor"></a>A <b>sequence constructor</b> is a
sequence of zero or more sibling nodes in the <a title="stylesheet"
class="termref" href="#dt-stylesheet">stylesheet</a> that can be
evaluated to return a sequence of nodes, atomic values, <span>and
function items</span>. The way that the resulting sequence is used
depends on the containing instruction.<span class=
"definition">]</span></p>
<p>Many <a title="XSLT element" class="termref" href=
"#dt-xslt-element">XSLT elements</a>, and also <a title=
"literal result element" class="termref" href=
"#dt-literal-result-element">literal result elements</a>, are
defined to take a <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> as their
content.</p>
<p>Four kinds of nodes may be encountered in a sequence
constructor:</p>
<ol class="enumar">
<li>
<p>A <em>Text node</em> appearing in the <a title="stylesheet"
class="termref" href="#dt-stylesheet">stylesheet</a> (if it has not
been removed in the process of whitespace stripping: see <a href=
"#stylesheet-stripping"><i>4.2 Stripping Whitespace from the
Stylesheet</i></a>) is <span>processed as follows:</span></p>
<ol class="enumla">
<li>
<p>if the effective value of the standard attribute
<code>[xsl:]expand-text</code> is <code>no</code>, or in the
absence of this attribute, the text node in the stylesheet is
copied to create a new parentless text node in the result of the
sequence constructor.</p>
</li>
<li>
<p>Otherwise (the effective value of <code>[xsl:]expand-text</code>
is <code>yes</code>), the text node in the stylesheet is processed
as described in <a href="#text-value-templates"><i>5.7.2 Text Value
Templates</i></a>.</p>
</li>
</ol>
</li>
<li>
<p>A <a title="literal result element" class="termref" href=
"#dt-literal-result-element">literal result element</a> is
evaluated to create a new parentless element node, having the same
<a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> as the literal result
element: see <a href="#literal-result-element"><i>11.1 Literal
Result Elements</i></a>.</p>
</li>
<li>
<p>An XSLT <a title="instruction" class="termref" href=
"#dt-instruction">instruction</a> produces a sequence of zero, one,
or more items as its result. For most XSLT instructions, these
items are nodes, but some instructions (<span>such as</span>
<a href="#element-sequence"><code>xsl:sequence</code></a> and
<a href="#element-copy-of"><code>xsl:copy-of</code></a>) can also
produce atomic values <span>or function items</span>. Several
instructions, such as <a href=
"#element-element"><code>xsl:element</code></a>, return a newly
constructed parentless node (which may have its own attributes,
namespaces, children, and other descendants). Other instructions,
such as <a href="#element-if"><code>xsl:if</code></a>, pass on the
items produced by their own nested sequence constructors. The
<a href="#element-sequence"><code>xsl:sequence</code></a>
instruction may return atomic values, <span>function items</span>,
or existing nodes.</p>
</li>
<li>
<p>An <a title="extension instruction" class="termref" href=
"#dt-extension-instruction">extension instruction</a> (see <a href=
"#extension-instruction"><i>23.2 Extension Instructions</i></a>)
also produces a sequence of items as its result.</p>
</li>
</ol>
<p>The result of evaluating a <a title="sequence constructor"
class="termref" href="#dt-sequence-constructor">sequence
constructor</a> is the sequence of items formed by concatenating
the results of evaluating each of the nodes in the sequence
constructor, retaining order.</p>
<p>There are several ways the result of a sequence constructor may
be used.</p>
<ul>
<li>
<p>The sequence may be bound to a variable or returned from a
stylesheet function, in which case it becomes available as a value
to be manipulated in arbitrary ways by XPath expressions. The
sequence is bound to a variable when the sequence constructor
appears within one of the elements <a href=
"#element-variable"><code>xsl:variable</code></a>, <a href=
"#element-param"><code>xsl:param</code></a>, or <a href=
"#element-with-param"><code>xsl:with-param</code></a>, when this
instruction has an <code>as</code> attribute. The sequence is
returned from a stylesheet function when the sequence constructor
appears within the <a href=
"#element-function"><code>xsl:function</code></a> element.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This will typically expose to the stylesheet elements,
attributes, and other nodes that have not yet been attached to a
parent node in a <a title="result tree" class="termref" href=
"#dt-result-tree">result tree</a>. The semantics of XPath
expressions when applied to parentless nodes are well-defined;
however, such expressions should be used with care. For example,
the expression <code>/</code> causes a type error if the root of
the tree containing the context node is not a document node.</p>
<p>Parentless attribute nodes require particular care because they
have no namespace nodes associated with them. A parentless
attribute node is not permitted to contain namespace-sensitive
content (for example, a QName or an XPath expression) because there
is no information enabling the prefix to be resolved to a namespace
URI. Parentless attributes can be useful in an application (for
example, they provide an alternative to the use of attribute sets:
see <a href="#attribute-sets"><i>10.2 Named Attribute Sets</i></a>)
but they need to be handled with care.</p>
</div>
</li>
<li>
<p>The sequence may be returned as the result of the containing
element. This happens when the <span>element</span> containing the
sequence constructor is <a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a>,
<a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a>,
<a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<span><a href="#element-break"><code>xsl:break</code></a></span>,
<a href=
"#element-call-template"><code>xsl:call-template</code></a>,
<span><a href="#element-catch"><code>xsl:catch</code></a></span>,
<a href="#element-choose"><code>xsl:choose</code></a>, <a href=
"#element-fallback"><code>xsl:fallback</code></a>, <a href=
"#element-for-each"><code>xsl:for-each</code></a>, <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>,
<span><a href="#element-fork"><code>xsl:fork</code></a></span>,
<a href="#element-if"><code>xsl:if</code></a>, <span><a href=
"#element-iterate"><code>xsl:iterate</code></a></span>, <a href=
"#element-matching-substring"><code>xsl:matching-substring</code></a>,
<a href="#element-next-match"><code>xsl:next-match</code></a>,
<a href=
"#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>,
<span><a href=
"#element-on-completion"><code>xsl:on-completion</code></a></span>,
<a href="#element-otherwise"><code>xsl:otherwise</code></a>,
<a href="#element-perform-sort"><code>xsl:perform-sort</code></a>,
<a href="#element-sequence"><code>xsl:sequence</code></a>,
<span><a href="#element-try"><code>xsl:try</code></a></span>, or
<a href="#element-when"><code>xsl:when</code></a>.</p>
</li>
<li>
<p>The sequence may be used to construct the content of a new
element or document node. This happens when the sequence
constructor appears as the content of a <a title=
"literal result element" class="termref" href=
"#dt-literal-result-element">literal result element</a>, or of one
of the instructions <a href=
"#element-copy"><code>xsl:copy</code></a>, <a href=
"#element-element"><code>xsl:element</code></a>, <a href=
"#element-document"><code>xsl:document</code></a>, <a href=
"#element-result-document"><code>xsl:result-document</code></a>,
<span><a href="#element-assert"><code>xsl:assert</code></a></span>,
or <a href="#element-message"><code>xsl:message</code></a>. It also
happens when the sequence constructor is contained in one of the
elements <a href="#element-variable"><code>xsl:variable</code></a>,
<a href="#element-param"><code>xsl:param</code></a>, or <a href=
"#element-with-param"><code>xsl:with-param</code></a>, when this
instruction has no <code>as</code> attribute. For details, see
<a href="#constructing-complex-content"><i>5.8.1 Constructing
Complex Content</i></a>.</p>
</li>
<li>
<p>The sequence may be used to construct the <a title=
"string value" class="termref" href="#dt-string-value">string
value</a> of an attribute node, text node, namespace node, comment
node, or processing instruction node. This happens when the
sequence constructor is contained in one of the elements <a href=
"#element-attribute"><code>xsl:attribute</code></a>, <a href=
"#element-value-of"><code>xsl:value-of</code></a>, <a href=
"#element-namespace"><code>xsl:namespace</code></a>, <a href=
"#element-comment"><code>xsl:comment</code></a>, or <a href=
"#element-processing-instruction"><code>xsl:processing-instruction</code></a>.
For details, see <a href="#constructing-simple-content"><i>5.8.2
Constructing Simple Content</i></a>.</p>
</li>
</ul>
<div class="div3">
<h4><a name="constructing-complex-content" id=
"constructing-complex-content"></a>5.8.1 <a href=
"#constructing-complex-content" style=
"text-decoration: none">Constructing Complex Content</a></h4>
<p>This section describes how the sequence obtained by evaluating a
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> may be used to
construct the children of a newly constructed document node, or the
children, attributes and namespaces of a newly constructed element
node. The sequence of items may be obtained by evaluating the
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> contained in an
instruction such as <a href=
"#element-copy"><code>xsl:copy</code></a>, <a href=
"#element-element"><code>xsl:element</code></a>, <a href=
"#element-document"><code>xsl:document</code></a>, <a href=
"#element-result-document"><code>xsl:result-document</code></a>, or
a <a title="literal result element" class="termref" href=
"#dt-literal-result-element">literal result element</a>.</p>
<p>When constructing the content of an element, the
<code>inherit-namespaces</code> attribute of the <a href=
"#element-element"><code>xsl:element</code></a> or <a href=
"#element-copy"><code>xsl:copy</code></a> instruction, or the
<code>xsl:inherit-namespaces</code> property of the literal result
element, determines whether namespace nodes are to be inherited.
The effect of this attribute is described in the rules that
follow.</p>
<p>The sequence is processed as follows (applying the rules in the
order they are listed):</p>
<ol class="enumar">
<li>
<p>The containing instruction may generate attribute nodes and/or
namespace nodes, as specified in the rules for the individual
instruction. For example, these nodes may be produced by expanding
an <code>[xsl:]use-attribute-sets</code> attribute, or by expanding
the attributes of a <a title="literal result element" class=
"termref" href="#dt-literal-result-element">literal result
element</a>. Any such nodes are prepended to the sequence produced
by evaluating the <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a>.</p>
</li>
<li>
<p>Any atomic value in the sequence is cast to a string.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Casting from <code>xs:QName</code> or <code>xs:NOTATION</code>
to <code>xs:string</code> always succeeds, because these values
retain a prefix for this purpose. However, there is no guarantee
that the prefix used will always be meaningful in the context where
the resulting string is used.</p>
</div>
</li>
<li>
<p>Any consecutive sequence of strings within the result sequence
is converted to a single text node, whose <a title="string value"
class="termref" href="#dt-string-value">string value</a> contains
the content of each of the strings in turn, with a single space
(#x20) used as a separator between successive strings.</p>
</li>
<li>
<p>Any document node within the result sequence is replaced by a
sequence containing each of its children, in document order.</p>
</li>
<li>
<p>Zero-length text nodes within the result sequence are
removed.</p>
</li>
<li>
<p>Adjacent text nodes within the result sequence are merged into a
single text node.</p>
</li>
<li>
<p>Invalid <span>items in the result sequence</span> are detected
as follows.</p>
<p><a name="err-XTDE0410" id="err-XTDE0410"><span class=
"error">[ERR XTDE0410]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
result sequence used to construct the content of an element node
contains a namespace node or attribute node that is preceded in the
sequence by a node that is neither a namespace node nor an
attribute node.</p>
<p><a name="err-XTDE0420" id="err-XTDE0420"><span class=
"error">[ERR XTDE0420]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
result sequence used to construct the content of a document node
contains a namespace node or attribute node.</p>
<p><a name="err-XTDE0430" id="err-XTDE0430"><span class=
"error">[ERR XTDE0430]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
result sequence contains two or more namespace nodes having the
same name but different <a title="string value" class="termref"
href="#dt-string-value">string values</a> (that is, namespace nodes
that map the same prefix to different namespace URIs).</p>
<p><a name="err-XTDE0440" id="err-XTDE0440"><span class=
"error">[ERR XTDE0440]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
result sequence contains a namespace node with no name and the
element node being constructed has a null namespace URI (that is,
it is an error to define a default namespace when the element is in
no namespace).</p>
<p><a name="err-XTDE0450" id="err-XTDE0450"><span class=
"error">[ERR XTDE0450]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
result sequence contains a function item.</p>
</li>
<li>
<p>If the result sequence contains two or more namespace nodes with
the same name (or no name) and the same <a title="string value"
class="termref" href="#dt-string-value">string value</a> (that is,
two namespace nodes mapping the same prefix to the same namespace
URI), then all but one of the duplicate nodes are discarded.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Since the order of namespace nodes is <a title=
"implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a>, it is
not significant which of the duplicates is retained.</p>
</div>
</li>
<li>
<p>If an attribute <var>A</var> in the result sequence has the same
name as another attribute <var>B</var> that appears later in the
result sequence, then attribute <var>A</var> is discarded from the
result sequence. Before discarding attribute <var>A</var>, the
processor <span class="verb">may</span> signal any <a title=
"type error" class="termref" href="#dt-type-error">type errors</a>
that would be signaled if attribute <var>B</var> were not
present.</p>
</li>
<li>
<p>Each node in the resulting sequence is attached as a namespace,
attribute, or child of the newly constructed element or document
node. Conceptually this involves making a deep copy of the node; in
practice, however, copying the node will only be necessary if the
existing node can be referenced independently of the parent to
which it is being attached. When copying an element or processing
instruction node, its base URI property is changed to be the same
as that of its new parent, unless it has an <code>xml:base</code>
attribute (see <a href="#xmlbase">[XML Base]</a>) that overrides
this. If the copied element has an <code>xml:base</code> attribute,
its base URI is the value of that attribute, resolved (if it is
relative) against the base URI of the new parent node.</p>
</li>
<li>
<p>If the newly constructed node is an element node, then namespace
fixup is applied to this node, as described in <a href=
"#namespace-fixup"><i>5.8.3 Namespace Fixup</i></a>.</p>
</li>
<li>
<p>If the newly constructed node is an element node, and if
namespaces are inherited, then each namespace node of the newly
constructed element (including any produced as a result of the
namespace fixup process) is copied to each descendant element of
the newly constructed element, unless that element or an
intermediate element already has a namespace node with the same
name (or absence of a name) or that descendant element or an
intermediate element is in no namespace and the namespace node has
no name.</p>
</li>
</ol>
<div class="example">
<div class="exampleHeader"><a name="d7e17317" id=
"d7e17317"></a>Example: A Sequence Constructor for Complex
Content</div>
<p>Consider the following stylesheet fragment:</p>
<div class="exampleInner">
<pre>
&lt;td&gt;
  &lt;xsl:attribute name="valign"&gt;top&lt;/xsl:attribute&gt;
  &lt;xsl:value-of select="@description"/&gt;
&lt;/td&gt;
</pre></div>
<p>This fragment consists of a literal result element
<code>td</code>, containing a sequence constructor that consists of
two instructions: <a href=
"#element-attribute"><code>xsl:attribute</code></a> and <a href=
"#element-value-of"><code>xsl:value-of</code></a>. The sequence
constructor is evaluated to produce a sequence of two nodes: a
parentless attribute node, and a parentless text node. The
<code>td</code> instruction causes a <code>td</code> element to be
created; the new attribute therefore becomes an attribute of the
new <code>td</code> element, while the text node created by the
<a href="#element-value-of"><code>xsl:value-of</code></a>
instruction becomes a child of the <code>td</code> element (unless
it is zero-length, in which case it is discarded).</p>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e17351" id=
"d7e17351"></a>Example: Space Separators in Element Content</div>
<p>Consider the following stylesheet fragment:</p>
<div class="exampleInner">
<pre>
&lt;doc&gt;
  &lt;e&gt;&lt;xsl:sequence select="1 to 5"/&gt;&lt;/e&gt;
  &lt;f&gt;
    &lt;xsl:for-each select="1 to 5"&gt;
      &lt;xsl:value-of select="."/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/f&gt;
&lt;/doc&gt;
</pre></div>
<p>This produces the output (when indented):</p>
<div class="exampleInner">
<pre>
&lt;doc&gt;
  &lt;e&gt;1 2 3 4 5&lt;/e&gt;
  &lt;f&gt;12345&lt;/f&gt;
&lt;/doc&gt;
</pre></div>
<p>The difference between the two cases is that for the
<code>e</code> element, the sequence constructor generates a
sequence of five atomic values, which are therefore separated by
spaces. For the <code>f</code> element, the content is a sequence
of five text nodes, which are concatenated without space
separation.</p>
<p>It is important to be aware of the distinction between <a href=
"#element-sequence"><code>xsl:sequence</code></a>, which returns
the value of its <code>select</code> expression unchanged, and
<a href="#element-value-of"><code>xsl:value-of</code></a>, which
constructs a text node.</p>
</div>
</div>
<div class="div3">
<h4><a name="constructing-simple-content" id=
"constructing-simple-content"></a>5.8.2 <a href=
"#constructing-simple-content" style=
"text-decoration: none">Constructing Simple Content</a></h4>
<p>The instructions <a href=
"#element-attribute"><code>xsl:attribute</code></a>, <a href=
"#element-comment"><code>xsl:comment</code></a>, <a href=
"#element-processing-instruction"><code>xsl:processing-instruction</code></a>,
<a href="#element-namespace"><code>xsl:namespace</code></a>, and
<a href="#element-value-of"><code>xsl:value-of</code></a> all
create nodes that cannot have children. Specifically, the <a href=
"#element-attribute"><code>xsl:attribute</code></a> instruction
creates an attribute node, <a href=
"#element-comment"><code>xsl:comment</code></a> creates a comment
node, <a href=
"#element-processing-instruction"><code>xsl:processing-instruction</code></a>
creates a processing instruction node, <a href=
"#element-namespace"><code>xsl:namespace</code></a> creates a
namespace node, and <a href=
"#element-value-of"><code>xsl:value-of</code></a> creates a text
node. The string value of the new node is constructed using either
the <code>select</code> attribute of the instruction, or the
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> that forms the
content of the instruction. The <code>select</code> attribute
allows the content to be specified by means of an XPath expression,
while the sequence constructor allows it to be specified by means
of a sequence of XSLT instructions. The <code>select</code>
attribute or sequence constructor is evaluated to produce a result
sequence, and the <a title="string value" class="termref" href=
"#dt-string-value">string value</a> of the new node is derived from
this result sequence according to the rules below.</p>
<p>These rules are also used to compute the <a title=
"effective value" class="termref" href=
"#dt-effective-value">effective value</a> of a <span><a title=
"value template" class="termref" href="#dt-value-template">value
template</a></span>. In this case the sequence being processed is
the result of evaluating an XPath expression enclosed between curly
brackets, and the separator is a single space character.</p>
<ol class="enumar">
<li>
<p>Zero-length text nodes in the sequence are discarded.</p>
</li>
<li>
<p>Adjacent text nodes in the sequence are merged into a single
text node.</p>
</li>
<li>
<p>The sequence is <a title="atomize" class="termref" href=
"#dt-atomization">atomized</a> <span>(which may cause a dynamic
error)</span>.</p>
</li>
<li>
<p>Every value in the atomized sequence is cast to a string.</p>
</li>
<li>
<p>The strings within the resulting sequence are concatenated, with
a (possibly zero-length) separator inserted between successive
strings. The default separator is a single space. In the case of
<a href="#element-attribute"><code>xsl:attribute</code></a> and
<a href="#element-value-of"><code>xsl:value-of</code></a>, a
different separator can be specified using the
<code>separator</code> attribute of the instruction; it is
permissible for this to be a zero-length string, in which case the
strings are concatenated with no separator. In the case of <a href=
"#element-comment"><code>xsl:comment</code></a>, <a href=
"#element-processing-instruction"><code>xsl:processing-instruction</code></a>,
and <a href="#element-namespace"><code>xsl:namespace</code></a>,
and when expanding a <span><a title="value template" class=
"termref" href="#dt-value-template">value template</a></span>, the
default separator cannot be changed.</p>
</li>
<li>
<p>In the case of <a href=
"#element-processing-instruction"><code>xsl:processing-instruction</code></a>,
any leading spaces in the resulting string are removed.</p>
</li>
<li>
<p>The resulting string forms the <a title="string value" class=
"termref" href="#dt-string-value">string value</a> of the new
attribute, namespace, comment, processing-instruction, or text
node.</p>
</li>
</ol>
<div class="example">
<div class="exampleHeader"><a name="d7e17499" id=
"d7e17499"></a>Example: Space Separators in Attribute Content</div>
<p>Consider the following stylesheet fragment:</p>
<div class="exampleInner">
<pre>
&lt;doc&gt;
  &lt;xsl:attribute name="e" select="1 to 5"/&gt;
  &lt;xsl:attribute name="f"&gt;
    &lt;xsl:for-each select="1 to 5"&gt;
      &lt;xsl:value-of select="."/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="g" expand-text="yes"&gt;{1 to 5}&lt;/xsl:attribute&gt;
&lt;/doc&gt;
</pre></div>
<p>This produces the output:</p>
<div class="exampleInner">
<pre>
&lt;doc e="1 2 3 4 5" f="12345" g="1 2 3 4 5"/&gt;
</pre></div>
<p>The difference between the three cases is as follows. For the
<code>e</code> attribute, the sequence constructor generates a
sequence of five atomic values, which are therefore separated by
spaces. For the <code>f</code> attribute, the content is supplied
as a sequence of five text nodes, which are concatenated without
space separation. For the <code>g</code> attribute, the <a title=
"text value template" class="termref" href=
"#dt-text-value-template">text value template</a> constructs a text
node using the rules for constructing simple content, which insert
space separators between atomic values; the text node is then
atomized to form the value of the attribute.</p>
<p>Specifying <code>separator=""</code> on the first <a href=
"#element-attribute"><code>xsl:attribute</code></a> instruction
would cause the attribute value to be <code>e="12345"</code>. A
<code>separator</code> attribute on the second <a href=
"#element-attribute"><code>xsl:attribute</code></a> instruction
would have no effect, since the separator only affects the way
adjacent atomic values are handled: separators are never inserted
between adjacent text nodes. <span>A <code>separator</code> on the
third <a href="#element-attribute"><code>xsl:attribute</code></a>
instruction would also have no effect, because text value templates
are evaluated without regard to the containing
instruction.</span></p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>If an attribute value template contains a sequence of fixed and
variable parts, no additional whitespace is inserted between the
expansions of the fixed and variable parts. For example, the
<a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the attribute
<code>a="chapters{4 to 6}"</code> is <code>a="chapters4 5
6"</code>.</p>
</div>
</div>
<div class="div3">
<h4><a name="namespace-fixup" id="namespace-fixup"></a>5.8.3
<a href="#namespace-fixup" style="text-decoration: none">Namespace
Fixup</a></h4>
<p>In a tree supplied to or constructed by an XSLT processor, the
constraints relating to namespace nodes that are specified in
<a href="#xpath-datamodel-30">[Data Model]</a> <span class=
"verb">must</span> be satisfied. For example</p>
<ul>
<li>
<p>If an element node has an <a title="expanded QName" class=
"termref" href="#dt-expanded-qname">expanded QName</a> with a
non-null namespace URI, then that element node <span class=
"verb">must</span> have at least one namespace node whose <a title=
"string value" class="termref" href="#dt-string-value">string
value</a> is the same as that namespace URI.</p>
</li>
<li>
<p>If an element node has an attribute node whose <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a> has a non-null namespace URI, then the element
<span class="verb">must</span> have at least one namespace node
whose <a title="string value" class="termref" href=
"#dt-string-value">string value</a> is the same as that namespace
URI and whose name is non-empty.</p>
</li>
<li>
<p>Every element <span class="verb">must</span> have a namespace
node whose <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> has local-part
<code>xml</code> and whose <a title="string value" class="termref"
href="#dt-string-value">string value</a> is
<code>http://www.w3.org/XML/1998/namespace</code>. The namespace
prefix <code>xml</code> <span class="verb">must</span> not be
associated with any other namespace URI, and the namespace URI
<code>http://www.w3.org/XML/1998/namespace</code> <span class=
"verb">must</span> not be associated with any other prefix.</p>
</li>
<li>
<p>A namespace node <span class="verb">must not</span> have the
name <code>xmlns</code> or the string value
<code>http://www.w3.org/2000/xmlns/</code>.</p>
</li>
</ul>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-namespace-fixup" id="dt-namespace-fixup" title=
"namespace fixup"></a>The rules for the individual XSLT
instructions that construct a <a title="result tree" class=
"termref" href="#dt-result-tree">result tree</a> (see <a href=
"#creating-new-nodes"><i>11 Creating Nodes and Sequences</i></a>)
prescribe some of the situations in which namespace nodes are
written to the tree. These rules, however, are not sufficient to
ensure that the prescribed constraints are always satisfied. The
XSLT processor <span class="verb">must</span> therefore add
additional namespace nodes to satisfy these constraints. This
process is referred to as <b>namespace fixup</b>.<span class=
"definition">]</span></p>
<p>The actual namespace nodes that are added to the tree by the
namespace fixup process are <a title="implementation-dependent"
class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a>,
provided firstly, that at the end of the process the above
constraints <span class="verb">must</span> all be satisfied, and
secondly, that a namespace node <span class="verb">must not</span>
be added to the tree unless the namespace node is necessary either
to satisfy these constraints, or to enable the tree to be
serialized using the original namespace prefixes from the source
document or <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a>.</p>
<p>Namespace fixup <span class="verb">must not</span> result in an
element having multiple namespace nodes with the same name.</p>
<p>Namespace fixup <span class="verb">may</span>, if necessary to
resolve conflicts, change the namespace prefix contained in the
QName value that holds the name of an element or attribute node.
This includes the option to add or remove a prefix. However,
namespace fixup <span class="verb">must not</span> change the
prefix component contained in a value of type <code>xs:QName</code>
or <code>xs:NOTATION</code> that forms the typed value of an
element or attribute node.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Namespace fixup is not used to create namespace declarations for
<code>xs:QName</code> or <code>xs:NOTATION</code> values appearing
in the content of an element or attribute.</p>
<p>Where values acquire such types as the result of validation,
namespace fixup does not come into play, because namespace fixup
happens before validation: in this situation, it is the user's
responsibility to ensure that the element being validated has the
required namespace nodes to enable validation to succeed.</p>
<p>Where existing elements are copied along with their existing
<a title="type annotation" class="termref" href=
"#dt-type-annotation">type annotations</a>
(<code>validation="preserve"</code>) the rules require that
existing namespace nodes are also copied, so that any
namespace-sensitive values remain valid.</p>
<p>Where existing attributes are copied along with their existing
type annotations, the rules of the XDM data model require that a
parentless attribute node cannot contain a namespace-sensitive
typed value; this means that it is an error to copy an attribute
using <code>validation="preserve"</code> if it contains
namespace-sensitive content.</p>
</div>
<p>Namespace fixup is applied to every element that is constructed
using a <a title="literal result element" class="termref" href=
"#dt-literal-result-element">literal result element</a>, or one of
the instructions <a href=
"#element-element"><code>xsl:element</code></a>, <a href=
"#element-copy"><code>xsl:copy</code></a>, or <a href=
"#element-copy-of"><code>xsl:copy-of</code></a>. An implementation
is not <span class="verb">required</span> to perform namespace
fixup for elements in any source document, that is, for a document
in the <a title="initial match selection" class="termref" href=
"#dt-initial-match-selection">initial match selection</a>,
documents loaded using the <a href=
"#func-document"><code>document</code></a>, <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>
or <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-collection"><code>collection</code></a><sup><small>FO30</small></sup>
function, documents supplied as the value of a <a title=
"stylesheet parameter" class="termref" href=
"#dt-stylesheet-parameter">stylesheet parameter</a>, or documents
returned by an <a title="extension function" class="termref" href=
"#dt-extension-function">extension function</a> or <a title=
"extension instruction" class="termref" href=
"#dt-extension-instruction">extension instruction</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>A source document (an input document, a document returned by the
<a href="#func-document"><code>document</code></a>, <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>
or <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-collection"><code>collection</code></a><sup><small>FO30</small></sup>
functions, a document returned by an extension function or
extension instruction, or a document supplied as a stylesheet
parameter) is required to satisfy the constraints described in
<a href="#xpath-datamodel-30">[Data Model]</a>, including the
constraints imposed by the namespace fixup process. The effect of
supplying a pseudo-document that does not meet these constraints is
<a title="implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a>.</p>
</div>
<p>In an Infoset (see <a href="#xml-infoset">[XML Information
Set]</a>) created from a document conforming to <a href=
"#xml-names">[Namespaces in XML]</a>, it will always be true that
if a parent element has an in-scope namespace with a non-empty
namespace prefix, then its child elements will also have an
in-scope namespace with the same namespace prefix, though possibly
with a different namespace URI. This constraint is removed in
<a href="#xml-names11">[Namespaces in XML 1.1]</a>. XSLT
<span>3.0</span> supports the creation of result trees that do not
satisfy this constraint: the namespace fixup process does not add a
namespace node to an element merely because its parent node in the
<a title="result tree" class="termref" href=
"#dt-result-tree">result tree</a> has such a namespace node.
However, the process of constructing the children of a new element,
which is described in <a href=
"#constructing-complex-content"><i>5.8.1 Constructing Complex
Content</i></a>, does cause the namespaces of a parent element to
be inherited by its children unless this is prevented using
<code>[xsl:]inherit-namespaces="no"</code> on the instruction that
creates the parent element.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This has implications on serialization, defined in <a href=
"#xslt-xquery-serialization-30">[XSLT and XQuery
Serialization]</a>. It means that it is possible to create
<a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result trees</a> that cannot be
faithfully serialized as XML 1.0 documents. When such a result tree
is serialized as XML 1.0, namespace declarations written for the
parent element will be inherited by its child elements as if the
corresponding namespace nodes were present on the child element,
except in the case of the default namespace, which can be
undeclared using the construct <code>xmlns=""</code>. When the same
result tree is serialized as XML 1.1, however, it is possible to
undeclare any namespace on the child element (for example,
<code>xmlns:foo=""</code>) to prevent this inheritance taking
place.</p>
</div>
</div>
</div>
<div class="div2">
<h3><a name="uri-references" id="uri-references"></a>5.9 <a href=
"#uri-references" style="text-decoration: none">URI
References</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-uri-reference" id="dt-uri-reference" title=
"URI Reference"></a>Within this specification, the term <b>URI
Reference</b>, unless otherwise stated, refers to a string in the
lexical space of the <code>xs:anyURI</code> datatype as defined in
<a href="#xmlschema-2">[XML Schema Part 2]</a>.<span class=
"definition">]</span> Note that this is a wider definition than
that in <a href="#RFC3986">[RFC3986]</a>: in particular, it is
designed to accommodate Internationalized Resource Identifiers
(IRIs) as described in <a href="#RFC3987">[RFC3987]</a>, and thus
allows the use of non-ASCII characters without escaping.</p>
<p>URI References are used in XSLT with three main roles:</p>
<ul>
<li>
<p>As namespace URIs</p>
</li>
<li>
<p>As collation URIs</p>
</li>
<li>
<p>As identifiers for resources such as stylesheet modules; these
resources are typically accessible using a protocol such as HTTP.
Examples of such identifiers are the URIs used in the
<code>href</code> attributes of <a href=
"#element-import"><code>xsl:import</code></a>, <a href=
"#element-include"><code>xsl:include</code></a>, and <a href=
"#element-result-document"><code>xsl:result-document</code></a>.</p>
</li>
</ul>
<p>The rules for namespace URIs are given in <a href=
"#xml-names">[Namespaces in XML]</a> and <a href=
"#xml-names11">[Namespaces in XML 1.1]</a>. Those specifications
deprecate the use of relative URI <span>references</span> as
namespace URIs.</p>
<p>The rules for collation URIs are given in <a href=
"#xpath-functions-30">[Functions and Operators]</a>.</p>
<p>URI references used to identify external resources must conform
to the same rules as the locator attribute (<code>href</code>)
defined in section 5.4 of <a href="#xlink">[XLink]</a>. If the URI
reference is relative, then it is resolved (unless otherwise
specified) against the base URI of the containing element node,
according to the rules of <a href="#RFC3986">[RFC3986]</a>, after
first escaping all characters that need to be escaped to make it a
valid RFC3986 URI reference. (But a relative URI
<span>reference</span> in the <code>href</code> attribute of
<a href=
"#element-result-document"><code>xsl:result-document</code></a> is
resolved against the <a title="base output URI" class="termref"
href="#dt-base-output-uri">Base Output URI</a>.)</p>
<p>Other URI references appearing in an XSLT stylesheet document,
for example the system identifiers of external entities or the
value of the <code>xml:base</code> attribute, must follow the rules
in their respective specifications.</p>
<p>The base URI of an element node in the stylesheet is determined
as defined in <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dm-base-uri">Section 5.2
base-uri Accessor</a> <sup><small>DM30</small></sup>. Some
implementations may allow the output of the static analysis phase
of stylesheet processing (a "compiled stylesheet") to be evaluated
in a different location from that where static analysis took place.
Furthermore, stylesheet authors may in such cases which to avoid
exposing the location of resources that are private to the
development environment. If the base URI of an element in the
stylesheet is defined by an absolute URI appearing in an
<code>xml:base</code> attribute within the stylesheet, this value
<span class="verb">must</span> be used as the static base URI. In
other cases where processing depends on the static base URI of a
stylesheet module, implementations <span class="verb">may</span>
use different values for the static base URI during static analysis
and during dynamic evaluation (for example, an implementation
<span class="verb">may</span> use different base URIs for resolving
<a href="#element-import"><code>xsl:import</code></a> module
references and for resolving a relative reference used as an
argument to the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>
function). In such cases an implementation <span class=
"verb">must</span> document how the static base URI is computed for
each situation in which it is required.</p>
</div>
</div>
<div class="div1">
<h2><a name="rules" id="rules"></a>6 <a href="#rules" style=
"text-decoration: none">Template Rules</a></h2>
<p>Template rules define the processing that can be applied to
<span>items</span> that match a particular <a title="pattern"
class="termref" href="#dt-pattern">pattern</a>.</p>
<div class="div2">
<h3><a name="defining-templates" id="defining-templates"></a>6.1
<a href="#defining-templates" style=
"text-decoration: none">Defining Templates</a></h3>
<p class="element-syntax"><a name="element-template" id=
"element-template"></a><code>&lt;!-- Category: declaration
--&gt;<br />
&lt;xsl:template<br />
&#160;&#160;match? = <var>pattern</var><br />
&#160;&#160;name? = <var>eqname</var><br />
&#160;&#160;priority? = <var>decimal</var><br />
&#160;&#160;mode? = <var>tokens</var><br />
&#160;&#160;as? = <var>sequence-type</var><br />
&#160;&#160;visibility? = "public" | "private" | "final" |
"abstract"&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-context-item">xsl:context-item</a>?, <a href=
"#element-param">xsl:param</a>*, <var>sequence-constructor</var>)
--&gt;<br />
&lt;/xsl:template&gt;</code></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-template" id="dt-template" title="template"></a>An <a href=
"#element-template"><code>xsl:template</code></a> declaration
defines a <b>template</b>, which contains a <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> <span>; this
sequence constructor is evaluated to determine the result of the
template</span>. A template can serve either as a <a title=
"template rule" class="termref" href="#dt-template-rule">template
rule</a>, invoked by matching <span>items</span> against a
<a title="pattern" class="termref" href="#dt-pattern">pattern</a>,
or as a <a title="named template" class="termref" href=
"#dt-named-template">named template</a>, invoked explicitly by
name. It is also possible for the same template to serve in both
capacities.<span class="definition">]</span></p>
<p><a name="err-XTSE0500" id="err-XTSE0500"><span class=
"error">[ERR XTSE0500]</span></a> An <a href=
"#element-template"><code>xsl:template</code></a> element
<span class="verb">must</span> have either a <code>match</code>
attribute or a <code>name</code> attribute, or both. An <a href=
"#element-template"><code>xsl:template</code></a> element that has
no <code>match</code> attribute <span class="verb">must</span> have
no <code>mode</code> attribute and no <code>priority</code>
attribute. <span>An <a href=
"#element-template"><code>xsl:template</code></a> element that has
no <code>name</code> attribute <span class="verb">must</span> have
no <code>visibility</code> attribute.</span></p>
<p>If an <a href="#element-template"><code>xsl:template</code></a>
element has a <code>match</code> attribute, then it is a <a title=
"template rule" class="termref" href="#dt-template-rule">template
rule</a>. If it has a <code>name</code> attribute, then it is a
<a title="named template" class="termref" href=
"#dt-named-template">named template</a>.</p>
<p>A <a title="template" class="termref" href=
"#dt-template">template</a> may be invoked in a number of ways,
depending on whether it is a <a title="template rule" class=
"termref" href="#dt-template-rule">template rule</a>, a <a title=
"named template" class="termref" href="#dt-named-template">named
template</a>, or both. The result of invoking the template is the
result of evaluating the <a title="sequence constructor" class=
"termref" href="#dt-sequence-constructor">sequence constructor</a>
contained in the <a href=
"#element-template"><code>xsl:template</code></a> element (see
<a href="#sequence-constructors"><i>5.8 Sequence
Constructors</i></a>).</p>
<p>For details of the optional <a href=
"#element-context-item"><code>xsl:context-item</code></a> child
element, see <a href="#declaring-context-item"><i>10.1.1 Declaring
the Context Item for a Template</i></a>.</p>
<p>If an <code>as</code> attribute of the <a href=
"#element-template"><code>xsl:template</code></a> element is
present, the <code>as</code> attribute defines the required type of
the result. The result of evaluating the <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> is then
converted to the required type using the <a title=
"function conversion rules" class="termref" href=
"#dt-function-conversion-rules">function conversion rules</a>. If
no <code>as</code> attribute is specified, the default value is
<code>item()*</code>, which permits any value. No conversion then
takes place.</p>
<p><a name="err-XTTE0505" id="err-XTTE0505"><span class=
"error">[ERR XTTE0505]</span></a> It is a <a title="type error"
class="termref" href="#dt-type-error">type error</a> if the result
of evaluating the <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> cannot be
converted to the required type.</p>
<p>If the <code>visibility</code> attribute is present with the
value <code>abstract</code> then (a) the <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> defining the
template body <span class="verb">must</span> be empty: that is, the
only permitted children are <a href=
"#element-context-item"><code>xsl:context-item</code></a> and
<a href="#element-param"><code>xsl:param</code></a>, and (b) there
<span class="verb">must</span> be no <code>match</code>
attribute.</p>
<p>If the parent of the <a href=
"#element-template"><code>xsl:template</code></a> element is an
<a href="#element-override"><code>xsl:override</code></a> element,
then there must be a <code>name</code> attribute and no
<code>match</code> attribute, and the <a title="package" class=
"termref" href="#dt-package">package</a> that is the target of the
containing <a href=
"#element-use-package"><code>xsl:use-package</code></a> element
must contain among its <a title="component" class="termref" href=
"#dt-component">components</a> a <a title="named template" class=
"termref" href="#dt-named-template">named template</a> whose
<a title="symbolic identifier" class="termref" href=
"#dt-symbolic-identifier">symbolic identifier</a> is the same as
this named template, and which has a <a title="compatible" class=
"termref" href="#dt-compatible">compatible</a> signature.</p>
</div>
<div class="div2">
<h3><a name="defining-template-rules" id=
"defining-template-rules"></a>6.2 <a href=
"#defining-template-rules" style="text-decoration: none">Defining
Template Rules</a></h3>
<p>This section describes <a title="template rule" class="termref"
href="#dt-template-rule">template rules</a>. <a title=
"named template" class="termref" href="#dt-named-template">Named
templates</a> are described in <a href="#named-templates"><i>10.1
Named Templates</i></a>.</p>
<p>A <a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a> is specified using the
<a href="#element-template"><code>xsl:template</code></a> element
with a <code>match</code> attribute. The <code>match</code>
attribute is a <a href="#doc-xslt30-patterns-Pattern30">Pattern</a>
that identifies the <span>items</span> to which the rule applies.
The result of applying the template rule is the result of
evaluating the sequence constructor contained in the <a href=
"#element-template"><code>xsl:template</code></a> element, with the
matching <span>item</span> used as the <span><a title=
"context item" class="termref" href="#dt-context-item">context
item</a></span>.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e18215" id=
"d7e18215"></a>Example: A Simple Template Rule</div>
<p>For example, an XML document might contain:</p>
<div class="exampleInner">
<pre>
This is an &lt;emph&gt;important&lt;/emph&gt; point.
</pre></div>
<p>The following <a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a> matches <code>emph</code>
elements and produces a <code>fo:wrapper</code> element with a
<code>font-weight</code> property of <code>bold</code>.</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="emph"&gt;
  &lt;fo:wrapper font-weight="bold" 
              xmlns:fo="http://www.w3.org/1999/XSL/Format"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:wrapper&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
<p>A <a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a> is evaluated when an <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction selects <span>an item</span> that matches the pattern
specified in the <code>match</code> attribute. The <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction is described in the next section. If several template
rules match a selected <span>item</span>, only one of them is
evaluated, as described in <a href="#conflict"><i>6.4 Conflict
Resolution for Template Rules</i></a>.</p>
</div>
<div class="div2">
<h3><a name="applying-templates" id="applying-templates"></a>6.3
<a href="#applying-templates" style=
"text-decoration: none">Applying Template Rules</a></h3>
<p class="element-syntax"><a name="element-apply-templates" id=
"element-apply-templates"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:apply-templates<br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;mode? = <var>token</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href="#element-sort">xsl:sort</a>
| <a href="#element-with-param">xsl:with-param</a>)* --&gt;<br />
&lt;/xsl:apply-templates&gt;</code></p>
<p>The <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction takes as input a sequence of <span>items</span>
(typically nodes in a <a title="source tree" class="termref" href=
"#dt-source-tree">source tree</a>), and produces as output a
sequence of items; these will often be nodes to be added to a
<a title="result tree" class="termref" href=
"#dt-result-tree">result tree</a>.</p>
<p>If the instruction has one or more <a href=
"#element-sort"><code>xsl:sort</code></a> children, then the input
sequence is sorted as described in <a href="#sorting"><i>13
Sorting</i></a>. The result of this sort is referred to below as
the <b>sorted sequence</b>; if there are no <a href=
"#element-sort"><code>xsl:sort</code></a> elements, then the sorted
sequence is the same as the input sequence.</p>
<p>Each <span>item</span> in the input sequence is processed by
finding a <a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a> whose <a title="pattern"
class="termref" href="#dt-pattern">pattern</a> matches that
<span>item</span>. If there is more than one such template rule,
the best among them is chosen, using rules described in <a href=
"#conflict"><i>6.4 Conflict Resolution for Template Rules</i></a>.
If there is no template rule whose pattern matches the
<span>item</span>, a built-in template rule is used (see <a href=
"#built-in-rule"><i>6.7 Built-in Template Rules</i></a>). The
chosen template rule is evaluated. The rule that matches the
<var>N</var>th <span>item</span> in the sorted sequence is
evaluated with that <span>item</span> as the <a title=
"context item" class="termref" href="#dt-context-item">context
item</a>, with <var>N</var> as the <a title="context position"
class="termref" href="#dt-context-position">context position</a>,
and with the length of the sorted sequence as the <a title=
"context size" class="termref" href="#dt-context-size">context
size</a>. Each template rule that is evaluated produces a sequence
of items as its result. The resulting sequences (one for each
<span>item</span> in the sorted sequence) are then concatenated, to
form a single sequence. They are concatenated retaining the order
of the <span>items</span> in the sorted sequence. The final
concatenated sequence forms the result of the <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e18358" id=
"d7e18358"></a>Example: Applying Template Rules</div>
<p>Suppose the source document is as follows:</p>
<div class="exampleInner">
<pre>
&lt;message&gt;Proceed &lt;emph&gt;at once&lt;/emph&gt; to the exit!&lt;/message&gt;
</pre></div>
<p>This can be processed using the two template rules shown
below.</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="message"&gt;
  &lt;p&gt;
    &lt;xsl:apply-templates select="child::node()"/&gt;
  &lt;/p&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="emph"&gt;
  &lt;b&gt;
    &lt;xsl:apply-templates select="child::node()"/&gt;
  &lt;/b&gt;
&lt;/xsl:template&gt;
</pre></div>
<p>There is no template rule for the document node; the built-in
template rule for this node will cause the <code>message</code>
element to be processed. The template rule for the
<code>message</code> element causes a <code>p</code> element to be
written to the <a title="result tree" class="termref" href=
"#dt-result-tree">result tree</a>; the contents of this
<code>p</code> element are constructed as the result of the
<a href="#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction. This instruction selects the three child nodes of the
<code>message</code> element (a text node containing the value
"<code>Proceed</code> ", an <code>emph</code> element node, and a
text node containing the value " <code>to the exit!</code>"). The
two text nodes are processed using the built-in template rule for
text nodes, which returns a copy of the text node. The
<code>emph</code> element is processed using the explicit template
rule that specifies <code>match="emph"</code>.</p>
<p>When the <code>emph</code> element is processed, this template
rule constructs a <code>b</code> element. The contents of the
<code>b</code> element are constructed by means of another <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction, which in this case selects a single node (the text
node containing the value "<code>at once</code>"). This is again
processed using the built-in template rule for text nodes, which
returns a copy of the text node.</p>
<p>The final result of the <code>match="message"</code> template
rule thus consists of a <code>p</code> element node with three
children: a text node containing the value "<code>Proceed</code> ",
a <code>b</code> element that is the parent of a text node
containing the value "<code>at once</code>", and a text node
containing the value " <code>to the exit!</code>". This <a title=
"result tree" class="termref" href="#dt-result-tree">result
tree</a> might be serialized as:</p>
<div class="exampleInner">
<pre>
&lt;p&gt;Proceed &lt;b&gt;at once&lt;/b&gt; to the exit!&lt;/p&gt;
</pre></div>
</div>
<p>The default value of the <code>select</code> attribute is
<code>child::node()</code>, which causes all the children of the
context node to be processed.</p>
<p><a name="err-XTTE0510" id="err-XTTE0510"><span class=
"error">[ERR XTTE0510]</span></a> It is a <a title="type error"
class="termref" href="#dt-type-error">type error</a> if an <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction with no <code>select</code> attribute is evaluated when
the <a title="context item" class="termref" href=
"#dt-context-item">context item</a> is not a node.</p>
<p>A <code>select</code> attribute can be used to process
<span>items</span> selected by an expression instead of processing
all children. The value of the <code>select</code> attribute is an
<a title="expression" class="termref" href=
"#dt-expression">expression</a>.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e18522" id=
"d7e18522"></a>Example: Applying Templates to Selected Nodes</div>
<p>The following example processes all of the
<code>given-name</code> children of the <code>author</code>
elements that are children of <code>author-group</code>:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="author-group"&gt;
  &lt;fo:wrapper&gt;
    &lt;xsl:apply-templates select="author/given-name"/&gt;
  &lt;/fo:wrapper&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e18538" id=
"d7e18538"></a>Example: Applying Templates to Nodes that are not
Descendants</div>
<p>It is also possible to process elements that are not descendants
of the context node. This example assumes that a
<code>department</code> element has <code>group</code> children and
<code>employee</code> descendants. It finds an employee's
department and then processes the <code>group</code> children of
the <code>department</code>.</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="employee"&gt;
  &lt;fo:block&gt;
    Employee &lt;xsl:apply-templates select="name"/&gt; belongs to group
    &lt;xsl:apply-templates select="ancestor::department/group"/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e18560" id=
"d7e18560"></a>Example: Matching Nodes by Schema-Defined
Types</div>
<p>It is possible to write template rules that are matched
according to the schema-defined type of an element or attribute.
The following example applies different formatting to the children
of an element depending on their type:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="product"&gt;
  &lt;table&gt;
    &lt;xsl:apply-templates select="*"/&gt;
  &lt;/table&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="product/*" priority="3"&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;xsl:value-of select="name()"/&gt;&lt;/td&gt;
    &lt;td&gt;&lt;xsl:next-match/&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="product/element(*, xs:decimal) | 
                     product/element(*, xs:double)" priority="2"&gt;  
  &lt;xsl:value-of select="format-number(xs:double(.), '#,###0.00')"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="product/element(*, xs:date)" priority="2"&gt;
  &lt;xsl:value-of select="format-date(., '[Mn] [D], [Y]')"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="product/*" priority="1.5"&gt;
  &lt;xsl:value-of select="."/&gt;
&lt;/xsl:template&gt;
</pre></div>
<p>The <a href=
"#element-next-match"><code>xsl:next-match</code></a> instruction
is described in <a href="#apply-imports"><i>6.8 Overriding Template
Rules</i></a>.</p>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e18574" id=
"d7e18574"></a>Example: Re-ordering Elements in the Result
Tree</div>
<p>Multiple <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
elements can be used within a single template to do simple
reordering. The following example creates two HTML tables. The
first table is filled with domestic sales while the second table is
filled with foreign sales.</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="product"&gt;
  &lt;table&gt;
    &lt;xsl:apply-templates select="sales/domestic"/&gt;
  &lt;/table&gt;
  &lt;table&gt;
    &lt;xsl:apply-templates select="sales/foreign"/&gt;
  &lt;/table&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e18584" id=
"d7e18584"></a>Example: Processing Recursive Structures</div>
<p>It is possible for there to be two matching descendants where
one is a descendant of the other. This case is not treated
specially: both descendants will be processed as usual.</p>
<p>For example, given a source document</p>
<div class="exampleInner">
<pre>
&lt;doc&gt;&lt;div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/doc&gt;
</pre></div>
<p>the rule</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="doc"&gt;
  &lt;xsl:apply-templates select=".//div"/&gt;
&lt;/xsl:template&gt;
</pre></div>
<p>will process both the outer <code>div</code> and inner
<code>div</code> elements.</p>
<p>This means that if the template rule for the <code>div</code>
element processes its own children, then these grandchildren will
be processed more than once, which is probably not what is
required. The solution is to process one level at a time in a
recursive descent, by using <code>select="div"</code> in place of
<code>select=".//div"</code></p>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e18616" id=
"d7e18616"></a>Example: Applying Templates to Atomic Values</div>
<p>This example reads a non-XML text file and processes it
line-by-line, applying different template rules based on the
content of each line:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template name="main"&gt;
  &lt;xsl:apply-templates select="unparsed-text-lines('input.txt')"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match=".[starts-with(., '==')]"&gt;
  &lt;h2&gt;&lt;xsl:value-of select="replace(., '==', '')"/&gt;&lt;/h2&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match=".[starts-with(., '::')]"&gt;
  &lt;p class="indent"&gt;&lt;xsl:value-of select="replace(., '::', '')"/&gt;&lt;/p&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="."&gt;
  &lt;p class="body"&gt;&lt;xsl:value-of select="."/&gt;&lt;/p&gt;
&lt;/xsl:template&gt;

</pre></div>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction is most commonly used to process nodes that are
descendants of the context node. Such use of <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
cannot result in non-terminating processing loops. However, when
<a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a> is
used to process elements that are not descendants of the context
node, the possibility arises of non-terminating loops. For
example,</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="foo"&gt;
  &lt;xsl:apply-templates select="."/&gt;
&lt;/xsl:template&gt;
</pre></div>
<p>Implementations may be able to detect such loops in some cases,
but the possibility exists that a <a title="stylesheet" class=
"termref" href="#dt-stylesheet">stylesheet</a> may enter a
non-terminating loop that an implementation is unable to detect.
This may present a denial of service security risk.</p>
</div>
</div>
<div class="div2">
<h3><a name="conflict" id="conflict"></a>6.4 <a href="#conflict"
style="text-decoration: none">Conflict Resolution for Template
Rules</a></h3>
<p>It is possible for <span>a selected item</span> to match more
than one <a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a> with a given <a title="mode"
class="termref" href="#dt-mode">mode</a> <var>M</var>. When this
happens, only one template rule is evaluated for the
<span>item</span>. The template rule to be used is determined as
follows:</p>
<ol class="enumar">
<li>
<p>First, only the matching template rule or rules with the highest
<a title="import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a> are considered. Other
matching template rules with lower precedence are eliminated from
consideration.</p>
</li>
<li>
<p>Next, of the remaining matching rules, only those with the
highest priority are considered. Other matching template rules with
lower priority are eliminated from consideration.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-priority" id="dt-priority" title="priority"></a>The
<b>priority</b> of a template rule is specified by the
<code>priority</code> attribute on the <a href=
"#element-template"><code>xsl:template</code></a> declaration. If
no priority is specified explicitly for a template rule, its
<a title="default priority" class="termref" href=
"#dt-default-priority">default priority</a> is used, as defined in
<a href="#default-priority"><i>6.5 Default Priority for Template
Rules</i></a>.<span class="definition">]</span></p>
<p><a name="err-XTSE0530" id="err-XTSE0530"><span class=
"error">[ERR XTSE0530]</span></a> The value of the
<code>priority</code> attribute <span class="verb">must</span>
conform to the rules for the <code>xs:decimal</code> type defined
in <a href="#xmlschema-2">[XML Schema Part 2]</a>. Negative values
are permitted.</p>
</li>
<li>
<p>If this leaves more than one matching template rule, then:</p>
<ol class="enumla">
<li>
<p>If the <a title="mode" class="termref" href="#dt-mode">mode</a>
<var>M</var> has an <a href=
"#element-mode"><code>xsl:mode</code></a> declaration, and the
attribute value <code>on-multiple-match="fail"</code> is specified
in the mode declaration, a dynamic error is signaled. The error is
treated as occurring in the <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction, and can be recovered by wrapping that instruction in
an <a href="#element-try"><code>xsl:try</code></a> instruction.</p>
<p><a name="err-XTDE0540" id="err-XTDE0540"><span class=
"error">[ERR XTDE0540]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
conflict resolution algorithm for template rules leaves more than
one matching template rule <span>when the declaration of the
relevant <a title="mode" class="termref" href="#dt-mode">mode</a>
has an <code>on-multiple-match</code> attribute with the value
<code>fail</code></span>.</p>
</li>
<li>
<p>Otherwise, of the matching template rules that remain, the one
that occurs last in <a title="declaration order" class="termref"
href="#dt-declaration-order">declaration order</a> is used.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This was a recoverable error in XSLT 2.0, meaning that it was
implementation-defined whether the error was signaled, or whether
the ambiguity was resolved by taking the last matching rule in
declaration order. In XSLT 3.0 this situation is not an error
unless the attribute value <code>on-multiple-match="fail"</code> is
specified in the mode declaration. It is also possible to request
warnings when this condition arises, by means of the attribute
<span><code>warning-on-multiple-match="yes"</code></span>.</p>
</div>
</li>
</ol>
</div>
<div class="div2">
<h3><a name="default-priority" id="default-priority"></a>6.5
<a href="#default-priority" style="text-decoration: none">Default
Priority for Template Rules</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-default-priority" id="dt-default-priority" title=
"default priority"></a>If no <code>priority</code> attribute is
specified on an <a href=
"#element-template"><code>xsl:template</code></a> element, a
<b>default priority</b> is computed, based on the syntax of the
<a title="pattern" class="termref" href="#dt-pattern">pattern</a>
supplied in the <code>match</code> attribute.<span class=
"definition">]</span> The rules are as follows.</p>
<ol class="enumar">
<li>
<p>If the top-level pattern is a <a href=
"#doc-xslt30-patterns-ParenthesizedExprP">ParenthesizedExprP</a>
then the outer parentheses are effectively stripped; these rules
are applied recursively to the <a href=
"#doc-xslt30-patterns-UnionExprP">UnionExprP</a> contained in the
<a href=
"#doc-xslt30-patterns-ParenthesizedExprP">ParenthesizedExprP</a>.</p>
</li>
<li>
<p>If the top-level pattern is a <a href=
"#doc-xslt30-patterns-UnionExprP">UnionExprP</a> consisting of
multiple alternatives separated by <code>|</code> or
<code>union</code>, then the template rule is treated equivalently
to a set of template rules, one for each alternative. <span>These
template rules are adjacent to each other in declaration order, and
the declaration order within this set of template rules (which
affects the result of <a href=
"#element-next-match"><code>xsl:next-match</code></a> if the
alternatives have the same default priority) is the order of
alternatives in the <a href=
"#doc-xslt30-patterns-UnionExprP">UnionExprP</a>.</span></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The splitting of a template rule into multiple rules occurs only
if there is no explicit <code>priority</code> attribute.</p>
</div>
</li>
<li>
<p>If the top-level pattern is an <a href=
"#doc-xslt30-patterns-IntersectExceptExprP">IntersectExceptExprP</a>
containing two or more <a href=
"#doc-xslt30-patterns-PathExprP">PathExprP</a> operands separated
by <code>intersect</code> or <code>except</code> operators, then
the priority of the pattern is that of the first <a href=
"#doc-xslt30-patterns-PathExprP">PathExprP</a>.</p>
</li>
<li>
<p>If the pattern is a <a href=
"#doc-xslt30-patterns-PredicatePattern">PredicatePattern</a> then
its priority is 1 (one), unless the <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-PredicateList">PredicateList</a><sup><small>XP30</small></sup>
is empty, in which case the priority is −1 (minus one).</p>
</li>
<li>
<p>If the pattern is a <a href=
"#doc-xslt30-patterns-PathExprP">PathExprP</a> taking the form
<code>/</code>, then the priority is −0.5 (minus 0.5).</p>
</li>
<li>
<p>If the pattern is a <a href=
"#doc-xslt30-patterns-PathExprP">PathExprP</a> taking the form of
an <a title="EQName" class="termref" href="#dt-eqname">EQName</a>
optionally preceded by a <a href=
"#doc-xslt30-patterns-ForwardAxisP">ForwardAxisP</a> or has the
form <code>processing-instruction(</code> <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-StringLiteral">StringLiteral</a><sup><small>XP30</small></sup>
<code>)</code> or <code>processing-instruction(</code> <a href=
"http://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a><sup><small>Names</small></sup>
<code>)</code> optionally preceded by a <a href=
"#doc-xslt30-patterns-ForwardAxisP">ForwardAxisP</a>, then the
priority is 0 (zero).</p>
</li>
<li>
<p>If the pattern is a <a href=
"#doc-xslt30-patterns-PathExprP">PathExprP</a> taking the form of
an <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-ElementTest">ElementTest</a><sup><small>XP30</small></sup>
or <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-AttributeTest">AttributeTest</a><sup><small>XP30</small></sup>,
optionally preceded by a <a href=
"#doc-xslt30-patterns-ForwardAxisP">ForwardAxisP</a>, then the
priority is as shown in the table below. In this table, the symbols
<var>E</var>, <var>A</var>, and <var>T</var> represent an arbitrary
element name, attribute name, and type name respectively, while the
symbol <code>*</code> represents itself. The presence or absence of
the symbol <code>?</code> following a type name does not affect the
priority.</p>
<table border="1" cellpadding="5" summary=
"default priority of patterns" width="100%">
<thead>
<tr>
<th align="left" colspan="1" valign="top">Format</th>
<th align="left" colspan="1" valign="top">Priority</th>
<th align="left" colspan="1" valign="top">Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><code>element()</code></td>
<td align="left" valign="top">−0.5</td>
<td align="left" valign="top">(equivalent to <code>*</code>)</td>
</tr>
<tr>
<td align="left" valign="top"><code>element(*)</code></td>
<td align="left" valign="top">−0.5</td>
<td align="left" valign="top">(equivalent to <code>*</code>)</td>
</tr>
<tr>
<td align="left" valign="top"><code>attribute()</code></td>
<td align="left" valign="top">−0.5</td>
<td align="left" valign="top">(equivalent to <code>@*</code>)</td>
</tr>
<tr>
<td align="left" valign="top"><code>attribute(*)</code></td>
<td align="left" valign="top">−0.5</td>
<td align="left" valign="top">(equivalent to <code>@*</code>)</td>
</tr>
<tr>
<td align="left" valign="top">
<code>element(<var>E</var>)</code></td>
<td align="left" valign="top">0</td>
<td align="left" valign="top">(equivalent to E)</td>
</tr>
<tr>
<td align="left" valign="top">
<code>element(*,<var>T</var>)</code></td>
<td align="left" valign="top">0</td>
<td align="left" valign="top">(matches by type only)</td>
</tr>
<tr>
<td align="left" valign="top">
<code>attribute(<var>A</var>)</code></td>
<td align="left" valign="top">0</td>
<td align="left" valign="top">(equivalent to <code>@A</code>)</td>
</tr>
<tr>
<td align="left" valign="top">
<code>attribute(*,<var>T</var>)</code></td>
<td align="left" valign="top">0</td>
<td align="left" valign="top">(matches by type only)</td>
</tr>
<tr>
<td align="left" valign="top">
<code>element(<var>E</var>,<var>T</var>)</code></td>
<td align="left" valign="top">0.25</td>
<td align="left" valign="top">(matches by name and type)</td>
</tr>
<tr>
<td align="left" valign="top">
<code>schema-element(<var>E</var>)</code></td>
<td align="left" valign="top">0.25</td>
<td align="left" valign="top">(matches by substitution group and
type)</td>
</tr>
<tr>
<td align="left" valign="top">
<code>attribute(<var>A</var>,<var>T</var>)</code></td>
<td align="left" valign="top">0.25</td>
<td align="left" valign="top">(matches by name and type)</td>
</tr>
<tr>
<td align="left" valign="top">
<code>schema-attribute(<var>A</var>)</code></td>
<td align="left" valign="top">0.25</td>
<td align="left" valign="top">(matches by name and type)</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>If the pattern is a <a href=
"#doc-xslt30-patterns-PathExprP">PathExprP</a> taking the form of a
<a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-DocumentTest">DocumentTest</a><sup><small>XP30</small></sup>,
then if it includes no <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-ElementTest">ElementTest</a><sup><small>XP30</small></sup>
or <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-SchemaElementTest">SchemaElementTest</a><sup><small>XP30</small></sup>
the priority is −0.5. If it does include an <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-ElementTest">ElementTest</a><sup><small>XP30</small></sup>
or <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-SchemaElementTest">SchemaElementTest</a><sup><small>XP30</small></sup>,
then the priority is the same as the priority of that <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-ElementTest">ElementTest</a><sup><small>XP30</small></sup>
or <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-SchemaElementTest">SchemaElementTest</a><sup><small>XP30</small></sup>,
computed according to the table above.</p>
</li>
<li>
<p>If the pattern is a <a href=
"#doc-xslt30-patterns-PathExprP">PathExprP</a> taking the form of
an <a href=
"http://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a><sup><small>Names</small></sup><code>:*</code>
or <code>*:</code><a href=
"http://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a><sup><small>Names</small></sup>,
optionally preceded by a <a href=
"#doc-xslt30-patterns-ForwardAxisP">ForwardAxisP</a>, then the
priority is −0.25.</p>
</li>
<li>
<p>If the pattern is a <a href=
"#doc-xslt30-patterns-PathExprP">PathExprP</a> taking the form of
any other <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-NodeTest">NodeTest</a><sup><small>XP30</small></sup>,
optionally preceded by a <a href=
"#doc-xslt30-patterns-ForwardAxisP">ForwardAxisP</a>, then the
priority is −0.5.</p>
</li>
<li>
<p>In all other cases, the priority is +0.5.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In many cases this means that highly selective patterns have
higher priority than less selective patterns. The most common kind
of pattern (a pattern that tests for a node of a particular kind,
with a particular <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> or a particular type) has
priority 0. The next less specific kind of pattern (a pattern that
tests for a node of a particular kind and an <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a> with a particular namespace URI) has priority −0.25.
Patterns less specific than this (patterns that just test for nodes
of a given kind) have priority −0.5. Patterns that specify both the
name and the required type have a priority of +0.25, putting them
above patterns that only specify the name <em>or</em> the type.
Patterns more specific than this, for example patterns that include
predicates or that specify the ancestry of the required node, have
priority 0.5.</p>
<p>However, it is not invariably true that a more selective pattern
has higher priority than a less selective pattern. For example, the
priority of the pattern <code>node()[self::*]</code> is higher than
that of the pattern <code>salary</code>. Similarly, the patterns
<code>attribute(*, xs:decimal)</code> and <code>attribute(*,
xs:short)</code> have the same priority, despite the fact that the
latter pattern matches a subset of the nodes matched by the former.
Therefore, to achieve clarity in a <a title="stylesheet" class=
"termref" href="#dt-stylesheet">stylesheet</a> it is good practice
to allocate explicit priorities.</p>
</div>
</div>
<div class="div2">
<h3><a name="modes" id="modes"></a>6.6 <a href="#modes" style=
"text-decoration: none">Modes</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-mode" id="dt-mode" title="mode"></a> <b>Modes</b> allow a node
in a <a title="source tree" class="termref" href=
"#dt-source-tree">source tree</a> to be processed multiple times,
each time producing a different result. They also allow different
sets of <a title="template rule" class="termref" href=
"#dt-template-rule">template rules</a> to be active when processing
different trees, for example when processing documents loaded using
the <a href="#func-document"><code>document</code></a> function
(see <a href="#func-document"><i>20.1 fn:document</i></a>) or when
processing <a title="temporary tree" class="termref" href=
"#dt-temporary-tree">temporary trees</a>.<span class=
"definition">]</span></p>
<p>Modes are identified by an <a title="expanded QName" class=
"termref" href="#dt-expanded-qname">expanded QName</a>; in addition
to any named modes, there is always one unnamed mode available.
Whether a mode is named or unnamed, its properties <span class=
"verb">may</span> be defined in an <a href=
"#element-mode"><code>xsl:mode</code></a> declaration. If a mode
name is used (for example in an <a href=
"#element-template"><code>xsl:template</code></a> declaration or an
<a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction) and no declaration of that mode appears in the
stylesheet, the mode is implicitly declared with default
properties.</p>
<div class="div3">
<h4><a name="declaring-modes" id="declaring-modes"></a>6.6.1
<a href="#declaring-modes" style="text-decoration: none">Declaring
Modes</a></h4>
<p class="element-syntax"><a name="element-mode" id=
"element-mode"></a><code>&lt;!-- Category: declaration --&gt;<br />
&lt;xsl:mode<br />
&#160;&#160;name? = <var>eqname</var><br />
&#160;&#160;streamable? = <var>boolean</var><br />
&#160;&#160;on-no-match? = "deep-copy" | "shallow-copy" |
"deep-skip" | "shallow-skip" | "text-only-copy" | "fail"<br />
&#160;&#160;on-multiple-match? = "use-last" | "fail"<br />
&#160;&#160;warning-on-no-match? = <var>boolean</var><br />
&#160;&#160;warning-on-multiple-match? = <var>boolean</var><br />
&#160;&#160;typed? = <var>boolean</var> | "strict" | "lax" |
"unspecified"<br />
&#160;&#160;visibility? = "public" | "private" |
"final"&#160;/&gt;</code></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-unnamed-mode" id="dt-unnamed-mode" title="unnamed mode"></a>The
<b>unnamed mode</b> is the default mode used when no
<code>mode</code> attribute is specified on an <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction or <a href=
"#element-template"><code>xsl:template</code></a> declaration,
unless a different default mode has been specified using the
<span><code>[xsl:]default-mode</code> attribute of a containing
element</span>.<span class="definition">]</span></p>
<p>Every <a title="mode" class="termref" href="#dt-mode">mode</a>
other than the <a title="unnamed mode" class="termref" href=
"#dt-unnamed-mode">unnamed mode</a> is identified by an <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a>.</p>
<p>A <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> may contain multiple <a href=
"#element-mode"><code>xsl:mode</code></a> declarations and may
include or import <a title="stylesheet module" class="termref"
href="#dt-stylesheet-module">stylesheet modules</a> that also
contain <a href="#element-mode"><code>xsl:mode</code></a>
declarations. The name of an <a href=
"#element-mode"><code>xsl:mode</code></a> declaration is the value
of its <code>name</code> attribute, if any.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-mode-definition" id="dt-mode-definition" title=
"mode definition"></a>All the <a href=
"#element-mode"><code>xsl:mode</code></a> declarations in a
<span><a title="package" class="termref" href=
"#dt-package">package</a></span> that share the same name are
grouped into a named <b>mode definition</b>; those that have no
name are grouped into a single unnamed mode definition.<span class=
"definition">]</span></p>
<p><span>The <code>declared-modes</code> attribute of the <a href=
"#element-package"><code>xsl:package</code></a> element determines
whether implicit mode declarations are allowed, as described in
<a href="#requiring-explicit-modes"><i>3.6.4.1 Requiring Explicit
Mode Declarations</i></a>. If the package allows implicit mode
declarations, then</span> if a <a title="stylesheet" class=
"termref" href="#dt-stylesheet">stylesheet</a> does not contain a
declaration of the unnamed mode, a declaration is implied
equivalent to an <a href="#element-mode"><code>xsl:mode</code></a>
element with <span>no attributes</span>. Similarly, if there is a
mode that is named in an <a href=
"#element-template"><code>xsl:template</code></a> or <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
element, or in the <span><code>[xsl:]default-mode</code> attribute
of a containing element</span>, and the <a title="stylesheet"
class="termref" href="#dt-stylesheet">stylesheet</a> does not
contain a declaration of that mode, then a declaration is implied
comprising an <a href="#element-mode"><code>xsl:mode</code></a>
element with a <code>name</code> attribute <span>equal to that mode
name, plus the attribute
<code>visibility="private"</code></span>.</p>
<p>The attributes of the <a href=
"#element-mode"><code>xsl:mode</code></a> declaration establish
values for a number of properties of a mode. The allowed values and
meanings of the attributes are given in the following table.</p>
<table cellpadding="5" width="100%" summary=
"attributes of the xsl:mode element" border="1">
<thead>
<tr>
<th colspan="1" align="left" valign="top">Attribute</th>
<th colspan="1" align="left" valign="top">Values</th>
<th colspan="1" align="left" valign="top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td valign="top" align="left">name</td>
<td valign="top" align="left">An <a title="EQName" class="termref"
href="#dt-eqname">EQName</a></td>
<td valign="top" align="left">Specifies the name of the mode. If
omitted, this <a href="#element-mode"><code>xsl:mode</code></a>
declaration provides properties of the <a title="unnamed mode"
class="termref" href="#dt-unnamed-mode">unnamed mode</a></td>
</tr>
<tr>
<td valign="top" align="left">streamable</td>
<td valign="top" align="left"><code>yes</code> or <code>no</code>
(default <code>no</code>)</td>
<td valign="top" align="left">Determines whether template rules in
this mode are to be capable of being processed using <a title=
"streaming" class="termref" href="#dt-streaming">streaming</a>. If
the value <code>yes</code> is specified, then the body of any
<a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a> that uses this mode
<span class="verb">must</span> conform to the rules for streamable
templates given in <a href="#streamable-templates"><i>6.6.4
Streamable Templates</i></a>.</td>
</tr>
<tr>
<td valign="top" align="left">on-no-match</td>
<td valign="top" align="left"><span>One of <code>deep-copy</code>,
<code>shallow-copy</code>, <code>deep-skip</code>,
<code>shallow-skip</code>, <code>text-only-copy</code> or
<code>fail</code> (default <code>text-only-copy</code>)</span></td>
<td valign="top" align="left">Determines selection of the built-in
<a title="template rule" class="termref" href=
"#dt-template-rule">template rules</a> that are used to process a
node when an <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction selects a node that does not match any user-written
<a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a> in the <a title="stylesheet"
class="termref" href="#dt-stylesheet">stylesheet</a>. For details,
see <a href="#built-in-rule"><i>6.7 Built-in Template
Rules</i></a>.</td>
</tr>
<tr>
<td valign="top" align="left">on-multiple-match</td>
<td valign="top" align="left">One of <code>fail</code> or
<code>use-last</code> (default <code>use-last</code>)</td>
<td valign="top" align="left">Defines the action to be taken when
<a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a> is
used in this mode and more than one user-written <a title=
"template rule" class="termref" href="#dt-template-rule">template
rule</a> is available to process the node, having the same
<a title="import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a> and <a title=
"priority" class="termref" href="#dt-priority">priority</a>. The
value <code>fail</code> indicates that it is a <a title=
"dynamic error" class="termref" href="#dt-dynamic-error">dynamic
error</a> if more than one template rule matches the node. The
value <code>use-last</code> indicates that the situation is not to
be treated as an error (the last template in <a title=
"declaration order" class="termref" href=
"#dt-declaration-order">declaration order</a> is the one that is
used).</td>
</tr>
<tr>
<td valign="top" align="left">warning-on-no-match</td>
<td valign="top" align="left">One of <code>yes</code> or
<code>no</code>. The default is <a title="implementation-defined"
class="termref" href=
"#dt-implementation-defined">implementation-defined</a></td>
<td valign="top" align="left">Requests the <a title="processor"
class="termref" href="#dt-processor">processor</a> to output (or
not to output) a warning message in the case where an <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction selects a node that matches no template rule. The form
and destination of such warnings is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. The
processor <span class="verb">may</span> ignore this attribute, for
example if the environment provides no suitable means of
communicating with the user.</td>
</tr>
<tr>
<td valign="top" align="left">warning-on-multiple-match</td>
<td valign="top" align="left">One of <code>yes</code> or
<code>no</code>. The default is <a title="implementation-defined"
class="termref" href=
"#dt-implementation-defined">implementation-defined</a></td>
<td valign="top" align="left">Requests the <a title="processor"
class="termref" href="#dt-processor">processor</a> to output a
warning message in the case where an <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction selects a node that matches multiple template rules
having the same <a title="import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a> and <a title=
"priority" class="termref" href="#dt-priority">priority</a>. The
form and destination of such warnings is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. The
processor <span class="verb">may</span> ignore this attribute, for
example if the environment provides no suitable means of
communicating with the user.</td>
</tr>
<tr>
<td valign="top" align="left">typed</td>
<td valign="top" align="left">One of <code>yes</code>,
<code>no</code>, <code>strict</code>, <code>lax</code>, or
<code>unspecified</code>. The default is
<code>unspecified</code>.</td>
<td valign="top" align="left"><span>See <a href=
"#xsl-mode-typed"><i>6.6.3 Declaring the Type of Nodes Processed by
a Mode</i></a>.</span></td>
</tr>
<tr>
<td valign="top" align="left">visibility</td>
<td valign="top" align="left">One of <code>public</code>,
<code>private</code>, or <code>final</code>. The default is
<code>private</code>.</td>
<td valign="top" align="left">See <a href="#visibility"><i>3.6.3.1
Visibility of Components</i></a>. <span>If the mode is unnamed,
that is, if the <code>name</code> attribute is absent, then the
<code>visibility</code> attribute if present <span class=
"verb">must</span> have the value <code>private</code></span>.
<span>A <span>named</span> mode is not eligible to be used as the
<a title="initial mode" class="termref" href=
"#dt-initial-mode">initial mode</a> if its visibility is
<code>private</code>.</span></td>
</tr>
</tbody>
</table>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-streamable-mode" id="dt-streamable-mode" title=
"streamable mode"></a>A <b>streamable mode</b> is a <a title="mode"
class="termref" href="#dt-mode">mode</a> that is declared in an
<a href="#element-mode"><code>xsl:mode</code></a> declaration with
the attribute <code>streamable="yes"</code>.<span class=
"definition">]</span></p>
<p>For any named <a title="mode" class="termref" href=
"#dt-mode">mode</a>, the effective value of each attribute is taken
from an <a href="#element-mode"><code>xsl:mode</code></a>
declaration that has a matching name in its <code>name</code>
attribute, and that specifies an explicit value for the required
attribute. <span>If there is no such declaration, the default value
of the attribute is used.</span> If there is more than one such
declaration, the one with highest <a title="import precedence"
class="termref" href="#dt-import-precedence">import precedence</a>
is used.</p>
<p>For the <a title="unnamed mode" class="termref" href=
"#dt-unnamed-mode">unnamed mode</a>, the effective value of each
attribute is taken from an <a href=
"#element-mode"><code>xsl:mode</code></a> declaration that has no
<code>name</code> attribute, and that specifies an explicit value
for the required attribute. If there is no such declaration, the
default value of the attribute is used. If there is more than one
such declaration, the one with highest <a title="import precedence"
class="termref" href="#dt-import-precedence">import precedence</a>
is used.</p>
<p>The above rules apply both to the attributes (other than
<code>name</code>) of the <a href=
"#element-mode"><code>xsl:mode</code></a> element itself, and to
the attributes of the contained <a href=
"#element-context-item"><code>xsl:context-item</code></a> element
if present.</p>
<p><a name="err-XTSE0545" id="err-XTSE0545"><span class=
"error">[ERR XTSE0545]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if for any
named or unnamed <a title="mode" class="termref" href=
"#dt-mode">mode</a>, <span>a package explicitly specifies</span>
two conflicting values for the same attribute in different <a href=
"#element-mode"><code>xsl:mode</code></a> declarations having the
same <a title="import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a>, unless there is
another definition of the same attribute with higher import
precedence. The attributes in question are the attributes other
than <code>name</code> on the <a href=
"#element-mode"><code>xsl:mode</code></a> element.</p>
</div>
<div class="div3">
<h4><a name="using-modes" id="using-modes"></a>6.6.2 <a href=
"#using-modes" style="text-decoration: none">Using Modes</a></h4>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-applicable" id="dt-applicable" title="applicable"></a>A
<a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a> is <b>applicable</b> to one
or more modes. The modes to which it is applicable are defined by
the <code>mode</code> attribute of the <a href=
"#element-template"><code>xsl:template</code></a> element. If the
attribute is omitted, then the template rule is applicable to the
<span>default mode specified in the
<span><code>[xsl:]default-mode</code> attribute of the innermost
containing element that has such an attribute</span>, which in turn
defaults to the <a title="unnamed mode" class="termref" href=
"#dt-unnamed-mode">unnamed mode</a>.</span> If the
<code>mode</code> attribute is present, then its value <span class=
"verb">must</span> be a non-empty whitespace-separated list of
tokens, each of which defines a mode to which the template rule is
applicable.<span class="definition">]</span></p>
<p>Each token in the <code>mode</code> attribute <span class=
"verb">must</span> be one of the following:</p>
<ul>
<li>
<p>an <span><a title="EQName" class="termref" href=
"#dt-eqname">EQName</a></span>, which is expanded as described in
<a href="#qname"><i>5.1 Qualified Names</i></a> to define the name
of the mode</p>
</li>
<li>
<p>the token <code>#default</code>, to indicate that the template
rule is applicable to the <span>default mode that would apply if
the <code>mode</code> attribute were absent</span></p>
</li>
<li>
<p>the token <code>#unnamed</code>, to indicate that the template
rule is applicable to the <a title="unnamed mode" class="termref"
href="#dt-unnamed-mode">unnamed mode</a></p>
</li>
<li>
<p>the token <code>#all</code>, to indicate that the template rule
is applicable to all modes (specifically, to the
<span>unnamed</span> mode and to every mode that is named
<span>explicitly or implicitly</span> in an <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction anywhere in the stylesheet).</p>
</li>
</ul>
<p>When a template rule specifies <code>mode="#all"</code> this is
interpreted as meaning all modes declared implicitly or explicitly
within the <a title="declaring package" class="termref" href=
"#dt-declaring-package">declaring package</a> of the <a href=
"#element-template"><code>xsl:template</code></a> element. This
value cannot be used in the case of a template rule declared within
an <a href="#element-override"><code>xsl:override</code></a>
element.</p>
<p><a name="err-XTSE0550" id="err-XTSE0550"><span class=
"error">[ERR XTSE0550]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
list of modes is empty, if the same token is included more than
once in the list, if the list contains an invalid token, or if the
token <code>#all</code> appears together with any other value.</p>
<p><a name="err-XTSE3440" id="err-XTSE3440"><span class=
"error">[ERR XTSE3440]</span></a> In the case of a <a title=
"template rule" class="termref" href="#dt-template-rule">template
rule</a> (that is, an <a href=
"#element-template"><code>xsl:template</code></a> element having a
<code>match</code> attribute) appearing as a child of <a href=
"#element-override"><code>xsl:override</code></a>, it is a
<a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the list of modes in the
<code>mode</code> attribute contains <code>#all</code> or
<code>#unnamed</code>, or if it contains <code>#default</code> and
the default mode is the <a title="unnamed mode" class="termref"
href="#dt-unnamed-mode">unnamed mode</a>, or if the
<code>mode</code> attribute is omitted when the default mode is the
<a title="unnamed mode" class="termref" href=
"#dt-unnamed-mode">unnamed mode</a>.</p>
<p>The <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
element also has an optional <code>mode</code> attribute. The value
of this attribute <span class="verb">must</span> be one of the
following:</p>
<ul>
<li>
<p>an <span><a title="EQName" class="termref" href=
"#dt-eqname">EQName</a></span>, which is expanded as described in
<a href="#qname"><i>5.1 Qualified Names</i></a> to define the name
of a mode</p>
</li>
<li>
<p>the token <code>#default</code>, to indicate that the default
mode <span>for the <a title="stylesheet module" class="termref"
href="#dt-stylesheet-module">stylesheet module</a></span> is to be
used</p>
</li>
<li>
<p>the token <code>#unnamed</code>, to indicate that the <a title=
"unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed
mode</a> is to be used</p>
</li>
<li>
<p>the token <code>#current</code>, to indicate that the <a title=
"current mode" class="termref" href="#dt-current-mode">current
mode</a> is to be used</p>
</li>
</ul>
<p>If the attribute is omitted, the default mode <span>for the
<a title="stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet module</a></span> is used.</p>
<p>When searching for a template rule to process each
<span>item</span> selected by the <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction, only those template rules that are applicable to the
selected mode are considered.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-current-mode" id="dt-current-mode" title="current mode"></a>At
any point in the processing of a stylesheet, there is a <b>current
mode</b>. When the transformation is initiated, the current mode is
the <span><a title="initial mode" class="termref" href=
"#dt-initial-mode">initial mode</a></span>, as described in
<a href="#initiating"><i>2.3 Initiating a Transformation</i></a>.
Whenever an <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction is evaluated, the current mode becomes the mode
selected by this instruction.<span class="definition">]</span> When
a <span><a title="non-contextual function call" class="termref"
href="#dt-non-contextual-function-call">non-contextual function
call</a> is made</span>, the current mode is set to the <a title=
"unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed
mode</a>. While evaluating global variables and parameters, and the
sequence constructor contained in <a href=
"#element-key"><code>xsl:key</code></a> or <a href=
"#element-sort"><code>xsl:sort</code></a>, the current mode is set
to the unnamed mode. No other instruction changes the current mode.
The current mode while evaluating an <a title="attribute set"
class="termref" href="#dt-attribute-set">attribute set</a> is the
same as the current mode of the caller. On completion of the
<a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction, or on return from a stylesheet function call, the
current mode reverts to its previous value. The current mode is
used when an <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction uses the syntax <code>mode="#current"</code>; it is
also used by the <a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a> and
<a href="#element-next-match"><code>xsl:next-match</code></a>
instructions (see <a href="#apply-imports"><i>6.8 Overriding
Template Rules</i></a>).</p>
</div>
<div class="div3">
<h4><a name="xsl-mode-typed" id="xsl-mode-typed"></a>6.6.3 <a href=
"#xsl-mode-typed" style="text-decoration: none">Declaring the Type
of Nodes Processed by a Mode</a></h4>
<p>Typically the template rules in a particular <a title="mode"
class="termref" href="#dt-mode">mode</a> will be designed to
process a specific kind of input document. The <code>typed</code>
attribute of <a href="#element-mode"><code>xsl:mode</code></a>
gives the stylesheet author the opportunity to provide information
about this document to the processor. This information may enable
the processor to improve diagnostics or to optimize
performance.</p>
<p>The <code>typed</code> attribute of <a href=
"#element-mode"><code>xsl:mode</code></a> informs the processor
whether the nodes to be processed by template rules in this mode
are to be typed or untyped.</p>
<ul>
<li>
<p>If the value <code>yes</code> is specified (synonyms
<code>true</code> or <code>1</code>), then all nodes processed in
this mode must be typed. A dynamic error occurs if <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a> in
this mode selects an element or attribute node whose <a title=
"type annotation" class="termref" href="#dt-type-annotation">type
annotation</a> is <code>xs:untyped</code> or
<code>xs:untypedAtomic</code>.</p>
</li>
<li>
<p>If the value <code>no</code> is specified (synonyms
<code>false</code> or <code>0</code>), then all nodes processed in
this mode must be untyped. A dynamic error occurs if <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a> in
this mode selects an element or attribute whose <a title=
"type annotation" class="termref" href="#dt-type-annotation">type
annotation</a> is anything other than <code>xs:untyped</code> or
<code>xs:untypedAtomic</code>.</p>
</li>
<li>
<p>The value <code>strict</code> is equivalent to <code>yes</code>,
with the additional provision that in the match pattern of any
template rule that is <a title="applicable" class="termref" href=
"#dt-applicable">applicable</a> to this mode, any
<code>NameTest</code> used in the <code>ForwardStepP</code> of the
first <code>StepExprP</code> of a <code>RelativePathExprP</code> is
interpreted as follows:</p>
<ul>
<li>
<p>If the <code>NameTest</code> is an <code>EQName</code>
<var>E</var>, and the principal node kind of the axis of this step
is <code>Element</code>, then:</p>
<ul>
<li>
<p>It is a static error if the in-scope schema declarations do not
include a global element declaration for element name
<var>E</var></p>
</li>
<li>
<p>When matching templates in this mode, the element name
<var>E</var> appearing in this step is interpreted as
<code>schema-element(E)</code>. (Informally, this means that it
will only match an element if it has been validated against this
element declaration).</p>
</li>
</ul>
</li>
<li>
<p>Otherwise (the <code>NameTest</code> is a wildcard or the
principal node kind is <code>Attribute</code> or
<code>Namespace</code>), the template matching proceeds as if the
<code>typed</code> attribute were absent.</p>
</li>
</ul>
</li>
<li>
<p>The value <code>lax</code> is equivalent to <code>yes</code>,
with the additional provision that in the match pattern of any
template rule that is <a title="applicable" class="termref" href=
"#dt-applicable">applicable</a> to this mode, any
<code>NameTest</code> used in the <code>ForwardStepP</code> of the
first <code>StepExprP</code> of a <code>RelativePathExprP</code> is
interpreted as follows:</p>
<ul>
<li>
<p>If the <code>NameTest</code> is an <code>EQName</code>
<var>E</var>, and the principal node kind of the axis of this step
is <code>Element</code>, and the in-scope schema declarations
include a global element declaration for element name <var>E</var>,
then:</p>
<ul>
<li>
<p>When matching templates in this mode, the element name
<var>E</var> appearing in this step is interpreted as
<code>schema-element(E)</code>. (Informally, this means that it
will only match an element if it has been validated against this
element declaration).</p>
</li>
</ul>
</li>
<li>
<p>Otherwise (the <code>NameTest</code> is a wildcard, or the
principal node kind is <code>Attribute</code> or
<code>Namespace</code>, or there is no element declaration for
<var>E</var>), the template matching proceeds as if the
<code>typed</code> attribute were absent.</p>
</li>
</ul>
</li>
</ul>
<p><a name="err-XTTE3100" id="err-XTTE3100"><span class=
"error">[ERR XTTE3100]</span></a> It is a <a title="type error"
class="termref" href="#dt-type-error">type error</a> if an <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction in a particular <code>mode</code> selects an element or
attribute whose type is <code>xs:untyped</code> or
<code>xs:untypedAtomic</code> when the <code>typed</code> attribute
of that mode specifies the value <code>yes</code>,
<code>strict</code>, or <code>lax</code>.</p>
<p><a name="err-XTSE3105" id="err-XTSE3105"><span class=
"error">[ERR XTSE3105]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if a
template rule applicable to a mode that is defined with
<code>typed="strict"</code> uses a match pattern that contains a
<code>RelativePathExprP</code> whose first <code>StepExprP</code>
is an <code>AxisStepP</code> whose <code>ForwardStepP</code> uses
an axis whose principal node kind is <code>Element</code> and whose
<code>NodeTest</code> is an <code>EQName</code> that does not
correspond to the name of any global element declaration in the
<a title="in-scope schema component" class="termref" href=
"#dt-in-scope-schema-component">in-scope schema components</a>.</p>
<p><a name="err-XTTE3110" id="err-XTTE3110"><span class=
"error">[ERR XTTE3110]</span></a> It is a <a title="type error"
class="termref" href="#dt-type-error">type error</a> if an <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction in a particular <code>mode</code> selects an element or
attribute whose type is anything other than <code>xs:untyped</code>
or <code>xs:untypedAtomic</code> when the <code>typed</code>
attribute of that mode specifies the value <code>no</code>.</p>
</div>
<div class="div3">
<h4><a name="streamable-templates" id=
"streamable-templates"></a>6.6.4 <a href="#streamable-templates"
style="text-decoration: none">Streamable Templates</a></h4>
<p>A <span>template rule that is <a title="applicable" class=
"termref" href="#dt-applicable">applicable</a> to a mode
<var>M</var></span> is <a title="guaranteed-streamable" class=
"termref" href=
"#dt-guaranteed-streamable">guaranteed-streamable</a> if and only
if all the following conditions are satisfied:</p>
<ol class="enumar">
<li>
<p>Mode <var>M</var> is declared in an <a href=
"#element-mode"><code>xsl:mode</code></a> declaration that
specifies <code>streamable="yes"</code>.</p>
</li>
<li>
<p>The <a title="pattern" class="termref" href=
"#dt-pattern">pattern</a> defined in the <code>match</code>
attribute of the <a href=
"#element-template"><code>xsl:template</code></a> element
<span>is</span> a <a title="motionless" class="termref" href=
"#dt-motionless">motionless</a> pattern as defined in <a href=
"#classifying-patterns"><i>19.8.9 Classifying Patterns</i></a>.</p>
</li>
<li>
<p>One or both of the following conditions is satisfied:</p>
<ol class="enumla">
<li>
<p>The <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> contained in
the body of the <a href=
"#element-template"><code>xsl:template</code></a> element <span>is
<a title="grounded" class="termref" href=
"#dt-grounded">grounded</a></span>, as defined in <a href=
"#streamability"><i>19 Streamability</i></a>.</p>
</li>
<li>
<p>The <a href="#element-template"><code>xsl:template</code></a>
element has an <code>as</code> attribute that specifies an atomic
or union type.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Such a type forces atomization of the result of the template,
which automatically makes the result grounded.</p>
</div>
</li>
</ol>
</li>
<li>
<p>Every <a title="expression" class="termref" href=
"#dt-expression">expression</a> and contained <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> in a contained
<a href="#element-param"><code>xsl:param</code></a> element (the
construct that provides the default value of the parameter)
<span>is</span> <a title="motionless" class="termref" href=
"#dt-motionless">motionless</a>.</p>
</li>
</ol>
<p>Specifying <code>streamable="yes"</code> on an <a href=
"#element-mode"><code>xsl:mode</code></a> declaration declares an
intent that every template rule that includes that mode (explicitly
or implicitly, including by specifying <code>#all</code>), should
be guaranteed streamable according to these criteria. The
consequences of declaring the mode to be streamable when there is
such a template rule that is not guaranteed streamable depend on
the conformance level of the processor, and are explained in
<a href="#streamability-guarantees"><i>19.10 Streamability
Guarantees</i></a>.</p>
<p>Processing of a document using streamable templates may be
initiated using code such as the following, where <code>S</code> is
a mode declared with <code>streamable="yes"</code>:</p>
<div class="exampleInner">
<pre>
&lt;xsl:stream href="bigdoc.xml"&gt;
  &lt;xsl:apply-templates mode="S"/&gt;
&lt;/xsl:stream&gt;
</pre></div>
<p>Alternatively, streamed processing may be initiated by invoking
the transformation with an <a title="initial mode" class="termref"
href="#dt-initial-mode">initial mode</a> declared as streamable,
while supplying the <span><a title="initial match selection" class=
"termref" href="#dt-initial-match-selection">initial match
selection</a></span> (in an <a title="implementation-defined"
class="termref" href=
"#dt-implementation-defined">implementation-defined</a> way) as a
streamed document.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Invoking a streamable template using the construct
<code>&lt;xsl:apply-templates
select="doc('bigdoc.xml')"/&gt;</code> does not ensure streamed
processing. As always, processors may use streamed processing if
they are able to do so, but when the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>
or <a href="#func-document"><code>document</code></a> functions are
used, processors are obliged to ensure that the results are
deterministic, which may be difficult to reconcile with streaming
(if the same document is read twice, the results must be
identical). The use of <a href=
"#element-stream"><code>xsl:stream</code></a> does not offer the
same guarantees of determinism.</p>
</div>
<p>For an example of processing a collection of documents by use of
the function <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-uri-collection"><code>
uri-collection</code></a><sup><small>FO30</small></sup> in
conjunction with <a href=
"#element-stream"><code>xsl:stream</code></a>, see <a href=
"#stream-examples"><i>18.1.2 Examples of xsl:stream</i></a>.</p>
</div>
</div>
<div class="div2">
<h3><a name="built-in-rule" id="built-in-rule"></a>6.7 <a href=
"#built-in-rule" style="text-decoration: none">Built-in Template
Rules</a></h3>
<p>When an <span>item</span> is selected by <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a> and
there is no user-specified <a title="template rule" class="termref"
href="#dt-template-rule">template rule</a> in the <a title=
"stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>
that can be used to process that <span>item</span>, then a built-in
template rule is evaluated instead.</p>
<p>The built-in <a title="template rule" class="termref" href=
"#dt-template-rule">template rules</a> have lower <a title=
"import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a> than all other
template rules. Thus, the stylesheet author can override a built-in
template rule by including an explicit template rule.</p>
<p>There are six sets of built-in template rules available. The set
that is chosen is a property of the <a title="mode" class="termref"
href="#dt-mode">mode</a> selected by the <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction. This property is set using the
<code>on-no-match</code> attribute of the <a href=
"#element-mode"><code>xsl:mode</code></a> declaration, which takes
one of the six values <code>deep-copy</code>,
<code>shallow-copy</code>, <code>deep-skip</code>,
<code>shallow-skip</code>, <code>text-only-copy</code>, or
<code>fail</code>, the default being <code>text-only-copy</code>.
The effect of these six sets of built-in template rules is
explained in the following subsections.</p>
<div class="div3">
<h4><a name="built-in-templates-text-only-copy" id=
"built-in-templates-text-only-copy"></a>6.7.1 <a href=
"#built-in-templates-text-only-copy" style=
"text-decoration: none">Built-in Templates: Text-only Copy</a></h4>
<p>The effect of <span>processing a tree using a <a title="mode"
class="termref" href="#dt-mode">mode</a> that specifies
<code>on-no-match="text-only-copy"</code></span> is that the
textual content of the source document is retained while losing the
markup, except where explicit template rules dictate otherwise.
When an element is encountered for which there is no explicit
<a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a>, the processing continues
with the children of that element. Text nodes are copied to the
output.</p>
<p>The built-in rule for document nodes and element nodes is
equivalent to calling <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
with no <code>select</code> attribute, and with the
<code>mode</code> attribute set to <code>#current</code>. the
built-in rule was invoked with parameters, those parameters are
passed on in the implicit <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction.</p>
<p>This is equivalent to the following in the case where there are
no parameters:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="document-node()|element()" mode="M"&gt;
  &lt;xsl:apply-templates mode="#current"/&gt;
&lt;/xsl:template&gt;
</pre></div>
<p>The built-in <a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a> for text and attribute nodes
returns a text node containing the <a title="string value" class=
"termref" href="#dt-string-value">string value</a> of the context
node. It is effectively:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="text()|@*" mode="M"&gt;
  &lt;xsl:value-of select="string(.)"/&gt;
&lt;/xsl:template&gt;
</pre></div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This text node may have a string value that is zero-length.</p>
</div>
<p>diff="chg" at="R-bug26751"&gt;The built-in <a title=
"template rule" class="termref" href="#dt-template-rule">template
rule</a> <span>atomic values</span> returns a text node containing
the value. It is effectively:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match=".[. instance of xs:anyAtomicType]" mode="M"&gt;
  &lt;xsl:value-of select="string(.)"/&gt;
&lt;/xsl:template&gt;
</pre></div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This text node may have a string value that is zero-length.</p>
</div>
<p>The built-in <a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a> for processing instructions,
comments, and namespace nodes does nothing (it returns the empty
sequence).</p>
<div class="exampleInner">
<pre>
&lt;xsl:template 
   match="processing-instruction()|comment()|namespace-node()" 
   mode="M"/&gt;
</pre></div>
<p>The built-in <a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a> for functions
<span>(including maps)</span> does nothing (it returns the empty
sequence).</p>
<div class="exampleInner">
<pre>
&lt;xsl:template 
   match=".[. instance of function(*)]" 
   mode="M"/&gt;
</pre></div>
<p>The following example illustrates the use of built-in template
rules when there are parameters.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e20924" id=
"d7e20924"></a>Example: Using a Built-In Template Rule</div>
<p>Suppose the stylesheet contains the following instruction:</p>
<div class="exampleInner">
<pre>
&lt;xsl:apply-templates select="title" mode="M"&gt;
  &lt;xsl:with-param name="init" select="10"/&gt;
&lt;/xsl:apply-templates&gt;
</pre></div>
<p>If there is no explicit template rule that matches the
<code>title</code> element, then the following implicit rule is
used:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="title" mode="M"&gt;
  &lt;xsl:param name="init"/&gt;
  &lt;xsl:apply-templates mode="#current"&gt;
    &lt;xsl:with-param name="init" select="$init"/&gt;
  &lt;/xsl:apply-templates&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
</div>
<div class="div3">
<h4><a name="built-in-templates-deep-copy" id=
"built-in-templates-deep-copy"></a>6.7.2 <a href=
"#built-in-templates-deep-copy" style=
"text-decoration: none">Built-in Templates: Deep Copy</a></h4>
<p>The effect of <span>processing a tree using a <a title="mode"
class="termref" href="#dt-mode">mode</a> that specifies
<code>on-no-match="deep-copy"</code></span> is that an unmatched
element in the source tree is copied unchanged to the output,
together with its entire subtree. Other unmatched items are also
copied unchanged. The subtree is copied unconditionally, without
attempting to match nodes in the subtree against template
rules.</p>
<p>When this default action is selected for a mode <var>M</var>,
all items <span>(nodes, atomic values, and functions,
<span>including maps</span>)</span> are processed using a template
rule that is equivalent to the following:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="." mode="M"&gt;
  &lt;xsl:copy-of select="." validation="preserve"/&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="built-in-templates-shallow-copy" id=
"built-in-templates-shallow-copy"></a>6.7.3 <a href=
"#built-in-templates-shallow-copy" style=
"text-decoration: none">Built-in Templates: Shallow Copy</a></h4>
<p>The effect of <span>processing a tree using a <a title="mode"
class="termref" href="#dt-mode">mode</a> that specifies
<code>on-no-match="shallow-copy"</code></span> is that the source
tree is copied unchanged to the output, except for nodes where
different processing is specified using an explicit <a title=
"template rule" class="termref" href="#dt-template-rule">template
rule</a>.</p>
<p>When this default action is selected for a mode <var>M</var>,
all items <span>(nodes, atomic values, and functions,
<span>including maps</span>)</span> are processed using a template
rule that is equivalent to the following, except that all
parameters supplied in <a href=
"#element-with-param"><code>xsl:with-param</code></a> elements are
passed on implicitly to the called templates:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="." mode="M"&gt;
  &lt;xsl:copy validation="preserve"&gt;
    &lt;xsl:apply-templates select="@*" mode="M"/&gt;
    &lt;xsl:apply-templates select="node()" mode="M"/&gt;
  &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;
</pre></div>
<p>This rule is often referred to as the <em>identity
template</em>, though it should be noted that it does not preserve
node identity.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This rule differs from the traditional identity template rule by
using two <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instructions, one to process the attributes and one to process the
children. The only observable difference from the traditional
<code>select="node() | @*"</code> is that with two separate
instructions, the value of <code>position()</code> in the called
templates forms one sequence starting at 1 for the attributes, and
a new sequence starting at 1 for the children.</p>
<p>A further reason for choosing this form is for streamability:
this formulation is <a title="guaranteed-streamable" class=
"termref" href=
"#dt-guaranteed-streamable">guaranteed-streamable</a>, whereas the
traditional form using <code>select="node() | @*"</code> is not
(see <a href="#streamability-xsl-apply-templates"><i>19.8.4.5
Streamability of xsl:apply-templates</i></a>).</p>
</div>
<div class="example">
<div class="exampleHeader"><a name="d7e21022" id=
"d7e21022"></a>Example: Modified Identity Transformation</div>
<p>The following stylesheet transforms an input document by
deleting all elements named <code>note</code>, together with their
attributes and descendants:</p>
<div class="exampleInner">
<pre>
&lt;xsl:stylesheet version="3.0"
     xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
                                  
&lt;xsl:mode on-no-match="shallow-copy" streamable="true"/&gt;

&lt;xsl:template match="note"&gt;
  &lt;!-- no action --&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</pre></div>
</div>
</div>
<div class="div3">
<h4><a name="built-in-templates-deep-skip" id=
"built-in-templates-deep-skip"></a>6.7.4 <a href=
"#built-in-templates-deep-skip" style=
"text-decoration: none">Built-in Templates: Deep Skip</a></h4>
<p>The effect of processing a tree using a <a title="mode" class=
"termref" href="#dt-mode">mode</a> that specifies
<code>on-no-match="deep-skip"</code> is that where no explicit
template rule is specified for an element, that element and all its
descendants are ignored, and are not copied to the result tree.</p>
<p>The effect of choosing <code>on-no-match="deep-skip"</code> is
as follows:</p>
<ul>
<li>
<p>The built-in rule for document nodes is equivalent to calling
<a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
with no <code>select</code> attribute, and with the
<code>mode</code> attribute set to <code>#current</code>. If the
built-in rule was invoked with parameters, those parameters are
passed on in the implicit <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction.</p>
<p>In the case where there are no parameters, this is equivalent to
the following rule:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="document-node()" mode="M"&gt;
  &lt;xsl:apply-templates mode="#current"/&gt;
&lt;/xsl:template&gt;
</pre></div>
</li>
<li>
<p>The built-in rule for all items other than document nodes
<span>(that is, for all other kinds of node, as well as atomic
values and functions, <span>including maps</span>)</span> is to do
nothing, that is, to return an empty sequence (without applying
templates to any children or ancestors).</p>
<p>This is equivalent to the following rule:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="." mode="M"/&gt;
</pre></div>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="built-in-templates-shallow-skip" id=
"built-in-templates-shallow-skip"></a>6.7.5 <a href=
"#built-in-templates-shallow-skip" style=
"text-decoration: none">Built-in Templates: Shallow Skip</a></h4>
<p>The effect of <span>processing a tree using a <a title="mode"
class="termref" href="#dt-mode">mode</a> that specifies
<code>on-no-match="shallow-skip"</code></span> is to drop both the
textual content and the markup from the result document, except
where there is an explicit user-written <a title="template rule"
class="termref" href="#dt-template-rule">template rule</a> that
dictates otherwise.</p>
<p>The built-in rule for document nodes and element nodes is the
same as for <code>on-no-match="text-only-copy"</code>: that is, it
is equivalent to calling <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
with no <code>select</code> attribute, and with the
<code>mode</code> attribute set to <code>#current</code>. If the
built-in rule was invoked with parameters, those parameters are
passed on in the implicit <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction.</p>
<p>In the case where there are no parameters, this is equivalent to
the following rule:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="document-node()|element()" mode="M"&gt;
  &lt;xsl:apply-templates mode="#current"/&gt;
&lt;/xsl:template&gt;
</pre></div>
<p>The built-in template rule for all other kinds of node, and for
atomic values and functions <span>(including maps)</span> is empty:
that is, when the item is matched, the built-in template rule
returns an empty sequence.</p>
<p>This is equivalent to the following rule:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="." mode="M"/&gt;
</pre></div>
</div>
<div class="div3">
<h4><a name="built-in-templates-fail" id=
"built-in-templates-fail"></a>6.7.6 <a href=
"#built-in-templates-fail" style="text-decoration: none">Built-in
Templates: Fail</a></h4>
<p>The effect of choosing <code>on-no-match="fail"</code> for a
<a title="mode" class="termref" href="#dt-mode">mode</a> is that
every <span>item</span> selected in an <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction must be matched by an explicit user-written <a title=
"template rule" class="termref" href="#dt-template-rule">template
rule</a>.</p>
<p>The built-in template rule is effectively:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="." mode="M"&gt;
  &lt;xsl:message terminate="yes" error-code="err:XTDE0555"/&gt;
&lt;/xsl:template&gt;
</pre></div>
<p>with an <a title="implementation-dependent" class="termref"
href="#dt-implementation-dependent">implementation-dependent</a>
message body.</p>
<p><a name="err-XTDE0555" id="err-XTDE0555"><span class=
"error">[ERR XTDE0555]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if
<a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href="#element-apply-imports"><code>xsl:apply-imports</code></a>
or <a href="#element-next-match"><code>xsl:next-match</code></a> is
used to process a node using a mode whose declaration specifies
<code>on-no-match="fail"</code> when there is no <a title=
"template rule" class="termref" href="#dt-template-rule">template
rule</a> in the <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> whose match pattern matches that
node.</p>
</div>
</div>
<div class="div2">
<h3><a name="apply-imports" id="apply-imports"></a>6.8 <a href=
"#apply-imports" style="text-decoration: none">Overriding Template
Rules</a></h3>
<p class="element-syntax"><a name="element-apply-imports" id=
"element-apply-imports"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:apply-imports&gt;<br />
&#160;&#160;&lt;!-- Content: <a href=
"#element-with-param">xsl:with-param</a>* --&gt;<br />
&lt;/xsl:apply-imports&gt;</code></p>
<p class="element-syntax"><a name="element-next-match" id=
"element-next-match"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:next-match&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-with-param">xsl:with-param</a> | <a href=
"#element-fallback">xsl:fallback</a>)* --&gt;<br />
&lt;/xsl:next-match&gt;</code></p>
<p>A <a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a> that is being used to
override another template rule (see <a href="#conflict"><i>6.4
Conflict Resolution for Template Rules</i></a>) can use the
<a href="#element-apply-imports"><code>xsl:apply-imports</code></a>
or <a href="#element-next-match"><code>xsl:next-match</code></a>
instruction to invoke the overridden template rule. The <a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a>
instruction only considers template rules in imported stylesheet
modules; the <a href=
"#element-next-match"><code>xsl:next-match</code></a> instruction
considers all other template rules of lower <a title=
"import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a> and/or priority,
<span>and also declarations of the same precedence and priority
that appear earlier in <a title="declaration order" class="termref"
href="#dt-declaration-order">declaration order</a></span>. Both
instructions will invoke the built-in template rule for the
<span>context item</span> (see <a href="#built-in-rule"><i>6.7
Built-in Template Rules</i></a>) if no other template rule is
found.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-current-template-rule" id="dt-current-template-rule" title=
"current template rule"></a>At any point in the processing of a
<a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a>, there may be a <b>current template
rule</b>. Whenever a <a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a> is chosen as a result of
evaluating <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a>, or
<a href="#element-next-match"><code>xsl:next-match</code></a>, the
template rule becomes the current template rule for the evaluation
of the rule's sequence constructor. When an <a href=
"#element-for-each"><code>xsl:for-each</code></a>, <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>,
<a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a>,
<span><a href="#element-iterate"><code>xsl:iterate</code></a>,
<a href="#element-stream"><code>xsl:stream</code></a>, <a href=
"#element-merge"><code>xsl:merge</code></a>, or <a href=
"#element-evaluate"><code>xsl:evaluate</code></a></span>
instruction is evaluated, or when evaluating a sequence constructor
contained in an <a href="#element-sort"><code>xsl:sort</code></a>
or <a href="#element-key"><code>xsl:key</code></a> element, or when
a <span><a title="non-contextual function call" class="termref"
href="#dt-non-contextual-function-call">non-contextual function
call</a> is made,</span> the current template rule becomes
<span><a title="absent" class="termref" href=
"#dt-absent">absent</a></span> for the evaluation of that
instruction or function.<span class="definition">]</span></p>
<p>The current template rule is not affected by invoking named
templates (see <a href="#named-templates"><i>10.1 Named
Templates</i></a>) or named attribute sets (see <a href=
"#attribute-sets"><i>10.2 Named Attribute Sets</i></a>). While
evaluating a <a title="global variable" class="termref" href=
"#dt-global-variable">global variable</a> or the default value of a
<a title="stylesheet parameter" class="termref" href=
"#dt-stylesheet-parameter">stylesheet parameter</a> (see <a href=
"#global-variables"><i>9.5 Global Variables and Parameters</i></a>)
the current template rule is <span><a title="absent" class=
"termref" href="#dt-absent">absent</a></span>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>These rules ensure that when <a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a> or
<a href="#element-next-match"><code>xsl:next-match</code></a> is
called, the <a title="context item" class="termref" href=
"#dt-context-item">context item</a> is the same as when the current
template rule was invoked.</p>
</div>
<p>Both <a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a> and
<a href="#element-next-match"><code>xsl:next-match</code></a>
search for a <a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a> that matches the
<span><a title="context item" class="termref" href=
"#dt-context-item">context item</a></span>, and that is applicable
to the <a title="current mode" class="termref" href=
"#dt-current-mode">current mode</a> (see <a href="#modes"><i>6.6
Modes</i></a>). In choosing a template rule, they use the usual
criteria such as the priority and <a title="import precedence"
class="termref" href="#dt-import-precedence">import precedence</a>
of the template rules, but they consider as candidates only a
subset of the template rules in the <a title="stylesheet" class=
"termref" href="#dt-stylesheet">stylesheet</a>. This subset differs
between the two instructions:</p>
<ul>
<li>
<p>The <a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a>
instruction considers as candidates only those template rules
contained in <a title="stylesheet level" class="termref" href=
"#dt-stylesheet-level">stylesheet levels</a> that are descendants
in the <a title="import tree" class="termref" href=
"#dt-import-tree">import tree</a> of the <a title=
"stylesheet level" class="termref" href=
"#dt-stylesheet-level">stylesheet level</a> that contains the
<a title="current template rule" class="termref" href=
"#dt-current-template-rule">current template rule</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This is <em>not</em> the same as saying that the search
considers all template rules whose import precedence is lower than
that of the current template rule.</p>
</div>
<p><a name="err-XTSE3460" id="err-XTSE3460"><span class=
"error">[ERR XTSE3460]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if an
<a href="#element-apply-imports"><code>xsl:apply-imports</code></a>
element appears in a <a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a> declared within an <a href=
"#element-override"><code>xsl:override</code></a> element. (To
invoke the template rule that is being overridden, <a href=
"#element-next-match"><code>xsl:next-match</code></a> should
therefore be used.)</p>
</li>
<li>
<p>The <a href=
"#element-next-match"><code>xsl:next-match</code></a> instruction
considers as candidates all those template rules that come after
the <a title="current template rule" class="termref" href=
"#dt-current-template-rule">current template rule</a> in the
ordering of template rules implied by the conflict resolution rules
given in <a href="#conflict"><i>6.4 Conflict Resolution for
Template Rules</i></a>. That is, it considers all template rules
with lower <a title="import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a> than the <a title=
"current template rule" class="termref" href=
"#dt-current-template-rule">current template rule</a>, plus the
template rules that are at the same import precedence that have
lower priority than the current template rule, <span>plus
the</span> template rules with the same import precedence and
priority that occur before the current template rule in <a title=
"declaration order" class="termref" href=
"#dt-declaration-order">declaration order</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>As explained in <a href="#conflict"><i>6.4 Conflict Resolution
for Template Rules</i></a>, a template rule <span>with no
<code>priority</code> attribute</span>, whose match pattern
contains multiple alternatives separated by <code>|</code>, is
treated equivalently to a set of template rules, one for each
alternative. This means that where the same <span>item</span>
matches more than one alternative, it is possible for an <a href=
"#element-next-match"><code>xsl:next-match</code></a> instruction
to cause the current template rule to be invoked recursively. This
situation does not occur when the <span>template rule has an
explicit</span> priority.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Because a template rule declared as a child of <a href=
"#element-override"><code>xsl:override</code></a> has higher
precedence than any template rule declared in the used package (see
<a href="#modes-and-packages"><i>3.6.4 Overriding Template Rules
from a Used Package</i></a>), the effect of <a href=
"#element-next-match"><code>xsl:next-match</code></a> within such a
template rule is to consider as candidates first the preceding
sibling template rules within the same <a href=
"#element-override"><code>xsl:override</code></a> element, and then
all template rules in the used package.</p>
</div>
</li>
</ul>
<p>If no matching template rule is found that satisfies these
criteria, the built-in template rule for the <span>context
item</span> is used (see <a href="#built-in-rule"><i>6.7 Built-in
Template Rules</i></a>).</p>
<p>An <a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a> or
<a href="#element-next-match"><code>xsl:next-match</code></a>
instruction may use <a href=
"#element-with-param"><code>xsl:with-param</code></a> child
elements to pass parameters to the chosen <a title="template rule"
class="termref" href="#dt-template-rule">template rule</a> (see
<a href="#with-param"><i>9.10 Setting Parameter Values</i></a>). It
also passes on any <a title="tunnel parameter" class="termref"
href="#dt-tunnel-parameter">tunnel parameters</a> as described in
<a href="#tunnel-params"><i>10.1.3 Tunnel Parameters</i></a>.</p>
<p><a name="err-XTDE0560" id="err-XTDE0560"><span class=
"error">[ERR XTDE0560]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if
<a href="#element-apply-imports"><code>xsl:apply-imports</code></a>
or <a href="#element-next-match"><code>xsl:next-match</code></a> is
evaluated when the <a title="current template rule" class="termref"
href="#dt-current-template-rule">current template rule</a> is
<span><a title="absent" class="termref" href=
"#dt-absent">absent</a></span>.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e21517" id=
"d7e21517"></a>Example: Using <a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a></div>
<p>For example, suppose the stylesheet <code>doc.xsl</code>
contains a <a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a> for <code>example</code>
elements:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="example"&gt;
  &lt;pre&gt;&lt;xsl:apply-templates/&gt;&lt;/pre&gt;
&lt;/xsl:template&gt;
</pre></div>
<p>Another stylesheet could import <code>doc.xsl</code> and modify
the treatment of <code>example</code> elements as follows:</p>
<div class="exampleInner">
<pre>
&lt;xsl:import href="doc.xsl"/&gt;

&lt;xsl:template match="example"&gt;
  &lt;div style="border: solid red"&gt;
     &lt;xsl:apply-imports/&gt;
  &lt;/div&gt;
&lt;/xsl:template&gt;
</pre></div>
<p>The combined effect would be to transform an
<code>example</code> into an element of the form:</p>
<div class="exampleInner">
<pre>
&lt;div style="border: solid red"&gt;&lt;pre&gt;...&lt;/pre&gt;&lt;/div&gt;
</pre></div>
</div>
<p>An <a href="#element-fallback"><code>xsl:fallback</code></a>
instruction appearing as a child of an <a href=
"#element-next-match"><code>xsl:next-match</code></a> instruction
is ignored by an XSLT 2.0 <span>or 3.0</span> processor, but can be
used to define fallback behavior when the stylesheet is processed
by an XSLT 1.0 processor with forwards compatible behavior.</p>
</div>
<div class="div2">
<h3><a name="parameters-to-template-rules" id=
"parameters-to-template-rules"></a>6.9 <a href=
"#parameters-to-template-rules" style=
"text-decoration: none">Passing Parameters to Template
Rules</a></h3>
<p>A template rule may have parameters. The parameters are declared
in the body of the template using <a href=
"#element-param"><code>xsl:param</code></a> elements, as described
in <a href="#parameters"><i>9.2 Parameters</i></a>.</p>
<p>Values for these parameters may be supplied in the calling
<a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a>, or
<a href="#element-next-match"><code>xsl:next-match</code></a>
instruction by means of <a href=
"#element-with-param"><code>xsl:with-param</code></a> elements
appearing as children of the calling instruction. The <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a> represented by the <code>name</code> attribute of the
<a href="#element-with-param"><code>xsl:with-param</code></a>
element must match the <a title="expanded QName" class="termref"
href="#dt-expanded-qname">expanded QName</a> represented by the
<code>name</code> attribute of the corresponding <a href=
"#element-param"><code>xsl:param</code></a> element.</p>
<p>It is not an error for these instructions to supply a parameter
that does not match any parameter declared in the template rule
that is invoked; unneeded parameter values are simply ignored.</p>
<p>A parameter may be declared as a <a title="tunnel parameter"
class="termref" href="#dt-tunnel-parameter">tunnel parameter</a> by
specifying <code>tunnel="yes"</code> in the <a href=
"#element-param"><code>xsl:param</code></a> declaration; in this
case the caller must supply the value as a tunnel parameter by
specifying <code>tunnel="yes"</code> in the corresponding <a href=
"#element-with-param"><code>xsl:with-param</code></a> element.
Tunnel parameters differ from ordinary template parameters in that
they are passed transparently through multiple template
invocations. They are fully described in <a href=
"#tunnel-params"><i>10.1.3 Tunnel Parameters</i></a>.</p>
</div>
</div>
<div class="div1">
<h2><a name="repetition" id="repetition"></a>7 <a href=
"#repetition" style="text-decoration: none">Repetition</a></h2>
<p>XSLT offers two constructs for processing each item of a
sequence: <a href="#element-for-each"><code>xsl:for-each</code></a>
and <a href="#element-iterate"><code>xsl:iterate</code></a>.</p>
<p>The main difference between the two constructs is that with
<a href="#element-for-each"><code>xsl:for-each</code></a>, the
processing applied to each item in the sequence is independent of
the processing applied to any other item; this means that the items
may be processed in any order or in parallel, though the order of
the output sequence is well defined and corresponds to the order of
the input (sorted if so requested). By contrast, with <a href=
"#element-iterate"><code>xsl:iterate</code></a>, the processing is
explicitly sequential: while one item is being processed, values
may be computed which are then available for use while the next
item is being processed. This makes <a href=
"#element-iterate"><code>xsl:iterate</code></a> suitable for tasks
such as creating a running total over a sequence of financial
transactions.</p>
<p>A further difference is that <a href=
"#element-for-each"><code>xsl:for-each</code></a> permits sorting
of the input sequence, while <a href=
"#element-iterate"><code>xsl:iterate</code></a> does not.</p>
<div class="div2">
<h3><a name="for-each" id="for-each"></a>7.1 <a href="#for-each"
style="text-decoration: none">The</a> <code>xsl:for-each</code>
<a href="#for-each" style=
"text-decoration: none">instruction</a></h3>
<p class="element-syntax"><a name="element-for-each" id=
"element-for-each"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:for-each<br />
&#160;&#160;<b>select</b> = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-sort">xsl:sort</a>*, <var>sequence-constructor</var>)
--&gt;<br />
&lt;/xsl:for-each&gt;</code></p>
<p>The <a href="#element-for-each"><code>xsl:for-each</code></a>
instruction processes each item in a sequence of items, evaluating
the <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> within the
<a href="#element-for-each"><code>xsl:for-each</code></a>
instruction once for each item in that sequence.</p>
<p>The <code>select</code> attribute is <span class=
"verb">required</span>; it contains an <a title="expression" class=
"termref" href="#dt-expression">expression</a> which is evaluated
to produce a sequence, called the input sequence. If there is an
<a href="#element-sort"><code>xsl:sort</code></a> element present
(see <a href="#sorting"><i>13 Sorting</i></a>) the input sequence
is sorted to produce a sorted sequence. Otherwise, the sorted
sequence is the same as the input sequence.</p>
<p>The <a href="#element-for-each"><code>xsl:for-each</code></a>
instruction contains a <a title="sequence constructor" class=
"termref" href="#dt-sequence-constructor">sequence constructor</a>.
The <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> is evaluated
once for each item in the sorted sequence, with the <a title=
"focus" class="termref" href="#dt-focus">focus</a> set as
follows:</p>
<ul>
<li>
<p>The <a title="context item" class="termref" href=
"#dt-context-item">context item</a> is the item being
processed.</p>
</li>
<li>
<p>The <a title="context position" class="termref" href=
"#dt-context-position">context position</a> is the position of this
item in the sorted sequence.</p>
</li>
<li>
<p>The <a title="context size" class="termref" href=
"#dt-context-size">context size</a> is the size of the sorted
sequence (which is the same as the size of the input sequence).</p>
</li>
</ul>
<p>For each item in the input sequence, evaluating the <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> produces a
sequence of items (see <a href="#sequence-constructors"><i>5.8
Sequence Constructors</i></a>). These output sequences are
concatenated; if item <var>Q</var> follows item <var>P</var> in the
sorted sequence, then the result of evaluating the sequence
constructor with <var>Q</var> as the context item is concatenated
after the result of evaluating the sequence constructor with
<var>P</var> as the context item. The result of the <a href=
"#element-for-each"><code>xsl:for-each</code></a> instruction is
the concatenated sequence of items.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e21768" id=
"d7e21768"></a>Example: Using <a href=
"#element-for-each"><code>xsl:for-each</code></a></div>
<p>For example, given an XML document with this structure</p>
<div class="exampleInner">
<pre>
&lt;customers&gt;
  &lt;customer&gt;
    &lt;name&gt;...&lt;/name&gt;
    &lt;order&gt;...&lt;/order&gt;
    &lt;order&gt;...&lt;/order&gt;
  &lt;/customer&gt;
  &lt;customer&gt;
    &lt;name&gt;...&lt;/name&gt;
    &lt;order&gt;...&lt;/order&gt;
    &lt;order&gt;...&lt;/order&gt;
  &lt;/customer&gt;
&lt;/customers&gt;
</pre></div>
<p>the following would create an HTML document containing a table
with a row for each <code>customer</code> element</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="/"&gt;
  &lt;html&gt;
    &lt;head&gt;
      &lt;title&gt;Customers&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
      &lt;table&gt;
        &lt;tbody&gt;
          &lt;xsl:for-each select="customers/customer"&gt;
            &lt;tr&gt;
              &lt;th&gt;
                &lt;xsl:apply-templates select="name"/&gt;
              &lt;/th&gt;
              &lt;xsl:for-each select="order"&gt;
                &lt;td&gt;
                  &lt;xsl:apply-templates/&gt;
                &lt;/td&gt;
              &lt;/xsl:for-each&gt;
            &lt;/tr&gt;
          &lt;/xsl:for-each&gt;
        &lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
</div>
<div class="div2">
<h3><a name="iterate" id="iterate"></a>7.2 <a href="#iterate"
style="text-decoration: none">The</a> <code>xsl:iterate</code>
<a href="#iterate" style=
"text-decoration: none">Instruction</a></h3>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In earlier working drafts, the <a href=
"#element-on-completion"><code>xsl:on-completion</code></a> element
appeared as the last child of <a href=
"#element-iterate"><code>xsl:iterate</code></a>. Its position has
been changed to ensure that variables declared in the sequence
constructor are not in scope within <a href=
"#element-on-completion"><code>xsl:on-completion</code></a>, since
such variables do not have a defined value within <a href=
"#element-on-completion"><code>xsl:on-completion</code></a>
especially in the case where the value of the <code>select</code>
attribute is an empty sequence.</p>
</div>
<p class="element-syntax"><a name="element-iterate" id=
"element-iterate"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:iterate<br />
&#160;&#160;<b>select</b> = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-param">xsl:param</a>*, <a href=
"#element-on-completion">xsl:on-completion</a>?,
<var>sequence-constructor</var>) --&gt;<br />
&lt;/xsl:iterate&gt;</code></p>
<p class="element-syntax"><a name="element-next-iteration" id=
"element-next-iteration"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:next-iteration&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-with-param">xsl:with-param</a>*) --&gt;<br />
&lt;/xsl:next-iteration&gt;</code></p>
<p class="element-syntax"><a name="element-break" id=
"element-break"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:break<br />
&#160;&#160;select? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:break&gt;</code></p>
<p class="element-syntax"><a name="element-on-completion" id=
"element-on-completion"></a><code>&lt;xsl:on-completion<br />
&#160;&#160;select? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:on-completion&gt;</code></p>
<p>The <code>select</code> attribute is <span class=
"verb">required</span>; it contains an <a title="expression" class=
"termref" href="#dt-expression">expression</a> which is evaluated
to produce a sequence, called the input sequence.</p>
<p>The <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> contained in
the <a href="#element-iterate"><code>xsl:iterate</code></a>
instruction is evaluated once for each item in the input sequence,
in order, or until the loop exits by evaluating an <a href=
"#element-break"><code>xsl:break</code></a> instruction, whichever
is earlier. Within the <a title="sequence constructor" class=
"termref" href="#dt-sequence-constructor">sequence constructor</a>
that forms the body of the <a href=
"#element-iterate"><code>xsl:iterate</code></a> instruction, the
<a title="context item" class="termref" href=
"#dt-context-item">context item</a> is set to each item from the
value of the <code>select</code> expression in turn; the <a title=
"context position" class="termref" href=
"#dt-context-position">context position</a> reflects the position
of this item in the input sequence, and the <a title="context size"
class="termref" href="#dt-context-size">context size</a> is the
number of items in the input sequence (which may be greater than
the number of iterations, if the loop exits prematurely using
<a href="#element-break"><code>xsl:break</code></a>).</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>If <a href="#element-iterate"><code>xsl:iterate</code></a> is
used in conjunction with <a href=
"#element-stream"><code>xsl:stream</code></a> to achieve streaming,
calls on the function <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-last"><code>last</code></a><sup><small>FO30</small></sup>
will be disallowed.</p>
</div>
<p>The <a href="#element-break"><code>xsl:break</code></a> and
<a href="#element-on-completion"><code>xsl:on-completion</code></a>
elements may have either a <code>select</code> attribute or a
non-empty contained <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> but not
both. The effect of the element in both cases is obtained by
evaluating the <code>select</code> expression if present or the
contained sequence constructor otherwise; if neither is present,
the value is an empty sequence.</p>
<p>The effect of <a href=
"#element-next-iteration"><code>xsl:next-iteration</code></a> is to
cause the iteration to continue by processing the next item in the
input sequence, potentially with different values for the iteration
parameters. The effect of <a href=
"#element-break"><code>xsl:break</code></a> is to cause the
iteration to finish, whether or not all the items in the input
sequence have been processed. In both cases the affected iteration
is the one controlled by the innermost ancestor <a href=
"#element-iterate"><code>xsl:iterate</code></a> element.</p>
<p>The instructions <a href=
"#element-next-iteration"><code>xsl:next-iteration</code></a> and
<a href="#element-break"><code>xsl:break</code></a> are allowed
only as descendants of an <a href=
"#element-iterate"><code>xsl:iterate</code></a> instruction, and
only in a <a title="tail position" class="termref" href=
"#dt-tail-position">tail position</a> within the <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> forming the
body of the <a href="#element-iterate"><code>xsl:iterate</code></a>
instruction.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-tail-position" id="dt-tail-position" title=
"tail position"></a>An <a title="instruction" class="termref" href=
"#dt-instruction">instruction</a> <var>J</var> is in a <b>tail
position</b> within a <a title="sequence constructor" class=
"termref" href="#dt-sequence-constructor">sequence constructor</a>
<var>SC</var> if it satisfies one of the following
conditions:<span class="definition">]</span></p>
<ul>
<li>
<p><var>J</var> is the last instruction in <var>SC</var>, ignoring
any <a href="#element-fallback"><code>xsl:fallback</code></a>
instructions.</p>
</li>
<li>
<p><var>J</var> is in a <a title="tail position" class="termref"
href="#dt-tail-position">tail position</a> within the sequence
constructor that forms the body of an <a href=
"#element-if"><code>xsl:if</code></a> instruction that is itself in
a <a title="tail position" class="termref" href=
"#dt-tail-position">tail position</a> within <var>SC</var>.</p>
</li>
<li>
<p><var>J</var> is in a <a title="tail position" class="termref"
href="#dt-tail-position">tail position</a> within the sequence
constructor that forms the body of an <a href=
"#element-when"><code>xsl:when</code></a> or <a href=
"#element-otherwise"><code>xsl:otherwise</code></a> branch of an
<a href="#element-choose"><code>xsl:choose</code></a> instruction
that is itself in a <a title="tail position" class="termref" href=
"#dt-tail-position">tail position</a> within <var>SC</var>.</p>
</li>
<li>
<p><var>J</var> is in a <a title="tail position" class="termref"
href="#dt-tail-position">tail position</a> within the sequence
constructor that forms the body of an <a href=
"#element-try"><code>xsl:try</code></a> instruction that is itself
in a <a title="tail position" class="termref" href=
"#dt-tail-position">tail position</a> within <var>SC</var> (that
is, it is immediately followed by an <a href=
"#element-catch"><code>xsl:catch</code></a> element, ignoring any
<a href="#element-fallback"><code>xsl:fallback</code></a>
elements).</p>
</li>
<li>
<p><var>J</var> is in a <a title="tail position" class="termref"
href="#dt-tail-position">tail position</a> within the sequence
constructor that forms the body of an <a href=
"#element-catch"><code>xsl:catch</code></a> element within an
<a href="#element-try"><code>xsl:try</code></a> instruction that is
itself in a <a title="tail position" class="termref" href=
"#dt-tail-position">tail position</a> within <var>SC</var>.</p>
</li>
</ul>
<p><a name="err-XTSE3120" id="err-XTSE3120"><span class=
"error">[ERR XTSE3120]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if an
<a href="#element-break"><code>xsl:break</code></a> or <a href=
"#element-next-iteration"><code>xsl:next-iteration</code></a>
element appears other than in a <a title="tail position" class=
"termref" href="#dt-tail-position">tail position</a> within the
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> forming the
body of an <a href="#element-iterate"><code>xsl:iterate</code></a>
instruction.</p>
<p><a name="err-XTSE3125" id="err-XTSE3125"><span class=
"error">[ERR XTSE3125]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
<code>select</code> attribute of <a href=
"#element-break"><code>xsl:break</code></a> or <a href=
"#element-on-completion"><code>xsl:on-completion</code></a> is
present and the instruction has children.</p>
<p><a name="err-XTSE3130" id="err-XTSE3130"><span class=
"error">[ERR XTSE3130]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
<code>name</code> attribute of an <a href=
"#element-with-param"><code>xsl:with-param</code></a> child of an
<a href=
"#element-next-iteration"><code>xsl:next-iteration</code></a>
element does not match the <code>name</code> attribute of an
<a href="#element-param"><code>xsl:param</code></a> child of the
<span>innermost</span> containing <a href=
"#element-iterate"><code>xsl:iterate</code></a> instruction.</p>
<p>Parameter names in <a href=
"#element-with-param"><code>xsl:with-param</code></a> must be
unique: <span class="error">[see <a href="#err-XTSE0670">ERR
XTSE0670</a>]</span>.</p>
<p>The result of the <a href=
"#element-iterate"><code>xsl:iterate</code></a> instruction is the
concatenation of the sequences that result from the repeated
evaluation of the contained <a title="sequence constructor" class=
"termref" href="#dt-sequence-constructor">sequence constructor</a>,
followed by the sequence that results from evaluating the <a href=
"#element-break"><code>xsl:break</code></a> or <a href=
"#element-on-completion"><code>xsl:on-completion</code></a> element
if any.</p>
<p>Any <a href="#element-param"><code>xsl:param</code></a> element
that appears as a child of <a href=
"#element-iterate"><code>xsl:iterate</code></a> declares a
parameter whose value may vary from one iteration to the next. The
initial value of the parameter is the value obtained according to
the rules given in <a href="#variable-values"><i>9.3 Values of
Variables and Parameters</i></a>. The dynamic context for
evaluating the initial value of an <a href=
"#element-param"><code>xsl:param</code></a> element is the same as
the dynamic context for evaluating the <code>select</code>
expression of the <a href=
"#element-iterate"><code>xsl:iterate</code></a> instruction (the
context item is thus <em>not</em> the first item in the input
sequence).</p>
<p>On the first iteration a parameter always takes its initial
value (which may depend on variables or other aspects of the
dynamic context). Subsequently:</p>
<ul>
<li>
<p>If an <a href=
"#element-next-iteration"><code>xsl:next-iteration</code></a>
instruction is evaluated, then parameter values for processing the
next item in the input sequence can be set in the <a href=
"#element-with-param"><code>xsl:with-param</code></a> children of
that instruction; in the absence of an <a href=
"#element-with-param"><code>xsl:with-param</code></a> element that
names a particular parameter, that parameter will retain its value
from the previous iteration.</p>
</li>
<li>
<p>If an <a href="#element-break"><code>xsl:break</code></a>
instruction is evaluated, no further items in the input sequence
are processed.</p>
</li>
<li>
<p>If neither an <a href=
"#element-next-iteration"><code>xsl:next-iteration</code></a> nor
an <a href="#element-break"><code>xsl:break</code></a> instruction
is evaluated, then the next item in the input sequence is processed
using parameter values that are unchanged from the previous
iteration.</p>
</li>
</ul>
<p>The <a href=
"#element-next-iteration"><code>xsl:next-iteration</code></a>
instruction contributes nothing to the result sequence
(technically, it returns an empty sequence). The instruction
supplies parameter values for the next iteration, which are
evaluated according to the rules given in <a href=
"#with-param"><i>9.10 Setting Parameter Values</i></a>; if there
are no further items in the input sequence then it supplies
parameter values for use while evaluating the body of the <a href=
"#element-on-completion"><code>xsl:on-completion</code></a> element
if any.</p>
<p>The <a href="#element-break"><code>xsl:break</code></a>
instruction indicates that the iteration should terminate without
processing any remaining items from the input sequence. The
<span><code>select</code> expression or</span> contained sequence
constructor is evaluated using the same context item, position, and
size as the <a href="#element-break"><code>xsl:break</code></a>
instruction itself, and the result is appended to the result of the
<a href="#element-iterate"><code>xsl:iterate</code></a> instruction
as a whole.</p>
<p>If neither an <a href=
"#element-next-iteration"><code>xsl:next-iteration</code></a> nor
an <a href="#element-break"><code>xsl:break</code></a> instruction
is evaluated, the next item in the input sequence is processed with
parameter values unchanged from the previous iteration; if there
are no further items in the input sequence, the iteration
terminates.</p>
<p>The optional <a href=
"#element-on-completion"><code>xsl:on-completion</code></a> element
(which is not technically an <a title="instruction" class="termref"
href="#dt-instruction">instruction</a> and is not technically part
of the <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>) is evaluated
when the input sequence is exhausted. It is not evaluated if the
evaluation is terminated using <a href=
"#element-break"><code>xsl:break</code></a>. During evaluation of
its <span><code>select</code> expression or</span> sequence
constructor the context item, position, and size are <a title=
"absent" class="termref" href="#dt-absent">absent</a> (that is, any
reference to these values is an error). However, the values of the
parameters to <a href=
"#element-iterate"><code>xsl:iterate</code></a> are available, and
take the values supplied by the <a href=
"#element-next-iteration"><code>xsl:next-iteration</code></a>
instruction evaluated while processing the last item in the
sequence.</p>
<p>If the input sequence is empty, then the result of the <a href=
"#element-iterate"><code>xsl:iterate</code></a> instruction is the
result of evaluating the <span><code>select</code> attribute
or</span> <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> forming the
body of the <a href=
"#element-on-completion"><code>xsl:on-completion</code></a>
element, using the initial values of the <a href=
"#element-param"><code>xsl:param</code></a> elements. If there is
no <a href=
"#element-on-completion"><code>xsl:on-completion</code></a>
element, the result is an empty sequence.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Conceptually, <a href=
"#element-iterate"><code>xsl:iterate</code></a> behaves like a
tail-recursive function. The <a href=
"#element-next-iteration"><code>xsl:next-iteration</code></a>
instruction then represents the recursive call, supplying the tail
of the input sequence as an implicit parameter. There are two main
reasons for providing the <a href=
"#element-iterate"><code>xsl:iterate</code></a> instruction. One is
that many XSLT users find writing recursive functions to be a
difficult skill, and this construct promises to be easier to learn.
The other is that recursive function calls are difficult for an
optimizer to analyze. Because <a href=
"#element-iterate"><code>xsl:iterate</code></a> is more constrained
than a general-purpose head-tail recursive function, it should be
more amenable to optimization. In particular, when the instruction
is used in conjunction with <a href=
"#element-stream"><code>xsl:stream</code></a>, it is designed to
make it easy for the implementation to use streaming techniques,
processing the nodes in an input document sequentially as they are
read, without building the entire document tree in memory.</p>
</div>
<p>The examples below use <a href=
"#element-iterate"><code>xsl:iterate</code></a> in conjunction with
the <a href="#element-stream"><code>xsl:stream</code></a>
instruction. This is not the only way of using <a href=
"#element-iterate"><code>xsl:iterate</code></a>, but it illustrates
the way in which the two features can be combined to achieve
streaming of a large input document.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e22319" id=
"d7e22319"></a>Example: Using <a href=
"#element-iterate"><code>xsl:iterate</code></a> to Compute
Cumulative Totals</div>
<p>Suppose that the input XML document has this structure</p>
<div class="exampleInner">
<pre>
&lt;transactions&gt;
  &lt;transaction date="2008-09-01" value="12.00"/&gt;
  &lt;transaction date="2008-09-01" value="8.00"/&gt;
  &lt;transaction date="2008-09-02" value="-2.00"/&gt;
  &lt;transaction date="2008-09-02" value="5.00"/&gt;
&lt;/transactions&gt;
</pre></div>
<p>and that the requirement is to transform this to:</p>
<div class="exampleInner">
<pre>
&lt;account&gt;
  &lt;balance date="2008-09-01" value="12.00"/&gt;
  &lt;balance date="2008-09-01" value="20.00"/&gt;
  &lt;balance date="2008-09-02" value="18.00"/&gt;
  &lt;balance date="2008-09-02" value="23.00"/&gt;
&lt;/account&gt;
</pre></div>
<p>This can be achieved using the following code, which is designed
to process the transaction file using streaming:</p>
<div class="exampleInner">
<pre>
&lt;account&gt;
  &lt;xsl:stream href="transactions.xml"&gt;
    &lt;xsl:iterate select="transactions/transaction"&gt;
      &lt;xsl:param name="balance" select="0.00" as="xs:decimal"/&gt;
      &lt;xsl:variable name="newBalance" 
                    select="$balance + xs:decimal(@value)"/&gt;
      &lt;balance date="{@date}" value="{$newBalance}"/&gt;
      &lt;xsl:next-iteration&gt;
        &lt;xsl:with-param name="balance" select="$newBalance"/&gt;
      &lt;/xsl:next-iteration&gt;
    &lt;/xsl:iterate&gt;
  &lt;/xsl:stream&gt;
&lt;/account&gt;
</pre></div>
<p>The following example modifies this by only outputting the
information for the first day's transactions:</p>
<div class="exampleInner">
<pre>
&lt;account&gt;
  &lt;xsl:stream href="'transactions.xml"&gt;
    &lt;xsl:iterate select="transactions/transaction"&gt;
      &lt;xsl:param name="balance" select="0.00" as="xs:decimal"/&gt;
      &lt;xsl:param name="prevDate" select="()" as="xs:date?"/&gt;
      &lt;xsl:variable name="newBalance" 
                    select="$balance + xs:decimal(@value)"/&gt;
      &lt;xsl:variable name="thisDate" 
                    select="xs:date(@date)"/&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test="empty($prevDate) or $thisDate eq $prevDate"&gt;
          &lt;balance date="{$thisDate}" 
                   value="{format-number($newBalance, '0.00')}"/&gt;
          &lt;xsl:next-iteration&gt;
            &lt;xsl:with-param name="balance" select="$newBalance"/&gt;
            &lt;xsl:with-param name="prevDate" select="$thisDate"/&gt;
          &lt;/xsl:next-iteration&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:break/&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
    &lt;/xsl:iterate&gt;
  &lt;/xsl:stream&gt;
&lt;/account&gt;
</pre></div>
<p>The following code outputs the balance only at the end of each
day, together with the final balance:</p>
<div class="exampleInner">
<pre>
&lt;account&gt;
  &lt;xsl:stream href="transactions.xml"&gt;
    &lt;xsl:iterate select="transactions/transaction"&gt;
      &lt;xsl:param name="balance" select="0.00" as="xs:decimal"/&gt;
      &lt;xsl:param name="prevDate" select="()" as="xs:date?"/&gt;
      &lt;xsl:on-completion&gt;
        &lt;balance date="{$prevDate}" 
                 value="{format-number($balance, '0.00')}"/&gt;
      &lt;/xsl:on-completion&gt;     
      &lt;xsl:variable name="newBalance" 
                    select="$balance + xs:decimal(@value)"/&gt;
      &lt;xsl:variable name="thisDate" select="xs:date(@date)"/&gt;
      &lt;xsl:if test="exists($prevDate) and $thisDate ne $prevDate"&gt;
        &lt;balance date="{$prevDate}" 
                 value="{format-number($balance, '0.00')}"/&gt;
      &lt;/xsl:if&gt;
      &lt;xsl:next-iteration&gt;
        &lt;xsl:with-param name="balance" select="$newBalance"/&gt;
        &lt;xsl:with-param name="prevDate" select="$thisDate"/&gt;
      &lt;/xsl:next-iteration&gt;     
    &lt;/xsl:iterate&gt;
  &lt;/xsl:stream&gt;
&lt;/account&gt;
</pre></div>
<p>If the sequence of transactions is empty, this code outputs a
single element: <code>&lt;balance date=""
value="0.00"/&gt;</code>.</p>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e22351" id=
"d7e22351"></a>Example: Collecting Multiple Values in a Single
Pass</div>
<p>Problem: Given a sequence of <code>employee</code> elements,
find the employees having the highest and lowest salary, while
processing each employee only once.</p>
<p>Solution:</p>
<div class="exampleInner">
<pre>
&lt;xsl:stream href="employees.xml"&gt;
  &lt;xsl:iterate select="employees/employee"&gt;
    &lt;xsl:param name="highest" as="element(employee)*"/&gt;
    &lt;xsl:param name="lowest" as="element(employee)*"/&gt;
    &lt;xsl:on-completion&gt;
      &lt;highest-paid-employees&gt;
        &lt;xsl:value-of select="$highest/name"/&gt;
      &lt;/highest-paid-employees&gt;
      &lt;lowest-paid-employees&gt;
        &lt;xsl:value-of select="$lowest/name"/&gt;
      &lt;/lowest-paid-employees&gt;  
    &lt;/xsl:on-completion&gt;   
    &lt;xsl:variable name="is-new-highest" as="xs:boolean"
                  select="empty($highest[@salary ge current()/@salary])"/&gt;
    &lt;xsl:variable name="is-equal-highest" as="xs:boolean" 
                  select="exists($highest[@salary eq current()/@salary])"/&gt; 
    &lt;xsl:variable name="is-new-lowest" as="xs:boolean" 
                  select="empty($lowest[@salary le current()/@salary])"/&gt;
    &lt;xsl:variable name="is-equal-lowest" as="xs:boolean" 
                  select="exists($lowest[@salary eq current()/@salary])"/&gt; 
    &lt;xsl:variable name="new-highest-set" as="element(employee)*"
                  select="if ($is-new-highest) then .
                          else if ($is-equal-highest) then ($highest, .)
                          else $highest"/&gt;
    &lt;xsl:variable name="new-lowest-set" as="element(employee)*"
                  select="if ($is-new-lowest) then .
                          else if ($is-equal-lowest) then ($lowest, .)
                          else $lowest"/&gt;
    &lt;xsl:next-iteration&gt;
      &lt;xsl:with-param name="highest" select="$new-highest-set"/&gt;
      &lt;xsl:with-param name="lowest" select="$new-lowest-set"/&gt;
    &lt;/xsl:next-iteration&gt;
   &lt;/xsl:iterate&gt;
 &lt;/xsl:stream&gt;
</pre></div>
<p>If the input sequence is empty, this code outputs an empty
<code>highest-paid-employees</code> element and an empty
<code>lowest-paid-employees</code> element.</p>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e22371" id=
"d7e22371"></a>Example: Processing the Last Item in a Sequence
Specially</div>
<p>When streaming, some limited look-ahead is needed to determine
whether the item being processed is the last in a sequence. The
<a href=
"http://www.w3.org/TR/xpath-functions-30/#func-last"><code>last</code></a><sup><small>FO30</small></sup>
function cannot be used in <a title="guaranteed-streamable" class=
"termref" href=
"#dt-guaranteed-streamable">guaranteed-streamable</a> code. The
<a href="#element-iterate"><code>xsl:iterate</code></a> instruction
provides a solution to this problem.</p>
<p>Problem: render the last paragraph in a section in some special
way, for example by using bold face. (The actual rendition is
achieved by processing the paragraph with mode
<code>last-para</code>.)</p>
<p>The solution uses <a href=
"#element-iterate"><code>xsl:iterate</code></a> <span>together with
the <a href="#func-copy-of"><code>copy-of</code></a>
function</span> to maintain a one-element look-ahead by explicit
coding:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="section" mode="streaming"&gt;
   &lt;xsl:iterate select="para"&gt;
     &lt;xsl:param name="prev" select="()" as="element(para)?"/&gt;
     &lt;xsl:on-completion&gt;
       &lt;xsl:apply-templates select="$prev" mode="last-para"/&gt;      
     &lt;/xsl:on-completion&gt;
     &lt;xsl:if test="$prev"&gt;
       &lt;xsl:apply-templates select="$prev"/&gt;
     &lt;/xsl:if&gt;
     &lt;xsl:next-iteration&gt;
       &lt;xsl:with-param name="prev" select="copy-of(.)"/&gt;
     &lt;/xsl:next-iteration&gt;
   &lt;/xsl:iterate&gt;
 &lt;/xsl:template&gt;
</pre></div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="conditionals" id="conditionals"></a>8 <a href=
"#conditionals" style="text-decoration: none">Conditional
Processing</a></h2>
<p>There are two instructions in XSLT that support conditional
processing: <a href="#element-if"><code>xsl:if</code></a> and
<a href="#element-choose"><code>xsl:choose</code></a>. The <a href=
"#element-if"><code>xsl:if</code></a> instruction provides simple
if-then conditionality; the <a href=
"#element-choose"><code>xsl:choose</code></a> instruction supports
selection of one choice when there are several possibilities.</p>
<p>XSLT 3.0 also supports <a href=
"#element-try"><code>xsl:try</code></a> and <a href=
"#element-catch"><code>xsl:catch</code></a> which define
conditional processing to handle <a title="dynamic error" class=
"termref" href="#dt-dynamic-error">dynamic errors</a>.</p>
<div class="div2">
<h3><a name="xsl-if" id="xsl-if"></a>8.1 <a href="#xsl-if" style=
"text-decoration: none">Conditional Processing with</a> <a href=
"#element-if"><code>xsl:if</code></a> <a href="#xsl-if" style=
"text-decoration: none"></a></h3>
<p class="element-syntax"><a name="element-if" id=
"element-if"></a><code>&lt;!-- Category: instruction --&gt;<br />
&lt;xsl:if<br />
&#160;&#160;<b>test</b> = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:if&gt;</code></p>
<p>The <a href="#element-if"><code>xsl:if</code></a> element has a
mandatory <code>test</code> attribute, which specifies an <a title=
"expression" class="termref" href="#dt-expression">expression</a>.
The content is a <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a>.</p>
<p>The result of the <a href="#element-if"><code>xsl:if</code></a>
instruction depends on the <a href=
"http://www.w3.org/TR/xpath-30/#dt-ebv">effective boolean
value</a><sup><small>XP30</small></sup> of the expression in the
<code>test</code> attribute. The rules for determining the
effective boolean value of an expression are given in <a href=
"#xpath-30">[XPath 3.0]</a>: they are the same as the rules used
for XPath conditional expressions.</p>
<p>If the effective boolean value of the <a title="expression"
class="termref" href="#dt-expression">expression</a> is true, then
the <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> is evaluated
(see <a href="#sequence-constructors"><i>5.8 Sequence
Constructors</i></a>), and the resulting sequence is returned as
the result of the <a href="#element-if"><code>xsl:if</code></a>
instruction; otherwise, the sequence constructor is not evaluated,
and the empty sequence is returned.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e22485" id=
"d7e22485"></a>Example: Using <a href=
"#element-if"><code>xsl:if</code></a></div>
<p>In the following example, the names in a group of names are
formatted as a comma separated list:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="namelist/name"&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:if test="not(position()=last())"&gt;, &lt;/xsl:if&gt;
&lt;/xsl:template&gt;
</pre></div>
<p>The following colors every other table row yellow:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="item"&gt;
  &lt;tr&gt;
    &lt;xsl:if test="position() mod 2 = 0"&gt;
       &lt;xsl:attribute name="bgcolor"&gt;yellow&lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/tr&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
</div>
<div class="div2">
<h3><a name="xsl-choose" id="xsl-choose"></a>8.2 <a href=
"#xsl-choose" style="text-decoration: none">Conditional Processing
with</a> <a href="#element-choose"><code>xsl:choose</code></a>
<a href="#xsl-choose" style="text-decoration: none"></a></h3>
<p class="element-syntax"><a name="element-choose" id=
"element-choose"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:choose&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-when">xsl:when</a>+, <a href=
"#element-otherwise">xsl:otherwise</a>?) --&gt;<br />
&lt;/xsl:choose&gt;</code></p>
<p class="element-syntax"><a name="element-when" id=
"element-when"></a><code>&lt;xsl:when<br />
&#160;&#160;<b>test</b> = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:when&gt;</code></p>
<p class="element-syntax"><a name="element-otherwise" id=
"element-otherwise"></a><code>&lt;xsl:otherwise&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:otherwise&gt;</code></p>
<p>The <a href="#element-choose"><code>xsl:choose</code></a>
element selects one among a number of possible alternatives. It
consists of a sequence of one or more <a href=
"#element-when"><code>xsl:when</code></a> elements followed by an
optional <a href=
"#element-otherwise"><code>xsl:otherwise</code></a> element. Each
<a href="#element-when"><code>xsl:when</code></a> element has a
single attribute, <code>test</code>, which specifies an <a title=
"expression" class="termref" href="#dt-expression">expression</a>.
The content of the <a href=
"#element-when"><code>xsl:when</code></a> and <a href=
"#element-otherwise"><code>xsl:otherwise</code></a> elements is a
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>.</p>
<p>When an <a href="#element-choose"><code>xsl:choose</code></a>
element is processed, each of the <a href=
"#element-when"><code>xsl:when</code></a> elements is tested in
turn (that is, in the order that the elements appear in the
stylesheet), until one of the <a href=
"#element-when"><code>xsl:when</code></a> elements is satisfied. If
none of the <a href="#element-when"><code>xsl:when</code></a>
elements is satisfied, then the <a href=
"#element-otherwise"><code>xsl:otherwise</code></a> element is
considered, as described below.</p>
<p>An <a href="#element-when"><code>xsl:when</code></a> element is
satisfied if the <a href=
"http://www.w3.org/TR/xpath-30/#dt-ebv">effective boolean
value</a><sup><small>XP30</small></sup> of the <a title=
"expression" class="termref" href="#dt-expression">expression</a>
in its <code>test</code> attribute is <code>true</code>. The rules
for determining the effective boolean value of an expression are
given in <a href="#xpath-30">[XPath 3.0]</a>: they are the same as
the rules used for XPath conditional expressions.</p>
<p>The content of the first, and only the first, <a href=
"#element-when"><code>xsl:when</code></a> element that is satisfied
is evaluated, and the resulting sequence is returned as the result
of the <a href="#element-choose"><code>xsl:choose</code></a>
instruction. If no <a href=
"#element-when"><code>xsl:when</code></a> element is satisfied, the
content of the <a href=
"#element-otherwise"><code>xsl:otherwise</code></a> element is
evaluated, and the resulting sequence is returned as the result of
the <a href="#element-choose"><code>xsl:choose</code></a>
instruction. If no <a href=
"#element-when"><code>xsl:when</code></a> element is satisfied, and
no <a href="#element-otherwise"><code>xsl:otherwise</code></a>
element is present, the result of the <a href=
"#element-choose"><code>xsl:choose</code></a> instruction is an
empty sequence.</p>
<p>Only the sequence constructor of the selected <a href=
"#element-when"><code>xsl:when</code></a> or <a href=
"#element-otherwise"><code>xsl:otherwise</code></a> instruction is
evaluated. The <code>test</code> expressions for <a href=
"#element-when"><code>xsl:when</code></a> instructions after the
selected one are not evaluated.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e22629" id=
"d7e22629"></a>Example: Using <a href=
"#element-choose"><code>xsl:choose</code></a></div>
<p>The following example enumerates items in an ordered list using
arabic numerals, letters, or roman numerals depending on the depth
to which the ordered lists are nested.</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="orderedlist/listitem"&gt;
  &lt;fo:list-item indent-start='2pi'&gt;
    &lt;fo:list-item-label&gt;
      &lt;xsl:variable name="level"
                    select="count(ancestor::orderedlist) mod 3"/&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test='$level=1'&gt;
          &lt;xsl:number format="i"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:when test='$level=2'&gt;
          &lt;xsl:number format="a"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:number format="1"/&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
      &lt;xsl:text&gt;. &lt;/xsl:text&gt;
    &lt;/fo:list-item-label&gt;
    &lt;fo:list-item-body&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/fo:list-item-body&gt;
  &lt;/fo:list-item&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
</div>
<div class="div2">
<h3><a name="try-catch" id="try-catch"></a>8.3 <a href="#try-catch"
style="text-decoration: none">Try/Catch</a></h3>
<p>The <a href="#element-try"><code>xsl:try</code></a> instruction
can be used to trap dynamic errors occurring within the expression
it wraps; the recovery action if such errors occur is defined using
a child <a href="#element-catch"><code>xsl:catch</code></a>
element.</p>
<p class="element-syntax"><a name="element-try" id=
"element-try"></a><code>&lt;!-- Category: instruction --&gt;<br />
&lt;xsl:try<br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;rollback-output? = <var>boolean</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<var>sequence-constructor</var>,
<a href="#element-catch">xsl:catch</a>, (<a href=
"#element-catch">xsl:catch</a> | <a href=
"#element-fallback">xsl:fallback</a>)*) --&gt;<br />
&lt;/xsl:try&gt;</code></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Because a sequence constructor may contain an <a href=
"#element-fallback"><code>xsl:fallback</code></a> element, the
effect of this content model is that an <a href=
"#element-fallback"><code>xsl:fallback</code></a> instruction may
appear as a child of <a href=
"#element-try"><code>xsl:try</code></a> in any position.</p>
</div>
<p class="element-syntax"><a name="element-catch" id=
"element-catch"></a><code>&lt;xsl:catch<br />
&#160;&#160;errors? = <var>tokens</var><br />
&#160;&#160;select? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:catch&gt;</code></p>
<p>An <a href="#element-try"><code>xsl:try</code></a> instruction
evaluates either the expression contained in its
<code>select</code> attribute, or its contained <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>, and returns
the result of that evaluation if it succeeds without error. If a
<a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> occurs during the evaluation,
the processor evaluates the first <a href=
"#element-catch"><code>xsl:catch</code></a> child element
applicable to the error, and returns that result instead.</p>
<p>If the <a href="#element-try"><code>xsl:try</code></a> element
has a <code>select</code> attribute, then it <span class=
"verb">must</span> have no children other than <a href=
"#element-catch"><code>xsl:catch</code></a> and <a href=
"#element-fallback"><code>xsl:fallback</code></a>. That is, the
<code>select</code> attribute and the contained sequence
constructor are mutually exclusive. If neither is present, the
result of the <a href="#element-try"><code>xsl:try</code></a> is an
empty sequence (no dynamic error can occur in this case).</p>
<p>The <code>rollback-output</code> attribute is described in
<a href="#recovery"><i>8.3.1 Recovery of Result Trees</i></a>. The
default value is <code>yes</code>.</p>
<p><a name="err-XTSE3140" id="err-XTSE3140"><span class=
"error">[ERR XTSE3140]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
<code>select</code> attribute of the <a href=
"#element-try"><code>xsl:try</code></a> element is present and the
element has children other than <a href=
"#element-catch"><code>xsl:catch</code></a> and <a href=
"#element-fallback"><code>xsl:fallback</code></a> elements.</p>
<p>Any <a href="#element-fallback"><code>xsl:fallback</code></a>
children of the <a href="#element-try"><code>xsl:try</code></a>
element are ignored by an XSLT 3.0 processor, but can be used to
define the recovery action taken by an XSLT 1.0 or XSLT 2.0
processor operating with <a title="forwards compatible behavior"
class="termref" href="#dt-forwards-compatible-behavior">forwards
compatible behavior</a>.</p>
<p>The <a href="#element-catch"><code>xsl:catch</code></a> element
has an optional <code>errors</code> attribute, which lists the
error conditions that the <a href=
"#element-catch"><code>xsl:catch</code></a> element is designed to
intercept. The default value is <code>errors="*"</code>, which
catches all errors. The value is a whitespace-separated list of
<a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-NameTest">NameTests</a><sup><small>XP30</small></sup>;
an <a href="#element-catch"><code>xsl:catch</code></a> element
catches an error condition if this list includes a
<code>NameTest</code> that matches the error code associated with
that error condition.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Error codes are QNames. Those defined in this specification and
in related specifications are all in the <a title=
"standard error namespace" class="termref" href=
"#dt-standard-error-namespace">standard error namespace</a>, and
may therefore be caught using an <a href=
"#element-catch"><code>xsl:catch</code></a> element such as
<code>&lt;xsl:catch errors="err:FODC0001 err:FODC0005"&gt;</code>
where the namespace prefix <code>err</code> is bound to this
namespace. Errors defined by implementers, and errors raised by an
explicit call of the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-error"><code>error</code></a><sup><small>FO30</small></sup>
function or by use of the <a href=
"#element-message"><code>xsl:message</code></a> <span>or <a href=
"#element-assert"><code>xsl:assert</code></a></span> instruction,
may use error codes in other namespaces.</p>
</div>
<p>If more than one <a href=
"#element-catch"><code>xsl:catch</code></a> element matches an
error, the error is processed using the first one that matches, in
document order. If no <a href=
"#element-catch"><code>xsl:catch</code></a> matches the error, then
the error is not caught (that is, evaluation of the <a href=
"#element-try"><code>xsl:try</code></a> element fails with the
dynamic error).</p>
<p>An <a href="#element-catch"><code>xsl:catch</code></a> element
may have either a <code>select</code> attribute, or a contained
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>.</p>
<p><a name="err-XTSE3150" id="err-XTSE3150"><span class=
"error">[ERR XTSE3150]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
<code>select</code> attribute of the <a href=
"#element-catch"><code>xsl:catch</code></a> element is present
unless the element has empty content.</p>
<p>The result of evaluating the <a href=
"#element-catch"><code>xsl:catch</code></a> element is the result
of evaluating the XPath expression in its <code>select</code>
attribute or the result of evaluating the contained sequence
constructor; if neither is present, the result is an empty
sequence. This result is delivered as the result of the
<code>xsl:try</code> instruction.</p>
<p>If a dynamic error occurs during the evaluation of <a href=
"#element-catch"><code>xsl:catch</code></a>, it causes the
containing <a href="#element-try"><code>xsl:try</code></a> to fail
with this error. The error is not caught by other sibling <a href=
"#element-catch"><code>xsl:catch</code></a> elements within the
same <a href="#element-try"><code>xsl:try</code></a> instruction,
but it may be caught by an <a href=
"#element-try"><code>xsl:try</code></a> instruction at an outer
level, or by an <a href="#element-try"><code>xsl:try</code></a>
instruction nested within the <a href=
"#element-catch"><code>xsl:catch</code></a>.</p>
<p>Within the <code>select</code> expression, or within the
sequence constructor contained by the <a href=
"#element-catch"><code>xsl:catch</code></a> element, a number of
variables are implicitly declared, giving information about the
error that occurred. These are lexically scoped to the
<code>xsl:catch</code> element. These variables are all in the
<a title="standard error namespace" class="termref" href=
"#dt-standard-error-namespace">standard error namespace</a>, and
they are initialized as described in the following table:</p>
<table border="1" cellpadding="5" summary=
"variables containing information for use within try/catch" width=
"100%">
<thead>
<tr>
<th align="left" colspan="1" valign="top">Variable</th>
<th align="left" colspan="1" valign="top">Type</th>
<th align="left" colspan="1" valign="top">Value</th>
</tr>
</thead>
<tbody>
<tr>
<td valign="top" align="left">err:code</td>
<td valign="top" align="left">xs:QName</td>
<td valign="top" align="left">The error code</td>
</tr>
<tr>
<td valign="top" align="left">err:description</td>
<td valign="top" align="left">xs:string<span>?</span></td>
<td valign="top" align="left">A description of the error condition;
<span>an empty sequence if no description is available (for
example, if the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-error"><code>error</code></a><sup><small>FO30</small></sup>
function was called with one argument)</span>.</td>
</tr>
<tr>
<td valign="top" align="left">err:value</td>
<td valign="top" align="left">item()*</td>
<td valign="top" align="left">Value associated with the error. For
an error raised by calling the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-error"><code>error</code></a><sup><small>FO30</small></sup>
function, this is the value of the third argument (if supplied).
For an error raised by evaluating <a href=
"#element-message"><code>xsl:message</code></a> with
<code>terminate="yes"</code>, <span>or a failing <a href=
"#element-assert"><code>xsl:assert</code></a></span>, this is the
document node at the root of the tree containing the XML message
body.</td>
</tr>
<tr>
<td valign="top" align="left">err:module</td>
<td valign="top" align="left">xs:string?</td>
<td valign="top" align="left">The URI (or system ID) of the
stylesheet module containing the instruction where the error
occurred; an empty sequence if the information is not
available.</td>
</tr>
<tr>
<td valign="top" align="left">err:line-number</td>
<td valign="top" align="left">xs:integer?</td>
<td valign="top" align="left">The line number within the stylesheet
module of the instruction where the error occurred; an empty
sequence if the information is not available. The value
<span class="verb">may</span> be approximate.</td>
</tr>
<tr>
<td valign="top" align="left">err:column-number</td>
<td valign="top" align="left">xs:integer?</td>
<td valign="top" align="left">The column number within the
stylesheet module of the instruction where the error occurred; an
empty sequence if the information is not available. The value
<span class="verb">may</span> be approximate.</td>
</tr>
</tbody>
</table>
<p>Variables declared within the sequence constructor of the
<a href="#element-try"><code>xsl:try</code></a> element (and not
within an <a href="#element-catch"><code>xsl:catch</code></a>) are
not visible within the <a href=
"#element-catch"><code>xsl:catch</code></a> element.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Within an <a href="#element-catch"><code>xsl:catch</code></a> it
is possible to re-throw the error using the function call
<code>error($err:code, $err:description, $err:value)</code>.</p>
</div>
<p>The following additional rules apply to the catching of
errors:</p>
<ol class="enumar">
<li>
<p>All dynamic errors occurring during the evaluation of the
<a href="#element-try"><code>xsl:try</code></a> sequence
constructor or <code>select</code> expression are caught (provided
they match one of the <a href=
"#element-catch"><code>xsl:catch</code></a> elements).</p>
<ul>
<li>
<p>This includes errors occurring in functions or templates invoked
in the course of this evaluation, unless already caught by a nested
<a href="#element-try"><code>xsl:try</code></a>.</p>
</li>
<li>
<p>It also includes errors caused by calling the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-error"><code>error</code></a><sup><small>FO30</small></sup>
function, or the <a href=
"#element-message"><code>xsl:message</code></a> instruction with
<code>terminate="yes"</code>, or the <span><a href=
"#element-assert"><code>xsl:assert</code></a>
instruction</span>.</p>
</li>
<li>
<p>It does not include errors that occur while evaluating
references to variables whose declaration and initialization is
outside the <a href="#element-try"><code>xsl:try</code></a>.</p>
</li>
</ul>
</li>
<li>
<p>The existence of an <a href=
"#element-try"><code>xsl:try</code></a> instruction does not affect
the obligation of the processor to signal certain errors as static
errors, or its right to choose whether to signal some errors (such
as <a title="type error" class="termref" href="#dt-type-error">type
errors</a>) statically or dynamically. Static errors are never
caught.</p>
</li>
<li>
<p>Some fatal errors arising in the processing environment, such as
running out of memory, may cause termination of the transformation
despite the presence of an <a href=
"#element-try"><code>xsl:try</code></a> instruction. This is
<a title="implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a>.</p>
</li>
<li>
<p>If the sequence constructor or <code>select</code> expression of
the <a href="#element-try"><code>xsl:try</code></a> causes
execution of <a href=
"#element-result-document"><code>xsl:result-document</code></a>,
<a href="#element-message"><code>xsl:message</code></a>, <span>or
<a href="#element-assert"><code>xsl:assert</code></a></span>
instructions and fails with a dynamic error that is caught, it is
implementation-dependent whether these instructions have any
externally visible effect. The processor is <span class="verb">not
required</span> to roll back any changes made by these
instructions. The same applies to any side effects caused by
extension functions or extension instructions.</p>
</li>
<li>
<p>A serialization error that occurs during the serialization of a
<a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a> produced using
<a href=
"#element-result-document"><code>xsl:result-document</code></a> is
treated as a dynamic error in the evaluation of the <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction, and may be caught (for example by an <a href=
"#element-try"><code>xsl:try</code></a> instruction that contains
the <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction). A serialization error that occurs while serializing
the implicit <a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a> returned by the
<a title="initial named template" class="termref" href=
"#dt-initial-named-template">initial named template</a> is treated
as occurring after the transformation has finished, and cannot be
caught.</p>
</li>
<li>
<p>A validation error is treated as occurring in the instruction
that requested validation. For example, if the stylesheet is
producing XHTML output and requests validation of the entire result
document by means of the attribute <code>validation="strict"</code>
on the instruction that creates the outermost <code>html</code>
element, then a validation failure can be caught only at that
level. Although the validation error might be detected, for
example, while writing a <code>p</code> element at a location where
no <code>p</code> element is allowed, it is not treated as an error
in the instruction that writes the <code>p</code> element and
cannot be caught at that level.</p>
</li>
<li>
<p>A type error may be caught if the processor raises it
dynamically; this does not affect the processor's right to raise
the error statically if it chooses.</p>
<p>The following rules are provided to define which expression is
considered to fail when a type error occurs, and therefore where
the error can be caught. The general principle is that where the
semantics of a construct <var>C</var> place requirements on the
type of some subexpression, a type error is an error in the
evaluation of <var>C</var>, not in the evaluation of the
subexpression.</p>
<p>For example, consider the following construct:</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="v" as="xs:integer"&gt;
  &lt;xsl:sequence select="$foo"/&gt;
&lt;/xsl:variable&gt;
</pre></div>
<p>The expected type of the result of the sequence constructor is
<code>xs:integer</code>; if the value of variable <code>$foo</code>
turns out to be a string, then a type error will occur. It is not
possible to catch this by writing:</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="v" as="xs:integer"&gt;
  &lt;xsl:try&gt;
    &lt;xsl:sequence select="$foo"/&gt;
    &lt;xsl:catch&gt;...&lt;/xsl:catch&gt;
  &lt;/xsl:try&gt;
&lt;/xsl:variable&gt;
</pre></div>
<p>This fails to catch the error because the <a href=
"#element-sequence"><code>xsl:sequence</code></a> instruction is
deemed to evaluate successfully; the failure only occurs when the
result of this instruction is bound to the variable.</p>
<p>A similar rule applies to functions: if the body of a function
computes a result which does not conform to the required type of
the function result, it is not possible to catch this error within
the function body itself; it can only be caught by the caller of
the function. Similarly, if an expression used to compute an
argument to a function returns a value of the wrong type for the
function signature, this is not considered an error in this
expression, but an error in evaluating the function call as a
whole.</p>
<p>A consequence of these rules is that when a type error occurs
while initializing a global variable (because the initializer
returns a value of the wrong type, given the declared type of the
variable), then this error cannot be caught.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Because processors are permitted to report type errors during
static analysis, it is unwise to attempt to recover from type
errors dynamically. The best strategy is generally to prevent their
occurrence. For example, rather than writing <code>$p + 1</code>
where <code>$p</code> is a parameter of unknown type, and then
catching the type error that occurs if <code>$p</code> is not
numeric, it is better first to test whether <code>$p</code> is
numeric, perhaps by means of an expression such as <code>$p
instance of my:numeric</code>, where <code>my:numeric</code> is a
union type with <code>xs:double</code>, <code>xs:float</code>, and
<code>xs:decimal</code> as its member types.</p>
</div>
</li>
<li>
<p>The fact that the application tries to catch errors does not
prevent the processor from organizing the evaluation in such a way
as to prevent errors occurring. For example <code>exists(//a[10 div
. gt 5])</code> may still do an "early exit", rather than examining
every item in the sequence just to see if it triggers a
divide-by-zero error.</p>
</li>
<li>
<p>Except as specified above, the optimizer must not rearrange the
evaluation (at compile time or at run time) so that expressions
written to be subject to the try/catch are evaluated outside its
scope, or expressions written to be external to the try/catch are
evaluated within its scope. This does not prevent expressions being
rearranged, but any expression that is so rearranged must carry its
try/catch context with it.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>If an error occurs while evaluating an instruction within
<a href="#element-try"><code>xsl:try</code></a>, then no
instruction within the <a href=
"#element-try"><code>xsl:try</code></a> has any effect on the
result returned by the <a href=
"#element-try"><code>xsl:try</code></a> instruction. This means
that if a processor is streaming the output to a serializer, it
needs to adopt a strategy such as buffering the output in memory so
that nothing is written until successful completion of the <a href=
"#element-try"><code>xsl:try</code></a> instruction, or
checkpointing the output so it can be rolled back when an error
occurs.</p>
</div>
<div class="div3">
<h4><a name="recovery" id="recovery"></a>8.3.1 <a href="#recovery"
style="text-decoration: none">Recovery of Result Trees</a></h4>
<p>The XSLT language is designed so that a processor that chooses
to execute instructions in document order will always append nodes
to the result tree in document order, and never needs to update a
result tree in situ. As a result, it is normal practice for XSLT
processors to stream the result tree directly to its final
destination (for example, a serializer) without ever holding the
tree in memory. This applies whether or not the processor is
streamable, and whether or not source documents are streamed.</p>
<p>The language specification states that when a transformation
terminates with a dynamic error, the state of persistent resources
affected by the transformation (for example, serialized result
documents) is implementation-defined, so processors are not
required to take any special steps to recover such resources to
their pre-transformation state; at the same time, there is no
guarantee that secondary result documents produced before the
failure occurs will be in a usable state.</p>
<p>The situation becomes more complicated when dynamic errors occur
while writing to a result tree, and the dynamic error is caught by
an <a href="#element-try"><code>xsl:try</code></a>/<a href=
"#element-catch"><code>xsl:catch</code></a> instruction. The
semantics of these instructions requires that when an error
occurring during the evaluation of <a href=
"#element-try"><code>xsl:try</code></a> is caught, the result of
the <a href="#element-try"><code>xsl:try</code></a> instruction is
the result of the relevant <a href=
"#element-catch"><code>xsl:catch</code></a>. To achieve this, any
output written to the result tree during the execution of <a href=
"#element-try"><code>xsl:try</code></a> until the point where the
error occurs must effectively be undone. There are two basic
strategies for achieving this: either the updates are not committed
to persistent storage until the <a href=
"#element-try"><code>xsl:try</code></a> instruction is completed,
or the updates are written in such a way that they can be "rolled
back" in the event of a failure.</p>
<p>Both these strategies are potentially expensive, and both have
an adverse effect on streaming, in that they affect the amount of
memory needed to transform large amounts of data. XSLT 3.0
therefore provides an option to relax the requirement to recover
result trees when failures occur in the course of evaluating an
<a href="#element-try"><code>xsl:try</code></a> instruction. This
option is invoked by specifying <code>rollback-output="no"</code>
on the <a href="#element-try"><code>xsl:try</code></a>
instruction.</p>
<p>The default value of the attribute is
<code>rollback-output="yes"</code>.</p>
<p>The effect of specifying <code>rollback-output="no"</code> on
<a href="#element-try"><code>xsl:try</code></a> is as follows: if a
dynamic error occurs in the course of evaluating the <a href=
"#element-try"><code>xsl:try</code></a> instruction, and if the
failing construct is evaluated in <a title="final output state"
class="termref" href="#dt-final-output-state">final output
state</a> while writing to some result document, then it is
<a title="implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a> whether
an attempt to catch this error using <a href=
"#element-catch"><code>xsl:catch</code></a> will be successful. If
the attempt is successful, then the <a href=
"#element-try"><code>xsl:try</code></a> instruction succeeds,
delivering the result of evaluating the <a href=
"#element-catch"><code>xsl:catch</code></a> clause, and the
transformation proceeds as normal. If the attempt is unsuccessful
(typically, because non-recoverable updates have already been made
to the result tree), then the <a href=
"#element-try"><code>xsl:try</code></a> instruction as a whole
fails with a dynamic error. The state of this result document will
then be undefined, but the transformation can ignore the failure
and continue to produce other result documents, for example by
wrapping the <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction in an <a href="#element-try"><code>xsl:try</code></a>
instruction that catches the relevant error.</p>
<p><a name="err-XTDE3530" id="err-XTDE3530"><span class=
"error">[ERR XTDE3530]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if an
<a href="#element-try"><code>xsl:try</code></a> instruction is
unable to recover the state of a final result tree because recovery
has been disabled by use of the attribute
<code>rollback-output="no"</code>.</p>
<p>For example, consider the following:</p>
<div class="exampleInner">
<pre>
          &lt;xsl:result-document href="out.xml"&gt;     
            &lt;xsl:try rollback-output="no"&gt;
              &lt;xsl:stream href="in.xml"&gt;
                &lt;xsl:copy-of select="."/&gt;
              &lt;/xsl:stream&gt;
              &lt;xsl:catch errors="*"&gt;
                &lt;error code="{$err:code}" message="{$err:description}" file="in.xml"/&gt;
              &lt;/xsl:catch&gt;
            &lt;/xsl:try&gt;
         &lt;/xsl:result-document&gt;
</pre></div>
<p>The most likely failure to occur here is a failure to read the
streamed input file <code>in.xml</code>. In the common case where
this failure is detected immediately, for example if the file does
not exist or the network connection is down, no output will have
been written to the result document, and the attempt to catch the
error is likely to be successful. If however a failure is detected
after several megabytes of data have been copied to
<code>out.xml</code>, for example an XML well-formedness error in
the input file, or a network failure that occurs while reading the
file, recovery of the output file may be impossible. In this
situation the <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction will fail with a dynamic error. It is possible to catch
this error, but the state of the file <code>out.xml</code> will be
unpredictable.</p>
<p>Note that adding an <a href=
"#element-try"><code>xsl:try</code></a> instruction as a child of
<a href="#element-stream"><code>xsl:stream</code></a> does not
help. Any error reading the input file (such as a well-formedness
error) is an error in the <a href=
"#element-stream"><code>xsl:stream</code></a> instruction and can
only be caught at that level.</p>
<p>When <code>rollback-output="no"</code> is specified, it is still
possible to ensure recovery of errors happens predictably by
evaluating the potentially-failing code in <a title=
"temporary output state" class="termref" href=
"#dt-temporary-output-state">temporary output state</a>: typically,
within an <a href=
"#element-variable"><code>xsl:variable</code></a>. In effect the
variable acts as an explicit buffer for temporary results, which is
only copied to the final output if evaluation succeeds.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>An application might wish to ensure that when a fatal error
occurs while reading an input stream, data written to persistent
storage up to the point of failure is available after the
transformation terminates. Setting
<code>rollback-output="no"</code> does not guarantee this, but a
processor might choose to interpret this as the intent.</p>
</div>
<p>Changing the attribute to <code>rollback-output="yes"</code>
makes the stylesheet more robust and able to handle error
conditions predictably, but the cost may be substantial; for
example it may be necessary to buffer the whole of the result
document in memory.</p>
</div>
<div class="div3">
<h4><a name="try-catch-examples" id="try-catch-examples"></a>8.3.2
<a href="#try-catch-examples" style=
"text-decoration: none">Try/Catch Examples</a></h4>
<div class="example">
<div class="exampleHeader"><a name="d7e23423" id=
"d7e23423"></a>Example: Catching a Divide-by-Zero Error</div>
<p>The following example divides an employee's salary by the number
of years they have served, catching the divide-by-zero error if the
latter is zero.</p>
<div class="exampleInner">
<pre>
&lt;xsl:try select="salary div length-of-service"&gt;
  &lt;xsl:catch errors="err:FOA0001" select="()"/&gt;
&lt;/xsl:try&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e23430" id=
"d7e23430"></a>Example: Catching an Error during Result-tree
Validation</div>
<p>The following example generates a result tree and performs
schema validation, outputting a warning message and serializing the
invalid tree if validation fails.</p>
<div class="exampleInner">
<pre>
&lt;xsl:result-document href="out.xml"&gt;
  &lt;xsl:variable name="result"&gt;
    &lt;xsl:call-template name="construct-output"/&gt;
  &lt;/xsl:variable&gt;
  &lt;xsl:try&gt;
    &lt;xsl:copy-of select="$result" validation="strict"/&gt;
    &lt;xsl:catch&gt;
      &lt;xsl:message&gt;Warning: validation of result document failed:
          Error code: &lt;xsl:value-of select="$err:code"/&gt;
          Reason: &lt;xsl:value-of select="$err:description"/&gt;
      &lt;/xsl:message&gt;
      &lt;xsl:sequence select="$result"/&gt;
    &lt;/xsl:catch&gt;
  &lt;/xsl:try&gt;
&lt;/xsl:result-document&gt;
</pre></div>
<p>The reason that the result tree is constructed in a variable in
this example is so that the unvalidated tree is available to be
used within the <a href="#element-catch"><code>xsl:catch</code></a>
element. An alternative approach would be to repeat the logic for
constructing the tree:</p>
<div class="exampleInner">
<pre>
&lt;xsl:try&gt;
  &lt;xsl:result-document href="out.xml" validation="strict"&gt;  
    &lt;xsl:call-template name="construct-output"/&gt;
  &lt;/xsl:result-document&gt;
  &lt;xsl:catch&gt;
    &lt;xsl:message&gt;Warning: validation of result document failed:
          Error code: &lt;xsl:value-of select="$err:code"/&gt;
          Reason: &lt;xsl:value-of select="$err:description"/&gt;
    &lt;/xsl:message&gt;
    &lt;xsl:call-template name="construct-output"/&gt;
  &lt;/xsl:catch&gt;
  &lt;/xsl:try&gt;
</pre></div>
</div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="variables-and-parameters" id=
"variables-and-parameters"></a>9 <a href=
"#variables-and-parameters" style="text-decoration: none">Variables
and Parameters</a></h2>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-variable-binding-element" id="dt-variable-binding-element"
title="variable-binding element"></a>The two elements <a href=
"#element-variable"><code>xsl:variable</code></a> and <a href=
"#element-param"><code>xsl:param</code></a> are referred to as
<b>variable-binding elements</b> <span class=
"definition">]</span>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-variable" id="dt-variable" title="variable"></a>The <a href=
"#element-variable"><code>xsl:variable</code></a> element declares
a <b>variable</b>, which may be a <a title="global variable" class=
"termref" href="#dt-global-variable">global variable</a> or a
<a title="local variable" class="termref" href=
"#dt-local-variable">local variable</a>.<span class=
"definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-parameter" id="dt-parameter" title="parameter"></a>The <a href=
"#element-param"><code>xsl:param</code></a> element declares a
<b>parameter</b>, which may be a <a title="stylesheet parameter"
class="termref" href="#dt-stylesheet-parameter">stylesheet
parameter</a>, a <a title="template parameter" class="termref"
href="#dt-template-parameter">template parameter</a>, a <a title=
"function parameter" class="termref" href=
"#dt-function-parameter">function parameter</a><span>, or an
<a href="#element-iterate"><code>xsl:iterate</code></a>
parameter</span>. A parameter is a <a title="variable" class=
"termref" href="#dt-variable">variable</a> with the additional
property that its value can be set by the caller.<span class=
"definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-value" id="dt-value" title="value"></a>A variable is a binding
between a name and a value. The <b>value</b> of a variable is any
sequence (of nodes, atomic values, <span>and/or function
items</span>), as defined in <a href="#xpath-datamodel-30">[Data
Model]</a>.<span class="definition">]</span></p>
<div class="div2">
<h3><a name="variables" id="variables"></a>9.1 <a href="#variables"
style="text-decoration: none">Variables</a></h3>
<p class="element-syntax"><a name="element-variable" id=
"element-variable"></a><code>&lt;!-- Category: declaration
--&gt;<br />
&lt;!-- Category: instruction --&gt;<br />
&lt;xsl:variable<br />
&#160;&#160;<b>name</b> = <var>eqname</var><br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;as? = <var>sequence-type</var><br />
&#160;&#160;static? = <var>boolean</var><br />
&#160;&#160;visibility? = "public" | "private" | "final" |
"abstract"&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:variable&gt;</code></p>
<p>The <a href="#element-variable"><code>xsl:variable</code></a>
element has a <span class="verb">required</span> <code>name</code>
attribute, which specifies the name of the variable. The value of
the <code>name</code> attribute is an <span><a title="EQName"
class="termref" href="#dt-eqname">EQName</a></span>, which is
expanded as described in <a href="#qname"><i>5.1 Qualified
Names</i></a>.</p>
<p>The <a href="#element-variable"><code>xsl:variable</code></a>
element has an optional <code>as</code> attribute, which specifies
the <a title="required type" class="termref" href=
"#dt-required-type">required type</a> of the variable. The value of
the <code>as</code> attribute is a <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-SequenceType">SequenceType</a><sup><small>XP30</small></sup>,
as defined in <a href="#xpath-30">[XPath 3.0]</a>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-supplied-value" id="dt-supplied-value" title=
"supplied value"></a>The value of the variable is computed using
the <a title="expression" class="termref" href=
"#dt-expression">expression</a> given in the <code>select</code>
attribute or the contained <a title="sequence constructor" class=
"termref" href="#dt-sequence-constructor">sequence constructor</a>,
as described in <a href="#variable-values"><i>9.3 Values of
Variables and Parameters</i></a>. This value is referred to as the
<b>supplied value</b> of the variable.<span class=
"definition">]</span> If the <a href=
"#element-variable"><code>xsl:variable</code></a> element has a
<code>select</code> attribute, then the sequence constructor
<span class="verb">must</span> be empty.</p>
<p>If the <code>as</code> attribute is specified, then the
<a title="supplied value" class="termref" href=
"#dt-supplied-value">supplied value</a> of the variable is
converted to the required type, using the <a title=
"function conversion rules" class="termref" href=
"#dt-function-conversion-rules">function conversion rules</a>.</p>
<p><a name="err-XTTE0570" id="err-XTTE0570"><span class=
"error">[ERR XTTE0570]</span></a> It is a <a title="type error"
class="termref" href="#dt-type-error">type error</a> if the
<a title="supplied value" class="termref" href=
"#dt-supplied-value">supplied value</a> of a variable cannot be
converted to the required type.</p>
<p>If the <code>as</code> attribute is omitted, the <a title=
"supplied value" class="termref" href="#dt-supplied-value">supplied
value</a> of the variable is used directly, and no conversion takes
place.</p>
<p>For the effect of the <code>static</code> attribute, see
<a href="#static-params"><i>9.6 Static Variables and
Parameters</i></a>.</p>
<p>The <code>visibility</code> attribute <span class="verb">must
not</span> be specified for a local variable: that is, it is
allowed only when the parent element is
<code>xsl:stylesheet</code>, <code>xsl:transform</code>, or
<code>xsl:override</code>.</p>
<p>If the <code>visibility</code> attribute is present with the
value <code>abstract</code> then the <code>select</code> attribute
<span class="verb">must</span> be absent and the contained
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> <span class=
"verb">must</span> be empty. In this situation there is no
<a title="supplied value" class="termref" href=
"#dt-supplied-value">supplied value</a>, and therefore the
constraint that the supplied value is consistent with the required
type does not apply.</p>
</div>
<div class="div2">
<h3><a name="parameters" id="parameters"></a>9.2 <a href=
"#parameters" style="text-decoration: none">Parameters</a></h3>
<p class="element-syntax"><a name="element-param" id=
"element-param"></a><code>&lt;!-- Category: declaration
--&gt;<br />
&lt;xsl:param<br />
&#160;&#160;<b>name</b> = <var>eqname</var><br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;as? = <var>sequence-type</var><br />
&#160;&#160;required? = <var>boolean</var><br />
&#160;&#160;tunnel? = <var>boolean</var><br />
&#160;&#160;static? = <var>boolean</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:param&gt;</code></p>
<p>The <a href="#element-param"><code>xsl:param</code></a> element
may be used:</p>
<ul>
<li>
<p>As a child of <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a>, to define a
parameter to the transformation. In this case all attributes except
<code>tunnel</code> are permitted. <a title="stylesheet parameter"
class="termref" href="#dt-stylesheet-parameter">Stylesheet
parameters</a> are set by the calling application: see <a href=
"#priming-stylesheet"><i>2.3.2 Priming a Stylesheet</i></a>.</p>
</li>
<li>
<p>As a child of <a href=
"#element-template"><code>xsl:template</code></a> to define a
parameter to a template, which may be supplied when the template is
invoked using <a href=
"#element-call-template"><code>xsl:call-template</code></a>,
<a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href="#element-apply-imports"><code>xsl:apply-imports</code></a>
or <a href="#element-next-match"><code>xsl:next-match</code></a>.
In this case the permitted attributes are <code>name</code>,
<code>select</code>, <code>as</code>, <code>required</code>, and
<code>tunnel</code>. <a title="template parameter" class="termref"
href="#dt-template-parameter">Template parameters</a> are set by
means of an <a href=
"#element-with-param"><code>xsl:with-param</code></a> child element
of the invoking instruction, as described in <a href=
"#with-param"><i>9.10 Setting Parameter Values</i></a>.</p>
</li>
<li>
<p>As a child of <a href=
"#element-function"><code>xsl:function</code></a> to define a
parameter to a stylesheet function, which may be supplied when the
function is called from an XPath <a title="expression" class=
"termref" href="#dt-expression">expression</a>. In this case the
permitted attributes are <code>name</code> and <code>as</code>.
<a title="function parameter" class="termref" href=
"#dt-function-parameter">Function parameters</a> are set
positionally by means of the argument list in an XPath function
call.</p>
</li>
<li>
<p>As a child of <a href=
"#element-iterate"><code>xsl:iterate</code></a> to define a
parameter that can vary from one iteration to the next. In this
case the permitted attributes are <code>name</code>,
<code>as</code>, and <code>select</code> (of which
<code>name</code> and <code>select</code> are mandatory). Iteration
parameters always take their default values for the first
iteration, and in subsequent iterations are set using an <a href=
"#element-with-param"><code>xsl:with-param</code></a> child of the
<a href=
"#element-next-iteration"><code>xsl:next-iteration</code></a>
instruction.</p>
</li>
</ul>
<p>The <a href="#element-param"><code>xsl:param</code></a> element
has a <span class="verb">required</span> <code>name</code>
attribute, which specifies the name of the parameter. The value of
the <code>name</code> attribute is an <span><a title="EQName"
class="termref" href="#dt-eqname">EQName</a></span>, which is
expanded as described in <a href="#qname"><i>5.1 Qualified
Names</i></a>.</p>
<p><a name="err-XTSE0580" id="err-XTSE0580"><span class=
"error">[ERR XTSE0580]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
values of the <code>name</code> attribute of two <span>sibling
<a href="#element-param"><code>xsl:param</code></a> elements
represent the same <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a></span>.</p>
<p>If the <a href="#element-param"><code>xsl:param</code></a>
element has a <code>select</code> attribute, then the sequence
constructor <span class="verb">must</span> be empty.</p>
<p>diff="chg" at="R-bug26740"&gt;The <code>static</code> attribute
is used only on <a title="stylesheet parameter" class="termref"
href="#dt-stylesheet-parameter">stylesheet parameters</a>, and is
explained in <a href="#global-variables"><i>9.5 Global Variables
and Parameters</i></a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Local variables may <a title="shadows" class="termref" href=
"#dt-shadows">shadow</a> template parameters and function
parameters: see <a href="#scope-of-variables"><i>9.9 Scope of
Variables</i></a>.</p>
</div>
<p>The optional <code>tunnel</code> attribute may be used to
indicate that a parameter is a <a title="tunnel parameter" class=
"termref" href="#dt-tunnel-parameter">tunnel parameter</a>. The
default is <code>no</code>; the value <code>yes</code> may be
specified only for <a title="template parameter" class="termref"
href="#dt-template-parameter">template parameters</a>. Tunnel
parameters are described in <a href="#tunnel-params"><i>10.1.3
Tunnel Parameters</i></a></p>
<div class="div3">
<h4><a name="parameter-type" id="parameter-type"></a>9.2.1 <a href=
"#parameter-type" style="text-decoration: none">The Required Type
of a Parameter</a></h4>
<p>The <a href="#element-param"><code>xsl:param</code></a> element
has an optional <code>as</code> attribute, which specifies the
<a title="required type" class="termref" href=
"#dt-required-type">required type</a> of the parameter. The value
of the <code>as</code> attribute is a <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-SequenceType">SequenceType</a><sup><small>XP30</small></sup>,
as defined in <a href="#xpath-30">[XPath 3.0]</a>. If the
<code>as</code> attribute is omitted, then the required type is
<code>item()*</code>.</p>
<p>The <a title="supplied value" class="termref" href=
"#dt-supplied-value">supplied value</a> of the parameter is the
value supplied by the caller. If no value was supplied by the
caller, and if the parameter is not mandatory, then the default
value is used as the supplied value as described in <a href=
"#default-values-of-parameters"><i>9.2.2 Default Values of
Parameters</i></a>.</p>
<p>The <a title="supplied value" class="termref" href=
"#dt-supplied-value">supplied value</a> of the parameter is
converted to the <a title="required type" class="termref" href=
"#dt-required-type">required type</a> using the <a title=
"function conversion rules" class="termref" href=
"#dt-function-conversion-rules">function conversion rules</a>.</p>
<p><a name="err-XTTE0590" id="err-XTTE0590"><span class=
"error">[ERR XTTE0590]</span></a> It is a <a title="type error"
class="termref" href="#dt-type-error">type error</a> if the
conversion of the <a title="supplied value" class="termref" href=
"#dt-supplied-value">supplied value</a> of a parameter to its
<a title="required type" class="termref" href=
"#dt-required-type">required type</a> fails.</p>
</div>
<div class="div3">
<h4><a name="default-values-of-parameters" id=
"default-values-of-parameters"></a>9.2.2 <a href=
"#default-values-of-parameters" style=
"text-decoration: none">Default Values of Parameters</a></h4>
<p>The optional <code>required</code> attribute may be used to
indicate that a parameter is mandatory. This attribute may be
specified for <a title="stylesheet parameter" class="termref" href=
"#dt-stylesheet-parameter">stylesheet parameters</a> and for
<a title="template parameter" class="termref" href=
"#dt-template-parameter">template parameters</a>; it <span class=
"verb">must not</span> be specified for <a title=
"function parameter" class="termref" href=
"#dt-function-parameter">function parameters</a>, which are always
mandatory, <span>or for parameters to <a href=
"#element-iterate"><code>xsl:iterate</code></a>, which are always
initialized to a default value</span>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-explicitly-mandatory" id="dt-explicitly-mandatory" title=
"explicitly mandatory"></a>A parameter is <b>explicitly
mandatory</b> if it is a <a title="function parameter" class=
"termref" href="#dt-function-parameter">function parameter</a>, or
if the <code>required</code> attribute is present and has the value
<code>yes</code>.<span class="definition">]</span> If a parameter
is explicitly mandatory, then the <a href=
"#element-param"><code>xsl:param</code></a> element <span class=
"verb">must</span> be empty and <span class="verb">must not</span>
have a <code>select</code> attribute.</p>
<p>If a parameter is not <a title="explicitly mandatory" class=
"termref" href="#dt-explicitly-mandatory">explicitly mandatory</a>,
then it may have a default value. The default value is obtained by
evaluating the <a title="expression" class="termref" href=
"#dt-expression">expression</a> given in the <code>select</code>
attribute or the contained <a title="sequence constructor" class=
"termref" href="#dt-sequence-constructor">sequence constructor</a>,
as described in <a href="#variable-values"><i>9.3 Values of
Variables and Parameters</i></a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This specification does not dictate whether and when the default
value of a parameter is evaluated. For example, if the default is
specified as <code>&lt;xsl:param
name="p"&gt;&lt;foo/&gt;&lt;/xsl:param&gt;</code>, then it is not
specified whether a distinct <code>foo</code> element node will be
created on each invocation of the template, or whether the same
<code>foo</code> element node will be used for each invocation.
However, it is permissible for the default value to depend on the
values of other parameters, or on the evaluation context, in which
case the default must effectively be evaluated on each
invocation.</p>
</div>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-explicit-default" id="dt-explicit-default" title=
"explicit default"></a>An <b>explicit default</b> for a parameter
is indicated by the presence of either a <code>select</code>
attribute or a non-empty sequence constructor.<span class=
"definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-implicit-default" id="dt-implicit-default" title=
"implicit default"></a>If a parameter that is not <a title=
"explicitly mandatory" class="termref" href=
"#dt-explicitly-mandatory">explicitly mandatory</a> has no
<a title="explicit default" class="termref" href=
"#dt-explicit-default">explicit default</a> value, then it has an
<b>implicit default</b> value, which is the empty sequence if there
is an <code>as</code> attribute, or a zero-length string if
not.<span class="definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-implicitly-mandatory" id="dt-implicitly-mandatory" title=
"implicitly mandatory"></a>If a parameter has an <a title=
"implicit default" class="termref" href=
"#dt-implicit-default">implicit default</a> value which cannot be
converted to the <a title="required type" class="termref" href=
"#dt-required-type">required type</a> (that is, if it has an
<code>as</code> attribute which does not permit the empty
sequence), then the parameter is <b>implicitly
mandatory</b>.<span class="definition">]</span></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The effect of these rules is that specifying <code>&lt;xsl:param
name="p" as="xs:date" select="2"/&gt;</code> is an error, but if
the default value of the parameter is never used, then the
processor has discretion whether or not to report the error. By
contrast, <code>&lt;xsl:param name="p" as="xs:date"/&gt;</code> is
treated as if <code>required="yes"</code> had been specified: the
empty sequence is not a valid instance of <code>xs:date</code>, so
in effect there is no default value and the parameter is therefore
treated as being mandatory.</p>
</div>
<p>Various errors can arise with regard to mandatory parameters
when no value is supplied. In the rules below, <b>non-tunnel</b>
means: not having a <code>tunnel</code> attribute with the value
<code>yes</code>.</p>
<ul>
<li>
<p><a name="err-XTSE3520" id="err-XTSE3520"><span class=
"error">[ERR XTSE3520]</span></a> It is a static error if a
parameter to <a href=
"#element-iterate"><code>xsl:iterate</code></a> is <a title=
"implicitly mandatory" class="termref" href=
"#dt-implicitly-mandatory">implicitly mandatory</a>.</p>
</li>
<li>
<p><a name="err-XTSE0690" id="err-XTSE0690"><span class=
"error">[ERR XTSE0690]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if a
<a title="package" class="termref" href="#dt-package">package</a>
contains both (a) a named template named <var>T</var> that is not
overridden by another named template of higher import precedence
and that has an <a title="explicitly mandatory" class="termref"
href="#dt-explicitly-mandatory">explicitly mandatory</a> non-tunnel
parameter named <var>P</var>, and (b) an <a href=
"#element-call-template"><code>xsl:call-template</code></a>
instruction whose <code>name</code> attribute equals <var>T</var>
and that has no non-tunnel <a href=
"#element-with-param"><code>xsl:with-param</code></a> child element
whose <code>name</code> attribute equals <var>P</var>. (All names
are compared as QNames.)</p>
</li>
<li>
<p><a name="err-XTDE0700" id="err-XTDE0700"><span class=
"error">[ERR XTDE0700]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if a
template that has an <a title="explicitly mandatory" class=
"termref" href="#dt-explicitly-mandatory">explicitly mandatory</a>
or <a title="implicitly mandatory" class="termref" href=
"#dt-implicitly-mandatory">implicitly mandatory</a> parameter is
invoked without supplying a value for that parameter.</p>
<p>This includes the following cases:</p>
<ul>
<li>
<p>The template is invoked using <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a>, or
<a href="#element-next-match"><code>xsl:next-match</code></a> and
there is no <a href=
"#element-with-param"><code>xsl:with-param</code></a> child whose
<code>name</code> and <code>tunnel</code> attributes match the
corresponding attributes of the mandatory parameter.</p>
</li>
<li>
<p>The mandatory parameter is a tunnel parameter, and the template
is invoked using <a href=
"#element-call-template"><code>xsl:call-template</code></a>, and
there is no <a href=
"#element-with-param"><code>xsl:with-param</code></a> child whose
<code>name</code> and <code>tunnel</code> attributes match the
corresponding attributes of the mandatory parameter.</p>
</li>
<li>
<p>The template is invoked as the entry point to the
transformation, either by invoking an initial mode (<a href=
"#invoking-initial-mode"><i>2.3.3 Apply-Templates
Invocation</i></a>) or by invoking an initial template (<a href=
"#invoking-initial-template"><i>2.3.4 Call-Template
Invocation</i></a>) and no value is supplied for the mandatory
parameter by the calling application.</p>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a name="variable-values" id="variable-values"></a>9.3 <a href=
"#variable-values" style="text-decoration: none">Values of
Variables and Parameters</a></h3>
<p>A <a title="variable-binding element" class="termref" href=
"#dt-variable-binding-element">variable-binding element</a> may
specify the <a title="supplied value" class="termref" href=
"#dt-supplied-value">supplied value</a> of a <a title="variable"
class="termref" href="#dt-variable">variable</a> <span>or the
default value of a</span> <a title="parameter" class="termref"
href="#dt-parameter">parameter</a> in four different ways.</p>
<ul>
<li>
<p>If the <a title="variable-binding element" class="termref" href=
"#dt-variable-binding-element">variable-binding element</a> has a
<code>select</code> attribute, then the value of the attribute
<span class="verb">must</span> be an <a title="expression" class=
"termref" href="#dt-expression">expression</a> and the <a title=
"supplied value" class="termref" href="#dt-supplied-value">supplied
value</a> of the variable is the value that results from evaluating
the expression. In this case, the content of the variable-binding
element <span class="verb">must</span> be empty.</p>
</li>
<li>
<p>If the <a title="variable-binding element" class="termref" href=
"#dt-variable-binding-element">variable-binding element</a> has
empty content and has neither a <code>select</code> attribute nor
an <code>as</code> attribute, then the <a title="supplied value"
class="termref" href="#dt-supplied-value">supplied value</a> of the
variable is a zero-length string. Thus</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="x"/&gt;
</pre></div>
<p>is equivalent to</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="x" select="''"/&gt;
</pre></div>
</li>
<li>
<p>If a <a title="variable-binding element" class="termref" href=
"#dt-variable-binding-element">variable-binding element</a> has no
<code>select</code> attribute and has non-empty content (that is,
the variable-binding element has one or more child nodes), and has
no <code>as</code> attribute, then the content of the
variable-binding element specifies the <a title="supplied value"
class="termref" href="#dt-supplied-value">supplied value</a>. The
content of the variable-binding element is a <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>; a new document
is constructed with a document node having as its children the
sequence of nodes that results from evaluating the sequence
constructor and then applying the rules given in <a href=
"#constructing-complex-content"><i>5.8.1 Constructing Complex
Content</i></a>. The value of the variable is then a singleton
sequence containing this document node. For further information,
see <a href="#temporary-trees"><i>9.4 Creating Implicit Document
Nodes</i></a>.</p>
</li>
<li>
<p>If a <a title="variable-binding element" class="termref" href=
"#dt-variable-binding-element">variable-binding element</a> has an
<code>as</code> attribute but no <code>select</code> attribute,
then the <a title="supplied value" class="termref" href=
"#dt-supplied-value">supplied value</a> is the sequence that
results from evaluating the (possibly empty) <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> contained
within the variable-binding element (see <a href=
"#sequence-constructors"><i>5.8 Sequence Constructors</i></a>).</p>
</li>
</ul>
<p>These combinations are summarized in the table below.</p>
<table border="1" cellpadding="5" summary=
"effect of different attribute combinations on xsl:variable" width=
"100%">
<col width="12%" span="1" />
<col width="12%" span="1" />
<col width="12%" span="1" />
<col span="1" />
<thead>
<tr>
<th align="left" colspan="1" valign="top">select attribute</th>
<th align="left" colspan="1" valign="top">as attribute</th>
<th align="left" colspan="1" valign="top">content</th>
<th align="left" colspan="1" valign="top">Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td valign="top" align="left">present</td>
<td valign="top" align="left">absent</td>
<td valign="top" align="left">empty</td>
<td valign="top" align="left">Value is obtained by evaluating the
<code>select</code> attribute</td>
</tr>
<tr>
<td valign="top" align="left">present</td>
<td valign="top" align="left">present</td>
<td valign="top" align="left">empty</td>
<td valign="top" align="left">Value is obtained by evaluating the
<code>select</code> attribute, adjusted to the type required by the
<code>as</code> attribute</td>
</tr>
<tr>
<td valign="top" align="left">present</td>
<td valign="top" align="left">absent</td>
<td valign="top" align="left">present</td>
<td valign="top" align="left">Static error</td>
</tr>
<tr>
<td valign="top" align="left">present</td>
<td valign="top" align="left">present</td>
<td valign="top" align="left">present</td>
<td valign="top" align="left">Static error</td>
</tr>
<tr>
<td valign="top" align="left">absent</td>
<td valign="top" align="left">absent</td>
<td valign="top" align="left">empty</td>
<td valign="top" align="left">Value is a zero-length string</td>
</tr>
<tr>
<td valign="top" align="left">absent</td>
<td valign="top" align="left">present</td>
<td valign="top" align="left">empty</td>
<td valign="top" align="left">Value is an empty sequence, provided
the <code>as</code> attribute permits an empty sequence</td>
</tr>
<tr>
<td valign="top" align="left">absent</td>
<td valign="top" align="left">absent</td>
<td valign="top" align="left">present</td>
<td valign="top" align="left">Value is a document node whose
content is obtained by evaluating the sequence constructor</td>
</tr>
<tr>
<td valign="top" align="left">absent</td>
<td valign="top" align="left">present</td>
<td valign="top" align="left">present</td>
<td valign="top" align="left">Value is obtained by evaluating the
sequence constructor, adjusted to the type required by the
<code>as</code> attribute</td>
</tr>
</tbody>
</table>
<p><a name="err-XTSE0620" id="err-XTSE0620"><span class=
"error">[ERR XTSE0620]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if a
<a title="variable-binding element" class="termref" href=
"#dt-variable-binding-element">variable-binding element</a> has a
<code>select</code> attribute and has non-empty content.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e24464" id=
"d7e24464"></a>Example: Values of Variables</div>
<p>The value of the following variable is the sequence of integers
(1, 2, 3):</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="i" as="xs:integer*" select="1 to 3"/&gt;
</pre></div>
<p>The value of the following variable is an integer, assuming that
the attribute <code>@size</code> exists, and is annotated either as
an integer, or as <code>xs:untypedAtomic</code>:</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="i" as="xs:integer" select="@size"/&gt;
</pre></div>
<p>The value of the following variable is a zero-length string:</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="z"/&gt;
</pre></div>
<p>The value of the following variable is a document node
containing an empty element as a child:</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="doc"&gt;&lt;c/&gt;&lt;/xsl:variable&gt;
</pre></div>
<p>The value of the following variable is a sequence of integers
(2, 4, 6):</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="seq" as="xs:integer*"&gt;
  &lt;xsl:for-each select="1 to 3"&gt;
    &lt;xsl:sequence select=".*2"/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:variable&gt;
</pre></div>
<p>The value of the following variable is a sequence of parentless
attribute nodes:</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="attset" as="attribute()+"&gt;
  &lt;xsl:attribute name="x"&gt;2&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="y"&gt;3&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="z"&gt;4&lt;/xsl:attribute&gt;    
&lt;/xsl:variable&gt;
</pre></div>
<p>The value of the following variable is an empty sequence:</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="empty" as="empty-sequence()"/&gt;
</pre></div>
</div>
<p>The actual value of the variable depends on the <a title=
"supplied value" class="termref" href="#dt-supplied-value">supplied
value</a>, as described above, and the required type, which is
determined by the value of the <code>as</code> attribute.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e24510" id=
"d7e24510"></a>Example: Pitfalls with Numeric Predicates</div>
<p>When a variable is used to select nodes by position, be careful
not to do:</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="n"&gt;2&lt;/xsl:variable&gt;
...
&lt;xsl:value-of select="td[$n]"/&gt;
</pre></div>
<p>This will output the values of all the <code>td</code> elements,
space-separated (or <span>with <a title="XSLT 1.0 behavior" class=
"termref" href="#dt-xslt-10-behavior">XSLT 1.0 behavior</a></span>,
the value of the first <code>td</code> element), because the
variable <code>n</code> will be bound to a node, not a number.
Instead, do one of the following:</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="n" select="2"/&gt;
...
&lt;xsl:value-of select="td[$n]"/&gt;
</pre></div>
<p>or</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="n"&gt;2&lt;/xsl:variable&gt;
...
&lt;xsl:value-of select="td[position()=$n]"/&gt;
</pre></div>
<p>or</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="n" as="xs:integer"&gt;2&lt;/xsl:variable&gt;
...
&lt;xsl:value-of select="td[$n]"/&gt;
</pre></div>
</div>
</div>
<div class="div2">
<h3><a name="temporary-trees" id="temporary-trees"></a>9.4 <a href=
"#temporary-trees" style="text-decoration: none">Creating Implicit
Document Nodes</a></h3>
<p>A document node is created implicitly when evaluating an
<a href="#element-variable"><code>xsl:variable</code></a>, <a href=
"#element-param"><code>xsl:param</code></a>, or <a href=
"#element-with-param"><code>xsl:with-param</code></a> element that
has non-empty content and that has no <code>as</code> attribute.
The value of the <a title="variable" class="termref" href=
"#dt-variable">variable</a> is a single node, the document node of
a <a title="temporary tree" class="termref" href=
"#dt-temporary-tree">temporary tree</a>. The content of the
document node is formed from the result of evaluating the <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> contained
within the variable-binding element, as described in <a href=
"#constructing-complex-content"><i>5.8.1 Constructing Complex
Content</i></a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The construct:</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="tree"&gt;
  &lt;a/&gt;
&lt;/xsl:variable&gt;
</pre></div>
<p>can be regarded as a shorthand for:</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="tree" as="document-node()"&gt;
  &lt;xsl:document validation="preserve"&gt;
    &lt;a/&gt;
  &lt;/xsl:document&gt;  
&lt;/xsl:variable&gt;
</pre></div>
</div>
<p>The base URI of the document node is taken from the base URI of
the variable binding element in the stylesheet. (See <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dm-base-uri">Section 5.2
base-uri Accessor</a> <sup><small>DM30</small></sup> in <a href=
"#xpath-datamodel-30">[Data Model]</a>)</p>
<p>No document-level validation takes place (which means, for
example, that there is no checking that ID values are unique).
However, <a title="type annotation" class="termref" href=
"#dt-type-annotation">type annotations</a> on nodes within the new
tree are copied unchanged.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The base URI of other nodes in the tree is determined by the
rules for constructing complex content. The effect of these rules
is that the base URI of a node in the temporary tree is determined
as if all the nodes in the temporary tree came from a single entity
whose URI was the base URI of the <a title=
"variable-binding element" class="termref" href=
"#dt-variable-binding-element">variable-binding element</a>. Thus,
the base URI of the document node will be equal to the base URI of
the variable-binding element, while an <code>xml:base</code>
attribute within the temporary tree will change the base URI for
its parent element and that element's descendants, just as it would
within a document constructed by parsing.</p>
</div>
<p>The <code>document-uri</code> and <code>unparsed-entities</code>
properties of the new document node are set to empty.</p>
<p>A <a title="temporary tree" class="termref" href=
"#dt-temporary-tree">temporary tree</a> is available for processing
in exactly the same way as any source document. For example, its
nodes are accessible using path expressions, and they can be
processed using instructions such as <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a> and
<a href="#element-for-each"><code>xsl:for-each</code></a>. Also,
the <a href="#func-key"><code>key</code></a> and <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-id"><code>id</code></a><sup><small>FO30</small></sup>
functions can be used to find nodes within a temporary tree,
<span>by supplying the document node at the root of the tree as an
argument to the function or by making it the context
node</span>.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e24630" id=
"d7e24630"></a>Example: Two-Phase Transformation</div>
<p>For example, the following stylesheet uses a temporary tree as
the intermediate result of a two-phase transformation, using
different <a title="mode" class="termref" href="#dt-mode">modes</a>
for the two phases (see <a href="#modes"><i>6.6 Modes</i></a>).
Typically, the template rules in module <code>phase1.xsl</code>
will be declared with <code>mode="phase1"</code>, while those in
module <code>phase2.xsl</code> will be declared with
<code>mode="phase2"</code>:</p>
<div class="exampleInner">
<pre>
&lt;xsl:stylesheet
  version="3.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:import href="phase1.xsl"/&gt;
&lt;xsl:import href="phase2.xsl"/&gt;

&lt;xsl:variable name="intermediate"&gt;
  &lt;xsl:apply-templates select="/" mode="phase1"/&gt;
&lt;/xsl:variable&gt;

&lt;xsl:template match="/"&gt;
  &lt;xsl:apply-templates select="$intermediate" mode="phase2"/&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</pre></div>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The algorithm for matching nodes against template rules is
exactly the same regardless which tree the nodes come from. If
different template rules are to be used when processing different
trees, then unless nodes from different trees can be distinguished
by means of <a title="pattern" class="termref" href=
"#dt-pattern">patterns</a>, it is a good idea to use <a title=
"mode" class="termref" href="#dt-mode">modes</a> to ensure that
each tree is processed using the appropriate set of template
rules.</p>
</div>
</div>
<div class="div2">
<h3><a name="global-variables" id="global-variables"></a>9.5
<a href="#global-variables" style="text-decoration: none">Global
Variables and Parameters</a></h3>
<p>Both <a href="#element-variable"><code>xsl:variable</code></a>
and <a href="#element-param"><code>xsl:param</code></a> are allowed
as <a title="declaration" class="termref" href=
"#dt-declaration">declaration</a> elements: that is, they may
appear as children of the <span><a href=
"#element-package"><code>xsl:package</code></a> or</span> <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> element.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-global-variable" id="dt-global-variable" title=
"global variable"></a>A top-level <a title=
"variable-binding element" class="termref" href=
"#dt-variable-binding-element">variable-binding element</a>
declares a <b>global variable</b> that is visible everywhere
(except <span>within its own declaration, and</span> where it is
<a title="shadows" class="termref" href="#dt-shadows">shadowed</a>
by another binding).<span class="definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-stylesheet-parameter" id="dt-stylesheet-parameter" title=
"stylesheet parameter"></a>A top-level <a href=
"#element-param"><code>xsl:param</code></a> element declares a
<b>stylesheet parameter</b>. A stylesheet parameter is a global
variable with the additional property that its value can be
supplied by the caller when a transformation is
initiated.<span class="definition">]</span> As described in
<a href="#parameters"><i>9.2 Parameters</i></a>, a stylesheet
parameter may be declared as being mandatory, or may have a default
value specified for use when no value is supplied by the caller.
The mechanism by which the caller supplies a value for a stylesheet
parameter is <a title="implementation-defined" class="termref"
href="#dt-implementation-defined">implementation-defined</a>. An
XSLT <a title="processor" class="termref" href=
"#dt-processor">processor</a> <span class="verb">must</span>
provide such a mechanism.</p>
<p>It is an error if no value is supplied for a mandatory
stylesheet parameter <span class="error">[see <a href=
"#err-XTDE0050">ERR XTDE0050</a>]</span>.</p>
<p>If a <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> contains more than one binding for
a global variable of a particular name, then the binding with the
highest <a title="import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a> is used.</p>
<p><a name="err-XTSE0630" id="err-XTSE0630"><span class=
"error">[ERR XTSE0630]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if a
<a title="package" class="termref" href="#dt-package">package</a>
contains more than one <span>non-hidden</span> binding of a global
variable with the same name and same <a title="import precedence"
class="termref" href="#dt-import-precedence">import precedence</a>,
unless it also contains another binding with the same name and
higher import precedence.</p>
<p>For a global variable or the default value of a stylesheet
parameter, the <a title="expression" class="termref" href=
"#dt-expression">expression</a> or <a title="sequence constructor"
class="termref" href="#dt-sequence-constructor">sequence
constructor</a> specifying the variable value is evaluated with a
<a title="singleton focus" class="termref" href=
"#dt-singleton-focus">singleton focus</a> as follows:</p>
<ul>
<li>
<p>If the declaration appears within the <a title=
"top-level package" class="termref" href=
"#dt-top-level-package">top-level package</a> (including within an
<a href="#element-override"><code>xsl:override</code></a> element
in the top-level package), then the focus is based on the
<span><a title="global context item" class="termref" href=
"#dt-global-context-item">global context item</a></span> if
supplied, or <a title="absent" class="termref" href=
"#dt-absent">absent</a> otherwise.</p>
</li>
<li>
<p>If the declaration appears within a <a title="library package"
class="termref" href="#dt-library-package">library package</a>,
then the focus is <a title="absent" class="termref" href=
"#dt-absent">absent</a>.</p>
</li>
</ul>
<p>An XPath error will be reported if the evaluation of a global
variable or parameter references the context item, context
position, or context size when the <a title="focus" class="termref"
href="#dt-focus">focus</a> is <a title="absent" class="termref"
href="#dt-absent">absent</a>. The values of other components of the
dynamic context are the initial values as defined in <a href=
"#xpath-dynamic-context"><i>5.4.3 Initializing the Dynamic
Context</i></a> and <a href="#additional-dynamic-context"><i>5.4.4
Additional Dynamic Context Components used by XSLT</i></a>.</p>
<p>The <a title="visibility" class="termref" href=
"#dt-visibility">visibility</a> of a <a title=
"stylesheet parameter" class="termref" href=
"#dt-stylesheet-parameter">stylesheet parameter</a> is always
(implicitly) <code>private</code> if the parameter is
<code>static</code>, or <code>public</code> if the parameter is
non-static.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This rule has the effect that after combining all the packages
making up a stylesheet, the non-static stylesheet parameters whose
values are required necessarily have distinct names, which
simplifies the design of APIs.</p>
</div>
<p>For the effect of the <code>static</code> attribute, see
<a href="#static-params"><i>9.6 Static Variables and
Parameters</i></a>.</p>
<p>The <code>visibility</code> attribute <span class="verb">must
not</span> be specified for a local variable: that is, it is
allowed only when the parent element is <code>xsl:package</code>,
<code>xsl:stylesheet</code>, <code>xsl:transform</code>, or
<code>xsl:override</code>.</p>
<p>If the <code>visibility</code> attribute is present with the
value <code>abstract</code> then the <code>select</code> attribute
<span class="verb">must</span> be absent and the contained
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> <span class=
"verb">must</span> be empty. In this situation there is no
<a title="supplied value" class="termref" href=
"#dt-supplied-value">supplied value</a>, and therefore the
constraint that the supplied value is consistent with the required
type does not apply.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e24874" id=
"d7e24874"></a>Example: A Stylesheet Parameter</div>
<p>The following example declares a global parameter
<code>para-font-size</code>, which is referenced in an <a title=
"attribute value template" class="termref" href=
"#dt-attribute-value-template">attribute value template</a>.</p>
<div class="exampleInner">
<pre>
&lt;xsl:param name="para-font-size" as="xs:string"&gt;12pt&lt;/xsl:param&gt;

&lt;xsl:template match="para"&gt;
 &lt;fo:block font-size="{$para-font-size}"&gt;
   &lt;xsl:apply-templates/&gt;
 &lt;/fo:block&gt;
&lt;/xsl:template&gt;
</pre></div>
<p>The implementation must provide a mechanism allowing the user to
supply a value for the parameter <code>para-font-size</code> when
invoking the stylesheet; the value <code>12pt</code> acts as a
default.</p>
</div>
</div>
<div class="div2">
<h3><a name="static-params" id="static-params"></a>9.6 <a href=
"#static-params" style="text-decoration: none">Static Variables and
Parameters</a></h3>
<p>Static variables and parameters are global variables and can be
used in the same way as other global variables. In addition, they
can be used in <code>[xsl:]use-when</code> expressions and in
shadow attributes.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-static-variable" id="dt-static-variable" title=
"static variable"></a>A <a title="top-level" class="termref" href=
"#dt-top-level">top-level</a> <a title="variable-binding element"
class="termref" href=
"#dt-variable-binding-element">variable-binding element</a> having
the attribute <code>static="yes"</code> declares a <b>static
variable</b>: that is, a <a title="global variable" class="termref"
href="#dt-global-variable">global variable</a> whose value is known
during static analysis of the stylesheet.<span class=
"definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-static-parameter" id="dt-static-parameter" title=
"static parameter"></a>A <a title="static variable" class="termref"
href="#dt-static-variable">static variable</a> declared using an
<a href="#element-param"><code>xsl:param</code></a> element is
referred to as a <b>static parameter</b>.<span class=
"definition">]</span></p>
<p>The <code>static</code> attribute <span class="verb">must
not</span> be present on an <a href=
"#element-variable"><code>xsl:variable</code></a> or <a href=
"#element-param"><code>xsl:param</code></a> element unless it is a
<a title="top-level" class="termref" href=
"#dt-top-level">top-level</a> element.</p>
<p>When the <code>static</code> attribute is present with the value
<code>yes</code>, the <code>visibility</code> attribute
<span class="verb">must not</span> have a value other than
<code>private</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This rule prevents static variables being overridden in another
package. Since the values of such variables may be used at compile
time (for example, during processing of <code>[xsl:]use-when</code>
expressions), the rule is necessary to ensure that packages can be
independently compiled.</p>
<p>It is possible to make the value of a static variable or
parameter available in a using package by binding a non-static
public variable to its value, for example:</p>
<div class="exampleInner">
<pre>
     &lt;xsl:param name="DEBUG" static="yes" select="true()"/&gt;
     &lt;xsl:variable name="tracing" static="no" public="yes" select="$DEBUG"/&gt;
     
                 
</pre></div>
</div>
<p>When the attribute <code>static="yes"</code> is specified, the
<a href="#element-variable"><code>xsl:variable</code></a> or
<a href="#element-param"><code>xsl:param</code></a> element
<span class="verb">must</span> have empty content. In the case of
<a href="#element-variable"><code>xsl:variable</code></a> the
<code>select</code> attribute must be present to define the value
of the variable.</p>
<p>If the <code>select</code> attribute is present, then it is
evaluated using the rules for <a title="static expression" class=
"termref" href="#dt-static-expression">static expressions</a>.</p>
<p>The rules for the scope of static variables, and the handling of
duplicate declarations, are similar to the rules for non-static
variables, but with additional constraints designed to disallow
forwards references. The reason for disallowing forwards references
is to ensure that <code>use-when</code> attributes can always be
evaluated as early as possible, and in particular to ensure that
the value of a <code>use-when</code> attribute never has circular
dependencies. The additional constraints are as follows:</p>
<ol class="enumar">
<li>
<p>The static context for evaluation of a <a title=
"static expression" class="termref" href=
"#dt-static-expression">static expression</a> only contains those
<a title="static variable" class="termref" href=
"#dt-static-variable">static variables</a> visible within the
containing package whose declarations occur prior to the element
containing the static expression in stylesheet tree order.
Stylesheet tree order is the order that results when all <a href=
"#element-import"><code>xsl:import</code></a> and <a href=
"#element-include"><code>xsl:include</code></a> declarations are
replaced by the declarations in the imported or included stylesheet
module. A static variable is not in scope within its own
declaration.</p>
</li>
<li>
<p>If two static variables declared within the same package have
the same name, the one that has higher <a title="import precedence"
class="termref" href="#dt-import-precedence">import precedence</a>
is used (it is a consequence of rules defined elsewhere that there
cannot be more than one declaration with highest import
precedence). However, if the declaration with higher import
precedence occurs after the one with lower import precedence in
stylesheet tree order, then the two declarations must be
consistent. For this purpose two declarations are consistent if (a)
they are either both <a href=
"#element-variable"><code>xsl:variable</code></a> elements, or both
<a href="#element-param"><code>xsl:param</code></a> elements, and
(b) if the variables are initialized (that is, if the elements are
<a href="#element-variable"><code>xsl:variable</code></a> elements,
or if they are <a href="#element-param"><code>xsl:param</code></a>
elements and no value for the parameter is externally supplied)
then the values of both variables must be <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-identical">identical</a><sup><small>FO30</small></sup>,
and must not contain function items.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This rule ensures that when a static variable reference is
encountered, the value of the most recently declared static
variable with that name can be used, knowing that this value cannot
be overridden by a subsequent declaration having higher import
precedence.</p>
</div>
<p><a name="err-XTSE3450" id="err-XTSE3450"><span class=
"error">[ERR XTSE3450]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if a
variable declared with <code>static="yes"</code> is inconsistent
with another static variable of the same name that is declared
earlier in stylesheet tree order and that has lower <a title=
"import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a>.</p>
</li>
</ol>
</div>
<div class="div2">
<h3><a name="static-expression" id="static-expression"></a>9.7
<a href="#static-expression" style="text-decoration: none">Static
Expressions</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-static-expression" id="dt-static-expression" title=
"static expression"></a>A <b>static expression</b> is an XPath
<a title="expression" class="termref" href=
"#dt-expression">expression</a> whose value must be computed during
static analysis of the stylesheet.<span class=
"definition">]</span></p>
<p>Static expressions appear in two contexts:</p>
<ul>
<li>
<p>In <code>[xsl:]use-when</code> attributes (see <a href=
"#conditional-inclusion"><i>3.14.1 Conditional Element
Inclusion</i></a>)</p>
</li>
<li>
<p>In the <code>select</code> attribute of <a title=
"static variable" class="termref" href="#dt-static-variable">static
variable</a> declarations (<a href=
"#element-variable"><code>xsl:variable</code></a> or <a href=
"#element-param"><code>xsl:param</code></a> with
<code>static="yes"</code>).</p>
</li>
</ul>
<p>There are no syntactic constraints on the XPath expression that
can be used as a <a title="static expression" class="termref" href=
"#dt-static-expression">static expression</a>. However, there are
severe constraints on the information provided in its evaluation
context. These constraints are designed to ensure that the
expression can be evaluated at the earliest possible stage of
stylesheet processing, without any dependency on information
contained in the stylesheet itself or in any source document.</p>
<p>Specifically, the components of the static and dynamic context
are defined by the following two tables:</p>
<table border="1" cellpadding="5" width="100%" summary=
"static context for static expressions">
<caption>Static Context Components for Static Expressions</caption>
<col align="left" width="30%" span="1" />
<col align="left" span="1" />
<thead>
<tr>
<th colspan="1" align="left" valign="top">Component</th>
<th colspan="1" align="left" valign="top">Value</th>
</tr>
</thead>
<tbody>
<tr>
<td valign="top" align="left">XPath 1.0 compatibility mode</td>
<td align="left" valign="top">false</td>
</tr>
<tr>
<td valign="top" align="left">Statically known namespaces</td>
<td align="left" valign="top">determined by the in-scope namespaces
for the containing element in the stylesheet</td>
</tr>
<tr>
<td valign="top" align="left">Default element/type namespace</td>
<td align="left" valign="top">determined by the
<code>xpath-default-namespace</code> attribute if present (see
<a href="#unprefixed-qnames"><i>5.2 Unprefixed Lexical QNames in
Expressions and Patterns</i></a>); otherwise the null
namespace</td>
</tr>
<tr>
<td valign="top" align="left">Default function namespace</td>
<td align="left" valign="top">The <a title=
"standard function namespace" class="termref" href=
"#dt-standard-function-namespace">standard function
namespace</a></td>
</tr>
<tr>
<td valign="top" align="left">In-scope schema types</td>
<td align="left" valign="top">The type definitions that would be
available in the absence of any <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>
declaration</td>
</tr>
<tr>
<td valign="top" align="left">In-scope element declarations</td>
<td align="left" valign="top">None</td>
</tr>
<tr>
<td valign="top" align="left">In-scope attribute declarations</td>
<td align="left" valign="top">None</td>
</tr>
<tr>
<td valign="top" align="left">In-scope variables</td>
<td align="left" valign="top">The <a title="static variable" class=
"termref" href="#dt-static-variable">static variables</a> visible
within the containing package whose declarations occur prior to the
element containing the static expression in stylesheet tree order.
Stylesheet tree order is the order that results when all <a href=
"#element-import"><code>xsl:import</code></a> and <a href=
"#element-include"><code>xsl:include</code></a> declarations are
replaced by the declarations in the imported or included stylesheet
module. A static variable is not in scope within its own
declaration, <span>and it is in scope only within its declaring
package, not in any using packages.</span> If two static variables
satisfying this rule have the same name and are both in scope, the
one that appears most recently in stylesheet tree order; as a
consequence of rules defined elsewhere this will always be
consistent with the declaration having highest import
precedence.</td>
</tr>
<tr>
<td valign="top" align="left">Context item static type</td>
<td align="left" valign="top"><a title="absent" class="termref"
href="#dt-absent">Absent</a></td>
</tr>
<tr>
<td valign="top" align="left">Statically known function
signatures</td>
<td align="left" valign="top">The <a title="core function" class=
"termref" href="#dt-core-function">core functions</a> defined in
<a href="#xpath-functions-30">[Functions and Operators]</a>,
together with the functions <a href=
"#func-element-available"><code>element-available</code></a>,
<a href=
"#func-function-available"><code>function-available</code></a>,
<a href="#func-type-available"><code>type-available</code></a>, and
<a href="#func-system-property"><code>system-property</code></a>
defined in this specification, plus the set of extension functions
that are present in the static context of every XPath expression
(other than a static expression) within the content of the element
that contains the static expression. Note that <a title=
"stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet functions</a> are <em>not</em>
included in the context, which means that the function <a href=
"#func-function-available"><code>function-available</code></a> will
return <code>false</code> in respect of such functions, and
<a href="http://www.w3.org/TR/xpath-functions-30/#func-function-lookup">
<code>function-lookup</code></a><sup><small>FO30</small></sup> will
fail to find them. The effect of this rule is to ensure that
<a href=
"#func-function-available"><code>function-available</code></a>
returns true in respect of functions that can be called within the
static expression. It also has the effect that these extension
functions will be recognized within the static expression itself;
however, the fact that a function is available in this sense gives
no guarantee that a call on the function will succeed.</td>
</tr>
<tr>
<td valign="top" align="left">Statically known collations</td>
<td align="left" valign="top">Implementation-defined</td>
</tr>
<tr>
<td valign="top" align="left">Default collation</td>
<td align="left" valign="top">The Unicode Codepoint Collation</td>
</tr>
<tr>
<td valign="top" align="left">Static Base URI</td>
<td align="left" valign="top">The base URI of the containing
element in the stylesheet document <span>(see <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dm-base-uri">Section 5.2
base-uri Accessor</a> <sup><small>DM30</small></sup>)</span></td>
</tr>
<tr>
<td valign="top" align="left">Statically known documents</td>
<td align="left" valign="top">Implementation-defined</td>
</tr>
<tr>
<td valign="top" align="left">Statically known collections</td>
<td align="left" valign="top">Implementation-defined</td>
</tr>
<tr>
<td valign="top" align="left">Statically known default collection
type</td>
<td align="left" valign="top">Implementation-defined</td>
</tr>
<tr>
<td valign="top" align="left">Statically known decimal formats</td>
<td align="left" valign="top">A single unnamed <a title=
"decimal format" class="termref" href="#dt-decimal-format">decimal
format</a> equivalent to the decimal format that is created by an
<a href=
"#element-decimal-format"><code>xsl:decimal-format</code></a>
declaration with no attributes.</td>
</tr>
</tbody>
</table>
<p>&#160;</p>
<table border="1" cellpadding="5" width="100%" summary=
"dynamic context for static expressions">
<caption>Dynamic Context Components for Static
Expressions</caption>
<col align="left" width="30%" span="1" />
<col align="left" span="1" />
<thead>
<tr>
<th colspan="1" align="left" valign="top">Component</th>
<th colspan="1" align="left" valign="top">Value</th>
</tr>
</thead>
<tbody>
<tr>
<td valign="top" align="left">Context item, position, and size</td>
<td align="left" valign="top"><a title="absent" class="termref"
href="#dt-absent">Absent</a></td>
</tr>
<tr>
<td valign="top" align="left">Variable values</td>
<td align="left" valign="top">A value for every variable present in
the in-scope variables. For <a title="static parameter" class=
"termref" href="#dt-static-parameter">static parameters</a> where
an external value is supplied: the externally-supplied value of the
parameter. In all other cases: the value of the variable as defined
in <a href="#variable-values"><i>9.3 Values of Variables and
Parameters</i></a>.</td>
</tr>
<tr>
<td valign="top" align="left">Named functions</td>
<td align="left" valign="top">The function implementation
corresponding to each function signature in the statically known
function signatures</td>
</tr>
<tr>
<td valign="top" align="left">Current dateTime</td>
<td align="left" valign="top">Implementation-defined</td>
</tr>
<tr>
<td valign="top" align="left">Implicit timezone</td>
<td align="left" valign="top">Implementation-defined</td>
</tr>
<tr>
<td valign="top" align="left">Default language</td>
<td align="left" valign="top">Implementation-defined</td>
</tr>
<tr>
<td valign="top" align="left">Default calendar</td>
<td align="left" valign="top">Implementation-defined</td>
</tr>
<tr>
<td valign="top" align="left">Default place</td>
<td align="left" valign="top">Implementation-defined</td>
</tr>
<tr>
<td valign="top" align="left">Available documents</td>
<td align="left" valign="top">Implementation-defined</td>
</tr>
<tr>
<td valign="top" align="left">Available collections</td>
<td align="left" valign="top">Implementation-defined</td>
</tr>
<tr>
<td valign="top" align="left">Default collection</td>
<td align="left" valign="top">Implementation-defined</td>
</tr>
<tr>
<td valign="top" align="left">Environment variables</td>
<td align="left" valign="top">Implementation-defined</td>
</tr>
</tbody>
</table>
<p>Within a <a title="stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet module</a>, all static
expressions are evaluated in a single <a href=
"http://www.w3.org/TR/xpath-functions-30/#execution-scope">execution
scope</a><sup><small>FO30</small></sup>. This need not be the same
execution scope as that used for static expressions in other
stylesheet modules, or as that used when evaluating XPath
expressions appearing elsewhere in the stylesheet module. This
means that a function such as <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-current-date"><code>current-date</code></a><sup><small>FO30</small></sup>
will return the same result when called in different
<code>[xsl:]use-when</code> expressions within the same stylesheet
module, but will not necessarily return the same result as the same
call in an <code>[xsl:]use-when</code> expression within a
different stylesheet module, or as a call on the same function
executed during the transformation proper.</p>
</div>
<div class="div2">
<h3><a name="local-variables" id="local-variables"></a>9.8 <a href=
"#local-variables" style="text-decoration: none">Local Variables
and Parameters</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-local-variable" id="dt-local-variable" title=
"local variable"></a>As well as being allowed as a <a title=
"declaration" class="termref" href=
"#dt-declaration">declaration</a>, the <a href=
"#element-variable"><code>xsl:variable</code></a> element is also
allowed in <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructors</a>. Such a
variable is known as a <b>local variable</b>.<span class=
"definition">]</span></p>
<p>An <a href="#element-param"><code>xsl:param</code></a> element
may also be used to create a variable binding with local scope:</p>
<ul>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-template-parameter" id="dt-template-parameter" title=
"template parameter"></a> An <a href=
"#element-param"><code>xsl:param</code></a> element may appear as a
child of an <a href=
"#element-template"><code>xsl:template</code></a> element, before
any non-<a href="#element-param"><code>xsl:param</code></a>
children of that element. Such a parameter is known as a
<b>template parameter</b>. A template parameter is a <a title=
"local variable" class="termref" href="#dt-local-variable">local
variable</a> with the additional property that its value can be set
when the template is called, using any of the instructions <a href=
"#element-call-template"><code>xsl:call-template</code></a>,
<a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a>, or
<a href=
"#element-next-match"><code>xsl:next-match</code></a>.<span class=
"definition">]</span></p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-function-parameter" id="dt-function-parameter" title=
"function parameter"></a> An <a href=
"#element-param"><code>xsl:param</code></a> element may appear as a
child of an <a href=
"#element-function"><code>xsl:function</code></a> element, before
any non-<a href="#element-param"><code>xsl:param</code></a>
children of that element. Such a parameter is known as a
<b>function parameter</b>. A function parameter is a <a title=
"local variable" class="termref" href="#dt-local-variable">local
variable</a> with the additional property that its value can be set
when the function is called, using a function call in an XPath
<a title="expression" class="termref" href=
"#dt-expression">expression</a>.<span class=
"definition">]</span></p>
</li>
<li>
<p>An <a href="#element-param"><code>xsl:param</code></a> element
may appear as a child of an <a href=
"#element-iterate"><code>xsl:iterate</code></a> instruction, before
any non-<a href="#element-param"><code>xsl:param</code></a>
children of that element. This defines a parameter whose value may
be initialized on entry to the iteration, and which may be varied
each time round the iteration by use of an <a href=
"#element-with-param"><code>xsl:with-param</code></a> element in
the <a href=
"#element-next-iteration"><code>xsl:next-iteration</code></a>
instruction.</p>
</li>
</ul>
<p>The result of evaluating a local <a href=
"#element-variable"><code>xsl:variable</code></a> or <a href=
"#element-param"><code>xsl:param</code></a> element (that is, the
contribution it makes to the result of the <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> it is part of)
is an empty sequence.</p>
</div>
<div class="div2">
<h3><a name="scope-of-variables" id="scope-of-variables"></a>9.9
<a href="#scope-of-variables" style="text-decoration: none">Scope
of Variables</a></h3>
<p>For any <a title="variable-binding element" class="termref"
href="#dt-variable-binding-element">variable-binding element</a>,
there is a region (more specifically, a set of nodes) of the
<a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> within which the binding is
visible. The set of variable bindings in scope for an XPath
<a title="expression" class="termref" href=
"#dt-expression">expression</a> consists of those bindings that are
visible at the point in the stylesheet where the expression
occurs.</p>
<p>A global <a title="variable-binding element" class="termref"
href="#dt-variable-binding-element">variable binding element</a> is
visible everywhere in the <a title="stylesheet" class="termref"
href="#dt-stylesheet">stylesheet</a> (including other <a title=
"stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet modules</a>) except within the
<a href="#element-variable"><code>xsl:variable</code></a> or
<a href="#element-param"><code>xsl:param</code></a> element itself
and any region where it is <a title="shadows" class="termref" href=
"#dt-shadows">shadowed</a> by another variable binding.</p>
<p>A local <a title="variable-binding element" class="termref"
href="#dt-variable-binding-element">variable binding element</a> is
visible for all following siblings and their descendants, with
<span>the following</span> exceptions:</p>
<ol class="enumar">
<li>
<p>It is not visible in any region where it is <a title="shadows"
class="termref" href="#dt-shadows">shadowed</a> by another variable
binding.</p>
</li>
<li>
<p>It is not visible within the subtree rooted at an <a href=
"#element-fallback"><code>xsl:fallback</code></a> instruction that
is a sibling of the variable binding element.</p>
</li>
<li>
<p>It is not visible within the subtree rooted at an <a href=
"#element-catch"><code>xsl:catch</code></a> instruction that is a
sibling of the variable binding element.</p>
</li>
</ol>
<p>The binding is not visible for the <a href=
"#element-variable"><code>xsl:variable</code></a> or <a href=
"#element-param"><code>xsl:param</code></a> element itself.</p>
<p>If a binding is visible for an element then it is visible for
every attribute of that element and for every text node child of
that element.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-shadows" id="dt-shadows" title="shadows"></a>A binding
<b>shadows</b> another binding if the binding occurs at a point
where the other binding is visible, and the bindings have the same
name. <span class="definition">]</span> It is not an error if a
binding established by a local <a href=
"#element-variable"><code>xsl:variable</code></a> or <a href=
"#element-param"><code>xsl:param</code></a> <a title="shadows"
class="termref" href="#dt-shadows">shadows</a> a global binding. In
this case, the global binding will not be visible in the region of
the <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> where it is shadowed by the other
binding.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e25595" id=
"d7e25595"></a>Example: Local Variable Shadowing a Global
Variable</div>
<p>The following is allowed:</p>
<div class="exampleInner">
<pre>
&lt;xsl:param name="x" select="1"/&gt;
&lt;xsl:template name="foo"&gt;
  &lt;xsl:variable name="x" select="2"/&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
<p>It is also not an error if a binding established by a local
<a href="#element-variable"><code>xsl:variable</code></a> element
<a title="shadows" class="termref" href="#dt-shadows">shadows</a> a
binding established by another local <a href=
"#element-variable"><code>xsl:variable</code></a> or <a href=
"#element-param"><code>xsl:param</code></a>.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e25616" id=
"d7e25616"></a>Example: Misuse of Variable Shadowing</div>
<p>The following is not an error, but the effect is probably not
what was intended. The template outputs <code>&lt;x
value="1"/&gt;</code>, because the declaration of the inner
variable named <code>$x</code> has no effect on the value of the
outer variable named <code>$x</code>.</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="x" select="1"/&gt;
&lt;xsl:template name="foo"&gt;
  &lt;xsl:for-each select="1 to 5"&gt;
    &lt;xsl:variable name="x" select="$x+1"/&gt;
  &lt;/xsl:for-each&gt;
  &lt;x value="{$x}"/&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Once a variable has been given a value, the value cannot
subsequently be changed. XSLT does not provide an equivalent to the
assignment operator available in many procedural programming
languages.</p>
<p>This is because an assignment operator would make it harder to
create an implementation that processes a document other than in a
batch-like way, starting at the beginning and continuing through to
the end.</p>
</div>
<p>As well as global variables and local variables, an XPath
<a title="expression" class="termref" href=
"#dt-expression">expression</a> may also declare range variables
for use locally within an expression. For details, see <a href=
"#xpath-30">[XPath 3.0]</a>.</p>
<p>Where a reference to a variable occurs in an XPath expression,
it is resolved first by reference to range variables that are in
scope, then by reference to local variables and parameters, and
finally by reference to global variables and parameters. A range
variable may shadow a local variable or a global variable. XPath
also allows a range variable to shadow another range variable.</p>
</div>
<div class="div2">
<h3><a name="with-param" id="with-param"></a>9.10 <a href=
"#with-param" style="text-decoration: none">Setting Parameter
Values</a></h3>
<p class="element-syntax"><a name="element-with-param" id=
"element-with-param"></a><code>&lt;xsl:with-param<br />
&#160;&#160;<b>name</b> = <var>eqname</var><br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;as? = <var>sequence-type</var><br />
&#160;&#160;tunnel? = <var>boolean</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:with-param&gt;</code></p>
<p>Parameters are passed to templates using the <a href=
"#element-with-param"><code>xsl:with-param</code></a> element. The
<span class="verb">required</span> <code>name</code> attribute
specifies the name of the <a title="template parameter" class=
"termref" href="#dt-template-parameter">template parameter</a> (the
variable the value of whose binding is to be replaced). The value
of the <code>name</code> attribute is an <span><a title="EQName"
class="termref" href="#dt-eqname">EQName</a></span>, which is
expanded as described in <a href="#qname"><i>5.1 Qualified
Names</i></a>.</p>
<p><span>The <a href=
"#element-with-param"><code>xsl:with-param</code></a> element is
also used when passing parameters to an iteration of the <a href=
"#element-iterate"><code>xsl:iterate</code></a> instruction, or to
a dynamic invocation of an XPath expression using <a href=
"#element-evaluate"><code>xsl:evaluate</code></a>. In
consequence,</span> <a href=
"#element-with-param"><code>xsl:with-param</code></a> may appear
within <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a>,
<a href=
"#element-call-template"><code>xsl:call-template</code></a>,
<span><a href="#element-evaluate"><code>xsl:evaluate</code></a>,
<a href=
"#element-next-iteration"><code>xsl:next-iteration</code></a>,</span>
and <a href="#element-next-match"><code>xsl:next-match</code></a>.
(Arguments to <a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet functions</a>, however, are
supplied as part of an XPath function call: see <a href=
"#stylesheet-functions"><i>10.3 Stylesheet Functions</i></a>.)</p>
<p><a name="err-XTSE0670" id="err-XTSE0670"><span class=
"error">[ERR XTSE0670]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if two or
more sibling <a href=
"#element-with-param"><code>xsl:with-param</code></a> elements have
<code>name</code> attributes that represent the same <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a>.</p>
<p>The value of the parameter is specified in the same way as for
<a href="#element-variable"><code>xsl:variable</code></a> and
<a href="#element-param"><code>xsl:param</code></a> (see <a href=
"#variable-values"><i>9.3 Values of Variables and
Parameters</i></a>), taking account of the values of the
<code>select</code> and <code>as</code> attributes and the content
of the <a href=
"#element-with-param"><code>xsl:with-param</code></a> element, if
any.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>It is possible to have an <code>as</code> attribute on the
<a href="#element-with-param"><code>xsl:with-param</code></a>
element that differs from the <code>as</code> attribute on the
corresponding <a href="#element-param"><code>xsl:param</code></a>
element.</p>
<p>In this situation, the supplied value of the parameter will
first be processed according to the rules of the <code>as</code>
attribute on the <a href=
"#element-with-param"><code>xsl:with-param</code></a> element, and
the resulting value will then be further processed according to the
rules of the <code>as</code> attribute on the <a href=
"#element-param"><code>xsl:param</code></a> element.</p>
<p>For example, suppose the supplied value is a node with <a title=
"type annotation" class="termref" href="#dt-type-annotation">type
annotation</a> <code>xs:untypedAtomic</code>, and the <a href=
"#element-with-param"><code>xsl:with-param</code></a> element
specifies <code>as="xs:integer"</code>, while the <a href=
"#element-param"><code>xsl:param</code></a> element specifies
<code>as="xs:double"</code>. Then the node will first be atomized
and the resulting untyped atomic value will be cast to
<code>xs:integer</code>. If this succeeds, the
<code>xs:integer</code> will then be promoted to an
<code>xs:double</code>.</p>
</div>
<p>The <a title="focus" class="termref" href="#dt-focus">focus</a>
used for computing the value specified by the <a href=
"#element-with-param"><code>xsl:with-param</code></a> element is
the same as that used for <span>its parent <a title="instruction"
class="termref" href="#dt-instruction">instruction</a></span>.</p>
<p>The optional <code>tunnel</code> attribute may be used to
indicate that a parameter is a <a title="tunnel parameter" class=
"termref" href="#dt-tunnel-parameter">tunnel parameter</a>. The
default is <code>no</code>. Tunnel parameters are described in
<a href="#tunnel-params"><i>10.1.3 Tunnel Parameters</i></a>. They
are used only when passing parameters to templates: for an <a href=
"#element-with-param"><code>xsl:with-param</code></a> element that
is a child of <a href=
"#element-evaluate"><code>xsl:evaluate</code></a> or <a href=
"#element-next-iteration"><code>xsl:next-iteration</code></a> the
<code>tunnel</code> attribute <span class="verb">must</span> either
be omitted or take the value <code>no</code>.</p>
<p>In other cases it is a <a title="dynamic error" class="termref"
href="#dt-dynamic-error">dynamic error</a> if the template that is
invoked declares a <a title="template parameter" class="termref"
href="#dt-template-parameter">template parameter</a> with
<code>required="yes"</code> and no value for this parameter is
supplied by the calling instruction. <span class="error">[see
<a href="#err-XTDE0700">ERR XTDE0700</a>]</span></p>
</div>
<div class="div2">
<h3><a name="circularity" id="circularity"></a>9.11 <a href=
"#circularity" style="text-decoration: none">Circular
Definitions</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-circularity" id="dt-circularity" title="circularity"></a>A
<b>circularity</b> is said to exist if a construct such as a
<a title="global variable" class="termref" href=
"#dt-global-variable">global variable</a>, an <a title=
"attribute set" class="termref" href="#dt-attribute-set">attribute
set</a>, or a <a title="key" class="termref" href=
"#dt-key">key</a>, is defined in terms of itself. For example, if
the <a title="expression" class="termref" href=
"#dt-expression">expression</a> or <a title="sequence constructor"
class="termref" href="#dt-sequence-constructor">sequence
constructor</a> specifying the value of a <a title=
"global variable" class="termref" href="#dt-global-variable">global
variable</a> <var>X</var> references a global variable
<var>Y</var>, then the value for <var>Y</var> <span class=
"verb">must</span> be computed before the value of <var>X</var>. A
circularity exists if it is impossible to do this for all global
variable definitions.<span class="definition">]</span></p>
<div class="example">
<div class="exampleHeader"><a name="d7e25936" id=
"d7e25936"></a>Example: Circular Variable Definitions</div>
<p>The following two declarations create a circularity:</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="x" select="$y+1"/&gt;
&lt;xsl:variable name="y" select="$x+1"/&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e25943" id=
"d7e25943"></a>Example: Circularity involving Variables and
Functions</div>
<p>The definition of a global variable can be circular even if no
other variable is involved. For example the following two
declarations (see <a href="#stylesheet-functions"><i>10.3
Stylesheet Functions</i></a> for an explanation of the <a href=
"#element-function"><code>xsl:function</code></a> element) also
create a circularity:</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="x" select="my:f()"/&gt;

&lt;xsl:function name="my:f"&gt;
  &lt;xsl:sequence select="$x"/&gt;
&lt;/xsl:function&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e25955" id=
"d7e25955"></a>Example: Circularity involving Variables and
Templates</div>
<p>The definition of a variable is also circular if the evaluation
of the variable invokes an <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction and the variable is referenced in the pattern used in
the <code>match</code> attribute of any template rule in the
<a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a>. For example the following
definition is circular:</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="x"&gt;
  &lt;xsl:apply-templates select="//param[1]"/&gt;
&lt;/xsl:variable&gt;

&lt;xsl:template match="param[$x]"&gt;1&lt;/xsl:template&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e25971" id=
"d7e25971"></a>Example: Circularity involving Variables and
Keys</div>
<p>Similarly, a variable definition is circular if it causes a call
on the <a href="#func-key"><code>key</code></a> function, and the
definition of that <a title="key" class="termref" href=
"#dt-key">key</a> refers to that variable in its <code>match</code>
or <code>use</code> attributes. So the following definition is
circular:</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="x" select="my:f(10, /)"/&gt;

&lt;xsl:function name="my:f"&gt;
  &lt;xsl:param name="arg1"/&gt;
  &lt;xsl:param name="top"/&gt;
  &lt;xsl:sequence select="key('k', $arg1, $top)"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:key name="k" match="item[@code=$x]" use="@desc"/&gt;
</pre></div>
</div>
<p><a name="err-XTDE0640" id="err-XTDE0640"><span class=
"error">[ERR XTDE0640]</span></a> In general, a <a title=
"circularity" class="termref" href=
"#dt-circularity">circularity</a> in a <a title="stylesheet" class=
"termref" href="#dt-stylesheet">stylesheet</a> is a <a title=
"dynamic error" class="termref" href="#dt-dynamic-error">dynamic
error</a>. However, as with all other dynamic errors, an
implementation will signal the error only if it actually executes
the instructions and expressions that participate in the
circularity. Because different implementations may optimize the
execution of a stylesheet in different ways, it is <a title=
"implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a> whether
a particular circularity will actually be signaled.</p>
<p>For example, in the following declarations, the function
declares a local variable <code>$b</code>, but it returns a result
that does not require the variable to be evaluated. It is <a title=
"implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a> whether
the value is actually evaluated, and it is therefore
implementation-dependent whether the circularity is signaled as an
error:</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="x" select="my:f(1)"/&gt;

&lt;xsl:function name="my:f"&gt;
  &lt;xsl:param name="a"/&gt;
  &lt;xsl:variable name="b" select="$x"/&gt;  
  &lt;xsl:sequence select="$a + 2"/&gt;
&lt;/xsl:function&gt;
</pre></div>
<p>Circularities usually involve global variables or parameters,
but they can also exist between <a title="key" class="termref"
href="#dt-key">key</a> definitions (see <a href="#key"><i>20.2
Keys</i></a>), between named <a title="attribute set" class=
"termref" href="#dt-attribute-set">attribute sets</a> (see <a href=
"#attribute-sets"><i>10.2 Named Attribute Sets</i></a>), or between
any combination of these constructs. For example, a circularity
exists if a key definition invokes a function that references an
attribute set that calls the <a href=
"#func-key"><code>key</code></a> function, supplying the name of
the original key definition as an argument.</p>
<p>Circularity is not the same as recursion. Stylesheet functions
(see <a href="#stylesheet-functions"><i>10.3 Stylesheet
Functions</i></a>) and named templates (see <a href=
"#named-templates"><i>10.1 Named Templates</i></a>) may call other
functions and named templates without restriction. With careless
coding, recursion may be non-terminating. Implementations are
<span class="verb">required</span> to signal circularity as a
<a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a>, but they are not
<span class="verb">required</span> to detect non-terminating
recursion.</p>
<p>The requirement to report a circularity as a dynamic error
overrides the rule that dynamic errors in evaluating <a title=
"pattern" class="termref" href="#dt-pattern">patterns</a> are
normally masked (by treating the pattern as not matching).</p>
</div>
</div>
<div class="div1">
<h2><a name="callable-components" id="callable-components"></a>10
<a href="#callable-components" style=
"text-decoration: none">Callable Components</a></h2>
<p>This section describes three constructs that can be used to
provide subroutine-like functionality that can be invoked from
anywhere in the stylesheet: named templates (see <a href=
"#named-templates"><i>10.1 Named Templates</i></a>), named
attribute sets (see <a href="#attribute-sets"><i>10.2 Named
Attribute Sets</i></a>), and <a title="stylesheet function" class=
"termref" href="#dt-stylesheet-function">stylesheet functions</a>
(see <a href="#stylesheet-functions"><i>10.3 Stylesheet
Functions</i></a>).</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-invocation-construct" id="dt-invocation-construct" title=
"invocation construct"></a>The following <a title="construct"
class="termref" href="#dt-construct">constructs</a> are classified
as <b>invocation constructs</b>: the instructions <a href=
"#element-call-template"><code>xsl:call-template</code></a>,
<a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a>, and
<a href="#element-next-match"><code>xsl:next-match</code></a>;
XPath function calls that bind to <a title="stylesheet function"
class="termref" href="#dt-stylesheet-function">stylesheet
functions</a>; XPath dynamic function calls; the functions <a href=
"#func-accumulator-before"><code>accumulator-before</code></a> and
<a href=
"#func-accumulator-after"><code>accumulator-after</code></a>; the
<code>[xsl:]use-attribute-sets</code> attribute. These all have the
characteristic that they can cause evaluation of constructs that
are not lexically contained within the calling
construct.<span class="definition">]</span></p>
<div class="div2">
<h3><a name="named-templates" id="named-templates"></a>10.1
<a href="#named-templates" style="text-decoration: none">Named
Templates</a></h3>
<p class="element-syntax"><a name="element-call-template" id=
"element-call-template"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:call-template<br />
&#160;&#160;<b>name</b> = <var>eqname</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <a href=
"#element-with-param">xsl:with-param</a>* --&gt;<br />
&lt;/xsl:call-template&gt;</code></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-named-template" id="dt-named-template" title=
"named template"></a>Templates can be invoked by name. An <a href=
"#element-template"><code>xsl:template</code></a> element with a
<code>name</code> attribute defines a <b>named
template</b>.<span class="definition">]</span> The value of the
<code>name</code> attribute is an <span><a title="EQName" class=
"termref" href="#dt-eqname">EQName</a></span>, which is expanded as
described in <a href="#qname"><i>5.1 Qualified Names</i></a>. If an
<a href="#element-template"><code>xsl:template</code></a> element
has a <code>name</code> attribute, it may, but need not, also have
a <code>match</code> attribute. An <a href=
"#element-call-template"><code>xsl:call-template</code></a>
instruction invokes a template by name; it has a <span class=
"verb">required</span> <code>name</code> attribute that identifies
the template to be invoked. Unlike <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
the <a href=
"#element-call-template"><code>xsl:call-template</code></a>
instruction does not change the <a title="focus" class="termref"
href="#dt-focus">focus</a>.</p>
<p>The <code>match</code>, <code>mode</code> and
<code>priority</code> attributes on an <a href=
"#element-template"><code>xsl:template</code></a> element have no
effect when the <a title="template" class="termref" href=
"#dt-template">template</a> is invoked by an <a href=
"#element-call-template"><code>xsl:call-template</code></a>
instruction. Similarly, the <code>name</code> <span>and
<code>visibility</code></span> attributes on an <a href=
"#element-template"><code>xsl:template</code></a> element have no
effect when the template is invoked by an <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction.</p>
<p><a name="err-XTSE0650" id="err-XTSE0650"><span class=
"error">[ERR XTSE0650]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if a
<a title="package" class="termref" href="#dt-package">package</a>
contains an <a href=
"#element-call-template"><code>xsl:call-template</code></a>
instruction whose <code>name</code> attribute does not match the
<code>name</code> attribute of any <span><a title="named template"
class="termref" href="#dt-named-template">named template</a>
visible in the containing <a title="package" class="termref" href=
"#dt-package">package</a> (this includes any template defined in
this package, as well as templates accepted from used packages
whose visibility in this package is not <code>hidden</code>). For
more details of the process of binding the called template, see
<a href="#component-references"><i>3.6.3.4 Binding References to
Components</i></a>.</span></p>
<p><a name="err-XTSE0660" id="err-XTSE0660"><span class=
"error">[ERR XTSE0660]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if a
<span><a title="package" class="termref" href=
"#dt-package">package</a></span> contains more than one
<span>non-hidden</span> <a title="template" class="termref" href=
"#dt-template">template</a> with the same name and the same
<a title="import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a>, unless it also
contains a <a title="template" class="termref" href=
"#dt-template">template</a> with the same name and higher <a title=
"import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a>.</p>
<p><span>The target <a title="template" class="termref" href=
"#dt-template">template</a> for an <a href=
"#element-call-template"><code>xsl:call-template</code></a>
instruction is established using the binding rules described in
<a href="#component-references"><i>3.6.3.4 Binding References to
Components</i></a>. This will always be a template whose
<code>name</code> attribute matches the <code>name</code> attribute
of the <a href=
"#element-call-template"><code>xsl:call-template</code></a>
instruction. It may be a template defined in the same package that
has higher <a title="import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a> than any other
template with this name, or it may be a template accepted from a
used package, or (if the template is not defined as
<code>private</code> or <code>final</code>) it may be an overriding
template in a package that uses the containing package.</span> The
result of evaluating an <a href=
"#element-call-template"><code>xsl:call-template</code></a>
instruction is the sequence produced by evaluating the <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> contained in
its target <a title="template" class="termref" href=
"#dt-template">template</a> (see <a href=
"#sequence-constructors"><i>5.8 Sequence Constructors</i></a>).</p>
<p>The template name <code>xsl:initial-template</code> is specially
recognized in that it provides a default entry point for stylesheet
execution (see <a href="#initiating"><i>2.3 Initiating a
Transformation</i></a>.)</p>
<div class="div3">
<h4><a name="declaring-context-item" id=
"declaring-context-item"></a>10.1.1 <a href=
"#declaring-context-item" style="text-decoration: none">Declaring
the Context Item for a Template</a></h4>
<p>The <a href=
"#element-context-item"><code>xsl:context-item</code></a> element
is used as a child of <a href=
"#element-template"><code>xsl:template</code></a>, to declare the
required type of the context item. It is intended particularly for
use when the containing template is called using an <a href=
"#element-call-template"><code>xsl:call-template</code></a>
instruction, but it also constrains the context item if the same
template is invoked using <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a>, or
<a href="#element-next-match"><code>xsl:next-match</code></a>.</p>
<p class="element-syntax"><a name="element-context-item" id=
"element-context-item"></a><code>&lt;xsl:context-item<br />
&#160;&#160;as? = <var>sequence-type</var><br />
&#160;&#160;use? = "required" | "optional" |
"prohibited"&#160;/&gt;</code></p>
<p>If the <code>as</code> attribute is present then its value must
be an <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-ItemType">ItemType</a><sup><small>XP30</small></sup>.
If the attribute is omitted this is equivalent to specifying
<code>as="item()"</code>.</p>
<p>A <a title="type error" class="termref" href=
"#dt-type-error">type error</a> is signaled if the supplied context
item does not match its required type. No attempt is made to
convert the context item to the required type (using the function
conversion rules or otherwise). The error code is the same as for
<a href="#element-param"><code>xsl:param</code></a>: <span class=
"error">[see <a href="#err-XTTE0590">ERR XTTE0590</a>]</span>.</p>
<p>If an <a href=
"#element-context-item"><code>xsl:context-item</code></a> element
is present as the first child element of <a href=
"#element-template"><code>xsl:template</code></a>, it defines
whether the template requires a context item to be supplied, and if
so, what the type of the context item must be. If this template is
the <a title="initial named template" class="termref" href=
"#dt-initial-named-template">initial named template</a>, then this
has the effect of placing constraints on the <a title=
"global context item" class="termref" href=
"#dt-global-context-item">global context item</a> for the
transformation as a whole.</p>
<p>The <code>use</code> attribute of <a href=
"#element-context-item"><code>xsl:context-item</code></a> takes the
value <code>required</code>, <code>optional</code>, or
<code>prohibited</code>. <span>The default is
<code>optional</code></span>. If the value <code>required</code> is
specified, then there must be a context item. (This will
automatically be the case if the template is invoked using <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a>, or
<a href="#element-next-match"><code>xsl:next-match</code></a>, but
not if it is invoked using <a href=
"#element-call-template"><code>xsl:call-template</code></a>). If
the value <code>optional</code> is specified, or if the attribute
is omitted, or if the <a href=
"#element-context-item"><code>xsl:context-item</code></a> element
is omitted, then there may or may not be a context item when the
template is invoked. If the containing <a href=
"#element-template"><code>xsl:template</code></a> element has no
<code>name</code> attribute then the only permitted value is
<code>required</code>. If the value <code>prohibited</code> is
specified, then there will be no context item available to the body
template (if the calling template has a context item, it will not
be made available to the called template).</p>
<p>The <code>as</code> attribute of the <a href=
"#element-context-item"><code>xsl:context-item</code></a> defines
the required type of the context item supplied to the template if
one is supplied. The default value is <code>as="item()"</code>. If
a context item is supplied (which will automatically be the case if
the template is invoked using <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a>, or
<a href="#element-next-match"><code>xsl:next-match</code></a>) then
it will be converted to the required type by applying the <a title=
"function conversion rules" class="termref" href=
"#dt-function-conversion-rules">function conversion rules</a>; a
<a title="type error" class="termref" href="#dt-type-error">type
error</a> <span class="error">[see <a href="#err-XTTE0590">ERR
XTTE0590</a>]</span> occurs if conversion to the required type is
not possible. The processor <span class="verb">may</span> signal a
<a title="type error" class="termref" href="#dt-type-error">type
error</a> statically if the required context item type is
incompatible with the <code>match</code> pattern, that is, if no
item that satisfies the match pattern can also satisfy the required
context item type.</p>
<p>The <a href=
"#element-context-item"><code>xsl:context-item</code></a> element
plays no part in deciding whether and when the template rule is
invoked in response to an <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction.</p>
<p><a name="err-XTTE3090" id="err-XTTE3090"><span class=
"error">[ERR XTTE3090]</span></a> It is a <a title="type error"
class="termref" href="#dt-type-error">type error</a> if the
<a href="#element-context-item"><code>xsl:context-item</code></a>
child of <a href="#element-template"><code>xsl:template</code></a>
specifies that a context item is required and none is supplied by
the caller, that is, if the context item is absent at the point
where <a href=
"#element-call-template"><code>xsl:call-template</code></a> is
evaluated.</p>
</div>
<div class="div3">
<h4><a name="call-template-params" id=
"call-template-params"></a>10.1.2 <a href="#call-template-params"
style="text-decoration: none">Passing Parameters to Named
Templates</a></h4>
<p>Parameters are passed to named templates using the <a href=
"#element-with-param"><code>xsl:with-param</code></a> element as a
child of the <a href=
"#element-call-template"><code>xsl:call-template</code></a>
instruction.</p>
<p><a name="err-XTSE0680" id="err-XTSE0680"><span class=
"error">[ERR XTSE0680]</span></a> In the case of <a href=
"#element-call-template"><code>xsl:call-template</code></a>, it is
a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> to pass a non-tunnel parameter
named <var>x</var> to a template that does not have a
<span>non-tunnel</span> <a title="template parameter" class=
"termref" href="#dt-template-parameter">template parameter</a>
named <var>x</var>, unless <span>the <a href=
"#element-call-template"><code>xsl:call-template</code></a>
instruction is processed with <a title="XSLT 1.0 behavior" class=
"termref" href="#dt-xslt-10-behavior">XSLT 1.0 behavior</a></span>.
This is not an error in the case of <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a>, and
<a href="#element-next-match"><code>xsl:next-match</code></a>; in
these cases the parameter is simply ignored.</p>
<p>The optional <code>tunnel</code> attribute may be used to
indicate that a parameter is a <a title="tunnel parameter" class=
"termref" href="#dt-tunnel-parameter">tunnel parameter</a>. The
default is <code>no</code>. Tunnel parameters are described in
<a href="#tunnel-params"><i>10.1.3 Tunnel Parameters</i></a></p>
<div class="example">
<div class="exampleHeader"><a name="d7e26609" id=
"d7e26609"></a>Example: Calling a Named Template with a
Parameter</div>
<p>This example defines a named template for a
<code>numbered-block</code> with a parameter to control the format
of the number.</p>
<div class="exampleInner">
<pre>
&lt;xsl:template name="numbered-block"&gt;
  &lt;xsl:param name="format"&gt;1. &lt;/xsl:param&gt;
  &lt;fo:block&gt;
    &lt;xsl:number format="{$format}"/&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="ol//ol/li"&gt;
  &lt;xsl:call-template name="numbered-block"&gt;
    &lt;xsl:with-param name="format"&gt;a. &lt;/xsl:with-param&gt;
  &lt;/xsl:call-template&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
</div>
<div class="div3">
<h4><a name="tunnel-params" id="tunnel-params"></a>10.1.3 <a href=
"#tunnel-params" style="text-decoration: none">Tunnel
Parameters</a></h4>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-tunnel-parameter" id="dt-tunnel-parameter" title=
"tunnel parameter"></a>A parameter passed to a template may be
defined as a <b>tunnel parameter</b>. Tunnel parameters have the
property that they are automatically passed on by the called
template to any further templates that it calls, and so on
recursively.<span class="definition">]</span> Tunnel parameters
thus allow values to be set that are accessible during an entire
phase of stylesheet processing, without the need for each template
that is used during that phase to be aware of the parameter.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Tunnel parameters are conceptually similar to dynamically scoped
variables in some functional programming languages.</p>
</div>
<p>A <a title="tunnel parameter" class="termref" href=
"#dt-tunnel-parameter">tunnel parameter</a> is created by using an
<a href="#element-with-param"><code>xsl:with-param</code></a>
element that specifies <code>tunnel="yes"</code>. A template that
requires access to the value of a tunnel parameter must declare it
using an <a href="#element-param"><code>xsl:param</code></a>
element that also specifies <code>tunnel="yes"</code>.</p>
<p>On any template call using an <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href=
"#element-call-template"><code>xsl:call-template</code></a>,
<a href="#element-apply-imports"><code>xsl:apply-imports</code></a>
or <a href="#element-next-match"><code>xsl:next-match</code></a>
instruction, a set of <a title="tunnel parameter" class="termref"
href="#dt-tunnel-parameter">tunnel parameters</a> is passed from
the calling template to the called template. This set consists of
any parameters explicitly created using <code>&lt;xsl:with-param
tunnel="yes"&gt;</code>, overlaid on a base set of tunnel
parameters. If the <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href=
"#element-call-template"><code>xsl:call-template</code></a>,
<a href="#element-apply-imports"><code>xsl:apply-imports</code></a>
or <a href="#element-next-match"><code>xsl:next-match</code></a>
instruction has an <a href=
"#element-template"><code>xsl:template</code></a> declaration as an
ancestor element in the stylesheet, then the base set consists of
the tunnel parameters that were passed to that template; otherwise
(for example, if the instruction is within a global variable
declaration, an <a title="attribute set" class="termref" href=
"#dt-attribute-set">attribute set</a> declaration, or a <a title=
"stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet function</a>), the base set is
empty. If a parameter created using <code>&lt;xsl:with-param
tunnel="yes"&gt;</code> has the same <a title="expanded QName"
class="termref" href="#dt-expanded-qname">expanded QName</a> as a
parameter in the base set, then the parameter created using
<a href="#element-with-param"><code>xsl:with-param</code></a>
overrides the parameter in the base set; otherwise, the parameter
created using <a href=
"#element-with-param"><code>xsl:with-param</code></a> is added to
the base set.</p>
<p>When a template accesses the value of a <a title=
"tunnel parameter" class="termref" href=
"#dt-tunnel-parameter">tunnel parameter</a> by declaring it with
<code>xsl:param tunnel="yes"</code>, this does not remove the
parameter from the base set of tunnel parameters that is passed on
to any templates called by this template.</p>
<p>Two sibling <a href=
"#element-with-param"><code>xsl:with-param</code></a> elements
<span class="verb">must</span> have distinct parameter names, even
if one is a <a title="tunnel parameter" class="termref" href=
"#dt-tunnel-parameter">tunnel parameter</a> and the other is not.
Equally, two sibling <a href=
"#element-param"><code>xsl:param</code></a> elements representing
<a title="template parameter" class="termref" href=
"#dt-template-parameter">template parameters</a> <span class=
"verb">must</span> have distinct parameter names, even if one is a
<a title="tunnel parameter" class="termref" href=
"#dt-tunnel-parameter">tunnel parameter</a> and the other is not.
However, the tunnel parameters that are implicitly passed in a
template call <span class="verb">may</span> have names that
duplicate the names of non-tunnel parameters that are explicitly
passed on the same call.</p>
<p><a title="tunnel parameter" class="termref" href=
"#dt-tunnel-parameter">Tunnel parameters</a> are not passed in
calls to <a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet functions</a>.</p>
<p>All other options of <a href=
"#element-with-param"><code>xsl:with-param</code></a> and <a href=
"#element-param"><code>xsl:param</code></a> are available with
<a title="tunnel parameter" class="termref" href=
"#dt-tunnel-parameter">tunnel parameters</a> just as with
non-tunnel parameters. For example, parameters may be declared as
mandatory or optional, a default value may be specified, and a
required type may be specified. If any conversion is required from
the supplied value of a tunnel parameter to the required type
specified in <a href="#element-param"><code>xsl:param</code></a>,
then the converted value is used within the receiving template, but
the value that is passed on in any further template calls is the
original supplied value before conversion. Equally, any default
value is local to the template: specifying a default value for a
tunnel parameter does not change the set of tunnel parameters that
is passed on in further template calls.</p>
<p><a title="tunnel parameter" class="termref" href=
"#dt-tunnel-parameter">Tunnel parameters</a> are passed unchanged
through a built-in template rule (see <a href=
"#built-in-rule"><i>6.7 Built-in Template Rules</i></a>).</p>
<p>If a tunnel parameter is declared in an <a href=
"#element-param"><code>xsl:param</code></a> element with the
attribute <code>tunnel="yes"</code>, then a dynamic error occurs
<span class="error">[see <a href="#err-XTDE0700">ERR
XTDE0700</a>]</span> if the set of tunnel parameters passed to the
template does not include a parameter with a matching <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a>.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e26794" id=
"d7e26794"></a>Example: Using Tunnel Parameters</div>
<p>Suppose that the equations in a scientific paper are to be
sequentially numbered, but that the format of the number depends on
the context in which the equations appear. It is possible to
reflect this using a rule of the form:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="equation"&gt;
  &lt;xsl:param name="equation-format" select="'(1)'" tunnel="yes"/&gt;
  &lt;xsl:number level="any" format="{$equation-format}"/&gt;
&lt;/xsl:template&gt;
</pre></div>
<p>At any level of processing above this level, it is possible to
determine how the equations will be numbered, for example:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="appendix"&gt;
  ...
  &lt;xsl:apply-templates&gt;
    &lt;xsl:with-param name="equation-format" select="'[i]'" tunnel="yes"/&gt;
  &lt;/xsl:apply-templates&gt;
  ...
&lt;/xsl:template&gt;
</pre></div>
<p>The parameter value is passed transparently through all the
intermediate layers of template rules until it reaches the rule
with <code>match="equation"</code>. The effect is similar to using
a global variable, except that the parameter can take different
values during different phases of the transformation.</p>
</div>
</div>
</div>
<div class="div2">
<h3><a name="attribute-sets" id="attribute-sets"></a>10.2 <a href=
"#attribute-sets" style="text-decoration: none">Named Attribute
Sets</a></h3>
<p class="element-syntax"><a name="element-attribute-set" id=
"element-attribute-set"></a><code>&lt;!-- Category: declaration
--&gt;<br />
&lt;xsl:attribute-set<br />
&#160;&#160;<b>name</b> = <var>eqname</var><br />
&#160;&#160;use-attribute-sets? = <var>eqnames</var><br />
&#160;&#160;visibility? = "public" | "private" | "final" |
"abstract"<br />
&#160;&#160;streamable? = <var>boolean</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <a href=
"#element-attribute">xsl:attribute</a>* --&gt;<br />
&lt;/xsl:attribute-set&gt;</code></p>
<p>Attribute sets <span>generate</span> named collections of
attributes that can be used repeatedly on different constructed
elements. The <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a>
declaration is used to declare attribute sets. The <span class=
"verb">required</span> <code>name</code> attribute specifies the
name of the attribute set. The value of the <code>name</code>
attribute is an <code>EQName</code>, which is expanded as described
in <a href="#qname"><i>5.1 Qualified Names</i></a>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-attribute-set" id="dt-attribute-set" title=
"attribute set"></a>An <b>attribute set</b> is defined as a set of
<a href="#element-attribute-set"><code>xsl:attribute-set</code></a>
declarations in the same <a title="package" class="termref" href=
"#dt-package">package</a> that share the same <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a>.<span class="definition">]</span></p>
<p>The content of the <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a> element
consists of zero or more <a href=
"#element-attribute"><code>xsl:attribute</code></a> instructions
that are evaluated to produce the attributes in the set.</p>
<div class="div3">
<h4><a name="using-attribute-sets" id=
"using-attribute-sets"></a>10.2.1 <a href="#using-attribute-sets"
style="text-decoration: none">Using Attribute Sets</a></h4>
<p><a title="attribute set" class="termref" href=
"#dt-attribute-set">Attribute sets</a> are used by specifying a
<code>use-attribute-sets</code> attribute on the <a href=
"#element-element"><code>xsl:element</code></a> or <a href=
"#element-copy"><code>xsl:copy</code></a> instruction, or by
specifying an <code>xsl:use-attribute-sets</code> attribute on a
literal result element. An attribute set may be defined in terms of
other attribute sets by using the <code>use-attribute-sets</code>
attribute on the <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a> element
itself. The value of the <code>[xsl:]use-attribute-sets</code>
attribute is in each case a whitespace-separated list of names of
attribute sets. Each name is specified as an <span><a title=
"EQName" class="termref" href="#dt-eqname">EQName</a></span>, which
is expanded as described in <a href="#qname"><i>5.1 Qualified
Names</i></a>.</p>
<p>Specifying a <code>use-attribute-sets</code> attribute is
broadly equivalent to adding <a href=
"#element-attribute"><code>xsl:attribute</code></a> instructions
for each of the attributes in each of the named attribute sets to
the beginning of the content of the instruction with the
<code>[xsl:]use-attribute-sets</code> attribute, in the same order
in which the names of the attribute sets are specified in the
<code>use-attribute-sets</code> attribute.</p>
<p>More formally, an <code>xsl:use-attribute-sets</code> attribute
is expanded using the following recursive algorithm, or any
algorithm that produces the same results:</p>
<ul>
<li>
<p>The value of the attribute is tokenized as a list of QNames.</p>
</li>
<li>
<p>Each QName in the list is processed, in order, as follows:</p>
<ul>
<li>
<p>The QName must match the <code>name</code> attribute of one or
more <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a>
declarations in the stylesheet.</p>
</li>
<li>
<p>Each <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a>
declaration whose name matches is processed as follows. Where two
such declarations have different <a title="import precedence"
class="termref" href="#dt-import-precedence">import precedence</a>,
the one with lower import precedence is processed first. Where two
declarations have the same import precedence, they are processed in
<a title="declaration order" class="termref" href=
"#dt-declaration-order">declaration order</a>.</p>
<ul>
<li>
<p>If the <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a>
declaration has a <code>use-attribute-sets</code> attribute, the
attribute is expanded by applying this algorithm recursively.</p>
</li>
<li>
<p>If the <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a>
declaration contains one or more <a href=
"#element-attribute"><code>xsl:attribute</code></a> instructions,
these instructions are evaluated (following the rules for
evaluating a <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>: see <a href=
"#sequence-constructors"><i>5.8 Sequence Constructors</i></a>) to
produce a sequence of attribute nodes. These attribute nodes are
appended to the result sequence.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a name="err-XTSE0710" id="err-XTSE0710"><span class=
"error">[ERR XTSE0710]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
value of the <code>use-attribute-sets</code> attribute of an
<a href="#element-copy"><code>xsl:copy</code></a>, <a href=
"#element-element"><code>xsl:element</code></a>, or <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a>
element, or the <code>xsl:use-attribute-sets</code> attribute of a
<a title="literal result element" class="termref" href=
"#dt-literal-result-element">literal result element</a>, is not a
whitespace-separated sequence of <span><a title="EQName" class=
"termref" href="#dt-eqname">EQNames</a></span>, or if it contains a
QName that does not match the <code>name</code> attribute of any
<a href="#element-attribute-set"><code>xsl:attribute-set</code></a>
declaration in the <span>containing <a title="package" class=
"termref" href="#dt-package">package</a></span>.</p>
<p><a name="err-XTSE0720" id="err-XTSE0720"><span class=
"error">[ERR XTSE0720]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if an
<a href="#element-attribute-set"><code>xsl:attribute-set</code></a>
element directly or indirectly references itself via the names
contained in the <code>use-attribute-sets</code> attribute.</p>
</div>
<div class="div3">
<h4><a name="visibility-of-attribute-sets" id=
"visibility-of-attribute-sets"></a>10.2.2 <a href=
"#visibility-of-attribute-sets" style=
"text-decoration: none">Visibility of Attribute Sets</a></h4>
<p>The <code>visibility</code> attribute determines the potential
visibility of the attribute set in packages other than the
containing package. If the <code>visibility</code> attribute is
present on any of the <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a>
declarations making up the definition of an <a title=
"attribute set" class="termref" href="#dt-attribute-set">attribute
set</a> (that is, all declarations within the same package sharing
the same name), then it <span class="verb">must</span> be present,
with the same value, on every <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a>
declaration making up the definition of that <a title=
"attribute set" class="termref" href="#dt-attribute-set">attribute
set</a>.</p>
<p>If the <code>visibility</code> attribute is present with the
value <code>abstract</code> then there must be no <a href=
"#element-attribute"><code>xsl:attribute</code></a> children
<span>and no <code>use-attribute-sets</code> attribute</span>.</p>
</div>
<div class="div3">
<h4><a name="streamability-of-attribute-sets" id=
"streamability-of-attribute-sets"></a>10.2.3 <a href=
"#streamability-of-attribute-sets" style=
"text-decoration: none">Streamability of Attribute Sets</a></h4>
<p>An <a title="attribute set" class="termref" href=
"#dt-attribute-set">attribute set</a> may be designated as
streamable by including the attribute <code>streamable="yes"</code>
on each <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a>
declaration making up the attribute set. If any <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a>
declaration for an attribute set has the attribute
<code>streamable="yes"</code>, then every <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a>
declaration for that attribute set <span class="verb">must</span>
have the attribute <code>streamable="yes"</code>.</p>
<p>An <a title="attribute set" class="termref" href=
"#dt-attribute-set">attribute set</a> is <a title=
"guaranteed-streamable" class="termref" href=
"#dt-guaranteed-streamable">guaranteed-streamable</a> if all the
following conditions are satisfied:</p>
<ol class="enumar">
<li>
<p>Every <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a>
declaration for the attribute set has the attribute
<code>streamable="yes"</code>.</p>
</li>
<li>
<p>Every <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a>
declaration for the attribute set, considered as a <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>, is <a title=
"motionless" class="termref" href="#dt-motionless">motionless</a>
according to the analysis in <a href=
"#classifying-attribute-sets"><i>19.8.5 Classifying Attribute
Sets</i></a>.</p>
</li>
</ol>
<p>Specifying <code>streamable="yes"</code> on an <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a> element
declares an intent that the attribute set should be guaranteed
streamable according to these criteria. The consequences of
declaring the attribute set to be streamable when it is not in fact
guaranteed streamable depend on the conformance level of the
processor, and are explained in <a href=
"#streamability-guarantees"><i>19.10 Streamability
Guarantees</i></a>.</p>
<p><a name="err-XTSE0730" id="err-XTSE0730"><span class=
"error">[ERR XTSE0730]</span></a> If an <a href=
"#element-attribute"><code>xsl:attribute</code></a> set element
specifies <code>streamable="yes"</code> then every attribute set
referenced in its <code>use-attribute-sets</code> attribute (if
present) must also specify <code>streamable="yes"</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>It is common for attribute sets to create attributes with
constant values, and such attribute sets will always be motionless
and therefore streamable. Although such cases are fairly simple for
a processor to detect, references to attribute sets are not
guaranteed streamable unless the attribute set is declared with the
attribute <code>streamable="yes"</code>, which should therefore be
used if interoperable streaming is required.</p>
</div>
</div>
<div class="div3">
<h4><a name="evaluating-attribute-sets" id=
"evaluating-attribute-sets"></a>10.2.4 <a href=
"#evaluating-attribute-sets" style=
"text-decoration: none">Evaluating Attribute Sets</a></h4>
<p>Attribute sets are evaluated as follows:</p>
<ul>
<li>
<p>The <a href="#element-copy"><code>xsl:copy</code></a> and
<a href="#element-element"><code>xsl:element</code></a>
instructions have a <code>use-attribute-sets</code> attribute. The
sequence of attribute nodes produced by evaluating this attribute
is prepended to the sequence produced by evaluating the <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> contained
within the instruction.</p>
</li>
<li>
<p><a title="literal result element" class="termref" href=
"#dt-literal-result-element">Literal result elements</a> allow an
<code>xsl:use-attribute-sets</code> attribute, which is evaluated
in the same way as the <code>use-attribute-sets</code> attribute of
<a href="#element-element"><code>xsl:element</code></a> and
<a href="#element-copy"><code>xsl:copy</code></a>. The sequence of
attribute nodes produced by evaluating this attribute is prepended
to the sequence of attribute nodes produced by evaluating the
attributes of the literal result element, which in turn is
prepended to the sequence produced by evaluating the <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> contained with
the literal result element.</p>
</li>
</ul>
<p>The <a href="#element-attribute"><code>xsl:attribute</code></a>
instructions are evaluated using the same <a title="focus" class=
"termref" href="#dt-focus">focus</a> as is used for evaluating the
element that is the parent of the
<code>[xsl:]use-attribute-sets</code> attribute forming the initial
input to the algorithm. However, the static context for the
evaluation depends on the position of the <a href=
"#element-attribute"><code>xsl:attribute</code></a> instruction in
the stylesheet: thus, only local variables declared within an
<a href="#element-attribute"><code>xsl:attribute</code></a>
instruction, and global variables, are visible.</p>
<p>The set of attribute nodes produced by expanding
<code>xsl:use-attribute-sets</code> may include several attributes
with the same name. When the attributes are added to an element
node, only the last of the duplicates will take effect.</p>
<p>The way in which each instruction uses the results of expanding
the <code>[xsl:]use-attribute-sets</code> attribute is described in
the specification for the relevant instruction: see <a href=
"#literal-result-element"><i>11.1 Literal Result Elements</i></a>,
<a href="#xsl-element"><i>11.2 Creating Element Nodes Using
xsl:element</i></a> , and <a href="#copying"><i>11.9 Copying
Nodes</i></a>.</p>
<p>The result of evaluating an attribute set is a sequence of
attribute nodes. Evaluating the same attribute set more than once
can produce different results, because although an attribute set
does not have parameters, it may contain expressions or
instructions whose value depends on the evaluation context.</p>
<p>Each attribute node produced by expanding an attribute set has a
<a title="type annotation" class="termref" href=
"#dt-type-annotation">type annotation</a> determined by the rules
for the <a href="#element-attribute"><code>xsl:attribute</code></a>
instruction that created the attribute node: see <a href=
"#annotation-for-constructed-attribute"><i>11.3.1 Setting the Type
Annotation for a Constructed Attribute Node</i></a>. These type
annotations may be preserved, stripped, or replaced as determined
by the rules for the instruction that creates the element in which
the attributes are used.</p>
</div>
<div class="div3">
<h4><a name="attribute-sets-examples" id=
"attribute-sets-examples"></a>10.2.5 <a href=
"#attribute-sets-examples" style="text-decoration: none">Attribute
Sets: Examples</a></h4>
<div class="example">
<div class="exampleHeader"><a name="d7e27267" id=
"d7e27267"></a>Example: A Simple Attribute Set</div>
<p>The following example creates a named <a title="attribute set"
class="termref" href="#dt-attribute-set">attribute set</a>
<code>title-style</code> and uses it in a <a title="template rule"
class="termref" href="#dt-template-rule">template rule</a>.</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="chapter/heading"&gt;
  &lt;fo:block font-stretch="condensed" xsl:use-attribute-sets="title-style"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:attribute-set name="title-style"&gt;
  &lt;xsl:attribute name="font-size"&gt;12pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="font-weight"&gt;bold&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e27283" id=
"d7e27283"></a>Example: Overriding Attributes in an Attribute
Set</div>
<p>The following example creates a named attribute set
<code>base-style</code> and uses it in a template rule with
multiple specifications of the attributes:</p>
<dl>
<dt class="label">font-family</dt>
<dd>
<p>is specified only in the attribute set</p>
</dd>
<dt class="label">font-size</dt>
<dd>
<p>is specified in the attribute set, is specified on the literal
result element, and in an <a href=
"#element-attribute"><code>xsl:attribute</code></a> instruction</p>
</dd>
<dt class="label">font-style</dt>
<dd>
<p>is specified in the attribute set, and on the literal result
element</p>
</dd>
<dt class="label">font-weight</dt>
<dd>
<p>is specified in the attribute set, and in an <a href=
"#element-attribute"><code>xsl:attribute</code></a> instruction</p>
</dd>
</dl>
<p>Stylesheet fragment:</p>
<div class="exampleInner">
<pre>
&lt;xsl:attribute-set name="base-style"&gt;
  &lt;xsl:attribute name="font-family"&gt;Univers&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="font-size"&gt;10pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="font-style"&gt;normal&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="font-weight"&gt;normal&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;

&lt;xsl:template match="o"&gt;
  &lt;fo:block xsl:use-attribute-sets="base-style"
            font-size="12pt"
            font-style="italic"&gt;
    &lt;xsl:attribute name="font-size"&gt;14pt&lt;/xsl:attribute&gt;
    &lt;xsl:attribute name="font-weight"&gt;bold&lt;/xsl:attribute&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;
</pre></div>
<p>Result:</p>
<div class="exampleInner">
<pre>
&lt;fo:block font-family="Univers"
          font-size="14pt"
          font-style="italic"
          font-weight="bold"&gt;
...
&lt;/fo:block&gt;
</pre></div>
</div>
</div>
</div>
<div class="div2">
<h3><a name="stylesheet-functions" id=
"stylesheet-functions"></a>10.3 <a href="#stylesheet-functions"
style="text-decoration: none">Stylesheet Functions</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-stylesheet-function" id="dt-stylesheet-function" title=
"stylesheet function"></a>An <a href=
"#element-function"><code>xsl:function</code></a> declaration
declares the name, parameters, and implementation of a
<b>stylesheet function</b> that can be called from any XPath
<a title="expression" class="termref" href=
"#dt-expression">expression</a> within the <a title="stylesheet"
class="termref" href="#dt-stylesheet">stylesheet</a> <span>(subject
to visibility rules)</span>.<span class="definition">]</span></p>
<p class="element-syntax"><a name="element-function" id=
"element-function"></a><code>&lt;!-- Category: declaration
--&gt;<br />
&lt;xsl:function<br />
&#160;&#160;<b>name</b> = <var>eqname</var><br />
&#160;&#160;as? = <var>sequence-type</var><br />
&#160;&#160;visibility? = "public" | "private" | "final" |
"abstract"<br />
&#160;&#160;streamable? = <var>boolean</var><br />
&#160;&#160;override-extension-function? = <var>boolean</var><br />
&#160;&#160;<span class="grayed">[override]?</span> =
<var>boolean</var><br />
&#160;&#160;identity-sensitive? = <var>boolean</var><br />
&#160;&#160;cache? = "full" | "partial" | "no"&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-param">xsl:param</a>*, <var>sequence-constructor</var>)
--&gt;<br />
&lt;/xsl:function&gt;</code></p>
<p>The <a href="#element-function"><code>xsl:function</code></a>
declaration defines a <a title="stylesheet function" class=
"termref" href="#dt-stylesheet-function">stylesheet function</a>
that can be called from any XPath <a title="expression" class=
"termref" href="#dt-expression">expression</a> used in the
<a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> (including an XPath expression used
within a predicate in a <a title="pattern" class="termref" href=
"#dt-pattern">pattern</a>). The <code>name</code> attribute
specifies the name of the function. The value of the
<code>name</code> attribute is an <span><a title="EQName" class=
"termref" href="#dt-eqname">EQName</a></span>, which is expanded as
described in <a href="#qname"><i>5.1 Qualified Names</i></a>.</p>
<p>An <a href="#element-function"><code>xsl:function</code></a>
declaration can only appear as a <a title="top-level" class=
"termref" href="#dt-top-level">top-level</a> element in a
stylesheet module.</p>
<p>The content of the <a href=
"#element-function"><code>xsl:function</code></a> element consists
of zero or more <a href="#element-param"><code>xsl:param</code></a>
elements that specify the formal arguments of the function,
followed by a <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> that defines
the value to be returned by the function.</p>
<div class="div3">
<h4><a name="xsl-function-name" id="xsl-function-name"></a>10.3.1
<a href="#xsl-function-name" style="text-decoration: none">Function
Name and Arity</a></h4>
<p>The name of the function is given by the <code>name</code>
attribute; the arguments are defined by child <a href=
"#element-param"><code>xsl:param</code></a> elements; and the
return type is defined by the <code>as</code> attribute. Together
these definitions constitute the <em>function signature</em>.</p>
<p><a name="err-XTSE0740" id="err-XTSE0740"><span class=
"error">[ERR XTSE0740]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if a
<a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet function</a> has a name that
is in no namespace.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>To prevent the namespace declaration used for the function name
appearing in the result document, use the
<code>exclude-result-prefixes</code> attribute on the <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> element: see
<a href="#lre-namespaces"><i>11.1.3 Namespace Nodes for Literal
Result Elements</i></a>.</p>
<p>The name of the function must not be in a <a title=
"reserved namespace" class="termref" href=
"#dt-reserved-namespace">reserved namespace</a>: <span class=
"error">[see <a href="#err-XTSE0080">ERR XTSE0080</a>]</span></p>
</div>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-arity" id="dt-arity" title="arity"></a>The <b>arity</b> of a
stylesheet function is the number of <a href=
"#element-param"><code>xsl:param</code></a> elements in the
function definition.<span class="definition">]</span> Optional
arguments are not allowed.</p>
<p>As defined in XPath, the function that is executed as the result
of a function call is identified by looking in the in-scope
functions of the static context for a function whose name and
<a title="arity" class="termref" href="#dt-arity">arity</a> matches
the name and number of arguments in the function call.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Functions are not polymorphic. Although the XPath function call
mechanism allows two functions to have the same name and different
<a title="arity" class="termref" href="#dt-arity">arity</a>, it
does not allow them to be distinguished by the types of their
arguments.</p>
</div>
</div>
<div class="div3">
<h4><a name="function-arguments" id="function-arguments"></a>10.3.2
<a href="#function-arguments" style=
"text-decoration: none">Arguments</a></h4>
<p>The <a href="#element-param"><code>xsl:param</code></a> elements
define the formal arguments to the function. These are interpreted
positionally. When the function is called using a function-call in
an XPath <a title="expression" class="termref" href=
"#dt-expression">expression</a>, the first argument supplied is
assigned to the first <a href=
"#element-param"><code>xsl:param</code></a> element, the second
argument supplied is assigned to the second <a href=
"#element-param"><code>xsl:param</code></a> element, and so on.</p>
<p><a name="err-XTSE0760" id="err-XTSE0760"><span class=
"error">[ERR XTSE0760]</span></a> Because arguments to a stylesheet
function call <span class="verb">must</span> all be specified, the
<a href="#element-param"><code>xsl:param</code></a> elements within
an <a href="#element-function"><code>xsl:function</code></a>
element <span class="verb">must not</span> specify a default value:
this means they <span class="verb">must</span> be empty, and
<span class="verb">must not</span> have a <code>select</code>
attribute.</p>
<p>The <code>as</code> attribute of the <a href=
"#element-param"><code>xsl:param</code></a> element defines the
required type of the parameter. The rules for converting the values
of the actual arguments supplied in the function call to the types
required by each <a href=
"#element-param"><code>xsl:param</code></a> element are defined in
<a href="#xpath-30">[XPath 3.0]</a>. The rules that apply are those
for the case where <a title="XPath 1.0 compatibility mode" class=
"termref" href="#dt-xpath-compat-mode">XPath 1.0 compatibility
mode</a> is set to <code>false</code>.</p>
<p><a name="err-XTTE0790" id="err-XTTE0790"><span class=
"error">[ERR XTTE0790]</span></a> If the value of a parameter to a
<a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet function</a> cannot be
converted to the required type, a <a title="type error" class=
"termref" href="#dt-type-error">type error</a> is signaled.</p>
<p>If the <code>as</code> attribute is omitted, no conversion takes
place and any value is accepted.</p>
</div>
<div class="div3">
<h4><a name="function-result" id="function-result"></a>10.3.3
<a href="#function-result" style="text-decoration: none">Function
Result</a></h4>
<p>The result of the function is the result of evaluating the
contained <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>.</p>
<p>Within the sequence constructor, the <a title="focus" class=
"termref" href="#dt-focus">focus</a> is initially <a title="absent"
class="termref" href="#dt-absent">absent</a>; this means that any
attempt to reference the context item, context position, or context
size is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a>. <a href=
"http://www.w3.org/TR/xpath-30/#ERRXPDY0002" title=
"XPDY0002"><span class="error">[ERR XPDY0002]</span></a>
<sup><small>XP30</small></sup></p>
<p>It is not possible within the body of the <a title=
"stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet function</a> to access the
values of local variables that were in scope in the place where the
function call was written. Global variables, however, remain
available.</p>
<p>The optional <code>as</code> attribute indicates the <a title=
"required type" class="termref" href="#dt-required-type">required
type</a> of the result of the function. The value of the
<code>as</code> attribute is a <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-SequenceType">SequenceType</a><sup><small>XP30</small></sup>,
as defined in <a href="#xpath-30">[XPath 3.0]</a>.</p>
<p><a name="err-XTTE0780" id="err-XTTE0780"><span class=
"error">[ERR XTTE0780]</span></a> If the <code>as</code> attribute
is specified, then the result evaluated by the <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> (see <a href=
"#sequence-constructors"><i>5.8 Sequence Constructors</i></a>) is
converted to the required type, using the <a title=
"function conversion rules" class="termref" href=
"#dt-function-conversion-rules">function conversion rules</a>. It
is a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> if this conversion fails. If the
<code>as</code> attribute is omitted, the calculated result is used
as supplied, and no conversion takes place.</p>
</div>
<div class="div3">
<h4><a name="function-visibility-and-overriding" id=
"function-visibility-and-overriding"></a>10.3.4 <a href=
"#function-visibility-and-overriding" style=
"text-decoration: none">Visibility and Overriding of
Functions</a></h4>
<p>If the <code>visibility</code> attribute is present with the
value <code>abstract</code> then the <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> defining the
function body <span class="verb">must</span> be empty.</p>
<p>A <a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet function</a> is included in
the <em>in-scope functions</em> of the static context for all XPath
expressions used in the <span>containing <a title="package" class=
"termref" href="#dt-package">package</a></span>, unless</p>
<ul>
<li>
<p>there is another <a title="stylesheet function" class="termref"
href="#dt-stylesheet-function">stylesheet function</a> with the
same name and <a title="arity" class="termref" href=
"#dt-arity">arity</a>, and higher <a title="import precedence"
class="termref" href="#dt-import-precedence">import precedence</a>,
or</p>
</li>
<li>
<p>the <code>override-extension-function</code> or
<code>override</code> attribute has the value <code>no</code> and
there is already a function with the same name and <a title="arity"
class="termref" href="#dt-arity">arity</a> in the in-scope
functions.</p>
</li>
</ul>
<p>The <a title="visibility" class="termref" href=
"#dt-visibility">visibility</a> of the function in other packages
depends on the value of the <code>visibility</code> attribute and
other factors, as described in <a href="#packages"><i>3.6
Packages</i></a></p>
<p>The optional
<span><code>override-extension-function</code></span> attribute
defines what happens if this function has the same name and
<a title="arity" class="termref" href="#dt-arity">arity</a> as a
function provided by the implementer or made available in the
static context using an implementation-defined mechanism. If the
<span><code>override-extension-function</code></span> attribute has
the value <code>yes</code>, then this function is used in
preference; if it has the value <code>no</code>, then the other
function is used in preference. The default value is
<code>yes</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Specifying
<span><code>override-extension-function="yes"</code></span> ensures
interoperable behavior: the same code will execute with all
processors. Specifying
<span><code>override-extension-function="no"</code></span> is
useful when writing a fallback implementation of a function that is
available with some processors but not others: it allows the
vendor's implementation of the function (or a user's implementation
written as an extension function) to be used in preference to the
stylesheet implementation, which is useful when the extension
function is more efficient.</p>
<p>The <code>override-extension-function</code> attribute does
<em>not</em> affect the rules for deciding which of several
<a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet functions</a> with the same
name and <a title="arity" class="termref" href=
"#dt-arity">arity</a> takes precedence.</p>
</div>
<p>The <code>override</code> attribute is a <a title="deprecated"
class="termref" href="#dt-deprecated">deprecated</a> synonym of
<code>override-extension-function</code>, retained for
compatibility with XSLT 2.0. If both attributes are present then
they <span class="verb">must</span> have the same value.</p>
<p><a name="err-XTSE0770" id="err-XTSE0770"><span class=
"error">[ERR XTSE0770]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> for a
<span><a title="package" class="termref" href=
"#dt-package">package</a></span> to contain two or more
<span>non-hidden</span> functions with the same <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a>, the same <a title="arity" class="termref" href=
"#dt-arity">arity</a>, and the same <a title="import precedence"
class="termref" href="#dt-import-precedence">import precedence</a>,
unless there is another function with the same <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a> and arity, and a higher import precedence.</p>
<p>When the <a href=
"#element-function"><code>xsl:function</code></a> declaration
appears as a child of <a href=
"#element-override"><code>xsl:override</code></a>, there
<span class="verb">must</span> be a stylesheet function with the
same <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> and <a title="arity" class=
"termref" href="#dt-arity">arity</a> in the <a title="package"
class="termref" href="#dt-package">package</a> referenced by the
containing <a href=
"#element-use-package"><code>xsl:use-package</code></a> element;
the <a title="visibility" class="termref" href=
"#dt-visibility">visibility</a> of that function must be
<code>public</code> or <code>abstract</code>, and the overriding
and overridden functions <span class="verb">must</span> have the
same argument types and result type.</p>
</div>
<div class="div3">
<h4><a name="streamable-stylesheet-functions" id=
"streamable-stylesheet-functions"></a>10.3.5 <a href=
"#streamable-stylesheet-functions" style=
"text-decoration: none">Streamability of Stylesheet
Functions</a></h4>
<p>Under specific conditions, described in this section, a
stylesheeet function can be used to process nodes from a streamed
input document.</p>
<p>A <a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet function</a> is <a title=
"guaranteed-streamable" class="termref" href=
"#dt-guaranteed-streamable">guaranteed-streamable</a> if all the
following conditions apply:</p>
<ol class="enumar">
<li>
<p>The <code>streamable</code> attribute of the <a href=
"#element-function"><code>xsl:function</code></a> declaration is
present with the value <code>yes</code>.</p>
</li>
<li>
<p>There is at most one parameter whose declared type permits
nodes. The declared type permits nodes if the <code>as</code>
attribute of the <a href=
"#element-param"><code>xsl:param</code></a> element is either
absent, or is set to a <code>SequenceType</code> that maps to a
<a title="U-type" class="termref" href="#dt-utype">U-type</a> that
has a non-empty intersection with <var>U{N}</var> (see <a href=
"#determining-static-type"><i>19.2 Determining the Static Type of a
Construct</i></a>).</p>
</li>
<li>
<p>At least one of the following conditions is true:</p>
<ol class="enumla">
<li>
<p>There is no parameter whose declared type permits nodes.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In this case, the body of the function is immaterial.</p>
</div>
</li>
<li>
<p>Both of the following conditions are true:</p>
<ol class="enumlr">
<li>
<p>The <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> forming the
body of the function declaration has a <a title="sweep" class=
"termref" href="#dt-sweep">sweep</a> that is either <a title=
"motionless" class="termref" href="#dt-motionless">motionless</a>
or <a title="consuming" class="termref" href=
"#dt-consuming">consuming</a>.</p>
</li>
<li>
<p>At least one of the following conditions is true:</p>
<ol class="enumua">
<li>
<p>The <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> forming the
body of the function declaration has a <a title="posture" class=
"termref" href="#dt-posture">posture</a> that is either <a title=
"grounded" class="termref" href="#dt-grounded">grounded</a> or
<a title="striding" class="termref" href=
"#dt-striding">striding</a>.</p>
</li>
<li>
<p>The return type of the function, expressed in the
<code>as</code> attribute of the <a href=
"#element-function"><code>xsl:function</code></a> element, is an
atomic or union type.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In this case the result of the function is atomized, and is
therefore grounded.</p>
</div>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>The consequences of declaring a <a title="stylesheet function"
class="termref" href="#dt-stylesheet-function">stylesheet
function</a> to be streamable when it is not in fact <a title=
"guaranteed-streamable" class="termref" href=
"#dt-guaranteed-streamable">guaranteed-streamable</a> depend on the
conformance level of the processor, and are explained in <a href=
"#streamability-guarantees"><i>19.10 Streamability
Guarantees</i></a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>If a stylesheet function is declared streamable, then any
override of the stylesheet function must also be declared
streamable, <span>and in addition must have the same posture and
sweep as the function that it overrides.</span></p>
</div>
<p>As explained in <a href=
"#streamability-of-function-calls"><i>19.8.7.12 Streamability of
Function Calls</i></a>, the <a title="posture" class="termref"
href="#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of a function call that calls a
streamable stylesheet function depend on whether the function call
is <b>analyzable</b>. A function call is analyzable if <span>the
function is not (directly or indirectly) recursive. This relies on
the rule that when a streamable function is overridden in a
different <a title="package" class="termref" href=
"#dt-package">package</a>, the overriding function must have the
same streamability properties as the function that it
overrides.</span></p>
<div class="example">
<div class="exampleHeader"><a name="d7e27971" id=
"d7e27971"></a>Example: A Streamable Stylesheet Function that is
Analyzable</div>
<p>The following stylesheet function is guaranteed streamable, and
is also analyzable:</p>
<div class="exampleInner">
<pre>
&lt;xsl:function name="f:depth" as="xs:integer" streamable="true" visibility="final"&gt;
  &lt;xsl:param name="e" as="element()"/&gt;
  &lt;xsl:sequence select="max($e//*/count(ancestor::*)) - count($e/ancestor::*)"/&gt;
&lt;/xsl:function&gt;
</pre></div>
<p>It is guaranteed streamable because its body is <a title=
"consuming" class="termref" href="#dt-consuming">consuming</a> and
<a title="grounded" class="termref" href=
"#dt-grounded">grounded</a>, and it is analyzable because it makes
no recursive function calls.</p>
<p>In consequence, a function call <code>f:depth(.)</code> applied
to a streamed node is itself <a title="consuming" class="termref"
href="#dt-consuming">consuming</a> and <a title="grounded" class=
"termref" href="#dt-grounded">grounded</a>.</p>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e27999" id=
"d7e27999"></a>Example: A Streamable Stylesheet Function that is
not Analyzable</div>
<p>The following stylesheet function is guaranteed streamable, and
is not analyzable:</p>
<div class="exampleInner">
<pre>
&lt;xsl:function name="f:contains-PI" as="xs:boolean" streamable="true" visibility="final"&gt;
  &lt;xsl:param name="e" as="node()"/&gt;
  &lt;xsl:sequence select="$e/self::processing-instruction() or $e/*/f:contains-PI(.) = true()"/&gt;
&lt;/xsl:function&gt;
</pre></div>
<p>This function is not analyzable because it makes a recursive
function call. The streamability analysis of the function call
therefore only takes into account the function signature, and not
its body. A call to a streamable function with an atomic return
type is deemed to be <a title="consuming" class="termref" href=
"#dt-consuming">consuming</a> and <a title="grounded" class=
"termref" href="#dt-grounded">grounded</a>. In consequence, the
sequence constructor forming the body of the function is itself
<a title="consuming" class="termref" href=
"#dt-consuming">consuming</a> and <a title="grounded" class=
"termref" href="#dt-grounded">grounded</a>, which means that the
function is <a title="guaranteed-streamable" class="termref" href=
"#dt-guaranteed-streamable">guaranteed-streamable</a>.</p>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e28018" id=
"d7e28018"></a>Example: A Streamable Stylesheet Function that
Returns Streamed Nodes</div>
<p>The following stylesheet function is guaranteed streamable, and
is not analyzable:</p>
<div class="exampleInner">
<pre>
&lt;xsl:function name="f:alternate-children" as="node()" streamable="true" visibility="final"&gt;
  &lt;xsl:param name="e" as="node()"/&gt;
  &lt;xsl:sequence select="$e/*[position() mod 2 = 1]"/&gt;
&lt;/xsl:function&gt;
</pre></div>
<p>This function is analyzable. The body is <a title="consuming"
class="termref" href="#dt-consuming">consuming</a> and <a title=
"striding" class="termref" href="#dt-striding">striding</a>. A call
on the function is therefore also <a title="consuming" class=
"termref" href="#dt-consuming">consuming</a> and <a title=
"striding" class="termref" href="#dt-striding">striding</a>.</p>
</div>
</div>
<div class="div3">
<h4><a name="function-lookup" id="function-lookup"></a>10.3.6
<a href="#function-lookup" style="text-decoration: none">Dynamic
Access to Functions</a></h4>
<p>If a <a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet function</a> with a particular
<a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> and <a title="arity" class=
"termref" href="#dt-arity">arity</a> exists in the stylesheet, then
a call to the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>
function-lookup</code></a><sup><small>FO30</small></sup> function
supplying that name and arity will return the function as a value.
This applies only if the static context for the call on <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>
function-lookup</code></a><sup><small>FO30</small></sup> includes
the stylesheet function, which implies that the function is visible
in the containing package.</p>
<p>The <a href=
"#func-function-available"><code>function-available</code></a>
function, when called with a particular <a title="expanded QName"
class="termref" href="#dt-expanded-qname">expanded QName</a> and
<a title="arity" class="termref" href="#dt-arity">arity</a>,
returns true if and only if a call on <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>
function-lookup</code></a><sup><small>FO30</small></sup> with the
same arguments, in the same static context, would return a function
item.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>For legacy reasons there is also a single-argument version of
<a href=
"#func-function-available"><code>function-available</code></a>,
which returns true if there is a function with the given name
regardless of arity.</p>
</div>
<p>The standard rules for <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>
function-lookup</code></a><sup><small>FO30</small></sup> require
that if the supplied name and arity identify a context-dependent
function such as <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-name"><code>name#0</code></a><sup><small>FO30</small></sup>
or <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-lang"><code>lang#1</code></a><sup><small>FO30</small></sup>
(call it <var>F</var>), then the returned function value includes
in its closure a copy of the static and dynamic context of the call
to <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>
function-lookup</code></a><sup><small>FO30</small></sup>, and the
context item for a subsequent dynamic call of <var>F</var> is taken
from this saved context. In the case where the context item is a
node in a streamed input document, saving the node is not possible.
In this case, therefore, the context is saved with an absent focus,
so the call on <var>F</var> will fail with a dynamic error saying
that there is no context item available.</p>
</div>
<div class="div3">
<h4><a name="function-determinism" id=
"function-determinism"></a>10.3.7 <a href="#function-determinism"
style="text-decoration: none">Determinism of Functions</a></h4>
<p>Stylesheet functions have been designed to be largely
deterministic: unless a stylesheet function calls some <a title=
"extension function" class="termref" href=
"#dt-extension-function">extension function</a> which is itself
nondeterministic, the function will return results that depend only
on the supplied arguments. This property (coupled with the fact
that the effect of calling extension functions is entirely
<a title="implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a>)
enables a processor to implement various optimizations, such as
removing invariant function calls from the body of a loop, or
combining common subexpressions,.</p>
<p>One exception to the intrinsic determinism of stylesheet
functions arises because constructed nodes have distinct identity.
This means that when a function that creates a new node is called,
two calls on the function will return nodes that can be
distinguished: for example, with such a function,
<code>f:make-node() is f:make-node()</code> will return false. This
property of functions is called <em>identity-sensitivity</em>. If a
processor cannot determine by static analysis that the function is
not identity-sensitive, then it cannot perform optimizations that
would observably change this behavior.</p>
<p>To allow processors greater freedom to optimize calls on
stylesheet functions, the attribute
<code>identity-sensitive="no"</code> may be specified (the default
is <code>yes</code>). When the value <code>no</code> is specified,
the stylesheet author is asserting that for any node passed in the
value of an argument to the function, and for any node returned as
a result, the stylesheet as a whole will give acceptable results if
the node is replaced by a different node that is deep-equal to the
original.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Note the term "acceptable". The result of the transformation may
be different, but not in a way that the stylesheet author cares
about.</p>
<p>Declaring a function with <code>identity-sensitive="no"</code>
might allow a call to the function to be moved out of a loop, so
the function is only called once before entry to the loop rather
than being called repeatedly within the loop. If the arguments to
the function depend only on global variables then it might enable
the function call to be moved into a global variable. It might also
enable some caching or memoization at the processor's
discretion.</p>
<p>Declaring a function with <code>identity-sensitive="no"</code>
might also allow nodes from a streamed input document to be passed
to the function, since the function is licensed to operate on a
deep copy of the node. However, the streamability analysis in this
specification does not take account of this possibility.</p>
</div>
</div>
<div class="div3">
<h4><a name="memoization" id="memoization"></a>10.3.8 <a href=
"#memoization" style="text-decoration: none">Memoization</a></h4>
<p>The <code>cache</code> attribute is an optimization hint which
the processor can use or ignore at its discretion; however it
should be taken seriously, because it may make a difference to
whether execution of a stylesheet is practically feasible or
not.</p>
<p>The default value is <code>cache="no".</code></p>
<p>The value <code>cache="full"</code> encourages the processor to
retain memory of all previous calls of this function during the
same transformation and to reuse results from this memory whenever
possible. The value <code>cache="partial"</code> encourages the
processor to retain such memory but to discard results if necessary
to keep the amount of memory used within bounds. The default value
<code>cache="no"</code> encourages the processor not to retain
memory of previous calls.</p>
<p>In all cases the results must respect the semantics; for example
if an attribute node is supplied as the value of an argument, then
its identity must be assumed to be significant unless (a)
<code>identity-sensitive="no"</code> is specified, or (b) the
processor is able to determine by static analysis that the identity
of the attribute node makes no difference to the result (for
example, because all references to the argument are atomizing
references).</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Memoization using the <code>cache</code> attribute may be more
effective if the attribute <code>identity-sensitive="no"</code> is
also used, as this gives a processor more scope for optimization.
In particular, specifying <code>cache="full"</code> by itself does
not remove the obligation of a processor to return distinct nodes
on each call of a function, whereas combining this with
<code>identity-sensitive="no"</code> does remove this
obligation.</p>
</div>
</div>
<div class="div3">
<h4><a name="function-examples" id="function-examples"></a>10.3.9
<a href="#function-examples" style="text-decoration: none">Examples
of Stylesheet Functions</a></h4>
<div class="example">
<div class="exampleHeader"><a name="d7e28188" id=
"d7e28188"></a>Example: A Stylesheet Function</div>
<p>The following example creates a recursive <a title=
"stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet function</a> named
<code>str:reverse</code> that reverses the words in a supplied
sentence, and then invokes this function from within a <a title=
"template rule" class="termref" href="#dt-template-rule">template
rule</a>.</p>
<div class="exampleInner">
<pre>
&lt;xsl:transform 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:str="http://example.com/namespace"
  version="3.0"
  exclude-result-prefixes="str"&gt;

&lt;xsl:function name="str:reverse" as="xs:string"&gt;
  &lt;xsl:param name="sentence" as="xs:string"/&gt;
  &lt;xsl:sequence  
     select="if (contains($sentence, ' '))
             then concat(str:reverse(substring-after($sentence, ' ')),
                         ' ',
                         substring-before($sentence, ' '))
             else $sentence"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:template match="/"&gt;
&lt;output&gt;
  &lt;xsl:value-of select="str:reverse('DOG BITES MAN')"/&gt;
&lt;/output&gt;
&lt;/xsl:template&gt;

&lt;/xsl:transform&gt;
</pre></div>
<p>An alternative way of writing the same function is to implement
the conditional logic at the XSLT level, thus:</p>
<div class="exampleInner">
<pre>
&lt;xsl:function name="str:reverse" as="xs:string"&gt;
  &lt;xsl:param name="sentence" as="xs:string"/&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="contains($sentence, ' ')"&gt;  
      &lt;xsl:sequence 
           select="concat(str:reverse(substring-after($sentence, ' ')),
                                ' ',
                                substring-before($sentence, ' '))"/&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:sequence select="$sentence"/&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:function&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e28208" id=
"d7e28208"></a>Example: Declaring the Return Type of a
Function</div>
<p>The following example illustrates the use of the <code>as</code>
attribute in a function definition. It returns a string containing
the representation of its integer argument, expressed as a roman
numeral. For example, the function call <code>num:roman(7)</code>
will return the string <code>"vii"</code>. This example uses the
<a href="#element-number"><code>xsl:number</code></a> instruction,
described in <a href="#number"><i>12 Numbering</i></a>. The
<a href="#element-number"><code>xsl:number</code></a> instruction
returns a text node, and the <a title="function conversion rules"
class="termref" href="#dt-function-conversion-rules">function
conversion rules</a> are invoked to convert this text node to the
type declared in the <a href=
"#element-function"><code>xsl:function</code></a> element, namely
<code>xs:string</code>. So the text node is <a title="atomize"
class="termref" href="#dt-atomization">atomized</a> to a
string.</p>
<div class="exampleInner">
<pre>
&lt;xsl:function name="num:roman" as="xs:string"&gt;
  &lt;xsl:param name="value" as="xs:integer"/&gt;
  &lt;xsl:number value="$value" format="i"/&gt;
&lt;/xsl:function&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e28245" id=
"d7e28245"></a>Example: A Higher-Order Function</div>
<p>XPath 3.0 introduces the ability to pass function items as
argument to a function. A function that takes function items as
arguments is known as a higher-order function.</p>
<p>The following example is a higher-order function that operates
on any tree-structured data, for example an organization chart.
Given as input a function that finds the direct subordinates of a
node in this tree structure (for example, the direct reports of a
manager, or the geographical subdivisions of an administrative
area), it determines whether one object is present in the subtree
rooted at another object (for example, whether one person is among
the staff managed directly or indirectly by a manager, or whether
one parcel of land is contained directly or indirectly within
another parcel). The function does not check for cycles in the
data.</p>
<div class="exampleInner">
<pre>
&lt;xsl:function name="f:is-subordinate" as="xs:boolean"&gt;
    &lt;xsl:param name="superior" 
               as="node()"/&gt;
    &lt;xsl:param name="subordinate" 
               as="node()"/&gt;
    &lt;xsl:param name="get-direct-children" 
               as="function(node()) as node()*"/&gt;
    &lt;xsl:sequence select="
               some $sub in $get-direct-children($superior) satisfies
                 ($sub is $subordinate or
                  f:is-subordinate($sub, $subordinate, 
                                      $get-direct-children))"/&gt;
&lt;/xsl:function&gt;
</pre></div>
<p>Given source data representing an organization chart in the form
of elements such as:</p>
<div class="exampleInner">
<pre>
&lt;employee id="P57832" manager="P68951"/&gt;
</pre></div>
<p>the following function can be defined to get the direct reports
of a manager:</p>
<div class="exampleInner">
<pre>
&lt;xsl:function name="f:direct-reports" 
               as="element(employee)*"&gt;
    &lt;xsl:param name="manager" as="element(employee)"/&gt;
    &lt;xsl:sequence select="$manager/../employee
                               [@manager = $manager/@id]"/&gt;
&lt;/xsl:function&gt;
</pre></div>
<p>It is then possible to test whether one employee <code>$E</code>
reports directly or indirectly to another employee <code>$M</code>
by means of the function call:</p>
<div class="exampleInner">
<pre>
f:is-subordinate($M, $E, f:direct-reports#1)
</pre></div>
</div>
</div>
</div>
<div class="div2">
<h3><a name="dynamic-xpath" id="dynamic-xpath"></a>10.4 <a href=
"#dynamic-xpath" style="text-decoration: none">Dynamic XPath
Evaluation</a></h3>
<p class="element-syntax"><a name="element-evaluate" id=
"element-evaluate"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:evaluate<br />
&#160;&#160;<b>xpath</b> = <var>expression</var><br />
&#160;&#160;as? = <var>sequence-type</var><br />
&#160;&#160;base-uri? = { <var>uri</var> }<br />
&#160;&#160;with-params? = <var>expression</var><br />
&#160;&#160;context-item? = <var>expression</var><br />
&#160;&#160;namespace-context? = <var>expression</var><br />
&#160;&#160;schema-aware? = { <var>boolean</var> }&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-with-param">xsl:with-param</a> | <a href=
"#element-fallback">xsl:fallback</a>)* --&gt;<br />
&lt;/xsl:evaluate&gt;</code></p>
<p>The <a href="#element-evaluate"><code>xsl:evaluate</code></a>
instruction constructs an XPath expression in the form of a string,
evaluates the expression in a specified context, and returns the
result of the evaluation.</p>
<p>The expression given as the value of the <code>xpath</code>
attribute is evaluated and the result is converted to a string
using the <a title="function conversion rules" class="termref"
href="#dt-function-conversion-rules">function conversion
rules</a>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-target-expression" id="dt-target-expression" title=
"target expression"></a>The string that results from evaluating the
expression in the <code>xpath</code> attribute is referred to as
the <b>target expression</b>.<span class="definition">]</span></p>
<p><a name="err-XTDE3160" id="err-XTDE3160"><span class=
"error">[ERR XTDE3160]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<a title="target expression" class="termref" href=
"#dt-target-expression">target expression</a> is not a valid XPath
3.0 expression (that is, if a static error occurs when analyzing
the string according to the rules of the XPath 3.0
specification).</p>
<p>The <code>as</code> attribute, if present, indicates the
required type of the result. If the attribute is absent, the
required type is <code>item()*</code>, which allows any result. The
result of evaluating the <a title="target expression" class=
"termref" href="#dt-target-expression">target expression</a> is
converted to the required type using the <a title=
"function conversion rules" class="termref" href=
"#dt-function-conversion-rules">function conversion rules</a>. This
may cause a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> if conversion is not possible. The
result after conversion is returned as the result of the <a href=
"#element-evaluate"><code>xsl:evaluate</code></a> instruction.</p>
<p>The target expression may contain variable references; the
values of such variables may be supplied using an <a href=
"#element-with-param"><code>xsl:with-param</code></a> child
instruction if the names of the variables are known statically, or
using a map supplied as the value of the expression in the
<code>with-params</code> attribute if the names are only known
dynamically. If the <code>with-params</code> attribute is present
then it must contain an expression whose value, when evaluated, is
of type <code>map(xs:QName, item()*)</code> (see <a href=
"#map"><i>21.1 Maps</i></a> for details of maps).</p>
<div class="div3">
<h4><a name="evaluate-static-context" id=
"evaluate-static-context"></a>10.4.1 <a href=
"#evaluate-static-context" style="text-decoration: none">Static
context for the target expression</a></h4>
<p>The <a href=
"http://www.w3.org/TR/xpath-30/#dt-static-context">static
context</a><sup><small>XP30</small></sup> for the <a title=
"target expression" class="termref" href=
"#dt-target-expression">target expression</a> is as follows:</p>
<ul>
<li>
<p>XPath 1.0 compatibility mode is <code>false</code>.</p>
</li>
<li>
<p>Statically known namespaces and default element/type
namespace:</p>
<ul>
<li>
<p>if the <code>namespace-context</code> attribute is present, then
its value is an <a title="expression" class="termref" href=
"#dt-expression">expression</a> whose required type is a single
node. The expression is evaluated, and the in-scope namespaces of
the resulting node are used as the statically known namespaces for
the target expression. The binding for the default namespace in the
in-scope namespaces is used as the default namespace for elements
and types in the target expression.</p>
<p><a name="err-XTTE3170" id="err-XTTE3170"><span class=
"error">[ERR XTTE3170]</span></a> It is a <a title="type error"
class="termref" href="#dt-type-error">type error</a> if the result
of evaluating the <code>namespace-context</code> attribute of the
<a href="#element-evaluate"><code>xsl:evaluate</code></a>
instruction is anything other than a single node.</p>
</li>
<li>
<p>if the <code>namespace-context</code> attribute is absent, then
the in-scope namespaces of the <a href=
"#element-evaluate"><code>xsl:evaluate</code></a> instruction (with
the exception of any binding for the default namespace) are used as
the statically known namespaces for the target expression, and the
value of the innermost <code>[xsl:]xpath-default-namespace</code>
attribute, if any, is used as the default namespace for elements
and types in the target expression.</p>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>XPath 3.0 allows expanded names to be written in a
context-independent way using the syntax
<code>Q{namespace-uri}local-name</code></p>
</div>
</li>
<li>
<p>Default function namespace: the <a title=
"standard function namespace" class="termref" href=
"#dt-standard-function-namespace">standard function
namespace</a>.</p>
</li>
<li>
<p>In-scope schema definitions: if the <code>schema-aware</code>
attribute is present and has the <a title="effective value" class=
"termref" href="#dt-effective-value">effective value</a>
<code>yes</code>, then the in-scope schema definitions from the
stylesheet context (that is, the schema definitions imported using
<a href=
"#element-import-schema"><code>xsl:import-schema</code></a>).
Otherwise, the built-in types (see <a href=
"#built-in-types"><i>3.15 Built-in Types</i></a>).</p>
</li>
<li>
<p>In-scope variables: the names of the in-scope variables are the
union of the names appearing in the <code>name</code> attribute of
the contained <a href=
"#element-with-param"><code>xsl:with-param</code></a> elements, and
the names present as keys in the map obtained by evaluating the
<code>with-params</code> attribute, if present. The corresponding
type is <code>item()*</code> in the case of a name found as a key
in the <code>with-params</code> map, or the type named in the
<code>as</code> attribute of <a href=
"#element-with-param"><code>xsl:with-param</code></a> child
(defaulting to <code>item()*</code>) otherwise.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Variables declared in the stylesheet in <a href=
"#element-variable"><code>xsl:variable</code></a> or <a href=
"#element-param"><code>xsl:param</code></a> elements are
<em>not</em> in-scope within the target expression.</p>
<p>If variable names are present in both the static <a href=
"#element-with-param"><code>xsl:with-param</code></a> children and
also in the dynamic <code>with-params</code> map, the value from
the latter takes precedence.</p>
</div>
</li>
<li>
<p>Function signatures: All <a title="core function" class=
"termref" href="#dt-core-function">core functions</a>; constructor
functions for <span>named simple</span> types included in the
in-scope schema definitions; all user-defined functions <span>and
accumulator functions present in the containing package provided
their visibility is not <code>hidden</code> or
<code>private</code>;</span> and an <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> set of
<a title="extension function" class="termref" href=
"#dt-extension-function">extension functions</a>.</p>
<p>Note that this set deliberately excludes XSLT-defined functions
in the <a title="standard function namespace" class="termref" href=
"#dt-standard-function-namespace">standard function namespace</a>
including for example, <a href="#func-key"><code>key</code></a>,
<a href="#func-current-group"><code>current-group</code></a>, and
<a href="#func-system-property"><code>system-property</code></a> A
list of these functions is in <a href=
"#XSLT-defined-functions"><i>G List of XSLT-defined
functions</i></a>.</p>
</li>
<li>
<p>Statically known collations: the same as the collations
available at this point in the stylesheet.</p>
</li>
<li>
<p>Default collation: the same as the default collation defined at
this point in the stylesheet (for example, by use of the
<code>[xsl:]default-collation</code> attribute)</p>
</li>
<li>
<p>Base URI: if the <code>base-uri</code> attribute is present,
then its <a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a>; otherwise, the base URI
of the <a href="#element-evaluate"><code>xsl:evaluate</code></a>
instruction.</p>
</li>
<li>
<p>Statically known documents: the empty set</p>
</li>
<li>
<p>Statically known collections: the empty set</p>
</li>
<li>
<p>Statically known default collection type:
<code>node()*</code></p>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="evaluate-dynamic-context" id=
"evaluate-dynamic-context"></a>10.4.2 <a href=
"#evaluate-dynamic-context" style="text-decoration: none">Dynamic
context for the target expression</a></h4>
<p>The dynamic context for evaluation of the target expression is
as follows:</p>
<ul>
<li>
<p>The context item, position, and size depend on the result of
evaluating the expression in the <code>context-item</code>
attribute. If this attribute is absent, or if the result is an
empty sequence, then the context item, position, and size for
evaluation of the target expression are all <a title="absent"
class="termref" href="#dt-absent">absent</a>. If the result of
evaluating the <code>context-item</code> expression is a single
item, then the target expression is evaluated with a <a title=
"singleton focus" class="termref" href=
"#dt-singleton-focus">singleton focus</a> based on this item.</p>
<p><a name="err-XTTE3210" id="err-XTTE3210"><span class=
"error">[ERR XTTE3210]</span></a> If the result of evaluating the
<code>context-item</code> expression is a sequence containing more
than one item, then a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> is signaled.</p>
</li>
<li>
<p>The <b>variable values</b> consists of the values bound to
parameters defined either in the contained <a href=
"#element-with-param"><code>xsl:with-param</code></a> elements,
which are evaluated as described in <a href=
"#variable-values"><i>9.3 Values of Variables and
Parameters</i></a>, or in the map that results from evaluation of
the expression in the <code>with-params</code> attribute; if the
same QName is bound in both, the value in the
<code>with-params</code> map takes precedence.</p>
</li>
<li>
<p>The XSLT-specific aspects of the dynamic context described in
<a href="#additional-dynamic-context"><i>5.4.4 Additional Dynamic
Context Components used by XSLT</i></a> are all <a title="absent"
class="termref" href="#dt-absent">absent</a>.</p>
</li>
<li>
<p>All other aspects of the dynamic context are the same as the
dynamic context for the <a href=
"#element-evaluate"><code>xsl:evaluate</code></a> instruction
itself, <span>except that an implementation <code>may</code>
restrict the availability of external resources (for example,
available documents) or provide options to restrict their
availability, for security reasons</span>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>For example, a processor may disallow access using the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>
or <a href="#func-document"><code>document</code></a> functions to
documents in local filestore.</p>
</div>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="evaluate-effect" id="evaluate-effect"></a>10.4.3
<a href="#evaluate-effect" style="text-decoration: none">The effect
of the</a> <code>xsl:evaluate</code> <a href="#evaluate-effect"
style="text-decoration: none">instruction</a></h4>
<p>The XPath expression is evaluated in the same <a href=
"http://www.w3.org/TR/xpath-functions-30/#execution-scope">execution
scope</a><sup><small>FO30</small></sup> as the calling XSLT
transformation; this means that the results of <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>
functions such as <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>
or <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-current-dateTime"><code>
current-dateTime</code></a><sup><small>FO30</small></sup> will be
consistent between the calling stylesheet and the called XPath
expression.</p>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if evaluation of the XPath
expression fails with a dynamic error. The XPath-defined error code
is used unchanged.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Implementations wanting to avoid the cost of repeated
compilation of the same XPath expression should cache the compiled
form internally.</p>
</div>
<p>Stylesheet authors need to be aware of the security risks
associated with the use of <a href=
"#element-evaluate"><code>xsl:evaluate</code></a>. The instruction
should not be used to execute code from an untrusted source. To
avoid the risk of code injection, user-supplied data should never
be inserted into the expression using string concatenation, but
should always be referenced by use of parameters.</p>
</div>
<div class="div3">
<h4><a name="evaluation-as-optional-feature" id=
"evaluation-as-optional-feature"></a>10.4.4 <a href=
"#element-evaluate"><code>xsl:evaluate</code></a> <a href=
"#evaluation-as-optional-feature" style="text-decoration: none">as
an optional feature</a></h4>
<p>The <a href="#element-evaluate"><code>xsl:evaluate</code></a>
instruction is newly introduced in XSLT 3.0. It is part of the
dynamic evaluation feature, which is an optional feature of the
specification (see <a href="#dynamic-evaluation-feature"><i>26.6
Dynamic Evaluation Feature</i></a>). An XSLT 3.0 processor
<span class="verb">may</span> disable the feature, or allow users
to disable the feature. The processor <span class="verb">may</span>
be able to determine during static analysis whether or not the
feature is available, or it <span class="verb">may</span> only be
able to determine this during dynamic evaluation. In the first case
we refer to the feature being <b>statically disabled</b>, in the
second case to it being <b>dynamically disabled</b>.</p>
<p>If the feature is statically disabled, then:</p>
<ul>
<li>
<p>A call to <code>element-available('xsl:evaluate')</code> returns
false, wherever it appears;</p>
</li>
<li>
<p>A call to
<code>system-property('xsl:supports-dynamic-evaluation')</code>
returns "no", wherever it appears;</p>
</li>
<li>
<p>If an <a href="#element-evaluate"><code>xsl:evaluate</code></a>
instruction has an <a href=
"#element-fallback"><code>xsl:fallback</code></a> child, fallback
processing takes place;</p>
</li>
<li>
<p>No static error is raised if an <a href=
"#element-evaluate"><code>xsl:evaluate</code></a> instruction is
present in the stylesheet (an error occurs only if it is actually
evaluated).</p>
</li>
</ul>
<p>If the feature is dynamically disabled, then:</p>
<ul>
<li>
<p>A call to <code>element-available('xsl:evaluate')</code>
appearing in a <a title="static expression" class="termref" href=
"#dt-static-expression">static expression</a> (for example, in an
<code>[xsl:]use-when</code> attribute) returns true;</p>
</li>
<li>
<p>A call to <code>element-available('xsl:evaluate')</code>
appearing anywhere else returns false;</p>
</li>
<li>
<p>A call to
<code>system-property('xsl:supports-dynamic-evaluation')</code>
appearing in a <a title="static expression" class="termref" href=
"#dt-static-expression">static expression</a> (for example, in an
<code>[xsl:]use-when</code> attribute) returns "yes";</p>
</li>
<li>
<p>A call to
<code>system-property('xsl:supports-dynamic-evaluation')</code>
appearing anywhere else returns "no";</p>
</li>
<li>
<p>If an <a href="#element-evaluate"><code>xsl:evaluate</code></a>
instruction has an <a href=
"#element-fallback"><code>xsl:fallback</code></a> child, fallback
processing takes place;</p>
</li>
<li>
<p>In the absence of an <a href=
"#element-fallback"><code>xsl:fallback</code></a> child, a dynamic
error is raised if an <a href=
"#element-evaluate"><code>xsl:evaluate</code></a> instruction is
evaluated. The dynamic error may be caught using <a href=
"#element-try"><code>xsl:try</code></a> and <a href=
"#element-catch"><code>xsl:catch</code></a>.</p>
</li>
</ul>
<p><a name="err-XTDE3175" id="err-XTDE3175"><span class=
"error">[ERR XTDE3175]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if an
<a href="#element-evaluate"><code>xsl:evaluate</code></a>
instruction is evaluated when use of <a href=
"#element-evaluate"><code>xsl:evaluate</code></a> has been
statically or dynamically disabled.</p>
<p>In consequence of these rules, the recommended approach for
stylesheet authors to write code that works whether or not <a href=
"#element-evaluate"><code>xsl:evaluate</code></a> is enabled is to
use an <a href="#element-fallback"><code>xsl:fallback</code></a>
child instruction. For example:</p>
<div class="exampleInner">
<pre>
    &lt;xsl:variable name="isValid" as="xs:boolean"&gt;
      &lt;xsl:evaluate xpath="$validityCondition"&gt;
         &lt;xsl:fallback&gt;&lt;xsl:sequence select="true()"/&gt;&lt;/xsl:fallback&gt;
      &lt;/xsl:evaluate&gt;
      &lt;/xsl:variable&gt;
</pre></div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>There may be circumstances where it is inappropriate to allow
use of <a href="#element-evaluate"><code>xsl:evaluate</code></a>.
For example:</p>
<ul>
<li>
<p>There may be security risks associated with the ability to
execute code from an untrusted source, which cannot be inspected
during static analysis.</p>
</li>
<li>
<p>There may be environments where the available computing
resources are sufficient to enable pre-compiled stylesheets to be
executed, but not to enable XPath expressions to be compiled into
executable code.</p>
</li>
</ul>
<p>Processors that implement <a href=
"#element-evaluate"><code>xsl:evaluate</code></a> should provide
mechanisms allowing calls on <a href=
"#element-evaluate"><code>xsl:evaluate</code></a> to be disabled.
Implementations may disable the feature by default, and they may
disable it unconditionally.</p>
</div>
</div>
<div class="div3">
<h4><a name="evaluate-examples" id="evaluate-examples"></a>10.4.5
<a href="#evaluate-examples" style="text-decoration: none">Examples
of</a> <a href=
"#element-evaluate"><code>xsl:evaluate</code></a></h4>
<div class="example">
<div class="exampleHeader"><a name="d7e28870" id=
"d7e28870"></a>Example: Using a Dynamic Sort Key</div>
<p>A common requirement is to sort a table on the value of an
expression which is selected at run-time, perhaps by supplying the
expression as a string-valued parameter to the stylesheet. Suppose
that such an expression is supplied to the parameter:</p>
<div class="exampleInner">
<pre>
&lt;xsl:param name="sortkey" as="xs:string" select="'@name'"/&gt;
</pre></div>
<p>Then the data may be sorted as follows:</p>
<div class="exampleInner">
<pre>
&lt;xsl:sort&gt;
   &lt;xsl:evaluate xpath="$sortkey" as="xs:string" context-item="."/&gt;
&lt;/xsl:sort&gt;
</pre></div>
<p>Note the importance in this use case of caching the compiled
expression, since it is evaluated repeatedly, once for each item in
the list being sorted.</p>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e28883" id=
"d7e28883"></a>Example: Getting a Function if it Exists</div>
<p>The <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>
function-lookup</code></a><sup><small>FO30</small></sup> function,
if it were not available in the standard library, could be
implemented like this:</p>
<div class="exampleInner">
<pre>
     &lt;xsl:function name="f:function-lookup"&gt;
       &lt;xsl:param name="name" as="xs:QName"/&gt;
       &lt;xsl:param name="arity" as="xs:integer"/&gt;
       &lt;xsl:evaluate xpath="'Q{' || namespace-uri-from-QName($name) || '}' 
                      || local-name-from-QName($name) || '#' || $arity"&gt;
         &lt;xsl:with-param name="name" as="xs:QName" select="$name"/&gt;
         &lt;xsl:with-param name="arity" as="xs:integer" select="$arity"/&gt;
       &lt;/xsl:evaluate&gt;
     &lt;/xsl:function&gt;  
     
</pre></div>
<p>The <a href="#element-evaluate"><code>xsl:evaluate</code></a>
instruction uses the supplied QName and arity to construct an
expression of the form <code>Q{namespace-uri}local#arity</code>,
which is then evaluated to return a function item representing the
requested function.</p>
</div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="creating-new-nodes" id="creating-new-nodes"></a>11
<a href="#creating-new-nodes" style=
"text-decoration: none">Creating Nodes and Sequences</a></h2>
<p>This section describes instructions that directly create new
nodes, or sequences of nodes, atomic values, <span>and/or function
items</span>.</p>
<div class="div2">
<h3><a name="literal-result-element" id=
"literal-result-element"></a>11.1 <a href="#literal-result-element"
style="text-decoration: none">Literal Result Elements</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-literal-result-element" id="dt-literal-result-element" title=
"literal result element"></a>In a <a title="sequence constructor"
class="termref" href="#dt-sequence-constructor">sequence
constructor</a>, an element in the <a title="stylesheet" class=
"termref" href="#dt-stylesheet">stylesheet</a> that does not belong
to the <a title="XSLT namespace" class="termref" href=
"#dt-xslt-namespace">XSLT namespace</a> and that is not an
<a title="extension instruction" class="termref" href=
"#dt-extension-instruction">extension instruction</a> (see <a href=
"#extension-instruction"><i>23.2 Extension Instructions</i></a>) is
classified as a <b>literal result element</b>.<span class=
"definition">]</span> A literal result element is evaluated to
construct a new element node with the same <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a> (that is, the same namespace URI, local name, and
namespace prefix). The result of evaluating a literal result
element is a node sequence containing one element, the newly
constructed element node.</p>
<p>The content of the element is a <a title="sequence constructor"
class="termref" href="#dt-sequence-constructor">sequence
constructor</a> (see <a href="#sequence-constructors"><i>5.8
Sequence Constructors</i></a>). The sequence obtained by evaluating
this sequence constructor, after prepending any attribute nodes
produced as described in <a href="#attributes-for-lres"><i>11.1.2
Attribute Nodes for Literal Result Elements</i></a> and namespace
nodes produced as described in <a href="#lre-namespaces"><i>11.1.3
Namespace Nodes for Literal Result Elements</i></a>, is used to
construct the content of the element, following the rules in
<a href="#constructing-complex-content"><i>5.8.1 Constructing
Complex Content</i></a></p>
<p>The base URI of the new element is copied from the base URI of
the literal result element in the stylesheet, unless the content of
the new element includes an <code>xml:base</code> attribute, in
which case the base URI of the new element is the value of that
attribute, resolved (if it is a relative URI
<span>reference</span>) against the base URI of the literal result
element in the stylesheet. (Note, however, that this is only
relevant when creating a parentless element. When the literal
result element is copied to form a child of an element or document
node, the base URI of the new copy is taken from that of its new
parent.)</p>
<div class="div3">
<h4><a name="setting-annotation-for-lre" id=
"setting-annotation-for-lre"></a>11.1.1 <a href=
"#setting-annotation-for-lre" style="text-decoration: none">Setting
the Type Annotation for Literal Result Elements</a></h4>
<p>The attributes <code>xsl:type</code> and
<code>xsl:validation</code> may be used on a literal result element
to invoke validation of the contents of the element against a type
definition or element declaration in a schema, and to determine the
<a title="type annotation" class="termref" href=
"#dt-type-annotation">type annotation</a> that the new element node
will carry. These attributes also affect the type annotation
carried by any elements and attributes that have the new element
node as an ancestor. These two attributes are both optional, and if
one is specified then the other <span class="verb">must</span> be
omitted.</p>
<p>The value of the <code>xsl:validation</code> attribute, if
present, must be one of the values <code>strict</code>,
<code>lax</code>, <code>preserve</code>, or <code>strip</code>. The
value of the <code>xsl:type</code> attribute, if present, must be
an <span><a title="EQName" class="termref" href=
"#dt-eqname">EQName</a></span> identifying a type definition that
is present in the <a title="in-scope schema component" class=
"termref" href="#dt-in-scope-schema-component">in-scope schema
components</a> for the stylesheet. Neither attribute may be
specified as an <a title="attribute value template" class="termref"
href="#dt-attribute-value-template">attribute value template.</a>
The effect of these attributes is described in <a href=
"#validation"><i>24.4 Validation</i></a>.</p>
</div>
<div class="div3">
<h4><a name="attributes-for-lres" id=
"attributes-for-lres"></a>11.1.2 <a href="#attributes-for-lres"
style="text-decoration: none">Attribute Nodes for Literal Result
Elements</a></h4>
<p>Attribute nodes for a literal result element may be created by
including <a href=
"#element-attribute"><code>xsl:attribute</code></a> instructions
within the <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>. Additionally,
attribute nodes are created corresponding to the attributes of the
literal result element in the stylesheet, and as a result of
expanding the <code>xsl:use-attribute-sets</code> attribute of the
literal result element, if present.</p>
<p>The sequence that is used to construct the content of the
literal result element (as described in <a href=
"#constructing-complex-content"><i>5.8.1 Constructing Complex
Content</i></a>) is the concatenation of the following four
sequences, in order:</p>
<ol class="enumar">
<li>
<p>The sequence of namespace nodes produced as described in
<a href="#lre-namespaces"><i>11.1.3 Namespace Nodes for Literal
Result Elements</i></a>.</p>
</li>
<li>
<p>The sequence of attribute nodes produced by expanding the
<code>xsl:use-attribute-sets</code> attribute (if present)
following the rules given in <a href="#attribute-sets"><i>10.2
Named Attribute Sets</i></a></p>
</li>
<li>
<p>The attributes produced by processing the attributes of the
literal result element itself, other than attributes in the
<a title="XSLT namespace" class="termref" href=
"#dt-xslt-namespace">XSLT namespace</a>. The way these are
processed is described below.</p>
</li>
<li>
<p>The sequence produced by evaluating the contained <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>, if the element
is not empty.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The significance of this order is that an attribute produced by
an <code>xsl:attribute</code>, <a href=
"#element-copy"><code>xsl:copy</code></a>, or <a href=
"#element-copy-of"><code>xsl:copy-of</code></a> instruction in the
content of the literal result element takes precedence over an
attribute produced by expanding an attribute of the literal result
element itself, which in turn takes precedence over an attribute
produced by expanding the <code>xsl:use-attribute-sets</code>
attribute. This is because of the rules in <a href=
"#constructing-complex-content"><i>5.8.1 Constructing Complex
Content</i></a>, which specify that when two or more attributes in
the sequence have the same name, all but the last of the duplicates
are discarded.</p>
<p>Although the above rules place namespace nodes before
attributes, this is not strictly necessary, because the rules in
<a href="#constructing-complex-content"><i>5.8.1 Constructing
Complex Content</i></a> allow the namespaces and attributes to
appear in any order so long as both come before other kinds of
node. The order of namespace nodes and attribute nodes in the
sequence has no effect on the relative position of the nodes in
document order once they are added to a tree.</p>
</div>
<p>Each attribute of the literal result element, other than an
attribute in the <a title="XSLT namespace" class="termref" href=
"#dt-xslt-namespace">XSLT namespace</a>, is processed to produce an
attribute for the element in the <a title="result tree" class=
"termref" href="#dt-result-tree">result tree</a>.</p>
<p>The value of such an attribute is interpreted as an <a title=
"attribute value template" class="termref" href=
"#dt-attribute-value-template">attribute value template</a>: it can
therefore contain <a title="expression" class="termref" href=
"#dt-expression">expressions</a> contained in curly brackets
(<code>{}</code>). The new attribute node will have the same
<a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> (that is, the same
namespace URI, local name, and namespace prefix) as the attribute
in the stylesheet tree, and its <a title="string value" class=
"termref" href="#dt-string-value">string value</a> will be the same
as the <a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the attribute in the
stylesheet tree. The <a title="type annotation" class="termref"
href="#dt-type-annotation">type annotation</a> on the attribute
will initially be <code>xs:untypedAtomic</code>, and the <a title=
"typed value" class="termref" href="#dt-typed-value">typed
value</a> of the attribute node will be the same as its <a title=
"string value" class="termref" href="#dt-string-value">string
value</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The eventual <a title="type annotation" class="termref" href=
"#dt-type-annotation">type annotation</a> of the attribute in the
<a title="result tree" class="termref" href=
"#dt-result-tree">result tree</a> depends on the
<code>xsl:validation</code> and <code>xsl:type</code> attributes of
the parent literal result element, and on the instructions used to
create its ancestor elements. If the <code>xsl:validation</code>
attribute is set to <code>preserve</code> or <code>strip</code>,
the type annotation will be <code>xs:untypedAtomic</code>, and the
<a title="typed value" class="termref" href="#dt-typed-value">typed
value</a> of the attribute node will be the same as its <a title=
"string value" class="termref" href="#dt-string-value">string
value</a>. If the <code>xsl:validation</code> attribute is set to
<code>strict</code> or <code>lax</code>, or if the
<code>xsl:type</code> attribute is used, the type annotation on the
attribute will be set as a result of the schema validation process
applied to the parent element. If neither attribute is present, the
type annotation on the attribute will be
<code>xs:untypedAtomic</code>.</p>
</div>
<p>If the name of a constructed attribute is <code>xml:id</code>,
the processor must perform attribute value normalization by
effectively applying the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-normalize-space"><code>
normalize-space</code></a><sup><small>FO30</small></sup> function
to the value of the attribute, and the resulting attribute node
must be given the <code>is-id</code> property.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>If the attribute name is <code>xml:space</code>, it is
<em>not</em> an error when the value is something other than
<code>default</code> or <code>preserve</code>. Although the XML
specification states that other values are erroneous, a document
containing such values is well-formed; if erroneous values are to
be rejected, schema validation should be used.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The <code>xml:base</code>, <code>xml:lang</code>,
<code>xml:space</code>, and <code>xml:id</code> attributes have two
effects in XSLT. They behave as standard XSLT attributes, which
means for example that if they appear on a literal result element,
they will be copied to the <a title="result tree" class="termref"
href="#dt-result-tree">result tree</a> in the same way as any other
attribute. In addition, they have their standard meaning as defined
in the core XML specifications. Thus, an <code>xml:base</code>
attribute in the stylesheet affects the base URI of the element on
which it appears, and an <code>xml:space</code> attribute affects
the interpretation of <a title="whitespace text node" class=
"termref" href="#dt-whitespace-text-node">whitespace text nodes</a>
within that element. One consequence of this is that it is
inadvisable to write these attributes as attribute value templates:
although an XSLT processor will understand this notation, the XML
parser will not. See also <a href="#namespace-aliasing"><i>11.1.5
Namespace Aliasing</i></a> which describes how to use <a href=
"#element-namespace-alias"><code>xsl:namespace-alias</code></a>
with these attributes.</p>
<p>The same is true of the schema-defined attributes
<code>xsi:type</code>, <code>xsi:nil</code>,
<code>xsi:noNamespaceSchemaLocation</code>, and
<code>xsi:schemaLocation</code>. If the stylesheet is processed by
a schema processor, these attributes will be recognized and
interpreted by the schema processor, but in addition the XSLT
processor treats them like any other attribute on a literal result
element: that is, their <a title="effective value" class="termref"
href="#dt-effective-value">effective value</a> (after expanding
<a title="attribute value template" class="termref" href=
"#dt-attribute-value-template">attribute value templates</a>) is
copied to the result tree in the same way as any other attribute.
If the <a title="result tree" class="termref" href=
"#dt-result-tree">result tree</a> is validated, the copied
attributes will again be recognized and interpreted by the schema
processor.</p>
<p>None of these attributes will be generated in the <a title=
"result tree" class="termref" href="#dt-result-tree">result
tree</a> unless the stylesheet writes them to the result tree
explicitly, in the same way as any other attribute.</p>
</div>
<p><a name="err-XTSE0805" id="err-XTSE0805"><span class=
"error">[ERR XTSE0805]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if an
attribute on a literal result element is in the <a title=
"XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT
namespace</a>, unless it is one of the attributes explicitly
defined in this specification.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>If there is a need to create attributes in the XSLT namespace,
this can be achieved using <a href=
"#element-attribute"><code>xsl:attribute</code></a>, or by means of
the <a href=
"#element-namespace-alias"><code>xsl:namespace-alias</code></a>
declaration.</p>
</div>
</div>
<div class="div3">
<h4><a name="lre-namespaces" id="lre-namespaces"></a>11.1.3
<a href="#lre-namespaces" style="text-decoration: none">Namespace
Nodes for Literal Result Elements</a></h4>
<p>The created element node will have a copy of the namespace nodes
that were present on the element node in the stylesheet tree with
the exception of any namespace node whose <a title="string value"
class="termref" href="#dt-string-value">string value</a> is
designated as an <b>excluded namespace</b>. Special considerations
apply to aliased namespaces: see <a href=
"#namespace-aliasing"><i>11.1.5 Namespace Aliasing</i></a></p>
<p>The following namespaces are designated as excluded
namespaces:</p>
<ul>
<li>
<p>The <a title="XSLT namespace" class="termref" href=
"#dt-xslt-namespace">XSLT namespace</a> URI
(<code>http://www.w3.org/1999/XSL/Transform</code>)</p>
</li>
<li>
<p>A namespace URI declared as an extension namespace (see <a href=
"#extension-instruction"><i>23.2 Extension
Instructions</i></a>)</p>
</li>
<li>
<p>A namespace URI designated by using an
<code>[xsl:]exclude-result-prefixes</code> attribute either on the
literal result element itself or on an ancestor element. The
attribute <span class="verb">must</span> be in the XSLT namespace
only if its parent element is <em>not</em> in the XSLT
namespace.</p>
<p>The value of the attribute is either <code>#all</code>, or a
whitespace-separated list of tokens, each of which is either a
namespace prefix or <code>#default</code>. The namespace bound to
each of the prefixes is designated as an excluded namespace.</p>
<p><a name="err-XTSE0808" id="err-XTSE0808"><span class=
"error">[ERR XTSE0808]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if a
namespace prefix is used within the
<code>[xsl:]exclude-result-prefixes</code> attribute and there is
no namespace binding in scope for that prefix.</p>
<p>The default namespace of the parent element of the
<code>[xsl:]exclude-result-prefixes</code> attribute (see <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#ElementNode">Section 6.2
Element Nodes</a> <sup><small>DM30</small></sup>) may be designated
as an excluded namespace by including <code>#default</code> in the
list of namespace prefixes.</p>
<p><a name="err-XTSE0809" id="err-XTSE0809"><span class=
"error">[ERR XTSE0809]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
value <code>#default</code> is used within the
<code>[xsl:]exclude-result-prefixes</code> attribute and the parent
element of the <code>[xsl:]exclude-result-prefixes</code> attribute
has no default namespace.</p>
<p>The value <code>#all</code> indicates that all namespaces that
are in scope for the stylesheet element that is the parent of the
<code>[xsl:]exclude-result-prefixes</code> attribute are designated
as excluded namespaces.</p>
<p>The designation of a namespace as an excluded namespace is
effective within the subtree of the stylesheet module rooted at the
element bearing the <code>[xsl:]exclude-result-prefixes</code>
attribute; a subtree rooted at an <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> element does
not include any stylesheet modules imported or included by children
of that <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> element.</p>
</li>
</ul>
<p>The excluded namespaces, as described above, <em>only</em>
affect namespace nodes copied from the stylesheet when processing a
literal result element. There is no guarantee that an excluded
namespace will not appear on the <a title="result tree" class=
"termref" href="#dt-result-tree">result tree</a> for some other
reason. Namespace nodes are also written to the result tree as part
of the process of namespace fixup (see <a href=
"#namespace-fixup"><i>5.8.3 Namespace Fixup</i></a>), or as the
result of instructions such as <a href=
"#element-copy"><code>xsl:copy</code></a> and <a href=
"#element-element"><code>xsl:element</code></a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>When a stylesheet uses a namespace declaration only for the
purposes of addressing a <a title="source tree" class="termref"
href="#dt-source-tree">source tree</a>, specifying the prefix in
the <code>[xsl:]exclude-result-prefixes</code> attribute will avoid
superfluous namespace declarations in the serialized <a title=
"result tree" class="termref" href="#dt-result-tree">result
tree</a>. The attribute is also useful to prevent namespaces used
solely for the naming of stylesheet functions or extension
functions from appearing in the serialized result tree.</p>
</div>
<div class="example">
<div class="exampleHeader"><a name="d7e29433" id=
"d7e29433"></a>Example: Excluding Namespaces from the Result
Tree</div>
<p>For example, consider the following stylesheet:</p>
<div class="exampleInner">
<pre>
&lt;xsl:stylesheet version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:a="a.uri"
  xmlns:b="b.uri"
  exclude-result-prefixes="#all"&gt;
  
&lt;xsl:template match="/"&gt;
  &lt;foo xmlns:c="c.uri" xmlns:d="d.uri" xmlns:a2="a.uri" 
       xsl:exclude-result-prefixes="c"/&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</pre></div>
<p>The result of this stylesheet will be:</p>
<div class="exampleInner">
<pre>
&lt;foo xmlns:d="d.uri"/&gt;
</pre></div>
<p>The namespaces <code>a.uri</code> and <code>b.uri</code> are
excluded by virtue of the <code>exclude-result-prefixes</code>
attribute on the <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> element, and
the namespace <code>c.uri</code> is excluded by virtue of the
<code>xsl:exclude-result-prefixes</code> attribute on the
<code>foo</code> element. The setting <code>#all</code> does not
affect the namespace <code>d.uri</code> because <code>d.uri</code>
is not an in-scope namespace for the <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> element. The
element in the <a title="result tree" class="termref" href=
"#dt-result-tree">result tree</a> does not have a namespace node
corresponding to <code>xmlns:a2="a.uri"</code> because the effect
of <code>exclude-result-prefixes</code> is to designate the
namespace URI <code>a.uri</code> as an excluded namespace,
irrespective of how many prefixes are bound to this namespace
URI.</p>
<p>If the stylesheet is changed so that the literal result element
has an attribute <code>b:bar="3"</code>, then the element in the
<a title="result tree" class="termref" href=
"#dt-result-tree">result tree</a> will typically have a namespace
declaration <code>xmlns:b="b.uri"</code> (the processor may choose
a different namespace prefix if this is necessary to avoid
conflicts). The <code>exclude-result-prefixes</code> attribute
makes <code>b.uri</code> an excluded namespace, so the namespace
node is not automatically copied from the stylesheet, but the
presence of an attribute whose name is in the namespace
<code>b.uri</code> forces the namespace fixup process (see <a href=
"#namespace-fixup"><i>5.8.3 Namespace Fixup</i></a>) to introduce a
namespace node for this namespace.</p>
</div>
<p>A literal result element may have an optional
<code>xsl:inherit-namespaces</code> attribute, with the value
<code>yes</code> or <code>no</code>. The default value is
<code>yes</code>. If the value is set to <code>yes</code>, or is
omitted, then the namespace nodes created for the newly constructed
element are copied to the children and descendants of the newly
constructed element, as described in <a href=
"#constructing-complex-content"><i>5.8.1 Constructing Complex
Content</i></a>. If the value is set to <code>no</code>, then these
namespace nodes are not automatically copied to the children. This
may result in namespace undeclarations (such as
<code>xmlns=""</code> or, in the case of XML 1.1,
<code>xmlns:p=""</code>) appearing on the child elements when a
<a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a> is serialized.</p>
</div>
<div class="div3">
<h4><a name="conditional-literal-result-elements" id=
"conditional-literal-result-elements"></a>11.1.4 <a href=
"#conditional-literal-result-elements" style=
"text-decoration: none">Conditional Creation of Literal Result
Elements</a></h4>
<p>If a literal result element has an <code>xsl:on-empty</code>
attribute, then the value of the attribute <span class=
"verb">must</span> be an XPath expression. If the attribute is
present and the constructed element has <span>no attributes and no
children</span>, then instead of returning the constructed element,
the instruction returns the result of evaluating the expression in
the <code>xsl:on-empty</code> attribute<span>; if this expression
returns a node, the instruction returns a copy of this
node.</span></p>
<p><a name="err-XTTE3300" id="err-XTTE3300"><span class=
"error">[ERR XTTE3300]</span></a> It is a <a title="type error"
class="termref" href="#dt-type-error">type error</a> if the result
of evaluating the <code>xsl:on-empty</code> attribute does not
satisfy the required type <code>element()?</code>. That is, the
expression must deliver either a single element node, or an empty
sequence.</p>
<p>If the <code>xsl:on-empty</code> expression is evaluated and
returns an empty sequence, then the <code>xsl:validation</code> and
<code>xsl:type</code> attributes are ignored. However, if the
result of the <code>xsl:on-empty</code> expression is an element,
then it is subjected to validation as determined by these
attributes, along with <code>[xsl:]default-validation</code> where
relevant.</p>
<p>Note that when a literal result element has one or more
attributes (other than attributes in the XSLT namespace), or when
it references a non-empty attribute set, the <code>on-empty</code>
attribute has no effect because these conditions will not be
satisfied.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e29604" id=
"d7e29604"></a>Example: Generating a Wrapper Element for a
non-Empty Sequence</div>
<p>The following example generates an <code>events</code> element
if and only if there are one or more <code>event</code> elements.
The code could be written like this:</p>
<div class="exampleInner">
<pre>
&lt;xsl:if test="exists(event)"&gt;
  &lt;events&gt;
    &lt;xsl:copy-of select="event"/&gt;
  &lt;/events&gt;
&lt;/xsl:if&gt;
</pre></div>
<p>However, the above code would not be guaranteed streamable. To
make it streamable, it can be rewritten as:</p>
<div class="exampleInner">
<pre>
&lt;events xsl:on-empty="()"&gt;
    &lt;xsl:copy-of select="event"/&gt;
&lt;/events&gt;
</pre></div>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The reason for introducing the <code>xsl:on-empty</code>
attribute is primarily to make it easier to write applications that
conform to the rules for guaranteed streamability. A common
requirement is to generate a wrapper element for a sequence of
elements (for example an <code>events</code> wrapper for a sequence
of <code>event</code> elements) only if the content sequence is
non-empty. Without the <code>xsl:on-empty</code> attribute this is
difficult to achieve, because testing whether any
<code>event</code> element exists and processing the set of
<code>event</code> elements both count as <a title="consuming"
class="termref" href="#dt-consuming">consuming</a>
instructions.</p>
</div>
</div>
<div class="div3">
<h4><a name="namespace-aliasing" id="namespace-aliasing"></a>11.1.5
<a href="#namespace-aliasing" style=
"text-decoration: none">Namespace Aliasing</a></h4>
<p>When a stylesheet is used to define a transformation whose
output is itself a stylesheet module, or in certain other cases
where the result document uses namespaces that it would be
inconvenient to use in the stylesheet, namespace aliasing can be
used to declare a mapping between a namespace URI used in the
stylesheet and the corresponding namespace URI to be used in the
result document.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-literal-namespace-uri" id="dt-literal-namespace-uri" title=
"literal namespace URI"></a>A namespace URI in the stylesheet tree
that is being used to specify a namespace URI in the <a title=
"result tree" class="termref" href="#dt-result-tree">result
tree</a> is called a <b>literal namespace URI</b>.<span class=
"definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-target-namespace-uri" id="dt-target-namespace-uri" title=
"target namespace URI"></a>The namespace URI that is to be used in
the <a title="result tree" class="termref" href=
"#dt-result-tree">result tree</a> as a substitute for a <a title=
"literal namespace URI" class="termref" href=
"#dt-literal-namespace-uri">literal namespace URI</a> is called the
<b>target namespace URI</b>.<span class="definition">]</span></p>
<p>Either of the <a title="literal namespace URI" class="termref"
href="#dt-literal-namespace-uri">literal namespace URI</a> or the
<a title="target namespace URI" class="termref" href=
"#dt-target-namespace-uri">target namespace URI</a> can be
<em>null</em>: this is treated as a reference to the set of names
that are in no namespace.</p>
<p class="element-syntax"><a name="element-namespace-alias" id=
"element-namespace-alias"></a><code>&lt;!-- Category: declaration
--&gt;<br />
&lt;xsl:namespace-alias<br />
&#160;&#160;<b>stylesheet-prefix</b> = <var>prefix</var> |
"#default"<br />
&#160;&#160;<b>result-prefix</b> = <var>prefix</var> |
"#default"&#160;/&gt;</code></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-alias" id="dt-alias" title="alias"></a>A stylesheet can use the
<a href=
"#element-namespace-alias"><code>xsl:namespace-alias</code></a>
element to declare that a <a title="literal namespace URI" class=
"termref" href="#dt-literal-namespace-uri">literal namespace
URI</a> is being used as an <b>alias</b> for a <a title=
"target namespace URI" class="termref" href=
"#dt-target-namespace-uri">target namespace URI</a>.<span class=
"definition">]</span></p>
<p>The effect is that when names in the namespace identified by the
<a title="literal namespace URI" class="termref" href=
"#dt-literal-namespace-uri">literal namespace URI</a> are copied to
the <a title="result tree" class="termref" href=
"#dt-result-tree">result tree</a>, the namespace URI in the result
tree will be the <a title="target namespace URI" class="termref"
href="#dt-target-namespace-uri">target namespace URI</a>, instead
of the literal namespace URI. This applies to:</p>
<ul>
<li>
<p>the namespace URI in the <a title="expanded QName" class=
"termref" href="#dt-expanded-qname">expanded QName</a> of a literal
result element in the stylesheet</p>
</li>
<li>
<p>the namespace URI in the <a title="expanded QName" class=
"termref" href="#dt-expanded-qname">expanded QName</a> of an
attribute specified on a literal result element in the
stylesheet</p>
</li>
</ul>
<p>The effect of an <a href=
"#element-namespace-alias"><code>xsl:namespace-alias</code></a>
declaration is local to the <a title="package" class="termref"
href="#dt-package">package</a> in which it appears: that is, it
only affects the result of <a title="literal result element" class=
"termref" href="#dt-literal-result-element">literal result
elements</a> within the same package.</p>
<p>Where namespace aliasing changes the namespace URI part of the
<a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> containing the name of an
element or attribute node, the namespace prefix in that expanded
QName is replaced by the prefix indicated by the
<code>result-prefix</code> attribute of the <a href=
"#element-namespace-alias"><code>xsl:namespace-alias</code></a>
declaration.</p>
<p>The <a href=
"#element-namespace-alias"><code>xsl:namespace-alias</code></a>
element declares that the namespace URI bound to the prefix
specified by the <code>stylesheet-prefix</code> is the <a title=
"literal namespace URI" class="termref" href=
"#dt-literal-namespace-uri">literal namespace URI</a>, and the
namespace URI bound to the prefix specified by the
<code>result-prefix</code> attribute is the <a title=
"target namespace URI" class="termref" href=
"#dt-target-namespace-uri">target namespace URI</a>. Thus, the
<code>stylesheet-prefix</code> attribute specifies the namespace
URI that will appear in the stylesheet, and the
<code>result-prefix</code> attribute specifies the corresponding
namespace URI that will appear in the <a title="result tree" class=
"termref" href="#dt-result-tree">result tree</a>.</p>
<p>The default namespace (as declared by <code>xmlns</code>) may be
specified by using <code>#default</code> instead of a prefix. If no
default namespace is in force, specifying <code>#default</code>
denotes the null namespace URI. This allows elements that are in no
namespace in the stylesheet to acquire a namespace in the result
document, or vice versa.</p>
<p>If a <a title="literal namespace URI" class="termref" href=
"#dt-literal-namespace-uri">literal namespace URI</a> is declared
to be an alias for multiple different <a title=
"literal namespace URI" class="termref" href=
"#dt-literal-namespace-uri">target namespace URIs</a>, then the
declaration with the highest <a title="import precedence" class=
"termref" href="#dt-import-precedence">import precedence</a> is
used.</p>
<p><a name="err-XTSE0810" id="err-XTSE0810"><span class=
"error">[ERR XTSE0810]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if
<span>within a <a title="package" class="termref" href=
"#dt-package">package</a></span> there is more than one such
declaration with the same <a title="literal namespace URI" class=
"termref" href="#dt-literal-namespace-uri">literal namespace
URI</a> and the same <a title="import precedence" class="termref"
href="#dt-import-precedence">import precedence</a> and different
values for the <a title="target namespace URI" class="termref"
href="#dt-target-namespace-uri">target namespace URI</a>, unless
there is also an <a href=
"#element-namespace-alias"><code>xsl:namespace-alias</code></a>
declaration with the same <a title="literal namespace URI" class=
"termref" href="#dt-literal-namespace-uri">literal namespace
URI</a> and a higher import precedence.</p>
<p>No error occurs if there is more than one such <a href=
"#element-namespace-alias"><code>xsl:namespace-alias</code></a>
declaration having the same <a title="literal namespace URI" class=
"termref" href="#dt-literal-namespace-uri">literal namespace
URI</a> and the same <a title="target namespace URI" class=
"termref" href="#dt-target-namespace-uri">target namespace URI</a>,
even if the <code>result-prefix</code> differs; in this case the
<code>result-prefix</code> used is the one that appears last in
<a title="declaration order" class="termref" href=
"#dt-declaration-order">declaration order</a>.</p>
<p><a name="err-XTSE0812" id="err-XTSE0812"><span class=
"error">[ERR XTSE0812]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if a value
other than <code>#default</code> is specified for either the
<code>stylesheet-prefix</code> or the <code>result-prefix</code>
attributes of the <a href=
"#element-namespace-alias"><code>xsl:namespace-alias</code></a>
element when there is no in-scope binding for that namespace
prefix.</p>
<p>When a literal result element is processed, its namespace nodes
are handled as follows:</p>
<ul>
<li>
<p>A namespace node whose string value is a <a title=
"literal namespace URI" class="termref" href=
"#dt-literal-namespace-uri">literal namespace URI</a> is not copied
to the <a title="result tree" class="termref" href=
"#dt-result-tree">result tree</a>.</p>
</li>
<li>
<p>A namespace node whose string value is a <a title=
"target namespace URI" class="termref" href=
"#dt-target-namespace-uri">target namespace URI</a> is copied to
the <a title="result tree" class="termref" href=
"#dt-result-tree">result tree</a>, whether or not the URI
identifies an excluded namespace.</p>
</li>
</ul>
<p>In the event that the same URI is used as a <a title=
"literal namespace URI" class="termref" href=
"#dt-literal-namespace-uri">literal namespace URI</a> and a
<a title="target namespace URI" class="termref" href=
"#dt-target-namespace-uri">target namespace URI</a>, the second of
these rules takes precedence.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>These rules achieve the effect that the element generated from
the literal result element will have an in-scope namespace node
that binds the <code>result-prefix</code> to the <a title=
"target namespace URI" class="termref" href=
"#dt-target-namespace-uri">target namespace URI</a>, provided that
the namespace declaration associating this prefix with this URI is
in scope for both the <a href=
"#element-namespace-alias"><code>xsl:namespace-alias</code></a>
instruction and for the literal result element. Conversely, the
<code>stylesheet-prefix</code> and the <a title=
"literal namespace URI" class="termref" href=
"#dt-literal-namespace-uri">literal namespace URI</a> will not
normally appear in the <a title="result tree" class="termref" href=
"#dt-result-tree">result tree</a>.</p>
</div>
<div class="example">
<div class="exampleHeader"><a name="d7e29941" id=
"d7e29941"></a>Example: Using <a href=
"#element-namespace-alias"><code>xsl:namespace-alias</code></a> to
Generate a Stylesheet</div>
<p>When literal result elements are being used to create element,
attribute, or namespace nodes that use the <a title=
"XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT
namespace</a> URI, the stylesheet may use an alias.</p>
<p>For example, the stylesheet</p>
<div class="exampleInner">
<pre>
&lt;xsl:stylesheet
  version="3.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:fo="http://www.w3.org/1999/XSL/Format"
  xmlns:axsl="file://namespace.alias"&gt;

&lt;xsl:namespace-alias stylesheet-prefix="axsl" result-prefix="xsl"/&gt;

&lt;xsl:template match="/"&gt;
  &lt;axsl:stylesheet version="3.0"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/axsl:stylesheet&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="elements"&gt;
  &lt;axsl:template match="/"&gt;
     &lt;axsl:comment select="system-property('xsl:version')"/&gt;
     &lt;axsl:apply-templates/&gt;
  &lt;/axsl:template&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="block"&gt;
  &lt;axsl:template match="{.}"&gt;
     &lt;fo:block&gt;&lt;axsl:apply-templates/&gt;&lt;/fo:block&gt;
  &lt;/axsl:template&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</pre></div>
<p>will generate an XSLT stylesheet from a document of the
form:</p>
<div class="exampleInner">
<pre>
&lt;elements&gt;
&lt;block&gt;p&lt;/block&gt;
&lt;block&gt;h1&lt;/block&gt;
&lt;block&gt;h2&lt;/block&gt;
&lt;block&gt;h3&lt;/block&gt;
&lt;block&gt;h4&lt;/block&gt;
&lt;/elements&gt;
</pre></div>
<p>The output of the transformation will be a stylesheet such as
the following. Whitespace has been added for clarity. Note that an
implementation may output different namespace prefixes from those
appearing in this example; however, the rules guarantee that there
will be a namespace node that binds the prefix <code>xsl</code> to
the URI <code>http://www.w3.org/1999/XSL/Transform</code>, which
makes it safe to use the QName <code>xsl:version</code> in the
content of the generated stylesheet.</p>
<div class="exampleInner">
<pre>
&lt;xsl:stylesheet
  version="3.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
  xmlns:fo="http://www.w3.org/1999/XSL/Format"&gt;

&lt;xsl:template match="/"&gt;
  &lt;xsl:comment select="system-property('xsl:version')"/&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;
  
&lt;xsl:template match="p"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="h1"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="h2"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="h3"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="h4"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</pre></div>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>It may be necessary also to use aliases for namespaces other
than the XSLT namespace URI. For example, it can be useful to
define an alias for the namespace
<code>http://www.w3.org/2001/XMLSchema-instance</code>, so that the
stylesheet can use the attributes <code>xsi:type</code>,
<code>xsi:nil</code>, and <code>xsi:schemaLocation</code> on a
literal result element, without running the risk that a schema
processor will interpret these as applying to the stylesheet
itself. Equally, literal result elements belonging to a namespace
dealing with digital signatures might cause XSLT stylesheets to be
mishandled by general-purpose security software; using an alias for
the namespace would avoid the possibility of such mishandling.</p>
</div>
<div class="example">
<div class="exampleHeader"><a name="d7e29989" id=
"d7e29989"></a>Example: Aliasing the XML Namespace</div>
<p>It is possible to define an alias for the XML namespace.</p>
<div class="exampleInner">
<pre>
&lt;xsl:stylesheet xmlns:axml="http://www.example.com/alias-xml"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                version="3.0"&gt;

&lt;xsl:namespace-alias stylesheet-prefix="axml" result-prefix="xml"/&gt;

&lt;xsl:template match="/"&gt;
  &lt;name axml:space="preserve"&gt;
    &lt;first&gt;James&lt;/first&gt;
    &lt;xsl:text&gt; &lt;/xsl:text&gt;
    &lt;last&gt;Clark&lt;/last&gt;
  &lt;/name&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</pre></div>
<p>produces the output:</p>
<div class="exampleInner">
<pre>
&lt;name xml:space="preserve"&gt;&lt;first&gt;James&lt;/first&gt; &lt;last&gt;Clark&lt;/last&gt;&lt;/name&gt;
</pre></div>
<p>This allows an <code>xml:space</code> attribute to be generated
in the output without affecting the way the stylesheet is parsed.
The same technique can be used for other attributes such as
<code>xml:lang</code>, <code>xml:base</code>, and
<code>xml:id</code>.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Namespace aliasing is only necessary when literal result
elements are used. The problem of reserved namespaces does not
arise when using <a href=
"#element-element"><code>xsl:element</code></a> and <a href=
"#element-attribute"><code>xsl:attribute</code></a> to construct
the <a title="result tree" class="termref" href=
"#dt-result-tree">result tree</a>. Therefore, as an alternative to
using <a href=
"#element-namespace-alias"><code>xsl:namespace-alias</code></a>, it
is always possible to achieve the desired effect by replacing
literal result elements with <a href=
"#element-element"><code>xsl:element</code></a> and <a href=
"#element-attribute"><code>xsl:attribute</code></a>
instructions.</p>
</div>
</div>
</div>
<div class="div2">
<h3><a name="xsl-element" id="xsl-element"></a>11.2 <a href=
"#xsl-element" style="text-decoration: none">Creating Element Nodes
Using</a> <code>xsl:element</code> <a href="#xsl-element" style=
"text-decoration: none"></a></h3>
<p class="element-syntax"><a name="element-element" id=
"element-element"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:element<br />
&#160;&#160;<b>name</b> = { <var>qname</var> }<br />
&#160;&#160;namespace? = { <var>uri</var> }<br />
&#160;&#160;inherit-namespaces? = <var>boolean</var><br />
&#160;&#160;use-attribute-sets? = <var>eqnames</var><br />
&#160;&#160;type? = <var>eqname</var><br />
&#160;&#160;validation? = "strict" | "lax" | "preserve" |
"strip"<br />
&#160;&#160;on-empty? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:element&gt;</code></p>
<p>The <a href="#element-element"><code>xsl:element</code></a>
instruction allows an element to be created with a computed name.
The <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> of the element to be
created is specified by a <span class="verb">required</span>
<code>name</code> attribute and an optional <code>namespace</code>
attribute.</p>
<p>The result of evaluating the <a href=
"#element-element"><code>xsl:element</code></a> instruction,
<span>in usual circumstances</span>, is the newly constructed
element node.</p>
<div class="div3">
<h4><a name="xsl-element-content" id=
"xsl-element-content"></a>11.2.1 <a href="#xsl-element-content"
style="text-decoration: none">The Content of the Constructed
Element Node</a></h4>
<p>The content of the <a href=
"#element-element"><code>xsl:element</code></a> instruction is a
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> for the
children, attributes, and namespaces of the created element. The
sequence obtained by evaluating this sequence constructor (see
<a href="#sequence-constructors"><i>5.8 Sequence
Constructors</i></a>) is used to construct the content of the
element, as described in <a href=
"#constructing-complex-content"><i>5.8.1 Constructing Complex
Content</i></a>.</p>
<p>The <a href="#element-element"><code>xsl:element</code></a>
element may have a <code>use-attribute-sets</code> attribute, whose
value is a whitespace-separated list of QNames that identify
<a href="#element-attribute-set"><code>xsl:attribute-set</code></a>
declarations. If this attribute is present, it is expanded as
described in <a href="#attribute-sets"><i>10.2 Named Attribute
Sets</i></a> to produce a sequence of attribute nodes. This
sequence is prepended to the sequence produced as a result of
evaluating the <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a>, as
described in <a href="#constructing-complex-content"><i>5.8.1
Constructing Complex Content</i></a>.</p>
</div>
<div class="div3">
<h4><a name="xsl-element-name" id="xsl-element-name"></a>11.2.2
<a href="#xsl-element-name" style="text-decoration: none">The Name
of the Constructed Element Node</a></h4>
<p>The <code>name</code> attribute is interpreted as an <a title=
"attribute value template" class="termref" href=
"#dt-attribute-value-template">attribute value template</a>, whose
<a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> <span class=
"verb">must</span> be a <a title="lexical QName" class="termref"
href="#dt-lexical-qname">lexical QName</a>.</p>
<p><a name="err-XTDE0820" id="err-XTDE0820"><span class=
"error">[ERR XTDE0820]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the <code>name</code>
attribute is not a <a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a>.</p>
<p><a name="err-XTDE0830" id="err-XTDE0830"><span class=
"error">[ERR XTDE0830]</span></a> In the case of an <a href=
"#element-element"><code>xsl:element</code></a> instruction with no
<code>namespace</code> attribute, it is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the <code>name</code>
attribute is a <a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a> whose prefix is not declared
in an in-scope namespace declaration for the <a href=
"#element-element"><code>xsl:element</code></a> instruction.</p>
<p>If the <code>namespace</code> attribute is not present then the
<a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a> is expanded into an <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a> using the namespace declarations in effect for the
<a href="#element-element"><code>xsl:element</code></a> element,
including any default namespace declaration.</p>
<p>If the <code>namespace</code> attribute is present, then it too
is interpreted as an <a title="attribute value template" class=
"termref" href="#dt-attribute-value-template">attribute value
template</a>. The <a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> <span class=
"verb">must</span> be in the lexical space of the
<code>xs:anyURI</code> type. If the string is zero-length, then the
<a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> of the element has a null
namespace URI. Otherwise, the string is used as the namespace URI
of the <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> of the element to be
created. The local part of the <a title="lexical QName" class=
"termref" href="#dt-lexical-qname">lexical QName</a> specified by
the <code>name</code> attribute is used as the local part of the
<a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> of the element to be
created.</p>
<p><a name="err-XTDE0835" id="err-XTDE0835"><span class=
"error">[ERR XTDE0835]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the
<code>namespace</code> attribute is not in the lexical space of the
<code>xs:anyURI</code> datatype or if it is the string
<code>http://www.w3.org/2000/xmlns/</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The XDM data model requires the name of a node to be an instance
of <code>xs:QName</code>, and XML Schema defines the namespace part
of an <code>xs:QName</code> to be an instance of
<code>xs:anyURI</code>. However, the schema specification, and the
specifications that it refers to, give implementations some
flexibility in how strictly they enforce these constraints.</p>
</div>
<p>The prefix of the <a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a> specified in the
<code>name</code> attribute (or the absence of a prefix) is copied
to the prefix part of the <a title="expanded QName" class="termref"
href="#dt-expanded-qname">expanded QName</a> representing the name
of the new element node. In the event of a conflict a prefix may
subsequently be added, changed, or removed during the namespace
fixup process (see <a href="#namespace-fixup"><i>5.8.3 Namespace
Fixup</i></a>). The term <em>conflict</em> here means any violation
of the constraints defined in <a href="#xpath-datamodel-30">[Data
Model]</a>, for example the use of the same prefix to refer to two
different namespaces in the element and in one of its attributes,
the use of the prefix <code>xml</code> to refer to a namespace
other than the XML namespace, or any use of the prefix
<code>xmlns</code>.</p>
</div>
<div class="div3">
<h4><a name="xsl-element-properties" id=
"xsl-element-properties"></a>11.2.3 <a href=
"#xsl-element-properties" style="text-decoration: none">Other
Properties of the Constructed Element Node</a></h4>
<p>The <a href="#element-element"><code>xsl:element</code></a>
instruction has an optional <code>inherit-namespaces</code>
attribute, with the value <code>yes</code> or <code>no</code>. The
default value is <code>yes</code>. If the value is set to
<code>yes</code>, or is omitted, then the namespace nodes created
for the newly constructed element (whether these were copied from
those of the source node, or generated as a result of namespace
fixup) are copied to the children and descendants of the newly
constructed element, as described in <a href=
"#constructing-complex-content"><i>5.8.1 Constructing Complex
Content</i></a>. If the value is set to <code>no</code>, then these
namespace nodes are not automatically copied to the children. This
may result in namespace undeclarations (such as
<code>xmlns=""</code> or, in the case of XML Namespaces 1.1,
<code>xmlns:p=""</code>) appearing on the child elements when a
<a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a> is serialized.</p>
<p>The base URI of the new element is copied from the base URI of
the <a href="#element-element"><code>xsl:element</code></a>
instruction in the stylesheet, unless the content of the new
element includes an <code>xml:base</code> attribute, in which case
the base URI of the new element is the value of that attribute,
resolved (if it is a relative URI) against the base URI of the
<a href="#element-element"><code>xsl:element</code></a> instruction
in the stylesheet. (Note, however, that this is only relevant when
creating parentless elements. When the new element is copied to
form a child of an element or document node, the base URI of the
new copy is taken from that of its new parent.)</p>
</div>
<div class="div3">
<h4><a name="annotation-for-constructed-element" id=
"annotation-for-constructed-element"></a>11.2.4 <a href=
"#annotation-for-constructed-element" style=
"text-decoration: none">The Type Annotation of the Constructed
Element Node</a></h4>
<p>The optional attributes <code>type</code> and
<code>validation</code> may be used on the <a href=
"#element-element"><code>xsl:element</code></a> instruction to
invoke validation of the contents of the element against a type
definition or element declaration in a schema, and to determine the
<a title="type annotation" class="termref" href=
"#dt-type-annotation">type annotation</a> that the new element node
will carry. These attributes also affect the type annotation
carried by any elements and attributes that have the new element
node as an ancestor. These two attributes are both optional, and if
one is specified then the other <span class="verb">must</span> be
omitted. The permitted values of these attributes and their
semantics are described in <a href="#validation"><i>24.4
Validation</i></a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The final type annotation of the element in the <a title=
"result tree" class="termref" href="#dt-result-tree">result
tree</a> also depends on the <code>type</code> and
<code>validation</code> attributes of the instructions used to
create the ancestors of the element.</p>
</div>
</div>
<div class="div3">
<h4><a name="xsl-element-on-empty" id=
"xsl-element-on-empty"></a>11.2.5 <a href="#xsl-element-on-empty"
style="text-decoration: none">Conditional Construction of Element
Nodes</a></h4>
<p>If the <code>on-empty</code> attribute is present and the
content of the constructed element as determined by the rules in
<a href="#xsl-element-content"><i>11.2.1 The Content of the
Constructed Element Node</i></a> (that is, the result of evaluating
the sequence constructor and prepending any attributes generated by
the <code>use-attribute-sets</code> attribute) is a sequence
containing nothing other than namespace nodes and zero-length text
nodes, then instead of returning the newly constructed element
node, the instruction returns the result of evaluating the
expression in the <code>on-empty</code> attribute<span>; if this
expression returns a node, the instruction returns a copy of this
node</span>.</p>
<p><a name="err-XTTE3310" id="err-XTTE3310"><span class=
"error">[ERR XTTE3310]</span></a> It is a <a title="type error"
class="termref" href="#dt-type-error">type error</a> if the result
of evaluating the <code>on-empty</code> attribute does not satisfy
the required type <code>element()?</code>. That is, the expression
must deliver either a single element node, or an empty
sequence.</p>
<p>If the <code>on-empty</code> expression is evaluated and returns
an empty sequence, then the <code>validation</code> and
<code>type</code> attributes are ignored. However, if the result of
the <code>on-empty</code> expression is an element, then it is
subjected to validation as determined by these attributes, along
with <code>[xsl:]default-validation</code> where relevant.</p>
</div>
</div>
<div class="div2">
<h3><a name="creating-attributes" id="creating-attributes"></a>11.3
<a href="#creating-attributes" style=
"text-decoration: none">Creating Attribute Nodes Using</a>
<code>xsl:attribute</code> <a href="#creating-attributes" style=
"text-decoration: none"></a></h3>
<p class="element-syntax"><a name="element-attribute" id=
"element-attribute"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:attribute<br />
&#160;&#160;<b>name</b> = { <var>qname</var> }<br />
&#160;&#160;namespace? = { <var>uri</var> }<br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;separator? = { <var>string</var> }<br />
&#160;&#160;type? = <var>eqname</var><br />
&#160;&#160;validation? = "strict" | "lax" | "preserve" |
"strip"&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:attribute&gt;</code></p>
<p>The <a href="#element-attribute"><code>xsl:attribute</code></a>
element can be used to add attributes to result elements whether
created by literal result elements in the stylesheet or by
instructions such as <a href=
"#element-element"><code>xsl:element</code></a> or <a href=
"#element-copy"><code>xsl:copy</code></a>. The <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a> of the attribute to be created is specified by a
<span class="verb">required</span> <code>name</code> attribute and
an optional <code>namespace</code> attribute. Except in error
cases, the result of evaluating an <a href=
"#element-attribute"><code>xsl:attribute</code></a> instruction is
the newly constructed attribute node.</p>
<p>The string value of the new attribute node may be defined either
by using the <code>select</code> attribute, or by the <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> that forms the
content of the <a href=
"#element-attribute"><code>xsl:attribute</code></a> element.
<span>These are mutually exclusive: if the <code>select</code>
attribute is present then the sequence constructor must be empty,
and if the sequence constructor is non-empty then the
<code>select</code> attribute must be absent. If the
<code>select</code> attribute is absent and the sequence
constructor is empty</span>, then the string value of the new
attribute node will be a zero-length string. The way in which the
value is constructed is specified in <a href=
"#constructing-simple-content"><i>5.8.2 Constructing Simple
Content</i></a>.</p>
<p><a name="err-XTSE0840" id="err-XTSE0840"><span class=
"error">[ERR XTSE0840]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
<code>select</code> attribute of the <a href=
"#element-attribute"><code>xsl:attribute</code></a> element is
present unless the element has empty content.</p>
<p>If the <code>separator</code> attribute is present, then the
<a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of this attribute is used
to separate adjacent items in the result sequence, as described in
<a href="#constructing-simple-content"><i>5.8.2 Constructing Simple
Content</i></a>. In the absence of this attribute, the default
separator is a single space (#x20) when the content is specified
using the <code>select</code> attribute, or a zero-length string
when the content is specified using a <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>.</p>
<p>The <code>name</code> attribute is interpreted as an <a title=
"attribute value template" class="termref" href=
"#dt-attribute-value-template">attribute value template</a>, whose
<a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> <span class=
"verb">must</span> be a <a title="lexical QName" class="termref"
href="#dt-lexical-qname">lexical QName</a>.</p>
<p><a name="err-XTDE0850" id="err-XTDE0850"><span class=
"error">[ERR XTDE0850]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the <code>name</code>
attribute is not a <a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a>.</p>
<p><a name="err-XTDE0855" id="err-XTDE0855"><span class=
"error">[ERR XTDE0855]</span></a> In the case of an <a href=
"#element-attribute"><code>xsl:attribute</code></a> instruction
with no <code>namespace</code> attribute, it is a <a title=
"dynamic error" class="termref" href="#dt-dynamic-error">dynamic
error</a> if the <a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the <code>name</code>
attribute is the string <code>xmlns</code>.</p>
<p><a name="err-XTDE0860" id="err-XTDE0860"><span class=
"error">[ERR XTDE0860]</span></a> In the case of an <a href=
"#element-attribute"><code>xsl:attribute</code></a> instruction
with no <code>namespace</code> attribute, it is a <a title=
"dynamic error" class="termref" href="#dt-dynamic-error">dynamic
error</a> if the <a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the <code>name</code>
attribute is a <a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a> whose prefix is not declared
in an in-scope namespace declaration for the <a href=
"#element-attribute"><code>xsl:attribute</code></a>
instruction.</p>
<p>If the <code>namespace</code> attribute is not present, then the
<a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a> is expanded into an <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a> using the namespace declarations in effect for the
<a href="#element-attribute"><code>xsl:attribute</code></a>
element, <em>not</em> including any default namespace
declaration.</p>
<p>If the <code>namespace</code> attribute is present, then it too
is interpreted as an <a title="attribute value template" class=
"termref" href="#dt-attribute-value-template">attribute value
template</a>. The <a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> <span class=
"verb">must</span> be in the lexical space of the
<code>xs:anyURI</code> type. If the string is zero-length, then the
<a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> of the attribute has a null
namespace URI. Otherwise, the string is used as the namespace URI
of the <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> of the attribute to be
created. The local part of the <a title="lexical QName" class=
"termref" href="#dt-lexical-qname">lexical QName</a> specified by
the <code>name</code> attribute is used as the local part of the
<a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> of the attribute to be
created.</p>
<p><a name="err-XTDE0865" id="err-XTDE0865"><span class=
"error">[ERR XTDE0865]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the
<code>namespace</code> attribute is not in the lexical space of the
<code>xs:anyURI</code> datatype or if it is the string
<code>http://www.w3.org/2000/xmlns/</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The same considerations apply as for elements: <span class=
"error">[see <a href="#err-XTDE0835">ERR XTDE0835</a>]</span> in
<a href="#xsl-element"><i>11.2 Creating Element Nodes Using
xsl:element</i></a> .</p>
</div>
<p>The prefix of the <a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a> specified in the
<code>name</code> attribute (or the absence of a prefix) is copied
to the prefix part of the <a title="expanded QName" class="termref"
href="#dt-expanded-qname">expanded QName</a> representing the name
of the new attribute node. In the event of a conflict this prefix
may subsequently be added, changed, or removed during the namespace
fixup process (see <a href="#namespace-fixup"><i>5.8.3 Namespace
Fixup</i></a>). If the attribute is in a non-null namespace and no
prefix is specified, then the namespace fixup process will invent a
prefix. The term <em>conflict</em> here means any violation of the
constraints defined in <a href="#xpath-datamodel-30">[Data
Model]</a>, for example the use of the same prefix to refer to two
different namespaces in the element and in one of its attributes,
the use of the prefix <code>xml</code> to refer to a namespace
other than the XML namespace, or any use of the prefix
<code>xmlns</code>.</p>
<p>If the name of a constructed attribute is <code>xml:id</code>,
the processor must perform attribute value normalization by
effectively applying the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-normalize-space"><code>
normalize-space</code></a><sup><small>FO30</small></sup> function
to the value of the attribute, and the resulting attribute node
must be given the <code>is-id</code> property. This applies whether
the attribute is constructed using the <a href=
"#element-attribute"><code>xsl:attribute</code></a> instruction or
whether it is constructed using an attribute of a literal result
element. This does not imply any constraints on the value of the
attribute, or on its uniqueness, and it does not affect the
<a title="type annotation" class="termref" href=
"#dt-type-annotation">type annotation</a> of the attribute, unless
the containing document is validated.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The effect of setting the <code>is-id</code> property is that
the parent element can be located within the containing document by
use of the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-id"><code>id</code></a><sup><small>FO30</small></sup>
function. In effect, XSLT when constructing a document performs
some of the functions of an <code>xml:id</code> processor, as
defined in <a href="#xml-id">[xml:id]</a>; the other aspects of
<code>xml:id</code> processing are performed during validation.</p>
</div>
<div class="example">
<div class="exampleHeader"><a name="d7e30812" id=
"d7e30812"></a>Example: Creating a List-Valued Attribute</div>
<p>The following instruction creates the attribute
<code>colors="red green blue"</code>:</p>
<div class="exampleInner">
<pre>
&lt;xsl:attribute name="colors" select="'red', 'green', 'blue'"/&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e30822" id=
"d7e30822"></a>Example: Namespaces are not Attributes</div>
<p>It is not an error to write:</p>
<div class="exampleInner">
<pre>
&lt;xsl:attribute name="xmlns:xsl" 
   namespace="file://some.namespace"
   select="'http://www.w3.org/1999/XSL/Transform'"/&gt;
</pre></div>
<p>However, this will not result in the namespace declaration
<code>xmlns:xsl="http://www.w3.org/1999/XSL/Transform"</code> being
output. Instead, it will produce an attribute node with local name
<code>xsl</code>, and with a system-allocated namespace prefix
mapped to the namespace URI <code>file://some.namespace</code>.
This is because the namespace fixup process is not allowed to use
<code>xmlns</code> as the name of a namespace node.</p>
</div>
<p>As described in <a href="#constructing-complex-content"><i>5.8.1
Constructing Complex Content</i></a>, in a sequence that is used to
construct the content of an element, any attribute nodes
<span class="verb">must</span> appear in the sequence before any
element, text, comment, or processing instruction nodes. Where the
sequence contains two or more attribute nodes with the same
<a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a>, the one that comes last is
the only one that takes effect.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>If a collection of attributes is generated repeatedly, this can
be done conveniently by using named attribute sets: see <a href=
"#attribute-sets"><i>10.2 Named Attribute Sets</i></a></p>
</div>
<div class="div3">
<h4><a name="annotation-for-constructed-attribute" id=
"annotation-for-constructed-attribute"></a>11.3.1 <a href=
"#annotation-for-constructed-attribute" style=
"text-decoration: none">Setting the Type Annotation for a
Constructed Attribute Node</a></h4>
<p>The optional attributes <code>type</code> and
<code>validation</code> may be used on the <a href=
"#element-attribute"><code>xsl:attribute</code></a> instruction to
invoke validation of the contents of the attribute against a type
definition or attribute declaration in a schema, and to determine
the <a title="type annotation" class="termref" href=
"#dt-type-annotation">type annotation</a> that the new attribute
node will carry. These two attributes are both optional, and if one
is specified then the other <span class="verb">must</span> be
omitted. The permitted values of these attributes and their
semantics are described in <a href="#validation"><i>24.4
Validation</i></a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The final <a title="type annotation" class="termref" href=
"#dt-type-annotation">type annotation</a> of the attribute in the
<a title="result tree" class="termref" href=
"#dt-result-tree">result tree</a> also depends on the
<code>type</code> and <code>validation</code> attributes of the
instructions used to create the ancestors of the attribute.</p>
</div>
</div>
</div>
<div class="div2">
<h3><a name="creating-text-nodes" id="creating-text-nodes"></a>11.4
<a href="#creating-text-nodes" style=
"text-decoration: none">Creating Text Nodes</a></h3>
<p>This section describes three different ways of creating text
nodes: by means of literal text nodes in the stylesheet, or by
using the <a href="#element-text"><code>xsl:text</code></a> and
<a href="#element-value-of"><code>xsl:value-of</code></a>
instructions. It is also possible to create text nodes using the
<a href="#element-number"><code>xsl:number</code></a> instruction
described in <a href="#number"><i>12 Numbering</i></a>.</p>
<p>If and when the sequence that results from evaluating a
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> is used to form
the content of a node, as described in <a href=
"#constructing-simple-content"><i>5.8.2 Constructing Simple
Content</i></a> and <a href=
"#constructing-complex-content"><i>5.8.1 Constructing Complex
Content</i></a>, adjacent text nodes in the sequence are merged.
Within the sequence itself, however, they exist as distinct
nodes.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e30970" id=
"d7e30970"></a>Example: A Sequence of Text Nodes</div>
<p>The following function returns a sequence of three text
nodes:</p>
<div class="exampleInner">
<pre>
&lt;xsl:function name="f:wrap"&gt;
  &lt;xsl:param name="s"/&gt;
  &lt;xsl:text&gt;(&lt;/xsl:text&gt;
  &lt;xsl:value-of select="$s"/&gt;
  &lt;xsl:text&gt;)&lt;/xsl:text&gt;
&lt;/xsl:function&gt;
</pre></div>
<p>When this function is called as follows:</p>
<div class="exampleInner">
<pre>
&lt;xsl:value-of select="f:wrap('---')"/&gt;
</pre></div>
<p>the result is:</p>
<div class="exampleInner">
<pre>
(---)
</pre></div>
<p>No additional spaces are inserted, because the calling <a href=
"#element-value-of"><code>xsl:value-of</code></a> instruction
merges adjacent text nodes before atomizing the sequence. However,
the result of the instruction:</p>
<div class="exampleInner">
<pre>
&lt;xsl:value-of select="data(f:wrap('---'))"/&gt;
</pre></div>
<p>is:</p>
<div class="exampleInner">
<pre>
( --- )
</pre></div>
<p>because in this case the three text nodes are atomized to form
three strings, and spaces are inserted between adjacent
strings.</p>
</div>
<p>It is possible to construct text nodes whose string value is
zero-length. A zero-length text node, when atomized, produces a
zero-length string. However, zero-length text nodes are ignored
when they appear in a sequence that is used to form the content of
a node, as described in <a href=
"#constructing-complex-content"><i>5.8.1 Constructing Complex
Content</i></a> and <a href="#constructing-simple-content"><i>5.8.2
Constructing Simple Content</i></a>.</p>
<div class="div3">
<h4><a name="literal-text-nodes" id="literal-text-nodes"></a>11.4.1
<a href="#literal-text-nodes" style="text-decoration: none">Literal
Text Nodes</a></h4>
<p>A <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> can contain
text nodes. Each text node in a sequence constructor remaining
after <a title="whitespace text node" class="termref" href=
"#dt-whitespace-text-node">whitespace text nodes</a> have been
stripped as specified in <a href="#stylesheet-stripping"><i>4.2
Stripping Whitespace from the Stylesheet</i></a> will construct a
new text node with the same <a title="string value" class="termref"
href="#dt-string-value">string value</a>. The resulting text node
is added to the result of the containing sequence constructor.</p>
<p>Text is processed at the tree level. Thus, markup of
<code>&amp;lt;</code> in a template will be represented in the
stylesheet tree by a text node that includes the character
<code>&lt;</code>. This will create a text node in the <a title=
"result tree" class="termref" href="#dt-result-tree">result
tree</a> that contains a <code>&lt;</code> character, which will be
represented by the markup <code>&amp;lt;</code> (or an equivalent
character reference) when the result tree is serialized as an XML
document, unless otherwise specified using <a title="character map"
class="termref" href="#dt-character-map">character maps</a> (see
<a href="#character-maps"><i>25.1 Character Maps</i></a>) or
<code>disable-output-escaping</code> (see <a href=
"#disable-output-escaping"><i>25.2 Disabling Output
Escaping</i></a>).</p>
</div>
<div class="div3">
<h4><a name="xsl-text" id="xsl-text"></a>11.4.2 <a href="#xsl-text"
style="text-decoration: none">Creating Text Nodes Using</a>
<code>xsl:text</code> <a href="#xsl-text" style=
"text-decoration: none"></a></h4>
<p class="element-syntax"><a name="element-text" id=
"element-text"></a><code>&lt;!-- Category: instruction --&gt;<br />
&lt;xsl:text<br />
&#160;&#160;<span class="grayed">[disable-output-escaping]?</span>
= <var>boolean</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: #PCDATA --&gt;<br />
&lt;/xsl:text&gt;</code></p>
<p>The <a href="#element-text"><code>xsl:text</code></a> element is
evaluated to construct a new text node.</p>
<p>If the element or one of its ancestors has an
<code>[xsl:]expand-text</code> attribute, and the nearest ancestor
with such an attribute has the value <code>yes</code>, then any
unescaped curly braces in the value of the element indicate the
presence of <a title="text value template" class="termref" href=
"#dt-text-value-template">text value templates</a>, which are
expanded as described in <a href="#text-value-templates"><i>5.7.2
Text Value Templates</i></a>.</p>
<p><span>In the absence of such an attribute, or if the effective
value is <code>no</code>,</span> the content of the <a href=
"#element-text"><code>xsl:text</code></a> element is a single text
node whose value forms the <a title="string value" class="termref"
href="#dt-string-value">string value</a> of the new text node. An
<a href="#element-text"><code>xsl:text</code></a> element may be
empty, in which case the result of evaluating the instruction is a
text node whose string value is the zero-length string.</p>
<p>The result of evaluating an <a href=
"#element-text"><code>xsl:text</code></a> instruction is the newly
constructed text node.</p>
<p>A text node that is an immediate child of an <a href=
"#element-text"><code>xsl:text</code></a> instruction will not be
stripped from the stylesheet tree, even if it consists entirely of
whitespace (see <a href="#strip"><i>4.4 Stripping Whitespace from a
Source Tree</i></a>).</p>
<p>For the effect of the <a title="deprecated" class="termref"
href="#dt-deprecated">deprecated</a>
<code>disable-output-escaping</code> attribute, see <a href=
"#disable-output-escaping"><i>25.2 Disabling Output
Escaping</i></a></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>It is not always necessary to use the <a href=
"#element-text"><code>xsl:text</code></a> instruction to write text
nodes to the <a title="result tree" class="termref" href=
"#dt-result-tree">result tree</a>. Literal text can be written to
the result tree by including it anywhere in a <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>, while computed
text can be output using the <a href=
"#element-value-of"><code>xsl:value-of</code></a> instruction. The
principal reason for using <a href=
"#element-text"><code>xsl:text</code></a> is that it offers
improved control over whitespace handling.</p>
</div>
</div>
<div class="div3">
<h4><a name="value-of" id="value-of"></a>11.4.3 <a href="#value-of"
style="text-decoration: none">Generating Text with</a> <a href=
"#element-value-of"><code>xsl:value-of</code></a> <a href=
"#value-of" style="text-decoration: none"></a></h4>
<p>Within a <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>, the <a href=
"#element-value-of"><code>xsl:value-of</code></a> instruction can
be used to generate computed text nodes. The <a href=
"#element-value-of"><code>xsl:value-of</code></a> instruction
computes the text using an <a title="expression" class="termref"
href="#dt-expression">expression</a> that is specified as the value
of the <code>select</code> attribute, or by means of contained
instructions. This might, for example, extract text from a
<a title="source tree" class="termref" href=
"#dt-source-tree">source tree</a> or insert the value of a
variable.</p>
<p class="element-syntax"><a name="element-value-of" id=
"element-value-of"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:value-of<br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;separator? = { <var>string</var> }<br />
&#160;&#160;<span class="grayed">[disable-output-escaping]?</span>
= <var>boolean</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:value-of&gt;</code></p>
<p>The <a href="#element-value-of"><code>xsl:value-of</code></a>
instruction is evaluated to construct a new text node; the result
of the instruction is the newly constructed text node.</p>
<p>The string value of the new text node may be defined either by
using the <code>select</code> attribute, or by the <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> (see <a href=
"#sequence-constructors"><i>5.8 Sequence Constructors</i></a>) that
forms the content of the <a href=
"#element-value-of"><code>xsl:value-of</code></a> element.
<span>These are mutually exclusive: if the <code>select</code>
attribute is present then the sequence constructor must be empty,
and if the sequence constructor is non-empty then the
<code>select</code> attribute must be absent. If the
<code>select</code> attribute is absent and the sequence
constructor is empty, then the result of the instruction is a text
node whose string value is zero-length.</span> The way in which the
value is constructed is specified in <a href=
"#constructing-simple-content"><i>5.8.2 Constructing Simple
Content</i></a>.</p>
<p><a name="err-XTSE0870" id="err-XTSE0870"><span class=
"error">[ERR XTSE0870]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
<code>select</code> attribute of the <a href=
"#element-value-of"><code>xsl:value-of</code></a> element is
present when the content of the element is non-empty</p>
<p>If the <code>separator</code> attribute is present, then the
<a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of this attribute is used
to separate adjacent items in the result sequence, as described in
<a href="#constructing-simple-content"><i>5.8.2 Constructing Simple
Content</i></a>. In the absence of this attribute, the default
separator is a single space (#x20) when the content is specified
using the <code>select</code> attribute, or a zero-length string
when the content is specified using a <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>.</p>
<p><span>Special rules apply when the instruction is processed with
<a title="XSLT 1.0 behavior" class="termref" href=
"#dt-xslt-10-behavior">XSLT 1.0 behavior</a>.</span> If no
<code>separator</code> attribute is present, and if the
<code>select</code> attribute is present, then all items in the
<a title="atomize" class="termref" href=
"#dt-atomization">atomized</a> result sequence other than the first
are ignored.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e31257" id=
"d7e31257"></a>Example: Generating a List with Separators</div>
<p>The instruction:</p>
<div class="exampleInner">
<pre>
&lt;x&gt;&lt;xsl:value-of select="1 to 4" separator="|"/&gt;&lt;/x&gt;
</pre></div>
<p>produces the output:</p>
<div class="exampleInner">
<pre>
&lt;x&gt;1|2|3|4&lt;/x&gt;
</pre></div>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The <a href="#element-copy-of"><code>xsl:copy-of</code></a>
element can be used to copy a sequence of nodes to the <a title=
"result tree" class="termref" href="#dt-result-tree">result
tree</a> without <a title="atomize" class="termref" href=
"#dt-atomization">atomization</a>. See <a href="#copy-of"><i>11.9.2
Deep Copy</i></a>.</p>
</div>
<p>For the effect of the <a title="deprecated" class="termref"
href="#dt-deprecated">deprecated</a>
<code>disable-output-escaping</code> attribute, see <a href=
"#disable-output-escaping"><i>25.2 Disabling Output
Escaping</i></a></p>
</div>
</div>
<div class="div2">
<h3><a name="creating-document-nodes" id=
"creating-document-nodes"></a>11.5 <a href=
"#creating-document-nodes" style="text-decoration: none">Creating
Document Nodes</a></h3>
<p class="element-syntax"><a name="element-document" id=
"element-document"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:document<br />
&#160;&#160;validation? = "strict" | "lax" | "preserve" |
"strip"<br />
&#160;&#160;type? = <var>eqname</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:document&gt;</code></p>
<p>The <a href="#element-document"><code>xsl:document</code></a>
instruction is used to create a new document node. The content of
the <a href="#element-document"><code>xsl:document</code></a>
element is a <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> for the
children of the new document node. A document node is created, and
the sequence obtained by evaluating the sequence constructor is
used to construct the content of the document, as described in
<a href="#constructing-complex-content"><i>5.8.1 Constructing
Complex Content</i></a>. The <a title="temporary tree" class=
"termref" href="#dt-temporary-tree">temporary tree</a> rooted at
this document node forms the <a title="result tree" class="termref"
href="#dt-result-tree">result tree</a>.</p>
<p>Except in error situations, the result of evaluating the
<a href="#element-document"><code>xsl:document</code></a>
instruction is a single node, the newly constructed document
node.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The new document is not serialized. To construct a document that
is to form a final result rather than an intermediate result, use
the <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction described in <a href="#creating-result-trees"><i>24.1
Creating Final Result Trees</i></a>.</p>
</div>
<p>The optional attributes <code>type</code> and
<code>validation</code> may be used on the <a href=
"#element-document"><code>xsl:document</code></a> instruction to
validate the contents of the new document, and to determine the
<a title="type annotation" class="termref" href=
"#dt-type-annotation">type annotation</a> that elements and
attributes within the <a title="result tree" class="termref" href=
"#dt-result-tree">result tree</a> will carry. The permitted values
and their semantics are described in <a href=
"#validating-document-nodes"><i>24.4.2 Validating Document
Nodes</i></a>.</p>
<p>The base URI of the new document node is taken from the base URI
of the <a href="#element-document"><code>xsl:document</code></a>
instruction.</p>
<p>The <code>document-uri</code> and <code>unparsed-entities</code>
properties of the new document node are set to empty.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e31372" id=
"d7e31372"></a>Example: Checking Uniqueness Constraints in a
Temporary Tree</div>
<p>The following example creates a temporary tree held in a
variable. The use of an enclosed <a href=
"#element-document"><code>xsl:document</code></a> instruction
ensures that uniqueness constraints defined in the schema for the
relevant elements are checked.</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="tree" as="document-node()"&gt;
  &lt;xsl:document validation="strict"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:document&gt;
&lt;/xsl:variable&gt;
</pre></div>
</div>
</div>
<div class="div2">
<h3><a name="creating-processing-instructions" id=
"creating-processing-instructions"></a>11.6 <a href=
"#creating-processing-instructions" style=
"text-decoration: none">Creating Processing Instructions</a></h3>
<p class="element-syntax"><a name="element-processing-instruction"
id="element-processing-instruction"></a><code>&lt;!-- Category:
instruction --&gt;<br />
&lt;xsl:processing-instruction<br />
&#160;&#160;<b>name</b> = { <var>ncname</var> }<br />
&#160;&#160;select? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:processing-instruction&gt;</code></p>
<p>The <a href=
"#element-processing-instruction"><code>xsl:processing-instruction</code></a>
element is evaluated to create a processing instruction node.</p>
<p>The <a href=
"#element-processing-instruction"><code>xsl:processing-instruction</code></a>
element has a <span class="verb">required</span> <code>name</code>
attribute that specifies the name of the processing instruction
node. The value of the <code>name</code> attribute is interpreted
as an <a title="attribute value template" class="termref" href=
"#dt-attribute-value-template">attribute value template</a>.</p>
<p>The string value of the new processing-instruction node may be
defined either by using the <code>select</code> attribute, or by
the <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> that forms the
content of the <a href=
"#element-processing-instruction"><code>xsl:processing-instruction</code></a>
element. <span>These are mutually exclusive: if the
<code>select</code> attribute is present then the sequence
constructor must be empty, and if the sequence constructor is
non-empty then the <code>select</code> attribute must be absent. If
the <code>select</code> attribute is absent and the sequence
constructor is empty</span>, then the string value of the new
processing-instruction node will be a zero-length string. The way
in which the value is constructed is specified in <a href=
"#constructing-simple-content"><i>5.8.2 Constructing Simple
Content</i></a>.</p>
<p><a name="err-XTSE0880" id="err-XTSE0880"><span class=
"error">[ERR XTSE0880]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
<code>select</code> attribute of the <a href=
"#element-processing-instruction"><code>xsl:processing-instruction</code></a>
element is present unless the element has empty content.</p>
<p>Except in error situations, the result of evaluating the
<a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a>
instruction is a single node, the newly constructed processing
instruction node.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e31462" id=
"d7e31462"></a>Example: Creating a Processing Instruction</div>
<p>This instruction:</p>
<div class="exampleInner">
<pre>
&lt;xsl:processing-instruction name="xml-stylesheet"
  select="('href=&amp;quot;book.css&amp;quot;', 'type=&amp;quot;text/css&amp;quot;')"/&gt;
</pre></div>
<p>creates the processing instruction</p>
<div class="exampleInner">
<pre>
&lt;?xml-stylesheet href="book.css" type="text/css"?&gt;
</pre></div>
<p>Note that the <code>xml-stylesheet</code> processing instruction
contains <em>pseudo-attributes</em> in the form
<code>name="value"</code>. Although these have the same textual
form as attributes in an element start tag, they are not
represented as XDM attribute nodes, and cannot therefore be
constructed using <a href=
"#element-attribute"><code>xsl:attribute</code></a>
instructions.</p>
</div>
<p><a name="err-XTDE0890" id="err-XTDE0890"><span class=
"error">[ERR XTDE0890]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the <code>name</code>
attribute is not both an <a href=
"http://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a><sup><small>Names</small></sup>
and a <a href=
"http://www.w3.org/TR/REC-xml/#NT-PITarget">PITarget</a><sup><small>XML</small></sup>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Because these rules disallow the name <code>xml</code>, the
<a href=
"#element-processing-instruction"><code>xsl:processing-instruction</code></a>
cannot be used to output an XML declaration. The <a href=
"#element-output"><code>xsl:output</code></a> declaration should be
used to control this instead (see <a href="#serialization"><i>25
Serialization</i></a>).</p>
</div>
<p>If the result of evaluating the content of the <a href=
"#element-processing-instruction"><code>xsl:processing-instruction</code></a>
contains the string <code>?&gt;</code>, this string is modified by
inserting a space between the <code>?</code> and <code>&gt;</code>
characters.</p>
<p>The base URI of the new processing-instruction is copied from
the base URI of the <a href=
"#element-processing-instruction"><code>xsl:processing-instruction</code></a>
element in the stylesheet. (Note, however, that this is only
relevant when creating a parentless processing instruction. When
the new processing instruction is copied to form a child of an
element or document node, the base URI of the new copy is taken
from that of its new parent.)</p>
</div>
<div class="div2">
<h3><a name="creating-namespace-nodes" id=
"creating-namespace-nodes"></a>11.7 <a href=
"#creating-namespace-nodes" style="text-decoration: none">Creating
Namespace Nodes</a></h3>
<p class="element-syntax"><a name="element-namespace" id=
"element-namespace"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:namespace<br />
&#160;&#160;<b>name</b> = { <var>ncname</var> }<br />
&#160;&#160;select? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:namespace&gt;</code></p>
<p>The <a href="#element-namespace"><code>xsl:namespace</code></a>
element is evaluated to create a namespace node. Except in error
situations, the result of evaluating the <a href=
"#element-namespace"><code>xsl:namespace</code></a> instruction is
a single node, the newly constructed namespace node.</p>
<p>The <a href="#element-namespace"><code>xsl:namespace</code></a>
element has a <span class="verb">required</span> <code>name</code>
attribute that specifies the name of the namespace node (that is,
the namespace prefix). The value of the <code>name</code> attribute
is interpreted as an <a title="attribute value template" class=
"termref" href="#dt-attribute-value-template">attribute value
template</a>. If the <a title="effective value" class="termref"
href="#dt-effective-value">effective value</a> of the
<code>name</code> attribute is a zero-length string, a namespace
node is added for the default namespace.</p>
<p>The string value of the new namespace node (that is, the
namespace URI) may be defined either by using the
<code>select</code> attribute, or by the <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> that forms the
content of the <a href=
"#element-namespace"><code>xsl:namespace</code></a> element.
<span>These are mutually exclusive: if the <code>select</code>
attribute is present then the sequence constructor must be empty,
and if the sequence constructor is non-empty then the
<code>select</code> attribute must be absent.</span> Since the
string value of a namespace node cannot be a zero-length string,
<span>either a <code>select</code> attribute or a non-empty
sequence constructor <span class="verb">must</span> be
present</span>. The way in which the value is constructed is
specified in <a href="#constructing-simple-content"><i>5.8.2
Constructing Simple Content</i></a>.</p>
<p><a name="err-XTDE0905" id="err-XTDE0905"><span class=
"error">[ERR XTDE0905]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
string value of the new namespace node is not valid in the lexical
space of the datatype <code>xs:anyURI</code>, or if it is the
string <code>http://www.w3.org/2000/xmlns/</code>.</p>
<p><a name="err-XTSE0910" id="err-XTSE0910"><span class=
"error">[ERR XTSE0910]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
<code>select</code> attribute of the <a href=
"#element-namespace"><code>xsl:namespace</code></a> element is
present when the element has content other than one or more
<a href="#element-fallback"><code>xsl:fallback</code></a>
instructions, or if the <code>select</code> attribute is absent
when the element has empty content.</p>
<p>Note the restrictions described in <a href=
"#constructing-complex-content"><i>5.8.1 Constructing Complex
Content</i></a> for the position of a namespace node relative to
other nodes in the node sequence returned by a sequence
constructor.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e31670" id=
"d7e31670"></a>Example: Constructing a QName-Valued Attribute</div>
<p>This literal result element:</p>
<div class="exampleInner">
<pre>
&lt;data xsi:type="xs:integer" 
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
  &lt;xsl:namespace name="xs" 
                 select="'http://www.w3.org/2001/XMLSchema'"/&gt;
  &lt;xsl:text&gt;42&lt;/xsl:text&gt;
&lt;/data&gt;
</pre></div>
<p>would typically cause the output document to contain the
element:</p>
<div class="exampleInner">
<pre>
&lt;data xsi:type="xs:integer"
     xmlns:xs="http://www.w3.org/2001/XMLSchema"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;42&lt;/data&gt;
</pre></div>
<p>In this case, the element is constructed using a literal result
element, and the namespace
<code>xmlns:xs="http://www.w3.org/2001/XMLSchema"</code> could
therefore have been added to the <a title="result tree" class=
"termref" href="#dt-result-tree">result tree</a> simply by
declaring it as one of the in-scope namespaces in the stylesheet.
In practice, the <a href=
"#element-namespace"><code>xsl:namespace</code></a> instruction is
more likely to be useful in situations where the element is
constructed using an <a href=
"#element-element"><code>xsl:element</code></a> instruction, which
does not copy all the in-scope namespaces from the stylesheet.</p>
</div>
<p><a name="err-XTDE0920" id="err-XTDE0920"><span class=
"error">[ERR XTDE0920]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the <code>name</code>
attribute is neither a zero-length string nor an <a href=
"http://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a><sup><small>Names</small></sup>,
or if it is <code>xmlns</code>.</p>
<p><a name="err-XTDE0925" id="err-XTDE0925"><span class=
"error">[ERR XTDE0925]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<a href="#element-namespace"><code>xsl:namespace</code></a>
instruction generates a namespace node whose name is
<code>xml</code> and whose string value is not
<code>http://www.w3.org/XML/1998/namespace</code>, or a namespace
node whose string value is
<code>http://www.w3.org/XML/1998/namespace</code> and whose name is
not <code>xml</code>.</p>
<p><a name="err-XTDE0930" id="err-XTDE0930"><span class=
"error">[ERR XTDE0930]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if
evaluating the <code>select</code> attribute or the contained
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> of an <a href=
"#element-namespace"><code>xsl:namespace</code></a> instruction
results in a zero-length string.</p>
<p>For details of other error conditions that may arise, see
<a href="#sequence-constructors"><i>5.8 Sequence
Constructors</i></a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>It is rarely necessary to use <a href=
"#element-namespace"><code>xsl:namespace</code></a> to create a
namespace node in the <a title="result tree" class="termref" href=
"#dt-result-tree">result tree</a>; in most circumstances, the
required namespace nodes will be created automatically, as a
side-effect of writing elements or attributes that use the
namespace. An example where <a href=
"#element-namespace"><code>xsl:namespace</code></a> is needed is a
situation where the required namespace is used only within
attribute values in the result document, not in element or
attribute names; especially where the required namespace prefix or
namespace URI is computed at run-time and is not present in either
the source document or the stylesheet.</p>
<p>Adding a namespace node to the <a title="result tree" class=
"termref" href="#dt-result-tree">result tree</a> will never change
the <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> of any element or attribute
node in the result tree: that is, it will never change the
namespace URI of an element or attribute. It might, however,
constrain the choice of prefixes when namespace fixup is
performed.</p>
<p>Namespace prefixes for element and attribute names are initially
established by the rules of the instruction that creates the
element or attribute node, and in the event of conflicts, they may
be changed by the namespace fixup process described in <a href=
"#namespace-fixup"><i>5.8.3 Namespace Fixup</i></a>. The fixup
process ensures that an element has in-scope namespace nodes for
the namespace URIs used in the element name and in its attribute
names, and the serializer will typically use these namespace nodes
to determine the prefix to use in the serialized output. The fixup
process cannot generate namespace nodes that are inconsistent with
those already present in the tree. This means that it is not
possible for the processor to decide the prefix to use for an
element or for any of its attributes until all the namespace nodes
for the element have been added.</p>
<p>If a namespace prefix is mapped to a particular namespace URI
using the <a href=
"#element-namespace"><code>xsl:namespace</code></a> instruction, or
by using <a href="#element-copy"><code>xsl:copy</code></a> or
<a href="#element-copy-of"><code>xsl:copy-of</code></a> to copy a
namespace node, this prevents the namespace fixup process (and
hence the serializer) from using the same prefix for a different
namespace URI on the same element.</p>
</div>
<div class="example">
<div class="exampleHeader"><a name="d7e31811" id=
"d7e31811"></a>Example: Conflicting Namespace Prefixes</div>
<p>Given the instruction:</p>
<div class="exampleInner">
<pre>
&lt;xsl:element name="p:item" 
                 xmlns:p="http://www.example.com/p"&gt;
  &lt;xsl:namespace name="p"&gt;http://www.example.com/q&lt;/xsl:namespace&gt;
&lt;/xsl:element&gt;
</pre></div>
<p>a possible serialization of the <a title="result tree" class=
"termref" href="#dt-result-tree">result tree</a> is:</p>
<div class="exampleInner">
<pre>
&lt;ns0:item 
    xmlns:ns0="http://www.example.com/p" 
    xmlns:p="http://www.example.com/q"/&gt;
</pre></div>
<p>The processor must invent a namespace prefix for the URI
<code>p.uri</code>; it cannot use the prefix <code>p</code> because
that prefix has been explicitly associated with a different
URI.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The <a href="#element-namespace"><code>xsl:namespace</code></a>
instruction cannot be used to generate a <b>namespace
undeclaration</b> of the form <code>xmlns=""</code> (nor the new
forms of namespace undeclaration permitted in <a href=
"#xml-names11">[Namespaces in XML 1.1]</a>). Namespace
undeclarations are generated automatically by the serializer if
<code>undeclare-prefixes="yes"</code> is specified on <a href=
"#element-output"><code>xsl:output</code></a>, whenever a parent
element has a namespace node for the default namespace prefix, and
a child element has no namespace node for that prefix.</p>
</div>
</div>
<div class="div2">
<h3><a name="creating-comments" id="creating-comments"></a>11.8
<a href="#creating-comments" style="text-decoration: none">Creating
Comments</a></h3>
<p class="element-syntax"><a name="element-comment" id=
"element-comment"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:comment<br />
&#160;&#160;select? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:comment&gt;</code></p>
<p>The <a href="#element-comment"><code>xsl:comment</code></a>
element is evaluated to construct a new comment node. Except in
error cases, the result of evaluating the <a href=
"#element-comment"><code>xsl:comment</code></a> instruction is a
single node, the newly constructed comment node.</p>
<p>The string value of the new comment node may be defined either
by using the <code>select</code> attribute, or by the <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> that forms the
content of the <a href=
"#element-comment"><code>xsl:comment</code></a> element.
<span>These are mutually exclusive: if the <code>select</code>
attribute is present then the sequence constructor must be empty,
and if the sequence constructor is non-empty then the
<code>select</code> attribute must be absent. If the
<code>select</code> attribute is absent and the sequence
constructor is empty</span>, then the string value of the new
comment node will be a zero-length string. The way in which the
value is constructed is specified in <a href=
"#constructing-simple-content"><i>5.8.2 Constructing Simple
Content</i></a>.</p>
<p><a name="err-XTSE0940" id="err-XTSE0940"><span class=
"error">[ERR XTSE0940]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
<code>select</code> attribute of the <a href=
"#element-comment"><code>xsl:comment</code></a> element is present
unless the element has empty content.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e31912" id=
"d7e31912"></a>Example: Generating a Comment Node</div>
<p>For example, this</p>
<div class="exampleInner">
<pre>
&lt;xsl:comment&gt;This file is automatically generated. Do not edit!&lt;/xsl:comment&gt;
</pre></div>
<p>would create the comment</p>
<div class="exampleInner">
<pre>
&lt;!--This file is automatically generated. Do not edit!--&gt;
</pre></div>
</div>
<p>In the generated comment node, the processor <span class=
"verb">must</span> insert a space after any occurrence of
<code>-</code> that is followed by another <code>-</code> or that
ends the comment.</p>
</div>
<div class="div2">
<h3><a name="copying" id="copying"></a>11.9 <a href="#copying"
style="text-decoration: none">Copying Nodes</a></h3>
<div class="div3">
<h4><a name="shallow-copy" id="shallow-copy"></a>11.9.1 <a href=
"#shallow-copy" style="text-decoration: none">Shallow Copy</a></h4>
<p class="element-syntax"><a name="element-copy" id=
"element-copy"></a><code>&lt;!-- Category: instruction --&gt;<br />
&lt;xsl:copy<br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;copy-namespaces? = <var>boolean</var><br />
&#160;&#160;inherit-namespaces? = <var>boolean</var><br />
&#160;&#160;use-attribute-sets? = <var>eqnames</var><br />
&#160;&#160;type? = <var>eqname</var><br />
&#160;&#160;validation? = "strict" | "lax" | "preserve" |
"strip"<br />
&#160;&#160;on-empty? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:copy&gt;</code></p>
<p>The <a href="#element-copy"><code>xsl:copy</code></a>
instruction provides a way of copying <span>a selected item. The
selected item is the item selected by evaluating the expression in
the <code>select</code> attribute if present, or the <a title=
"context item" class="termref" href="#dt-context-item">context
item</a> otherwise</span>. If the selected item is a node,
evaluating the <a href="#element-copy"><code>xsl:copy</code></a>
instruction constructs a copy of the selected node, and the result
of the <a href="#element-copy"><code>xsl:copy</code></a>
instruction is this newly constructed node. By default, the
namespace nodes of the context node are automatically copied as
well, but the attributes and children of the node are not
automatically copied.</p>
<p><a name="err-XTTE0945" id="err-XTTE0945"><span class=
"error">[ERR XTTE0945]</span></a> It is a <a title="type error"
class="termref" href="#dt-type-error">type error</a> to use the
<a href="#element-copy"><code>xsl:copy</code></a> instruction with
no <code>select</code> attribute when the context item is
absent.</p>
<p>When the <span>selected item</span> is an atomic value <span>or
function item</span>, the <a href=
"#element-copy"><code>xsl:copy</code></a> instruction returns this
value. The <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> is not
evaluated.</p>
<p>When the <span>selected item</span> is an attribute node, text
node, comment node, processing instruction node, or namespace node,
the <a href="#element-copy"><code>xsl:copy</code></a> instruction
returns a new node that is a copy of the context node. The new node
will have the same node kind, name, and string value as the context
node. In the case of an attribute node, it will also have the same
values for the <code>is-id</code> and <code>is-idrefs</code>
properties. The <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> is not
evaluated.</p>
<p>When the <span>selected item</span> is a document node or
element node, the <a href="#element-copy"><code>xsl:copy</code></a>
instruction returns a new node that has the same node kind and name
as the <span>selected</span> node. The content of the new node is
formed by evaluating the <a title="sequence constructor" class=
"termref" href="#dt-sequence-constructor">sequence constructor</a>
contained in the <a href="#element-copy"><code>xsl:copy</code></a>
instruction. <span>If the <code>select</code> attribute is present
then the sequence constructor is evaluated with the selected item
as the <a title="singleton focus" class="termref" href=
"#dt-singleton-focus">singleton focus</a>; otherwise it is
evaluated using the context of the <a href=
"#element-copy"><code>xsl:copy</code></a> instruction
unchanged.</span> The sequence obtained by evaluating this sequence
constructor is used (after prepending any attribute nodes or
namespace nodes as described in the following paragraphs) to
construct the content of the document or element node, as described
in <a href="#constructing-complex-content"><i>5.8.1 Constructing
Complex Content</i></a>.</p>
<p>If the <code>select</code> expression returns an empty sequence,
the <a href="#element-copy"><code>xsl:copy</code></a> instruction
returns an empty sequence, and the contained <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> is not
evaluated.</p>
<p><a name="err-XTTE3180" id="err-XTTE3180"><span class=
"error">[ERR XTTE3180]</span></a> It is a <a title="type error"
class="termref" href="#dt-type-error">type error</a> if the result
of evaluating the <code>select</code> expression is a sequence of
more than one item.</p>
<p>The <a href="#element-copy"><code>xsl:copy</code></a>
instruction has an optional <code>use-attribute-sets</code>
attribute, whose value is a whitespace-separated list of QNames
that identify <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a>
declarations. This attribute is used only when copying element
nodes. This list is expanded as described in <a href=
"#attribute-sets"><i>10.2 Named Attribute Sets</i></a> to produce a
sequence of attribute nodes. This sequence is prepended to the
sequence produced as a result of evaluating the <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>.</p>
<p>The <a href="#element-copy"><code>xsl:copy</code></a>
instruction has an optional <code>copy-namespaces</code> attribute,
with the value <code>yes</code> or <code>no</code>. The default
value is <code>yes</code>. The attribute is used only when copying
element nodes. If the value is set to <code>yes</code>, or is
omitted, then all the namespace nodes of the source element are
copied as namespace nodes for the result element. These copied
namespace nodes are prepended to the sequence produced as a result
of evaluating the <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> (it is
immaterial whether they come before or after any attribute nodes
produced by expanding the <code>use-attribute-sets</code>
attribute). If the value is set to <code>no</code>, then the
namespace nodes are not copied. However, namespace nodes will still
be added to the result element as <span class=
"verb">required</span> by the namespace fixup process: see <a href=
"#namespace-fixup"><i>5.8.3 Namespace Fixup</i></a>.</p>
<p>The <a href="#element-copy"><code>xsl:copy</code></a>
instruction has an optional <code>inherit-namespaces</code>
attribute, with the value <code>yes</code> or <code>no</code>. The
default value is <code>yes</code>. The attribute is used only when
copying element nodes. If the value is set to <code>yes</code>, or
is omitted, then the namespace nodes created for the newly
constructed element (whether these were copied from those of the
source node, or generated as a result of namespace fixup) are
copied to the children and descendants of the newly constructed
element, as described in <a href=
"#constructing-complex-content"><i>5.8.1 Constructing Complex
Content</i></a>. If the value is set to <code>no</code>, then these
namespace nodes are not automatically copied to the children. This
may result in namespace undeclarations (such as
<code>xmlns=""</code> or, in the case of XML Namespaces 1.1,
<code>xmlns:p=""</code>) appearing on the child elements when a
<a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a> is serialized.</p>
<p><a name="err-XTTE0950" id="err-XTTE0950"><span class=
"error">[ERR XTTE0950]</span></a> It is a <a title="type error"
class="termref" href="#dt-type-error">type error</a> to use the
<a href="#element-copy"><code>xsl:copy</code></a> or <a href=
"#element-copy-of"><code>xsl:copy-of</code></a> instruction to copy
a node that has namespace-sensitive content if the
<code>copy-namespaces</code> attribute has the value
<code>no</code> and its explicit or implicit
<code>validation</code> attribute has the value
<code>preserve</code>. It is also a type error if either of these
instructions (with <code>validation="preserve"</code>) is used to
copy an attribute having namespace-sensitive content, unless the
parent element is also copied. A node has namespace-sensitive
content if its typed value contains an item of type
<code>xs:QName</code> or <code>xs:NOTATION</code> or a type derived
therefrom. The reason this is an error is because the validity of
the content depends on the namespace context being preserved.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>When attribute nodes are copied, whether with <a href=
"#element-copy"><code>xsl:copy</code></a> or with <a href=
"#element-copy-of"><code>xsl:copy-of</code></a>, the processor does
not automatically copy any associated namespace information. The
namespace used in the attribute name itself will be declared by
virtue of the namespace fixup process (see <a href=
"#namespace-fixup"><i>5.8.3 Namespace Fixup</i></a>) when the
attribute is added to an element in the <a title="result tree"
class="termref" href="#dt-result-tree">result tree</a>, but if
namespace prefixes are used in the content of the attribute (for
example, if the value of the attribute is an XPath expression) then
it is the responsibility of the stylesheet author to ensure that
suitable namespace nodes are added to the <a title="result tree"
class="termref" href="#dt-result-tree">result tree</a>. This can be
achieved by copying the namespace nodes using <a href=
"#element-copy"><code>xsl:copy</code></a>, or by generating them
using <a href=
"#element-namespace"><code>xsl:namespace</code></a>.</p>
</div>
<p>The optional attributes <code>type</code> and
<code>validation</code> may be used on the <a href=
"#element-copy"><code>xsl:copy</code></a> instruction to validate
the contents of an element, attribute or document node against a
type definition, element declaration, or attribute declaration in a
schema, and thus to determine the <a title="type annotation" class=
"termref" href="#dt-type-annotation">type annotation</a> that the
new copy of an element or attribute node will carry. These
attributes are ignored when copying an item that is not an element,
attribute or document node. When the node being copied is an
element or document node, these attributes also affect the type
annotation carried by any elements and attributes that have the
copied element or document node as an ancestor. These two
attributes are both optional, and if one is specified then the
other <span class="verb">must</span> be omitted. The permitted
values of these attributes and their semantics are described in
<a href="#validation"><i>24.4 Validation</i></a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The final <a title="type annotation" class="termref" href=
"#dt-type-annotation">type annotation</a> of the node in the
<a title="result tree" class="termref" href=
"#dt-result-tree">result tree</a> also depends on the
<code>type</code> and <code>validation</code> attributes of the
instructions used to create the ancestors of the node.</p>
</div>
<p>When a node is copied, its base URI is copied, except when the
result of the <a href="#element-copy"><code>xsl:copy</code></a>
instruction is an element node having an <code>xml:base</code>
attribute, in which case the base URI of the new node is taken as
the value of its <code>xml:base</code> attribute, resolved if it is
relative against the base URI of the <a href=
"#element-copy"><code>xsl:copy</code></a> instruction.</p>
<p>When an <code>xml:id</code> attribute is copied, using either
the <a href="#element-copy"><code>xsl:copy</code></a> or <a href=
"#element-copy-of"><code>xsl:copy-of</code></a> instruction, it is
<a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> whether the
value of the attribute is subjected to attribute value
normalization (that is, effectively applying the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-normalize-space"><code>
normalize-space</code></a><sup><small>FO30</small></sup>
function).</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In most cases the value will already have been subjected to
attribute value normalization on the source tree, but if this
processing has not been performed on the source tree, it is not an
error for it to be performed on the result tree.</p>
</div>
<div class="div4">
<h5><a name="conditional-copy" id="conditional-copy"></a>11.9.1.1
<a href="#conditional-copy" style=
"text-decoration: none">Conditional Copying of Nodes</a></h5>
<p>The effect of specifying an <code>on-empty</code> attribute is
as follows.</p>
<p>If the <b>selected item</b> is not an element node, the
attribute has no effect, except that static errors <span class=
"verb">must</span> be reported and type errors <span class=
"verb">may</span> be reported.</p>
<p>If the result of the instruction in the absence of the
<code>on-empty</code> attribute would be an element or document
node having no attributes and no children then instead of returning
this result, the instruction returns the result of evaluating the
expression in the <code>on-empty</code> attribute; if the result of
this expression is a node, the instruction returns a copy of this
node. <span>The <code>on-empty</code> attribute is evaluated with
the same <a title="focus" class="termref" href=
"#dt-focus">focus</a> as the <a href=
"#element-copy"><code>xsl:copy</code></a> instruction
itself.</span></p>
<p><a name="err-XTTE3330" id="err-XTTE3330"><span class=
"error">[ERR XTTE3330]</span></a> It is a <a title="type error"
class="termref" href="#dt-type-error">type error</a> if the result
of evaluating the <code>on-empty</code> attribute does not satisfy
the required type <code>element()?</code>. That is, the expression
must deliver either a single element node, or an empty
sequence.</p>
<p>If the <code>on-empty</code> expression is evaluated and returns
an empty sequence then the <code>validation</code> and
<code>type</code> attributes are ignored. However, if the result of
the <code>on-empty</code> expression is an element node, then it is
subjected to validation as determined by these attributes, along
with <code>[xsl:]default-validation</code> where relevant.</p>
</div>
</div>
<div class="div3">
<h4><a name="copy-of" id="copy-of"></a>11.9.2 <a href="#copy-of"
style="text-decoration: none">Deep Copy</a></h4>
<p class="element-syntax"><a name="element-copy-of" id=
"element-copy-of"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:copy-of<br />
&#160;&#160;<b>select</b> = <var>expression</var><br />
&#160;&#160;copy-namespaces? = <var>boolean</var><br />
&#160;&#160;type? = <var>eqname</var><br />
&#160;&#160;validation? = "strict" | "lax" | "preserve" |
"strip"&#160;/&gt;</code></p>
<p>The <a href="#element-copy-of"><code>xsl:copy-of</code></a>
instruction can be used to construct a copy of a sequence of nodes,
atomic values, <span>and/or function items</span> with each new
node containing copies of all the children, attributes, and (by
default) namespaces of the original node, recursively. The result
of evaluating the instruction is a sequence of items corresponding
one-to-one with the supplied sequence, and retaining its order.</p>
<p>The <span class="verb">required</span> <code>select</code>
attribute contains an <a title="expression" class="termref" href=
"#dt-expression">expression</a>, whose value may be any sequence of
nodes, atomic values, <span>and/or function items</span>. The items
in this sequence are processed as follows:</p>
<ul>
<li>
<p>If the item is an element node, a new element is constructed and
appended to the result sequence. The new element will have the same
<a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> as the original, and it
will have deep copies of the attribute nodes and children of the
element node.</p>
<p>The new element will also have namespace nodes copied from the
original element node, unless they are excluded by specifying
<code>copy-namespaces="no"</code>. If this attribute is omitted, or
takes the value <code>yes</code>, then all the namespace nodes of
the original element are copied to the new element. If it takes the
value <code>no</code>, then none of the namespace nodes are copied:
however, namespace nodes will still be created in the <a title=
"result tree" class="termref" href="#dt-result-tree">result
tree</a> as <span class="verb">required</span> by the namespace
fixup process: see <a href="#namespace-fixup"><i>5.8.3 Namespace
Fixup</i></a>. This attribute affects all elements copied by this
instruction: both elements selected directly by the
<code>select</code> <a title="expression" class="termref" href=
"#dt-expression">expression</a>, and elements that are descendants
of nodes selected by the <code>select</code> expression.</p>
<p>The new element will have the same values of the
<code>is-id</code>, <code>is-idrefs</code>, and <code>nilled</code>
properties as the original element.</p>
</li>
<li>
<p>If the item is a document node, the instruction adds a new
document node to the result sequence; the children of this document
node will be one-to-one copies of the children of the original
document node (each copied according to the rules for its own node
kind).</p>
</li>
<li>
<p>If the item is an attribute or namespace node, or a text node, a
comment, or a processing instruction, the same rules apply as with
<a href="#element-copy"><code>xsl:copy</code></a> (see <a href=
"#shallow-copy"><i>11.9.1 Shallow Copy</i></a>).</p>
</li>
<li>
<p>If the item is an atomic value <span>or a function item</span>,
the value is appended to the result sequence, as with <a href=
"#element-sequence"><code>xsl:sequence</code></a>.</p>
</li>
</ul>
<p>The optional attributes <code>type</code> and
<code>validation</code> may be used on the <a href=
"#element-copy-of"><code>xsl:copy-of</code></a> instruction to
validate the contents of an element, attribute or document node
against a type definition, element declaration, or attribute
declaration in a schema and thus to determine the <a title=
"type annotation" class="termref" href="#dt-type-annotation">type
annotation</a> that the new copy of an element or attribute node
will carry. These attributes are applied individually to each
element, attribute, and document node that is selected by the
expression in the <code>select</code> attribute. These attributes
are ignored when copying an item that is not an element, attribute
or document node.</p>
<p>The specified <code>type</code> and <code>validation</code>
apply directly only to elements, attributes and document nodes
created as copies of nodes actually selected by the
<code>select</code> expression, they do not apply to nodes that are
implicitly copied because they have selected nodes as an ancestor.
However, these attributes do indirectly affect the <a title=
"type annotation" class="termref" href="#dt-type-annotation">type
annotation</a> carried by such implicitly copied nodes, as a
consequence of the validation process.</p>
<p>These two attributes are both optional, and if one is specified
then the other <span class="verb">must</span> be omitted. The
permitted values of these attributes and their semantics are
described in <a href="#validation"><i>24.4 Validation</i></a>.</p>
<p>Errors may occur when copying namespace-sensitive elements or
attributes using <code>validation="preserve"</code>. <span class=
"error">[see <a href="#err-XTTE0950">ERR XTTE0950</a>]</span>.</p>
<p>If removal of namespaces is requested using
<code>copy-namespaces="no"</code>, then any validation that is
requested is applied to the tree that remains after the relevant
namespaces have been removed. This will cause validation to fail if
there is namespace-sensitive content that depends on the presence
of the removed namespaces.</p>
<p>The base URI of a node is copied, except in the case of an
element node having an <code>xml:base</code> attribute, in which
case the base URI of the new node is taken as the value of the
<code>xml:base</code> attribute, resolved if it is relative against
the base URI of the <a href=
"#element-copy-of"><code>xsl:copy-of</code></a> instruction. If the
copied node is subsequently attached as a child to a new element or
document node, the final copy of the node inherits its base URI
from its parent node, unless this is overridden using an
<code>xml:base</code> attribute.</p>
</div>
</div>
<div class="div2">
<h3><a name="constructing-sequences" id=
"constructing-sequences"></a>11.10 <a href=
"#constructing-sequences" style=
"text-decoration: none">Constructing Sequences</a></h3>
<p class="element-syntax"><a name="element-sequence" id=
"element-sequence"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:sequence<br />
&#160;&#160;select? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:sequence&gt;</code></p>
<p>The <a href="#element-sequence"><code>xsl:sequence</code></a>
instruction may be used within a <a title="sequence constructor"
class="termref" href="#dt-sequence-constructor">sequence
constructor</a> to construct a sequence of nodes, atomic values,
<span>and/or function items</span>. This sequence is returned as
the result of the instruction. Unlike most other instructions,
<a href="#element-sequence"><code>xsl:sequence</code></a> can
return a sequence containing existing nodes, rather than
constructing new nodes. When <a href=
"#element-sequence"><code>xsl:sequence</code></a> is used to select
atomic values <span>or function items</span>, the effect is very
similar to the <a href=
"#element-copy-of"><code>xsl:copy-of</code></a> instruction.</p>
<p>The items comprising the result sequence are evaluated either
using the <code>select</code> attribute, or using the contained
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>. These are
mutually exclusive; if the instruction has a <code>select</code>
attribute, then it <span class="verb">must</span> have no children
other than <a href=
"#element-fallback"><code>xsl:fallback</code></a> instructions. If
there is no <code>select</code> attribute and no contained
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>, the result is
an empty sequence.</p>
<p><a name="err-XTSE3185" id="err-XTSE3185"><span class=
"error">[ERR XTSE3185]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
<code>select</code> attribute of <a href=
"#element-sequence"><code>xsl:sequence</code></a> is present and
the instruction has children other than <a href=
"#element-fallback"><code>xsl:fallback</code></a>.</p>
<p>Any contained <a href=
"#element-fallback"><code>xsl:fallback</code></a> instructions are
ignored by an XSLT 2.0 <span>or 3.0</span> processor, but can be
used to define fallback behavior for an XSLT 1.0 processor running
in forwards compatibility mode.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e32672" id=
"d7e32672"></a>Example: Constructing a Sequence of Integers</div>
<p>For example, the following code:</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="values" as="xs:integer*"&gt;
    &lt;xsl:sequence select="(1,2,3,4)"/&gt;
    &lt;xsl:sequence select="(8,9,10)"/&gt;
&lt;/xsl:variable&gt;
&lt;xsl:value-of select="sum($values)"/&gt;
</pre></div>
<p>produces the output: <code>37</code></p>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e32684" id=
"d7e32684"></a>Example: Using <code>xsl:for-each</code> to
Construct a Sequence</div>
<p>The following code constructs a sequence containing the value of
the <code>@price</code> attribute for selected elements (which we
assume to be typed as <code>xs:decimal</code>), or a computed price
for those elements that have no <code>@price</code> attribute. It
then returns the average price:</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="prices" as="xs:decimal*"&gt;
  &lt;xsl:for-each select="//product"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="@price"&gt;
        &lt;xsl:sequence select="@price"/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:sequence select="@cost * 1.5"/&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:variable&gt;
&lt;xsl:value-of select="avg($prices)"/&gt;
</pre></div>
<p>Note that the existing <code>@price</code> attributes could
equally have been added to the <code>$prices</code> sequence using
<a href="#element-copy-of"><code>xsl:copy-of</code></a> or <a href=
"#element-value-of"><code>xsl:value-of</code></a>. However,
<a href="#element-copy-of"><code>xsl:copy-of</code></a> would
create a copy of the attribute node, which is not needed in this
situation, while <a href=
"#element-value-of"><code>xsl:value-of</code></a> would create a
new text node, which then has to be converted to an
<code>xs:decimal</code>. Using <a href=
"#element-sequence"><code>xsl:sequence</code></a>, which in this
case atomizes the existing attribute node and adds an
<code>xs:decimal</code> atomic value to the result sequence, is a
more direct way of achieving the same result.</p>
<p>This example could alternatively be solved at the XPath
level:</p>
<div class="exampleInner">
<pre>
&lt;xsl:value-of select="avg(//product/(+@price, @cost*1.5)[1])"/&gt;
</pre></div>
<p>The apparently redundant <code>+</code> operator is there to
atomize the attribute value: the expression on the right hand side
of the <code>/</code> operator must not return a <span>sequence
containing both nodes and non-nodes (atomic values or function
items).</span></p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The main use case for allowing <a href=
"#element-sequence"><code>xsl:sequence</code></a> to contain a
sequence constructor is to allow the instructions within an
<a href="#element-fork"><code>xsl:fork</code></a> element to be
divided into groups.</p>
<p>It can also be used to limit the scope of local variables or of
standard attributes such as
<code>[xsl:]default-collation</code>.</p>
</div>
</div>
</div>
<div class="div1">
<h2><a name="number" id="number"></a>12 <a href="#number" style=
"text-decoration: none">Numbering</a></h2>
<p class="element-syntax"><a name="element-number" id=
"element-number"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:number<br />
&#160;&#160;value? = <var>expression</var><br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;level? = "single" | "multiple" | "any"<br />
&#160;&#160;count? = <var>pattern</var><br />
&#160;&#160;from? = <var>pattern</var><br />
&#160;&#160;format? = { <var>string</var> }<br />
&#160;&#160;lang? = { <var>language</var> }<br />
&#160;&#160;letter-value? = { "alphabetic" | "traditional" }<br />
&#160;&#160;ordinal? = { <var>string</var> }<br />
&#160;&#160;start-at? = { <var>integer</var> }<br />
&#160;&#160;grouping-separator? = { <var>char</var> }<br />
&#160;&#160;grouping-size? = { <var>integer</var>
}&#160;/&gt;</code></p>
<p>The <a href="#element-number"><code>xsl:number</code></a>
instruction is used to create a formatted number. The result of the
instruction is a newly constructed text node containing the
formatted number as its <a title="string value" class="termref"
href="#dt-string-value">string value</a>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-place-marker" id="dt-place-marker" title="place marker"></a>The
<a href="#element-number"><code>xsl:number</code></a> instruction
performs two tasks: firstly, determining a <b>place marker</b>
(this is a sequence of integers, to allow for hierarchic numbering
schemes such as <code>1.12.2</code> or <code>3(c)ii</code>), and
secondly, formatting the place marker for output as a text node in
the result sequence.<span class="definition">]</span> The place
marker to be formatted can either be supplied directly, in the
<code>value</code> attribute, or it can be computed based on the
position of a selected node within the tree that contains it.</p>
<p><a name="err-XTSE0975" id="err-XTSE0975"><span class=
"error">[ERR XTSE0975]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
<code>value</code> attribute of <a href=
"#element-number"><code>xsl:number</code></a> is present unless the
<code>select</code>, <code>level</code>, <code>count</code>, and
<code>from</code> attributes are all absent.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The facilities described in this section are specifically
designed to enable the calculation and formatting of section
numbers, paragraph numbers, and the like. For formatting of other
numeric quantities, the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-number"><code>
format-number</code></a><sup><small>FO30</small></sup> function may
be more suitable: see <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-number">Section
4.7.2 fn:format-number</a> <sup><small>FO30</small></sup>.</p>
<p>Furthermore, formatting of integers where there is no
requirement to calculate the position of a node in the document can
now be accomplished using the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-number"><code>
format-number</code></a><sup><small>FO30</small></sup> function,
which borrows many concepts from the <a href=
"#element-number"><code>xsl:number</code></a> specification.</p>
</div>
<div class="div2">
<h3><a name="formatting-supplied-number" id=
"formatting-supplied-number"></a>12.1 <a href=
"#formatting-supplied-number" style=
"text-decoration: none">Formatting a Supplied Number</a></h3>
<p>The <a title="place marker" class="termref" href=
"#dt-place-marker">place marker</a> to be formatted may be
specified by an expression. The <code>value</code> attribute
contains the <a title="expression" class="termref" href=
"#dt-expression">expression</a>. The value of this expression is
<a title="atomize" class="termref" href=
"#dt-atomization">atomized</a> using the procedure defined in
<a href="#xpath-30">[XPath 3.0]</a>, and each value <var>$V</var>
in the atomized sequence is then converted to the integer value
returned by the XPath expression
<code>xs:integer(round(number($V)))</code>. <span>If the
<code>start-at</code> attribute is present, then its effective
value is converted to an integer and decremented by one, and the
resulting value is added to each integer in the sequence.</span>
The resulting sequence of integers is used as the place marker to
be formatted.</p>
<p>If the instruction is processed with <a title=
"XSLT 1.0 behavior" class="termref" href=
"#dt-xslt-10-behavior">XSLT 1.0 behavior</a>, then:</p>
<ul>
<li>
<p>all items in the <a title="atomize" class="termref" href=
"#dt-atomization">atomized</a> sequence after the first are
discarded;</p>
</li>
<li>
<p>If the atomized sequence is empty, it is replaced by a sequence
containing the <code>xs:double</code> value <code>NaN</code> as its
only item;</p>
</li>
<li>
<p>If any value in the sequence cannot be converted to an integer
(this includes the case where the sequence contains a
<code>NaN</code> value) then the string <code>NaN</code> is
inserted into the formatted result string in its proper position.
The error described in the following paragraph does not apply in
this case.</p>
</li>
</ul>
<p><a name="err-XTDE0980" id="err-XTDE0980"><span class=
"error">[ERR XTDE0980]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if any
undiscarded item in the atomized sequence supplied as the value of
the <code>value</code> attribute of <a href=
"#element-number"><code>xsl:number</code></a> cannot be converted
to an integer, or if the resulting integer is less than 0
(zero).</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The value zero does not arise when numbering nodes in a source
document, but it can arise in other numbering sequences. It is
permitted specifically because the rules of the <a href=
"#element-number"><code>xsl:number</code></a> instruction are also
invoked by functions such as <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-time"><code>format-time</code></a><sup><small>FO30</small></sup>:
the minutes and seconds component of a time value can legitimately
be zero.</p>
</div>
<p>The resulting sequence is formatted as a string using the
<a title="effective value" class="termref" href=
"#dt-effective-value">effective values</a> of the attributes
specified in <a href="#convert"><i>12.3 Number to String Conversion
Attributes</i></a>; each of these attributes is interpreted as an
<a title="attribute value template" class="termref" href=
"#dt-attribute-value-template">attribute value template</a>. After
conversion, the <a href=
"#element-number"><code>xsl:number</code></a> element constructs a
new text node containing the resulting string, and returns this
node.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e32978" id=
"d7e32978"></a>Example: Numbering a Sorted List</div>
<p>The following example numbers a sorted list:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="items"&gt;
  &lt;xsl:for-each select="item"&gt;
    &lt;xsl:sort select="."/&gt;
    &lt;p&gt;
      &lt;xsl:number value="position()" format="1. "/&gt;
      &lt;xsl:value-of select="."/&gt;
    &lt;/p&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
</div>
<div class="div2">
<h3><a name="numbering-based-on-position" id=
"numbering-based-on-position"></a>12.2 <a href=
"#numbering-based-on-position" style=
"text-decoration: none">Numbering based on Position in a
Document</a></h3>
<p>If no <code>value</code> attribute is specified, then the
<a href="#element-number"><code>xsl:number</code></a> instruction
returns a new text node containing a formatted <a title=
"place marker" class="termref" href="#dt-place-marker">place
marker</a> that is based on the position of a selected node within
its containing document. If the <code>select</code> attribute is
present, then the expression contained in the <code>select</code>
attribute is evaluated to determine the selected node. If the
<code>select</code> attribute is omitted, then the selected node is
the <a title="context node" class="termref" href=
"#dt-context-node">context node</a>.</p>
<p><a name="err-XTTE0990" id="err-XTTE0990"><span class=
"error">[ERR XTTE0990]</span></a> It is a <a title="type error"
class="termref" href="#dt-type-error">type error</a> if the
<a href="#element-number"><code>xsl:number</code></a> instruction
is evaluated, with no <code>value</code> or <code>select</code>
attribute, when the <a title="context item" class="termref" href=
"#dt-context-item">context item</a> is not a node.</p>
<p><a name="err-XTTE1000" id="err-XTTE1000"><span class=
"error">[ERR XTTE1000]</span></a> It is a <a title="type error"
class="termref" href="#dt-type-error">type error</a> if the result
of evaluating the <code>select</code> attribute of the <a href=
"#element-number"><code>xsl:number</code></a> instruction is
anything other than a single node.</p>
<p><a name="err-XTDE1001" id="err-XTDE1001"><span class=
"error">[ERR XTDE1001]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the
<code>start-at</code> attribute of the <a href=
"#element-number"><code>xsl:number</code></a> instruction is not in
the lexical space of <code>xs:integer</code>. The error may be
signaled statically if it can be detected statically.</p>
<p>The following attributes control how the selected node is to be
numbered:</p>
<ul>
<li>
<p>The <code>level</code> attribute specifies rules for selecting
the nodes that are taken into account in allocating a number; it
has the values <code>single</code>, <code>multiple</code> or
<code>any</code>. The default is <code>single</code>.</p>
</li>
<li>
<p>The <code>count</code> attribute is a <a title="pattern" class=
"termref" href="#dt-pattern">pattern</a> that specifies which nodes
are to be counted at those levels. If <code>count</code> attribute
is not specified, then it defaults to the pattern that matches any
node with the same node kind as the selected node and, if the
selected node has an <a title="expanded QName" class="termref"
href="#dt-expanded-qname">expanded QName</a>, with the same
<a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> as the selected node.</p>
</li>
<li>
<p>The <code>from</code> attribute is a <a title="pattern" class=
"termref" href="#dt-pattern">pattern</a> that specifies where
counting starts.</p>
</li>
</ul>
<p>In addition, the attributes specified in <a href=
"#convert"><i>12.3 Number to String Conversion Attributes</i></a>
are used for number to string conversion, as in the case when the
<code>value</code> attribute is specified.</p>
<p>The <a href="#element-number"><code>xsl:number</code></a>
element first constructs a sequence of positive integers using the
<code>level</code>, <code>count</code> and <code>from</code>
attributes. Where <code>level</code> is <code>single</code> or
<code>any</code>, this sequence will either be empty or contain a
single number; where <code>level</code> is <code>multiple</code>,
the sequence may be of any length. The sequence is constructed as
follows:</p>
<p>Let <code>matches-count($node)</code> be a function that returns
true if and only if the given node <code>$node</code> matches the
pattern given in the <code>count</code> attribute, or the implied
pattern (according to the rules given above) if the
<code>count</code> attribute is omitted.</p>
<p>Let <code>matches-from($node)</code> be a function that returns
true if and only if the given node <code>$node</code> matches the
pattern given in the <code>from</code> attribute, or if
<code>$node</code> is the root node of a tree. If the
<code>from</code> attribute is omitted, then the function returns
true if and only if <code>$node</code> is the root node of a
tree.</p>
<p>Let <code>$S</code> be the selected node.</p>
<p>When <code>level="single"</code>:</p>
<ul>
<li>
<p>Let <code>$A</code> be the node sequence selected by the
following expression:</p>
<p>
<code>&#160;&#160;&#160;$S/ancestor-or-self::node()[matches-count(.)][1]</code></p>
<p>(this selects the innermost ancestor-or-self node that matches
the <code>count</code> pattern)</p>
</li>
<li>
<p>Let <code>$F</code> be the node sequence selected by the
expression</p>
<p>
<code>&#160;&#160;&#160;$S/ancestor-or-self::node()[matches-from(.)][1]</code></p>
<p>(this selects the innermost ancestor-or-self node that matches
the <code>from</code> pattern):</p>
</li>
<li>
<p>Let <code>$AF</code> be the value of:</p>
<p><code>&#160;&#160;&#160;$A[ancestor-or-self::node()[. is
$F]]</code></p>
<p>(this selects $A if it is in the subtree rooted at $F, or the
empty sequence otherwise)</p>
</li>
<li>
<p>If <code>$AF</code> is empty, return the empty sequence,
<code>()</code></p>
</li>
<li>
<p>Otherwise return the value of:</p>
<p><code>&#160;&#160;&#160;1 +
count($AF/preceding-sibling::node()[matches-count(.)])</code></p>
<p>(the number of preceding siblings of the counted node that match
the <code>count</code> pattern, plus one).</p>
</li>
</ul>
<p>When <code>level="multiple"</code>:</p>
<ul>
<li>
<p>Let <code>$A</code> be the node sequence selected by the
expression</p>
<p>
<code>&#160;&#160;&#160;$S/ancestor-or-self::node()[matches-count(.)]</code></p>
<p>(the set of ancestor-or-self nodes that match the
<code>count</code> pattern)</p>
</li>
<li>
<p>Let <code>$F</code> be the node sequence selected by the
expression</p>
<p>
<code>&#160;&#160;&#160;$S/ancestor-or-self::node()[matches-from(.)][1]</code></p>
<p>(the innermost ancestor-or-self node that matches the
<code>from</code> pattern)</p>
</li>
<li>
<p>Let <code>$AF</code> be the value of</p>
<p><code>&#160;&#160;&#160;$A[ancestor-or-self::node()[. is
$F]]</code></p>
<p>(the nodes selected in the first step that are in the subtree
rooted at the node selected in the second step)</p>
</li>
<li>
<p>Return the result of the expression</p>
<p><code>&#160;&#160;&#160;for $af in $AF return
1+count($af/preceding-sibling::node()[matches-count(.)])</code></p>
<p>(a sequence of integers containing, for each of these nodes, one
plus the number of preceding siblings that match the
<code>count</code> pattern)</p>
</li>
</ul>
<p>When <code>level="any"</code>:</p>
<ul>
<li>
<p>Let <code>$A</code> be the node sequence selected by the
expression</p>
<p>
<code>&#160;&#160;&#160;$S/(preceding::node()|ancestor-or-self::node())[matches-count(.)]</code></p>
<p>(the set of nodes consisting of the selected node together with
all nodes, other than attributes and namespaces, that precede the
selected node in document order, provided that they match the
<code>count</code> pattern)</p>
</li>
<li>
<p>Let <code>$F</code> be the node sequence selected by the
expression</p>
<p>
<code>&#160;&#160;&#160;$S/(preceding::node()|ancestor-or-self::node())[matches-from(.)][last()]</code></p>
<p>(the last node in document order that matches the
<code>from</code> pattern and that precedes the selected node,
using the same definition)</p>
</li>
<li>
<p>Let <code>$AF</code> be the node sequence <code>$A[. is $F or .
&gt;&gt; $F]</code>.</p>
<p>(the nodes selected in the first step, excluding those that
precede the node selected in the second step)</p>
</li>
<li>
<p>If <code>$AF</code> is empty, return the empty sequence,
<code>()</code></p>
</li>
<li>
<p>Otherwise return the value of the expression
<code>count($AF)</code></p>
</li>
</ul>
<p>The resulting sequence of numbers is referred to as the
<a title="place marker" class="termref" href=
"#dt-place-marker">place marker</a>).</p>
<p>If the <code>start-at</code> attribute is present, then the
effective value of the attribute is converted to an integer and
decremented by one, and the resulting value is added to each number
in the <a title="place marker" class="termref" href=
"#dt-place-marker">place marker</a>.</p>
<p>The sequence of numbers is then converted into a string using
the <a title="effective value" class="termref" href=
"#dt-effective-value">effective values</a> of the attributes
specified in <a href="#convert"><i>12.3 Number to String Conversion
Attributes</i></a>; each of these attributes is interpreted as an
<a title="attribute value template" class="termref" href=
"#dt-attribute-value-template">attribute value template</a>. After
conversion, the resulting string is used to create a text node,
which forms the result of the <a href=
"#element-number"><code>xsl:number</code></a> instruction.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e33422" id=
"d7e33422"></a>Example: Numbering the Items in an Ordered
List</div>
<p>The following will number the items in an ordered list:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="ol/item"&gt;
  &lt;fo:block&gt;
    &lt;xsl:number/&gt;
    &lt;xsl:text&gt;. &lt;/xsl:text&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e33430" id=
"d7e33430"></a>Example: Multi-Level Numbering</div>
<p>The following two rules will number <code>title</code> elements.
This is intended for a document that contains a sequence of
chapters followed by a sequence of appendices, where both chapters
and appendices contain sections, which in turn contain subsections.
Chapters are numbered 1, 2, 3; appendices are numbered A, B, C;
sections in chapters are numbered 1.1, 1.2, 1.3; sections in
appendices are numbered A.1, A.2, A.3. Subsections within a chapter
are numbered 1.1.1, 1.1.2, 1.1.3; subsections within an appendix
are numbered A.1.1, A.1.2, A.1.3.</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="title"&gt;
  &lt;fo:block&gt;
     &lt;xsl:number level="multiple"
                 count="chapter|section|subsection"
                 format="1.1 "/&gt;
     &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="appendix//title" priority="1"&gt;
  &lt;fo:block&gt;
     &lt;xsl:number level="multiple"
                 count="appendix|section|subsection"
                 format="A.1 "/&gt;
     &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e33440" id=
"d7e33440"></a>Example: Numbering Notes within a Chapter</div>
<p>This example numbers notes sequentially within a chapter,
<span>starting from the number 100:</span> :</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="note"&gt;
  &lt;fo:block&gt;
     &lt;xsl:number level="any" from="chapter" format="(1) " start-at="100"/&gt;
     &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
</div>
<div class="div2">
<h3><a name="convert" id="convert"></a>12.3 <a href="#convert"
style="text-decoration: none">Number to String Conversion
Attributes</a></h3>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This specification is aligned with that of the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-integer"><code>
format-integer</code></a><sup><small>FO30</small></sup> function,
but there are differences; for example grouping separators are part
of the primary format token in <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-integer"><code>
format-integer</code></a><sup><small>FO30</small></sup>, but are
indicated by separate attributes in <a href=
"#element-number"><code>xsl:number</code></a>.</p>
</div>
<p>The following attributes are used to control conversion of a
sequence of numbers into a string. The numbers are integers greater
than or equal to 0 (zero). The attributes are all optional.</p>
<p>The main attribute is <code>format</code>. The default value for
the <code>format</code> attribute is <code>1</code>. The
<code>format</code> attribute is split into a sequence of tokens
where each token is a maximal sequence of alphanumeric characters
or a maximal sequence of non-alphanumeric characters.
<em>Alphanumeric</em> means any character that has a Unicode
category of Nd, Nl, No, Lu, Ll, Lt, Lm or Lo <span>(see <a href=
"#UNICODE">[UNICODE]</a>)</span>. The alphanumeric tokens
(<em>format tokens</em>) indicate the format to be used for each
number in the sequence; in most cases the format token is the same
as the required representation of the number 1 (one).</p>
<p>Each non-alphanumeric token is either a prefix, a separator, or
a suffix. If there is a non-alphanumeric token but no format token,
then the single non-alphanumeric token is used as both the prefix
and the suffix. The prefix, if it exists, is the non-alphanumeric
token that precedes the first format token: the prefix always
appears exactly once in the constructed string, at the start. The
suffix, if it exists, is the non-alphanumeric token that follows
the last format token: the suffix always appears exactly once in
the constructed string, at the end. All other non-alphanumeric
tokens (those that occur between two format tokens) are
<em>separator tokens</em> and are used to separate numbers in the
sequence.</p>
<p>The <var>n</var>th format token is used to format the
<var>n</var>th number in the sequence. If there are more numbers
than format tokens, then the last format token is used to format
remaining numbers. If there are no format tokens, then a format
token of <code>1</code> is used to format all numbers. Each number
after the first is separated from the preceding number by the
separator token preceding the format token used to format that
number, or, if that is the first format token, then by
<code>.</code> (dot).</p>
<div class="example">
<div class="exampleHeader"><a name="d7e33512" id=
"d7e33512"></a>Example: Formatting a List of Numbers</div>
<p>Given the sequence of numbers <code>5, 13, 7</code> and the
format token <code>A-001(i)</code>, the output will be the string
<code>E-013(vii)</code></p>
</div>
<p>Format tokens are interpreted as follows:</p>
<ul>
<li>
<p>Any token where the last character has a decimal digit value of
1 (as specified in the Unicode character property database,
<span>see <a href="#UNICODE">[UNICODE]</a>)</span>, and the Unicode
value of preceding characters is one less than the Unicode value of
the last character generates a decimal representation of the number
where each number is at least as long as the format token. The
digits used in the decimal representation are the set of digits
containing the digit character used in the format token. Thus, a
format token <code>1</code> generates the sequence <code>0 1 2 ...
10 11 12 ...</code>, and a format token <code>01</code> generates
the sequence <code>00 01 02 ... 09 10 11 12 ... 99 100 101</code>.
A format token of <code>&amp;#x661;</code> (Arabic-Indic digit one)
generates the sequence <code>١</code> then <code>٢</code> then
<code>٣</code> ...</p>
</li>
<li>
<p>A format token <code>A</code> generates the sequence <code>A B C
... Z AA AB AC...</code>.</p>
</li>
<li>
<p>A format token <code>a</code> generates the sequence <code>a b c
... z aa ab ac...</code>.</p>
</li>
<li>
<p>A format token <code>i</code> generates the sequence <code>i ii
iii iv v vi vii viii ix x ...</code>.</p>
</li>
<li>
<p>A format token <code>I</code> generates the sequence <code>I II
III IV V VI VII VIII IX X ...</code>.</p>
</li>
<li>
<p>A format token <code>w</code> generates numbers written as
lower-case words, for example in English, <code>one two three four
...</code></p>
</li>
<li>
<p>A format token <code>W</code> generates numbers written as
upper-case words, for example in English, <code>ONE TWO THREE FOUR
...</code></p>
</li>
<li>
<p>A format token <code>Ww</code> generates numbers written as
title-case words, for example in English, <code>One Two Three Four
...</code></p>
</li>
<li>
<p>Any other format token indicates a numbering sequence in which
that token represents the number 1 (one) (but see the note below).
It is <a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> which
numbering sequences, additional to those listed above, are
supported. If an implementation does not support a numbering
sequence represented by the given token, it <span class=
"verb">must</span> use a format token of <code>1</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In some traditional numbering sequences additional signs are
added to denote that the letters should be interpreted as numbers;
these are not included in the format token. An example, see also
the example below, is classical Greek where a <em>dexia keraia</em>
and sometimes an <em>aristeri keraia</em> is added.</p>
</div>
</li>
</ul>
<p>For all format tokens other than the first kind above (one that
consists of decimal digits), there <span class="verb">may</span> be
<a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> lower and
upper bounds on the range of numbers that can be formatted using
this format token; indeed, for some numbering sequences there may
be intrinsic limits. For example, the formatting token
<code>&amp;#x2460;</code> (circled digit one) has a range of 1 to
20 imposed by the Unicode character repertoire. For the numbering
sequences described above any upper bound imposed by the
implementation <span class="verb">must not</span> be less than 1000
(one thousand) and any lower bound must not be greater than 1.
Numbers that fall outside this range <span class="verb">must</span>
be formatted using the format token <code>1</code>. The numbering
sequence associated with the format token <code>1</code> has a
lower bound of 0 (zero).</p>
<p>The above expansions of numbering sequences for format tokens
such as <code>a</code> and <code>i</code> are indicative but not
prescriptive. There are various conventions in use for how
alphabetic sequences continue when the alphabet is exhausted, and
differing conventions for how roman numerals are written (for
example, <code>IV</code> versus <code>IIII</code> as the
representation of the number 4). Sometimes alphabetic sequences are
used that omit letters such as <code>i</code> and <code>o</code>.
This specification does not prescribe the detail of any sequence
other than those sequences consisting entirely of decimal
digits.</p>
<p>Many numbering sequences are language-sensitive. This applies
especially to the sequence selected by the tokens <code>w</code>,
<code>W</code> and <code>Ww</code>. It also applies to other
sequences, for example different languages using the Cyrillic
alphabet use different sequences of characters, each starting with
the letter #x410 (Cyrillic capital letter A). In such cases, the
<code>lang</code> attribute specifies which language's conventions
are to be used; <span>its <a title="effective value" class=
"termref" href="#dt-effective-value">effective value</a>
<span class="verb">must</span> either be a string in the value
space of <code>xs:language</code>, or a zero-length string.</span>
If no <code>lang</code> value is specified, <span>or if the value
is a zero-length string</span>, the language that is used is
<a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. The set of
languages for which numbering is supported is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. If a
language is requested that is not supported, the processor
<span><span class="verb">may</span> use a fallback language
identified by removing successive hyphen-separated suffixes from
the supplied value until a supported language code is obtained;
failing this, the processor</span> uses the language that it would
use if the <code>lang</code> attribute were omitted.</p>
<p>If the optional <code>ordinal</code> attribute is present, and
if its value is not a zero-length string, this indicates a request
to output ordinal numbers rather than cardinal numbers. For
example, in English, the value <code>ordinal="yes"</code> when used
with the format token <code>1</code> outputs the sequence <code>1st
2nd 3rd 4th ...</code>, and when used with the format token
<code>w</code> outputs the sequence <code>first second third fourth
...</code>. In some languages, ordinal numbers vary depending on
the grammatical context, for example they may have different
genders and may decline with the noun that they qualify. In such
cases the value of the <code>ordinal</code> attribute may be used
to indicate the variation of the ordinal number required. The way
in which the variation is indicated will depend on the conventions
of the language. For inflected languages that vary the ending of
the word, the preferred approach is to indicate the required
ending, preceded by a hyphen: for example in German, appropriate
values are <code>-e, -er, -es, -en</code>. It is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> what
combinations of values of the format token, the language, and the
<code>ordinal</code> attribute are supported. If ordinal numbering
is not supported for the combination of the format token, the
language, and the actual value of the <code>ordinal</code>
attribute, the request is ignored and cardinal numbers are
generated instead.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e33802" id=
"d7e33802"></a>Example: Ordinal Numbering in Italian</div>
<p>The specification <code>format="1" ordinal="-º"
lang="it"</code>, if supported, should produce the sequence:</p>
<div class="exampleInner">
<pre>
1º 2º 3º 4º ...
</pre></div>
<p>The specification <code>format="Ww" ordinal="-o"
lang="it"</code>, if supported, should produce the sequence:</p>
<div class="exampleInner">
<pre>
Primo Secondo Terzo Quarto Quinto ...
</pre></div>
</div>
<p>The <code>letter-value</code> attribute disambiguates between
numbering sequences that use letters. In many languages there are
two commonly used numbering sequences that use letters. One
numbering sequence assigns numeric values to letters in alphabetic
sequence, and the other assigns numeric values to each letter in
some other manner traditional in that language. In English, these
would correspond to the numbering sequences specified by the format
tokens <code>a</code> and <code>i</code>. In some languages, the
first member of each sequence is the same, and so the format token
alone would be ambiguous. A value of <code>alphabetic</code>
specifies the alphabetic sequence; a value of
<code>traditional</code> specifies the other sequence. If the
<code>letter-value</code> attribute is not specified, then it is
<a title="implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a> how any
ambiguity is resolved.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Implementations may use <a title="extension attribute" class=
"termref" href="#dt-extension-attribute">extension attributes</a>
on <a href="#element-number"><code>xsl:number</code></a> to provide
additional control over the way in which numbers are formatted.</p>
</div>
<p>The <code>grouping-separator</code> attribute gives the
separator used as a grouping (for example, thousands) separator in
decimal numbering sequences, and the optional
<code>grouping-size</code> specifies the size (normally 3) of the
grouping. For example, <code>grouping-separator=","</code> and
<code>grouping-size="3"</code> would produce numbers of the form
<code>1,000,000</code> while <code>grouping-separator="."</code>
and <code>grouping-size="2"</code> would produce numbers of the
form <code>1.00.00.00</code>. If only one of the
<code>grouping-separator</code> and <code>grouping-size</code>
attributes is specified, then it is ignored.</p>
<p>The <a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the
<code>grouping-separator</code> attribute <span class=
"verb">may</span> be any string, including a zero-length
string.</p>
<p>The <a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the
<code>grouping-size</code> attribute <span class="verb">must</span>
be a string in the lexical space of <code>xs:integer</code>. If the
resulting integer is positive then it defines the number of digits
between adjacent grouping separators; it if is zero or negative,
then no grouping separators are inserted.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e33911" id=
"d7e33911"></a>Example: Format Tokens and the Resulting
Sequences</div>
<p>These examples use non-Latin characters which might not display
correctly in all browsers, depending on the system
configuration.</p>
<table border="1" cellpadding="5" summary=
"format tokens for use with xsl:number" width="100%">
<thead>
<tr>
<th align="left" colspan="1" valign="top">Description</th>
<th align="left" colspan="1" valign="top">Format Token</th>
<th align="left" colspan="1" valign="top">Sequence</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top">French cardinal words</td>
<td align="left" valign="top"><code>format="Ww"
lang="fr"</code></td>
<td align="left" valign="top">Un, Deux, Trois, Quatre</td>
</tr>
<tr>
<td align="left" valign="top">German ordinal words</td>
<td align="left" valign="top"><code>format="w" ordinal="-e"
lang="de"</code></td>
<td align="left" valign="top">erste, zweite, dritte, vierte</td>
</tr>
<tr>
<td align="left" valign="top">Katakana numbering</td>
<td align="left" valign="top">
<code>format="&amp;#x30A2;"</code></td>
<td align="left" valign="top">ア, イ, ウ, エ, オ, カ, キ, ク, ケ, コ, サ, シ,
ス, セ, ソ, タ, チ, ツ, テ, ト, ナ, ニ, ヌ, ネ, ノ, ハ, ヒ, フ, ヘ, ホ, マ, ミ, ム, メ,
モ, ヤ, ユ, ヨ, ラ, リ, ル, レ, ロ, ワ, ヰ, ヱ, ヲ, ン</td>
</tr>
<tr>
<td align="left" valign="top">Katakana numbering in iroha
order</td>
<td align="left" valign="top">
<code>format="&amp;#x30A4;"</code></td>
<td align="left" valign="top">イ, ロ, ハ, ニ, ホ, ヘ, ト, チ, リ, ヌ, ル, ヲ,
ワ, カ, ヨ, タ, レ, ソ, ツ, ネ, ナ, ラ, ム, ウ, ヰ, ノ, オ, ク, ヤ, マ, ケ, フ, コ, エ,
テ, ア, サ, キ, ユ, メ, ミ, シ, ヱ, ヒ, モ, セ, ス</td>
</tr>
<tr>
<td align="left" valign="top">Thai numbering</td>
<td align="left" valign="top">
<code>format="&amp;#x0E51;"</code></td>
<td align="left" valign="top">๑, ๒, ๓, ๔, ๕, ๖, ๗, ๘, ๙, ๑๐, ๑๑,
๑๒, ๑๓, ๑๔, ๑๕, ๑๖, ๑๗, ๑๘, ๑๙, ๒๐</td>
</tr>
<tr>
<td align="left" valign="top">Traditional Hebrew numbering</td>
<td align="left" valign="top"><code>format="&amp;#x05D0;"
letter-value="traditional"</code></td>
<td align="left" valign="top">א, ב, ג, ד, ה, ו, ז, ח, ט, י, יא, יב,
יג, יד, טו, טז, יז, יח, יט, כ</td>
</tr>
<tr>
<td align="left" valign="top">Traditional Georgian numbering</td>
<td align="left" valign="top"><code>format="&amp;#x10D0;"
letter-value="traditional"</code></td>
<td align="left" valign="top">ა, ბ, გ, დ, ე, ვ, ზ, ჱ, თ, ი, ია, იბ,
იგ, იდ, იე, ივ, იზ, იჱ, ით, კ</td>
</tr>
<tr>
<td align="left" valign="top">Classical Greek numbering (see
note)</td>
<td align="left" valign="top"><code>format="&amp;#x03B1;"
letter-value="traditional"</code></td>
<td align="left" valign="top">αʹ, βʹ, γʹ, δʹ, εʹ, ϛʹ, ζʹ, ηʹ, θʹ,
ιʹ, ιαʹ, ιβʹ, ιγʹ, ιδʹ, ιεʹ, ιϛʹ, ιζʹ, ιηʹ, ιθʹ, κʹ</td>
</tr>
<tr>
<td align="left" valign="top">Old Slavic numbering</td>
<td align="left" valign="top"><code>format="&amp;#x0430;"
letter-value="traditional"</code></td>
<td align="left" valign="top">А, В, Г, Д, Е, Ѕ, З, И, Ѳ, Ӏ, АӀ, ВӀ,
ГӀ, ДӀ, ЕӀ, ЅӀ, ЗӀ, ИӀ, ѲӀ, К</td>
</tr>
</tbody>
</table>
<p>Note that Classical Greek is an example where the format token
is not the same as the representation of the number 1.</p>
</div>
</div>
</div>
<div class="div1">
<h2><a name="sorting" id="sorting"></a>13 <a href="#sorting" style=
"text-decoration: none">Sorting</a></h2>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-sort-key-specification" id="dt-sort-key-specification" title=
"sort key specification"></a>A <b>sort key specification</b> is a
sequence of one or more adjacent <a href=
"#element-sort"><code>xsl:sort</code></a> elements which together
define rules for sorting the items in an input sequence to form a
sorted sequence.<span class="definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-sort-key-component" id="dt-sort-key-component" title=
"sort key component"></a>Within a <a title="sort key specification"
class="termref" href="#dt-sort-key-specification">sort key
specification</a>, each <a href=
"#element-sort"><code>xsl:sort</code></a> element defines one
<b>sort key component</b>.<span class="definition">]</span> The
first <a href="#element-sort"><code>xsl:sort</code></a> element
specifies the primary component of the sort key specification, the
second <a href="#element-sort"><code>xsl:sort</code></a> element
specifies the secondary component of the sort key specification,
and so on.</p>
<p>A sort key specification may occur immediately within an
<a href="#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href="#element-for-each"><code>xsl:for-each</code></a>, <a href=
"#element-perform-sort"><code>xsl:perform-sort</code></a>, or
<a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
element.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>When used within <a href=
"#element-for-each"><code>xsl:for-each</code></a>, <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>, or
<a href="#element-perform-sort"><code>xsl:perform-sort</code></a>,
<a href="#element-sort"><code>xsl:sort</code></a> elements must
occur before any other children.</p>
</div>
<div class="div2">
<h3><a name="xsl-sort" id="xsl-sort"></a>13.1 <a href="#xsl-sort"
style="text-decoration: none">The</a> <a href=
"#element-sort"><code>xsl:sort</code></a> <a href="#xsl-sort"
style="text-decoration: none">Element</a></h3>
<p class="element-syntax"><a name="element-sort" id=
"element-sort"></a><code>&lt;xsl:sort<br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;lang? = { <var>language</var> }<br />
&#160;&#160;order? = { "ascending" | "descending" }<br />
&#160;&#160;collation? = { <var>uri</var> }<br />
&#160;&#160;stable? = { <var>boolean</var> }<br />
&#160;&#160;case-order? = { "upper-first" | "lower-first" }<br />
&#160;&#160;data-type? = { "text" | "number" | <var>eqname</var>
}&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:sort&gt;</code></p>
<p>The <a href="#element-sort"><code>xsl:sort</code></a> element
defines a <a title="sort key component" class="termref" href=
"#dt-sort-key-component">sort key component</a>. A sort key
component specifies how a <a title="sort key value" class="termref"
href="#dt-sort-key-value">sort key value</a> is to be computed for
each item in the sequence being sorted, and also how two sort key
values are to be compared.</p>
<p>The value of a <a title="sort key component" class="termref"
href="#dt-sort-key-component">sort key component</a> is determined
either by its <code>select</code> attribute or by the contained
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>. If neither is
present, the default is <code>select="."</code>, which has the
effect of sorting on the actual value of the item if it is an
atomic value, or on the typed-value of the item if it is a node. If
a <code>select</code> attribute is present, its value <span class=
"verb">must</span> be an XPath <a title="expression" class=
"termref" href="#dt-expression">expression</a>.</p>
<p><a name="err-XTSE1015" id="err-XTSE1015"><span class=
"error">[ERR XTSE1015]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if an
<a href="#element-sort"><code>xsl:sort</code></a> element with a
<code>select</code> attribute has non-empty content.</p>
<p>Those attributes of the <a href=
"#element-sort"><code>xsl:sort</code></a> elements whose values are
<a title="attribute value template" class="termref" href=
"#dt-attribute-value-template">attribute value templates</a> are
evaluated using the same <a title="focus" class="termref" href=
"#dt-focus">focus</a> as is used to evaluate the
<code>select</code> attribute of the containing instruction
(specifically, <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href="#element-for-each"><code>xsl:for-each</code></a>, <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>, or
<a href=
"#element-perform-sort"><code>xsl:perform-sort</code></a>).</p>
<p>The <code>stable</code> attribute is permitted only on the first
<a href="#element-sort"><code>xsl:sort</code></a> element within a
<a title="sort key specification" class="termref" href=
"#dt-sort-key-specification">sort key specification</a></p>
<p><a name="err-XTSE1017" id="err-XTSE1017"><span class=
"error">[ERR XTSE1017]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if an
<a href="#element-sort"><code>xsl:sort</code></a> element other
than the first in a sequence of sibling <a href=
"#element-sort"><code>xsl:sort</code></a> elements has a
<code>stable</code> attribute.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-stable" id="dt-stable" title="stable"></a>A <a title=
"sort key specification" class="termref" href=
"#dt-sort-key-specification">sort key specification</a> is said to
be <b>stable</b> if its first <a href=
"#element-sort"><code>xsl:sort</code></a> element has no
<code>stable</code> attribute, or has a <code>stable</code>
attribute whose <a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> is
<code>yes</code>.<span class="definition">]</span></p>
<div class="div3">
<h4><a name="sorting-process" id="sorting-process"></a>13.1.1
<a href="#sorting-process" style="text-decoration: none">The
Sorting Process</a></h4>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-initial-sequence" id="dt-initial-sequence" title=
"initial sequence"></a>The sequence to be sorted is referred to as
the <b>initial sequence</b>.<span class="definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-sorted-sequence" id="dt-sorted-sequence" title=
"sorted sequence"></a>The sequence after sorting as defined by the
<a href="#element-sort"><code>xsl:sort</code></a> elements is
referred to as the <b>sorted sequence</b>.<span class=
"definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-sort-key-value" id="dt-sort-key-value" title=
"sort key value"></a> For each item in the <a title=
"initial sequence" class="termref" href=
"#dt-initial-sequence">initial sequence</a>, a value is computed
for each <a title="sort key component" class="termref" href=
"#dt-sort-key-component">sort key component</a> within the
<a title="sort key specification" class="termref" href=
"#dt-sort-key-specification">sort key specification</a>. The value
computed for an item by using the <var>N</var>th sort key component
is referred to as the <var>N</var>th <b>sort key value</b> of that
item.<span class="definition">]</span></p>
<p>The items in the <a title="initial sequence" class="termref"
href="#dt-initial-sequence">initial sequence</a> are ordered into a
<a title="sorted sequence" class="termref" href=
"#dt-sorted-sequence">sorted sequence</a> by comparing their
<a title="sort key value" class="termref" href=
"#dt-sort-key-value">sort key values</a>. The relative position of
two items <var>A</var> and <var>B</var> in the sorted sequence is
determined as follows. The first sort key value of <var>A</var> is
compared with the first sort key value of <var>B</var>, according
to the rules of the first <a title="sort key component" class=
"termref" href="#dt-sort-key-component">sort key component</a>. If,
under these rules, <var>A</var> is less than <var>B</var>, then
<var>A</var> will precede <var>B</var> in the sorted sequence,
unless the <code>order</code> attribute of this <a title=
"sort key component" class="termref" href=
"#dt-sort-key-component">sort key component</a> specifies
<code>descending</code>, in which case <var>B</var> will precede
<var>A</var> in the sorted sequence. If, however, the relevant sort
key values compare equal, then the second sort key value of
<var>A</var> is compared with the second sort key value of
<var>B</var>, according to the rules of the second <a title=
"sort key component" class="termref" href=
"#dt-sort-key-component">sort key component</a>. This continues
until two sort key values are found that compare unequal. If all
the sort key values compare equal, and the <a title=
"sort key specification" class="termref" href=
"#dt-sort-key-specification">sort key specification</a> is
<a title="stable" class="termref" href="#dt-stable">stable</a>,
then <var>A</var> will precede <var>B</var> in the <a title=
"sorted sequence" class="termref" href="#dt-sorted-sequence">sorted
sequence</a> if and only if <var>A</var> preceded <var>B</var> in
the <a title="initial sequence" class="termref" href=
"#dt-initial-sequence">initial sequence</a>. If all the sort key
values compare equal, and the <a title="sort key specification"
class="termref" href="#dt-sort-key-specification">sort key
specification</a> is not <a title="stable" class="termref" href=
"#dt-stable">stable</a>, then the relative order of <var>A</var>
and <var>B</var> in the <a title="sorted sequence" class="termref"
href="#dt-sorted-sequence">sorted sequence</a> is <a title=
"implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>If two items have equal <a title="sort key value" class=
"termref" href="#dt-sort-key-value">sort key values</a>, and the
sort is <a title="stable" class="termref" href=
"#dt-stable">stable</a>, then their order in the <a title=
"sorted sequence" class="termref" href="#dt-sorted-sequence">sorted
sequence</a> will be the same as their order in the <a title=
"initial sequence" class="termref" href=
"#dt-initial-sequence">initial sequence</a>, regardless of whether
<code>order="descending"</code> was specified on any or all of the
<a title="sort key component" class="termref" href=
"#dt-sort-key-component">sort key components</a>.</p>
</div>
<p>The <var>N</var>th sort key value is computed by evaluating
either the <code>select</code> attribute or the contained <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> of the
<var>N</var>th <a href="#element-sort"><code>xsl:sort</code></a>
element, or the expression <code>.</code> (dot) if neither is
present. This evaluation is done with the <a title="focus" class=
"termref" href="#dt-focus">focus</a> set as follows:</p>
<ul>
<li>
<p>The <a title="context item" class="termref" href=
"#dt-context-item">context item</a> is the item in the <a title=
"initial sequence" class="termref" href=
"#dt-initial-sequence">initial sequence</a> whose <a title=
"sort key value" class="termref" href="#dt-sort-key-value">sort key
value</a> is being computed.</p>
</li>
<li>
<p>The <a title="context position" class="termref" href=
"#dt-context-position">context position</a> is the position of that
item in the initial sequence.</p>
</li>
<li>
<p>The <a title="context size" class="termref" href=
"#dt-context-size">context size</a> is the size of the initial
sequence.</p>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>As in any other XPath expression, the <a href=
"#func-current"><code>current</code></a> function may be used
within the <code>select</code> expression of <a href=
"#element-sort"><code>xsl:sort</code></a> to refer to the item that
is the context item for the expression as a whole; that is, the
item whose <a title="sort key value" class="termref" href=
"#dt-sort-key-value">sort key value</a> is being computed.</p>
</div>
<p>The <a title="sort key value" class="termref" href=
"#dt-sort-key-value">sort key values</a> are <a title="atomize"
class="termref" href="#dt-atomization">atomized</a>, and are then
compared. The way they are compared depends on their datatype, as
described in the next section.</p>
</div>
<div class="div3">
<h4><a name="comparing-sort-keys" id=
"comparing-sort-keys"></a>13.1.2 <a href="#comparing-sort-keys"
style="text-decoration: none">Comparing Sort Key Values</a></h4>
<p>It is possible to force the system to compare <a title=
"sort key value" class="termref" href="#dt-sort-key-value">sort key
values</a> using the rules for a particular datatype by including a
cast as part of the <a title="sort key component" class="termref"
href="#dt-sort-key-component">sort key component</a>. For example,
<code>&lt;xsl:sort select="xs:date(@dob)"/&gt;</code> will force
the attributes to be compared as dates. In the absence of such a
cast, the sort key values are compared using the rules appropriate
to their datatype. Any values of type <code>xs:untypedAtomic</code>
are cast to <code>xs:string</code>.</p>
<p>For backwards compatibility with XSLT 1.0, the
<code>data-type</code> attribute remains available. If this has the
<a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> <code>text</code>, the
atomized <a title="sort key value" class="termref" href=
"#dt-sort-key-value">sort key values</a> are converted to strings
before being compared. If it has the effective value
<code>number</code>, the atomized sort key values are converted to
doubles before being compared. The conversion is done by using the
<a href=
"http://www.w3.org/TR/xpath-functions-30/#func-string"><code>string</code></a><sup><small>FO30</small></sup>
or <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-number"><code>number</code></a><sup><small>FO30</small></sup>
function as appropriate. <span>If the <code>data-type</code>
attribute has any other <a title="effective value" class="termref"
href="#dt-effective-value">effective value</a>, then this value
<span class="verb">must</span> be an <a title="EQName" class=
"termref" href="#dt-eqname">EQName</a> denoting an <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a> with a non-absent namespace</span>, and the effect of the
attribute is <a title="implementation-defined" class="termref"
href="#dt-implementation-defined">implementation-defined</a>.</p>
<p><a name="err-XTTE1020" id="err-XTTE1020"><span class=
"error">[ERR XTTE1020]</span></a> If any <a title="sort key value"
class="termref" href="#dt-sort-key-value">sort key value</a>, after
<a title="atomize" class="termref" href=
"#dt-atomization">atomization</a> and any type conversion
<span class="verb">required</span> by the <code>data-type</code>
attribute, is a sequence containing more than one item, then the
effect depends on whether the <a href=
"#element-sort"><code>xsl:sort</code></a> element <span>is
processed with <a title="XSLT 1.0 behavior" class="termref" href=
"#dt-xslt-10-behavior">XSLT 1.0 behavior</a>. With XSLT 1.0
behavior,</span> the effective sort key value is the first item in
the sequence. In other cases, this is a <a title="type error"
class="termref" href="#dt-type-error">type error</a>.</p>
<p>The set of <a title="sort key value" class="termref" href=
"#dt-sort-key-value">sort key values</a> (after any conversion) is
first divided into two categories: empty values, and ordinary
values. The empty sort key values represent those items where the
sort key value is an empty sequence. These values are considered
for sorting purposes to be equal to each other, but less than any
other value. The remaining values are classified as ordinary
values.</p>
<p><a name="err-XTDE1030" id="err-XTDE1030"><span class=
"error">[ERR XTDE1030]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if, for
any <a title="sort key component" class="termref" href=
"#dt-sort-key-component">sort key component</a>, the set of
<a title="sort key value" class="termref" href=
"#dt-sort-key-value">sort key values</a> evaluated for all the
items in the <a title="initial sequence" class="termref" href=
"#dt-initial-sequence">initial sequence</a>, after any type
conversion requested, contains a pair of ordinary values for which
the result of the XPath <code>lt</code> operator is an error.
<span>If the processor is able to detect the error statically, it
<span class="verb">may</span> optionally signal it as a <a title=
"static error" class="termref" href="#dt-static-error">static
error</a>.</span></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The above error condition may occur if the values to be sorted
are of a type that does not support ordering (for example,
<code>xs:QName</code>) or if the sequence is heterogeneous (for
example, if it contains both strings and numbers). The error can
generally be prevented by invoking a cast or constructor function
within the sort key component.</p>
<p>The error condition is subject to the usual caveat that a
processor is not required to evaluate any expression solely in
order to determine whether it raises an error. For example, if
there are several sort key components, then a processor is not
required to evaluate or compare minor sort key values unless the
corresponding major sort key values are equal.</p>
</div>
<p>In general, comparison of two ordinary values is performed
according to the rules of the XPath <code>lt</code> operator. To
ensure a total ordering, the same implementation of the
<code>lt</code> operator <span class="verb">must</span> be used for
all the comparisons: the one that is chosen is the one appropriate
to the most specific type to which all the values can be converted
by subtype substitution and/or type promotion. For example, if the
sequence contains both <code>xs:decimal</code> and
<code>xs:double</code> values, then the values are compared using
<code>xs:double</code> comparison, even when comparing two
<code>xs:decimal</code> values. NaN values, for sorting purposes,
are considered to be equal to each other, and less than any other
numeric value. Special rules also apply to the
<code>xs:string</code> and <code>xs:anyURI</code> types, and types
derived by restriction therefrom, as described in the next
section.</p>
</div>
<div class="div3">
<h4><a name="collating-sequences" id=
"collating-sequences"></a>13.1.3 <a href="#collating-sequences"
style="text-decoration: none">Sorting Using Collations</a></h4>
<p>The rules given in this section apply when comparing values
whose type is <code>xs:string</code> or a type derived by
restriction from <code>xs:string</code>, or whose type is
<code>xs:anyURI</code> or a type derived by restriction from
<code>xs:anyURI</code>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-collation" id="dt-collation" title="collation"></a>Facilities
in XSLT <span>3.0</span> and XPath <span>3.0</span> that require
strings to be ordered rely on the concept of a named
<b>collation</b>. A collation is a set of rules that determine
whether two strings are equal, and if not, which of them is to be
sorted before the other.<span class="definition">]</span> A
collation is identified by a URI, but the manner in which this URI
is associated with an actual rule or algorithm is largely <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
<p>For more information about collations, see <a href=
"http://www.w3.org/TR/xpath-functions-30/#string-compare">Section
5.3 Comparison of strings</a> <sup><small>FO30</small></sup> in
<a href="#xpath-functions-30">[Functions and Operators]</a>. Some
specifications, for example <a href="#UNICODE-TR10">[UNICODE
TR10]</a>, use the term "collation" to describe rules that can be
tailored or parameterized for various purposes. In this
specification, a collation URI refers to a collation in which all
such parameters have already been fixed. Therefore, if a collation
URI is specified, other attributes such as <code>case-order</code>
and <code>lang</code> are ignored.</p>
<p>Every implementation must recognize the collation URI that
<span class="verb">must</span>
<code>http://www.w3.org/2005/xpath-functions/collation/codepoint</code>,
which provides the ability to compare strings based on the Unicode
codepoint values of the characters in the string.</p>
<p>Furthermore, every implementation must recognize collation URIs
representing tailorings of the Unicode Collation Algorithm (UCA),
as described in <a href="#uca-collations"><i>13.4 The Unicode
Collation Algorithm</i></a>. Although this form of collation URI
must be recognized, implementations are not required to support
every possible tailoring.</p>
<p>If the <a href="#element-sort"><code>xsl:sort</code></a> element
has a <code>collation</code> attribute, then the strings are
compared according to the rules for the named <a title="collation"
class="termref" href="#dt-collation">collation</a>: that is, they
are compared using the XPath function call <code>compare($a, $b,
$collation)</code>.</p>
<p>If the <a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the
<code>collation</code> attribute of <a href=
"#element-sort"><code>xsl:sort</code></a> is a relative URI, then
it is resolved against the base URI of the <a href=
"#element-sort"><code>xsl:sort</code></a> element.</p>
<p><a name="err-XTDE1035" id="err-XTDE1035"><span class=
"error">[ERR XTDE1035]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<code>collation</code> attribute of <a href=
"#element-sort"><code>xsl:sort</code></a> (after resolving against
the base URI) is not a URI that is recognized by the implementation
as referring to a collation.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>It is entirely for the implementation to determine whether it
recognizes a particular collation URI. For example, if the
implementation allows collation URIs to contain parameters in the
query part of the URI, it is the implementation that determines
whether a URI containing an unknown or invalid parameter is or is
not a recognized collation URI. The fact that this situation is
described as an error thus does not prevent an implementation
applying a fallback collation if it chooses to do so.</p>
</div>
<p>The <code>lang</code> and <code>case-order</code> attributes are
ignored if a <code>collation</code> attribute is present. But in
the absence of a <code>collation</code> attribute, these attributes
provide input to an <a title="implementation-defined" class=
"termref" href=
"#dt-implementation-defined">implementation-defined</a> algorithm
to locate a suitable collation:</p>
<ul>
<li>
<p>The <code>lang</code> attribute indicates that a collation
suitable for a particular natural language <span class=
"verb">should</span> be used. The <a title="effective value" class=
"termref" href="#dt-effective-value">effective value</a> of the
attribute <span class="verb">must</span> <span>either be a string
in the value space of <code>xs:language</code>, or a zero-length
string. Supplying the zero-length string has the same effect as
omitting the attribute. If a language is requested that is not
supported, the processor <span class="verb">may</span> use a
fallback language identified by removing successive
hyphen-separated suffixes from the supplied value until a supported
language code is obtained; failing this, the processor behaves as
if the <code>lang</code> attribute were omitted.</span></p>
</li>
<li>
<p>The <code>case-order</code> attribute indicates whether the
desired collation <span class="verb">should</span> sort upper-case
letters before lower-case or vice versa. The <a title=
"effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the attribute
<span class="verb">must</span> be either <code>lower-first</code>
(indicating that lower-case letters precede upper-case letters in
the collating sequence) or <code>upper-first</code> (indicating
that upper-case letters precede lower-case).</p>
<p>When <code>lower-first</code> is requested, the returned
collation <span class="verb">should</span> have the property that
when two strings differ only in the case of one or more characters,
then a string in which the first differing character is lower-case
should precede a string in which the corresponding character is
title-case, which should in turn precede a string in which the
corresponding character is upper-case. When upper-first is
requested, the returned collation <span class="verb">should</span>
have the property that when two strings differ only in the case of
one or more characters, then a string in which the first differing
character is upper-case should precede a string in which the
corresponding character is title-case, which should in turn precede
a string in which the corresponding character is lower-case.</p>
<p>So, for example, if <code>lang="en"</code>, then <code>A a B
b</code> are sorted with <code>case-order="upper-first"</code> and
<code>a A b B</code> are sorted with
<code>case-order="lower-first"</code>.</p>
<p>As a further example, if lower-first is requested, then a sorted
sequence might be "MacAndrew, macintosh, macIntosh, Macintosh,
MacIntosh, macintoshes, Macintoshes, McIntosh". If upper-first is
requested, the same sequence would sort as "MacAndrew, MacIntosh,
Macintosh, macIntosh, macintosh, MacIntoshes, macintoshes,
McIntosh".</p>
</li>
</ul>
<p>If none of the <code>collation</code>, <code>lang</code>, or
<code>case-order</code> attributes is present, the collation is
chosen in an <a title="implementation-defined" class="termref"
href="#dt-implementation-defined">implementation-defined</a> way.
It is not <span class="verb">required</span> that the default
collation for sorting should be the same as the <a title=
"default collation" class="termref" href=
"#dt-default-collation">default collation</a> used when evaluating
XPath expressions, as described in <a href=
"#static-context"><i>5.4.1 Initializing the Static Context</i></a>
and <a href="#default-collation-attribute"><i>3.8.1 The
default-collation Attribute</i></a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>It is usually appropriate, when sorting, to use a strong
collation, that is, one that takes account of secondary differences
(accents) and tertiary differences (case) between strings that are
otherwise equal. A weak collation, which ignores such differences,
may be more suitable when comparing strings for equality.</p>
<p>Useful background information on international sorting is
provided in <a href="#UNICODE-TR10">[UNICODE TR10]</a>. The
<code>case-order</code> attribute may be interpreted as described
in section 6.6 of <a href="#UNICODE-TR10">[UNICODE TR10]</a>.</p>
</div>
</div>
</div>
<div class="div2">
<h3><a name="creating-sorted-sequence" id=
"creating-sorted-sequence"></a>13.2 <a href=
"#creating-sorted-sequence" style="text-decoration: none">Creating
a Sorted Sequence</a></h3>
<p class="element-syntax"><a name="element-perform-sort" id=
"element-perform-sort"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:perform-sort<br />
&#160;&#160;select? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-sort">xsl:sort</a>+, <var>sequence-constructor</var>)
--&gt;<br />
&lt;/xsl:perform-sort&gt;</code></p>
<p>The <a href=
"#element-perform-sort"><code>xsl:perform-sort</code></a>
instruction is used to return a <a title="sorted sequence" class=
"termref" href="#dt-sorted-sequence">sorted sequence</a>.</p>
<p>The <a title="initial sequence" class="termref" href=
"#dt-initial-sequence">initial sequence</a> is obtained either by
evaluating the <code>select</code> attribute or by evaluating the
contained sequence constructor (but not both). If there is no
<code>select</code> attribute and no sequence constructor then the
<a title="initial sequence" class="termref" href=
"#dt-initial-sequence">initial sequence</a> (and therefore, the
<a title="sorted sequence" class="termref" href=
"#dt-sorted-sequence">sorted sequence</a>) is an empty
sequence.</p>
<p><a name="err-XTSE1040" id="err-XTSE1040"><span class=
"error">[ERR XTSE1040]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if an
<a href="#element-perform-sort"><code>xsl:perform-sort</code></a>
instruction with a <code>select</code> attribute has any content
other than <a href="#element-sort"><code>xsl:sort</code></a> and
<a href="#element-fallback"><code>xsl:fallback</code></a>
instructions.</p>
<p>The result of the <a href=
"#element-perform-sort"><code>xsl:perform-sort</code></a>
instruction is the result of sorting its <a title=
"initial sequence" class="termref" href=
"#dt-initial-sequence">initial sequence</a> using its contained
<a title="sort key specification" class="termref" href=
"#dt-sort-key-specification">sort key specification</a>.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e35008" id=
"d7e35008"></a>Example: Sorting a Sequence of Atomic Values</div>
<p>The following stylesheet function sorts a sequence of atomic
values using the value itself as the sort key.</p>
<div class="exampleInner">
<pre>
&lt;xsl:function name="local:sort" 
          as="xs:anyAtomicType*"&gt;
  &lt;xsl:param name="in" as="xs:anyAtomicType*"/&gt;
  &lt;xsl:perform-sort select="$in"&gt;
    &lt;xsl:sort select="."/&gt;
  &lt;/xsl:perform-sort&gt;
&lt;/xsl:function&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e35015" id=
"d7e35015"></a>Example: Writing a Function to Perform a Sort</div>
<p>The following example defines a function that sorts books by
price, and uses this function to output the five books that have
the lowest prices:</p>
<div class="exampleInner">
<pre>
&lt;xsl:function name="bib:books-by-price" 
          as="schema-element(bib:book)*"&gt;
  &lt;xsl:param name="in" as="schema-element(bib:book)*"/&gt;
  &lt;xsl:perform-sort select="$in"&gt;
    &lt;xsl:sort select="xs:decimal(bib:price)"/&gt;
  &lt;/xsl:perform-sort&gt;
&lt;/xsl:function&gt;
   ...
   &lt;xsl:copy-of select="bib:books-by-price(//bib:book)
                             [position() = 1 to 5]"/&gt;

 
</pre></div>
</div>
</div>
<div class="div2">
<h3><a name="sorted-iteration" id="sorted-iteration"></a>13.3
<a href="#sorted-iteration" style=
"text-decoration: none">Processing a Sequence in Sorted
Order</a></h3>
<p>When used within <a href=
"#element-for-each"><code>xsl:for-each</code></a> or <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>, a
<a title="sort key specification" class="termref" href=
"#dt-sort-key-specification">sort key specification</a> indicates
that the sequence of items selected by that instruction is to be
processed in sorted order, not in the order of the supplied
sequence.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e35036" id=
"d7e35036"></a>Example: Processing Elements in Sorted Order</div>
<p>For example, suppose an employee database has the form</p>
<div class="exampleInner">
<pre>
&lt;employees&gt;
  &lt;employee&gt;
    &lt;name&gt;
      &lt;given&gt;James&lt;/given&gt;
      &lt;family&gt;Clark&lt;/family&gt;
    &lt;/name&gt;
    ...
  &lt;/employee&gt;
&lt;/employees&gt;
</pre></div>
<p>Then a list of employees sorted by name could be generated
using:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="employees"&gt;
  &lt;ul&gt;
    &lt;xsl:apply-templates select="employee"&gt;
      &lt;xsl:sort select="name/family"/&gt;
      &lt;xsl:sort select="name/given"/&gt;
    &lt;/xsl:apply-templates&gt;
  &lt;/ul&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="employee"&gt;
  &lt;li&gt;
    &lt;xsl:value-of select="name/given"/&gt;
    &lt;xsl:text&gt; &lt;/xsl:text&gt;
    &lt;xsl:value-of select="name/family"/&gt;
  &lt;/li&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
<p>When used within <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>, a
<a title="sort key specification" class="termref" href=
"#dt-sort-key-specification">sort key specification</a> indicates
the order in which the groups are to be processed. For the effect
of <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>, see
<a href="#grouping"><i>14 Grouping</i></a>.</p>
</div>
<div class="div2">
<h3><a name="uca-collations" id="uca-collations"></a>13.4 <a href=
"#uca-collations" style="text-decoration: none">The Unicode
Collation Algorithm</a></h3>
<p>XSLT 3.0 defines a family of collation URIs representing
tailorings of the Unicode Collation Algorithm (UCA) as defined in
<a href="#UNICODE-TR10">[UNICODE TR10]</a>. The parameters used for
tailoring the UCA are based on the parameters defined in the Locale
Data Markup Language (LDML), defined in <a href=
"#UNICODE-TR35">[UNICODE TR35]</a>.</p>
<p>This family of URIs use the scheme and path
<code>http://www.w3.org/2013/collation/UCA</code> followed by an
optional query part. The query part, if present, consists of a
question mark followed by a sequence of zero or more
semicolon-separated parameters. Each parameter is a keyword-value
pair, the keyword and value being separated by an equals sign.</p>
<p>All implementations must recognize URIs in this family. This
applies to all places where collations are used, including (for
example) the <a href="#element-sort"><code>xsl:sort</code></a>,
<a href="#element-key"><code>xsl:key</code></a>, <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>, and
<a href="#element-merge-key"><code>xsl:merge-key</code></a>
elements, the <code>[xsl:]default-collation</code> attribute, and
the <code>collation</code> argument of <a title="core function"
class="termref" href="#dt-core-function">core functions</a>
<span>and the <a href=
"#func-collation-key"><code>collation-key</code></a>
function</span>. If the <code>fallback</code> parameter is present
with the value <code>no</code>, then the implementation
<span class="verb">must</span> either use a collation that conforms
with the rules in the Unicode specifications for the requested
tailoring, or fail with a static or dynamic error indicating that
it does not provide the collation (the error code should be the
same as if the collation URI were not recognized). If the
<code>fallback</code> parameter is omitted or takes the value
<code>yes</code>, and if the collation URI is well-formed according
to the rules in this section, then the implementation <span class=
"verb">must</span> accept the collation URI, and <span class=
"verb">should</span> use the available collation that most closely
reflects the user's intentions. For example, if the collation URI
requested is
<code>http://www.w3.org/2013/collation/UCA?lang=se;fallback=yes</code>
and the implementation does not include a fully conformant version
of the UCA tailored for Swedish, then it <span class=
"verb">may</span> choose to use a Swedish collation that is known
to differ from the UCA definition, or one whose conformance has not
been established. It might even, as a last resort, fall back to
using codepoint collation.</p>
<p>If two query parameters use the same keyword then the last one
wins. If a query parameter uses a keyword or value which is not
defined in this specification then the meaning is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. If the
implementation recognizes the meaning of the keyword and value then
it <span class="verb">should</span> interpret it accordingly; if it
does not recognize the keyword or value then if the
<code>fallback</code> parameter is present with the value
<code>no</code> it should reject the collation as unsupported,
otherwise it should ignore the unrecognized parameter.</p>
<p>The following query parameters are defined. If any parameter is
absent, the default is <a title="implementation-defined" class=
"termref" href=
"#dt-implementation-defined">implementation-defined</a> except
where otherwise stated. The meaning given for each parameter is
non-normative; the normative specification is found in <a href=
"#UNICODE-TR35">[UNICODE TR35]</a>.</p>
<table summary="Options for the Unicode Collation Algorithm"
border="1" cellpadding="5" width="100%">
<thead>
<tr>
<th colspan="1" align="left" valign="top">Keyword</th>
<th colspan="1" align="left" valign="top">Values</th>
<th colspan="1" align="left" valign="top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top">fallback</td>
<td align="left" valign="top">yes | no (default yes)</td>
<td align="left" valign="top">Determines whether the processor uses
a fallback collation if a conformant collation is not
available.</td>
</tr>
<tr>
<td align="left" valign="top">lang</td>
<td align="left" valign="top">language code, as defined for the
<code>lang</code> attribute of <a href=
"#element-sort"><code>xsl:sort</code></a></td>
<td align="left" valign="top">The language whose collation
conventions are to be used.</td>
</tr>
<tr>
<td align="left" valign="top">version</td>
<td align="left" valign="top">string</td>
<td align="left" valign="top">The version number of the UCA to be
used.</td>
</tr>
<tr>
<td align="left" valign="top">strength</td>
<td align="left" valign="top">primary | secondary | tertiary |
quaternary | identical, or 1|2|3|4|5 as synonyms</td>
<td align="left" valign="top">The collation strength as defined in
UCA. Primary strength takes only the base form of the character
into account (so A=a=Â=â); secondary strength ignores case but
considers accents and diacritics as significant (so A=a and Â=â but
â!=a); tertiary considers case as significant (A!=a!=Â!=â);
quaternary considers spaces and punctuation that would otherwise be
ignored (for example
<code>data-base</code>=<code>database</code>).</td>
</tr>
<tr>
<td align="left" valign="top">alternate</td>
<td align="left" valign="top">non-ignorable | shifted |
blanked</td>
<td align="left" valign="top">Controls the effect of characters
such as spaces and hyphens.</td>
</tr>
<tr>
<td align="left" valign="top">backwards</td>
<td align="left" valign="top">yes | no</td>
<td align="left" valign="top">The value <code>backwards=yes</code>
indicates that the last accent in the search term is the most
significant.</td>
</tr>
<tr>
<td align="left" valign="top">normalization</td>
<td align="left" valign="top">yes | no</td>
<td align="left" valign="top">Indicates whether search terms are
converted to normalization form D.</td>
</tr>
<tr>
<td align="left" valign="top">caseLevel</td>
<td align="left" valign="top">yes | no</td>
<td align="left" valign="top">When used with primary strength,
setting <code>caseLevel=yes</code> has the effect of ignoring
accents while taking account of case.</td>
</tr>
<tr>
<td align="left" valign="top">caseFirst</td>
<td align="left" valign="top">upper | lower</td>
<td align="left" valign="top">Indicates whether upper-case precedes
lower-case or vice versa.</td>
</tr>
<tr>
<td align="left" valign="top">hiraganaQuaternary</td>
<td align="left" valign="top">yes | no</td>
<td align="left" valign="top">Controls special treatment of
Hiragana codepoints when strength is quaternary or greater.</td>
</tr>
<tr>
<td align="left" valign="top">numeric</td>
<td align="left" valign="top">yes | no</td>
<td align="left" valign="top">When <code>numeric=yes</code> is
specified, a sequence of consecutive digits is interpreted as a
number, for example <code>chap2</code> sorts before
<code>chap12</code>.</td>
</tr>
<tr>
<td align="left" valign="top">reorder</td>
<td align="left" valign="top">a comma-separated sequence of reorder
codes, where a reorder code is one of <code>space</code>,
<code>punct</code>, <code>symbol</code>, <code>currency</code>,
<code>digit</code>, or a four-letter script code defined in
<a href="#ISO15924_register">[ISO 15924 Register]</a>, the register
of scripts maintained by the Unicode Consortium in its capacity as
registration authority for <a href="#ISO15924">[ISO
15924]</a>.</td>
<td align="left" valign="top">Determines the relative ordering of
text in different scripts; for example the value
<code>digit,Grek,Latn</code> indicates that digits precede Greek
letters, which precede Latin letters.</td>
</tr>
</tbody>
</table>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This list excludes parameters that are inconvenient to express
in a URI, or that are applicable only to substring matching.</p>
</div>
</div>
</div>
<div class="div1">
<h2><a name="grouping" id="grouping"></a>14 <a href="#grouping"
style="text-decoration: none">Grouping</a></h2>
<p>The facilities described in this section are designed to allow
items in a sequence to be grouped based on common values; for
example it allows grouping of elements having the same value for a
particular attribute, or elements with the same name, or elements
with common values for any other <a title="expression" class=
"termref" href="#dt-expression">expression</a>. Since grouping
identifies items with duplicate values, the same facilities also
allow selection of the distinct values in a sequence of items, that
is, the elimination of duplicates.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Simple elimination of duplicates can also be achieved using the
function <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-distinct-values"><code>
distinct-values</code></a><sup><small>FO30</small></sup> in the
<a title="core function" class="termref" href=
"#dt-core-function">core function</a> library: see <a href=
"#xpath-functions-30">[Functions and Operators]</a>.</p>
</div>
<p>In addition these facilities allow grouping based on sequential
position, for example selecting groups of adjacent
<code>para</code> elements. The facilities also provide an easy way
to do fixed-size grouping, for example identifying groups of three
adjacent nodes, which is useful when arranging data in multiple
columns.</p>
<p>For each group of items identified, it is possible to evaluate a
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> for the group.
Grouping is nestable to multiple levels so that groups of distinct
items can be identified, then from among the distinct groups
selected, further sub-grouping of distinct items in the current
group can be done.</p>
<p>It is also possible for one item to participate in more than one
group.</p>
<div class="div2">
<h3><a name="xsl-for-each-group" id="xsl-for-each-group"></a>14.1
<a href="#xsl-for-each-group" style="text-decoration: none">The</a>
<code>xsl:for-each-group</code> <a href="#xsl-for-each-group"
style="text-decoration: none">Element</a></h3>
<p class="element-syntax"><a name="element-for-each-group" id=
"element-for-each-group"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:for-each-group<br />
&#160;&#160;<b>select</b> = <var>expression</var><br />
&#160;&#160;group-by? = <var>expression</var><br />
&#160;&#160;group-adjacent? = <var>expression</var><br />
&#160;&#160;group-starting-with? = <var>pattern</var><br />
&#160;&#160;group-ending-with? = <var>pattern</var><br />
&#160;&#160;composite? = <var>boolean</var><br />
&#160;&#160;collation? = { <var>uri</var> }&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-sort">xsl:sort</a>*, <var>sequence-constructor</var>)
--&gt;<br />
&lt;/xsl:for-each-group&gt;</code></p>
<p>This element is an <a title="instruction" class="termref" href=
"#dt-instruction">instruction</a> that may be used anywhere within
a <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-group" id="dt-group" title="group"></a>The <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction allocates the items in an input sequence into
<b>groups</b> of items (that is, it establishes a collection of
sequences) based either on common values of a grouping key, or on a
<a title="pattern" class="termref" href="#dt-pattern">pattern</a>
that the initial or final <span>item</span> in a group must
match.<span class="definition">]</span> The <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> that forms the
content of the <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction is evaluated once for each of these groups.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-population" id="dt-population" title="population"></a>The
sequence of items to be grouped, which is referred to as the
<b>population</b>, is determined by evaluating the XPath <a title=
"expression" class="termref" href="#dt-expression">expression</a>
contained in the <code>select</code> attribute.<span class=
"definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-population-order" id="dt-population-order" title=
"population order"></a>The population is treated as a sequence; the
order of items in this sequence is referred to as <b>population
order</b> <span class="definition">]</span>.</p>
<p>A group is never empty. If the population is empty, the number
of groups will be zero.</p>
<p>The assignment of items to groups depends on the
<code>group-by</code>, <code>group-adjacent</code>,
<code>group-starting-with</code>, and
<code>group-ending-with</code> attributes.</p>
<p><a name="err-XTSE1080" id="err-XTSE1080"><span class=
"error">[ERR XTSE1080]</span></a> These four attributes are
mutually exclusive: it is a <a title="static error" class="termref"
href="#dt-static-error">static error</a> if none of these four
attributes is present or if more than one of them is present.</p>
<p><a name="err-XTSE1090" id="err-XTSE1090"><span class=
"error">[ERR XTSE1090]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> to specify
the <code>collation</code> attribute <span>or the
<code>composite</code> attribute</span> if neither the
<code>group-by</code> attribute nor <code>group-adjacent</code>
attribute is specified.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-grouping-key" id="dt-grouping-key" title="grouping key"></a>If
either of the <code>group-by</code> or <code>group-adjacent</code>
attributes is present, then for each item in the <a title=
"population" class="termref" href="#dt-population">population</a> a
set of <b>grouping keys</b> is calculated, as follows: the
expression contained in the <code>group-by</code> or
<code>group-adjacent</code> attribute is evaluated; the result is
atomized; and any <code>xs:untypedAtomic</code> values are cast to
<code>xs:string</code>. <span>If <code>composite="yes"</code> is
specified, there is a single grouping key whose value is the
resulting sequence; otherwise, there is a set of grouping keys,
consisting of the distinct atomic values present in the result
sequence.</span> <span class="definition">]</span></p>
<p>When calculating grouping keys for an item in the population,
the <a title="expression" class="termref" href=
"#dt-expression">expression</a> contained in the
<code>group-by</code> or <code>group-adjacent</code> attribute is
evaluated with that item as the <a title="context item" class=
"termref" href="#dt-context-item">context item</a>, with its
position in <a title="population order" class="termref" href=
"#dt-population-order">population order</a> as the <a title=
"context position" class="termref" href=
"#dt-context-position">context position</a>, and with the size of
the population as the <a title="context size" class="termref" href=
"#dt-context-size">context size</a>.</p>
<p>If the <code>group-by</code> attribute is present, <span>and if
the <code>composite</code> attribute is omitted or takes the value
<code>no</code>,</span> then an item in the population <span class=
"verb">may</span> have multiple grouping keys: that is, the
<code>group-by</code> expression evaluates to a sequence<span>, and
each item in the sequence is treated as a separate grouping
key.</span> The item is included in as many groups as there are
distinct grouping keys (which may be zero).</p>
<p>If the <code>group-adjacent</code> attribute is used, <span>and
if the <code>composite</code> attribute is omitted or takes the
value <code>no</code>,</span> then each item in the population
<span class="verb">must</span> have exactly one grouping key
value.</p>
<p><a name="err-XTTE1100" id="err-XTTE1100"><span class=
"error">[ERR XTTE1100]</span></a> It is a <a title="type error"
class="termref" href="#dt-type-error">type error</a> if the result
of evaluating the <code>group-adjacent</code> expression is an
empty sequence or a sequence containing more than one item,
<span>unless <code>composite="yes"</code> is specified.</span></p>
<p><a title="grouping key" class="termref" href=
"#dt-grouping-key">Grouping keys</a> are compared using the rules
for the <span><a href=
"http://www.w3.org/TR/xpath-functions-30/#func-deep-equal"><code>deep-equal</code></a><sup><small>FO30</small></sup>
function. This means that values of type
<code>xs:untypedAtomic</code> will be cast to
<code>xs:string</code> before the comparison, and that items that
are not comparable using the <code>eq</code> operator are
considered to be not equal, that is, they are allocated to
different groups. It also means that the value <code>NaN</code> is
considered equal to itself.</span> If the values are strings, or
untyped atomic values, then if there is a <code>collation</code>
attribute the values are compared using the collation specified as
the <a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the
<code>collation</code> attribute, resolved if relative against the
base URI of the <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
element. If there is no <code>collation</code> attribute then the
<a title="default collation" class="termref" href=
"#dt-default-collation">default collation</a> is used.</p>
<p><a name="err-XTDE1110" id="err-XTDE1110"><span class=
"error">[ERR XTDE1110]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
collation URI specified to <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
(after resolving against the base URI) is a collation that is not
recognized by the implementation. (For notes, <span class=
"error">[see <a href="#err-XTDE1035">ERR XTDE1035</a>]</span>.)</p>
<p>For more information on collations, see <a href=
"#collating-sequences"><i>13.1.3 Sorting Using
Collations</i></a>.</p>
<p>The way in which an <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
element is evaluated depends on which of the four group-defining
attributes is present:</p>
<ul>
<li>
<p>If the <code>group-by</code> attribute is present, the items in
the <a title="population" class="termref" href=
"#dt-population">population</a> are examined, in population order.
For each item <var>J</var>, the expression in the
<code>group-by</code> attribute is evaluated to produce a sequence
of zero or more <a title="grouping key" class="termref" href=
"#dt-grouping-key">grouping key</a> values. <span>If
<code>composite="yes"</code> is specified, there will be a single
grouping key, which will in general be a sequence of zero or more
atomic values; otherwise, there will be zero or more grouping keys,
each of which will be a single atomic value.</span> For each one of
these <a title="grouping key" class="termref" href=
"#dt-grouping-key">grouping keys</a>, if there is already a group
created to hold items having that grouping key value, <var>J</var>
is <span>appended</span> to that group; otherwise a new group is
created for items with that grouping key value, and <var>J</var>
becomes its first member.</p>
<p>An item in the population may thus be <span>appended</span> to
zero, one, or many groups. An item will never be
<span>appended</span> more than once to the same group; if two or
more grouping keys for the same item are equal, then the duplicates
are ignored. An <em>item</em> here means the item at a particular
position within the population—if the population contains the same
node at several different positions in the sequence then a group
may indeed contain duplicate nodes.</p>
<p>The number of groups will be the same as the number of distinct
grouping key values present in the <a title="population" class=
"termref" href="#dt-population">population</a>.</p>
<p>If the population contains values of different numeric types
that differ from each other by small amounts, then the
<code>eq</code> operator is not transitive, because of rounding
effects occurring during type promotion. The effect of this is
described in <a href="#non-transitivity"><i>14.5
Non-Transitivity</i></a>.</p>
</li>
<li>
<p>If the <code>group-adjacent</code> attribute is present, the
items in the <a title="population" class="termref" href=
"#dt-population">population</a> are examined, in population order.
If an item has the same value for the <a title="grouping key"
class="termref" href="#dt-grouping-key">grouping key</a> as its
preceding item within the <a title="population" class="termref"
href="#dt-population">population</a> (in <a title=
"population order" class="termref" href=
"#dt-population-order">population order</a>), then it is
<span>appended</span> to the same group as its preceding item;
otherwise a new group is created and the item becomes its first
member.</p>
</li>
<li>
<p>If the <code>group-starting-with</code> attribute is present,
then its value <span class="verb">must</span> be a <a href=
"#doc-xslt30-patterns-Pattern30">pattern</a>.</p>
<p>The <span>items</span> in the <a title="population" class=
"termref" href="#dt-population">population</a> are examined in
<a title="population order" class="termref" href=
"#dt-population-order">population order</a>. If an
<span>item</span> matches the pattern, or is the first
<span>item</span> in the population, then a new group is created
and the <span>item</span> becomes its first member. Otherwise, the
<span>item</span> is <span>appended</span> to the same group as its
preceding <span>item</span> within the population.</p>
</li>
<li>
<p>If the <code>group-ending-with</code> attribute is present, then
its value <span class="verb">must</span> be a <a href=
"#doc-xslt30-patterns-Pattern30">pattern</a>.</p>
<p>The <span>items</span> in the <a title="population" class=
"termref" href="#dt-population">population</a> are examined in
<a title="population order" class="termref" href=
"#dt-population-order">population order</a>. If an
<span>item</span> is the first <span>item</span> in the population,
or if the previous <span>item</span> in the population matches the
pattern, then a new group is created and the <span>item</span>
becomes its first member. Otherwise, the <span>item</span> is
<span>appended</span> to the same group as its preceding
<span>item</span> within the population.</p>
</li>
</ul>
<p>In all cases the order of items within each group is
predictable, and reflects the original <a title="population order"
class="termref" href="#dt-population-order">population order</a>,
in that the items are processed in population order and each item
is appended at the end of zero or more groups.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>As always, a different algorithm may be used if it achieves the
same effect.</p>
</div>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-initial-item" id="dt-initial-item" title="initial item"></a>For
each <a title="group" class="termref" href="#dt-group">group</a>,
the item within the group that is first in <a title=
"population order" class="termref" href=
"#dt-population-order">population order</a> is known as the
<b>initial item</b> of the group.<span class=
"definition">]</span></p>
<p>The <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> contained in
the <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
element is evaluated once for each of the <a title="group" class=
"termref" href="#dt-group">groups</a>, in <a title=
"processing order" class="termref" href=
"#dt-processing-order">processing order</a>. The sequences that
result are concatenated, in <a title="processing order" class=
"termref" href="#dt-processing-order">processing order</a>, to form
the result of the <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
element. Within the <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a>, the
<a title="context item" class="termref" href=
"#dt-context-item">context item</a> is the <a title="initial item"
class="termref" href="#dt-initial-item">initial item</a> of the
relevant group, the <a title="context position" class="termref"
href="#dt-context-position">context position</a> is the position of
this <span>group in the <a title="processing order" class="termref"
href="#dt-processing-order">processing order</a> of the
groups</span>, and the <a title="context size" class="termref"
href="#dt-context-size">context size</a> is the number of groups
This has the effect that within the <a title="sequence constructor"
class="termref" href="#dt-sequence-constructor">sequence
constructor</a>, a call on <code>position()</code> takes successive
values <code>1, 2, ... last()</code>.</p>
</div>
<div class="div2">
<h3><a name="information-about-group" id=
"information-about-group"></a>14.2 <a href=
"#information-about-group" style="text-decoration: none">Accessing
Information about the Current Group Value</a></h3>
<p>Two pieces of information are available during the processing of
each group (that is, while evaluating the sequence constructor
contained in the <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction, and also while evaluating the sort key of a group as
expressed by the <code>select</code> attribute or sequence
constructor of an <a href="#element-sort"><code>xsl:sort</code></a>
child of the <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
element):</p>
<ul>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-current-group" id="dt-current-group" title=
"current group"></a>The <b>current group</b> is the <a title=
"group" class="termref" href="#dt-group">group</a> itself, as a
sequence of items<span class="definition">]</span>.</p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-current-grouping-key" id="dt-current-grouping-key" title=
"current grouping key"></a>The <b>current grouping key</b> is a
single atomic value, or in the case of a composite key, a sequence
of atomic values, containing the <a title="grouping key" class=
"termref" href="#dt-grouping-key">grouping key</a> of the items in
the <a title="current group" class="termref" href=
"#dt-current-group">current group</a>.<span class=
"definition">]</span></p>
</li>
</ul>
<p>Information about the <a title="current group" class="termref"
href="#dt-current-group">current group</a> and the <a title=
"current grouping key" class="termref" href=
"#dt-current-grouping-key">current grouping key</a> is held in the
dynamic context, and is available using the <a href=
"#func-current-group"><code>current-group</code></a> and <a href=
"#func-current-grouping-key"><code>current-grouping-key</code></a>
functions respectively.</p>
<p>In XSLT 2.0, the <a title="current group" class="termref" href=
"#dt-current-group">current group</a> and the <a title=
"current grouping key" class="termref" href=
"#dt-current-grouping-key">current grouping key</a> were passed
unchanged through calls of <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a> and
<a href=
"#element-call-template"><code>xsl:call-template</code></a>, and
also <a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a> and
<a href="#element-next-match"><code>xsl:next-match</code></a>. This
behavior is retained in XSLT 3.0 except in the case where streaming
is in use: specifically, if the <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href=
"#element-call-template"><code>xsl:call-template</code></a>,
<a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a>, or
<a href="#element-next-match"><code>xsl:next-match</code></a>
instruction occurs within a <a title="declared-streamable" class=
"termref" href="#dt-declared-streamable">declared-streamable</a>
construct (typically, within an <a href=
"#element-stream"><code>xsl:stream</code></a> instruction, or
within a streamable <a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a>), then the current group and
current grouping key are set to <a title="absent" class="termref"
href="#dt-absent">absent</a> in the called template. The reason for
this is to allow the streamability of an <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction to be assessed statically, as described in <a href=
"#streamability-xsl-for-each-group"><i>19.8.4.19 Streamability of
xsl:for-each-group</i></a>.</p>
<div class="div3">
<h4><a name="func-current-group" id="func-current-group"></a>14.2.1
<a href="#func-current-group" style=
"text-decoration: none">fn:current-group</a></h4>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Returns the group currently being processed by an <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction.</p>
</dd>
<dt class="label">Signature</dt>
<dd>
<p><a name="function-current-group" id=
"function-current-group"></a></p>
<div class="proto"><code class=
"function">current-group</code>()<code class=
"as">&#160;as&#160;</code><code class=
"return-type">item()*</code></div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>The evaluation context for XPath <a title="expression" class=
"termref" href="#dt-expression">expressions</a> includes a
component called the <a title="current group" class="termref" href=
"#dt-current-group">current group</a>, which is a sequence.</p>
<p>The function <a href=
"#func-current-group"><code>current-group</code></a> returns the
sequence of items making up the current group.</p>
<p>The current group is bound during evaluation of the <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction. If no <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction is being evaluated, the current group will be <a title=
"absent" class="termref" href="#dt-absent">absent</a>: that is, any
reference to it will cause a dynamic error.</p>
<p>The effect of <a title="invocation construct" class="termref"
href="#dt-invocation-construct">invocation constructs</a> on the
<a title="current group" class="termref" href=
"#dt-current-group">current group</a> is as follows:</p>
<ul>
<li>
<p>If the <a title="invocation construct" class="termref" href=
"#dt-invocation-construct">invocation construct</a> is contained
within a <a title="declared-streamable" class="termref" href=
"#dt-declared-streamable">declared-streamable</a> <a title=
"construct" class="termref" href="#dt-construct">construct</a> (for
example, if it is within an <a href=
"#element-stream"><code>xsl:stream</code></a> instruction or a
streamable template), then the invocation construct sets the
current group to <a title="absent" class="termref" href=
"#dt-absent">absent</a>. In this situation the scope of the current
group is effectively static; it can only be referenced within the
body of the <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction to which it applies.</p>
</li>
<li>
<p>If the <a title="invocation construct" class="termref" href=
"#dt-invocation-construct">invocation construct</a> is a (static or
dynamic) function call, then the invocation construct sets the
current group to <a title="absent" class="termref" href=
"#dt-absent">absent</a>.</p>
</li>
<li>
<p>Otherwise the <a title="invocation construct" class="termref"
href="#dt-invocation-construct">invocation construct</a> leaves the
current group unchanged. In this situation the scope of the current
group is effectively dynamic: it can be referenced within called
templates and attribute sets.</p>
</li>
</ul>
<p>The current group is initially <a title="absent" class="termref"
href="#dt-absent">absent</a> during the evaluation of global
variables and stylesheet parameters, during the evaluation of the
<code>use</code> attribute or contained sequence constructor of
<a href="#element-key"><code>xsl:key</code></a>, and during the
evaluation of the <code>initial-value</code> attribute of <a href=
"#element-accumulator"><code>xsl:accumulator</code></a> and the
<code>select</code> attribute of contained sequence constructor of
<a href=
"#element-accumulator-rule"><code>xsl:accumulator-rule</code></a>.</p>
</dd>
<dt class="label">Error Conditions</dt>
<dd>
<p><a name="err-XTSE1060" id="err-XTSE1060"><span class=
"error">[ERR XTSE1060]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
<a href="#func-current-group"><code>current-group</code></a>
function is used within a <a title="pattern" class="termref" href=
"#dt-pattern">pattern</a>.</p>
<p><a name="err-XTDE1061" id="err-XTDE1061"><span class=
"error">[ERR XTDE1061]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<a href="#func-current-group"><code>current-group</code></a>
function is used when the current group is <a title="absent" class=
"termref" href="#dt-absent">absent</a> <span>, or when it is
invoked in the course of evaluating a pattern</span>. The error
<span class="verb">may</span> be reported statically if it can be
detected statically.</p>
</dd>
<dt class="label">Notes</dt>
<dd>
<p>Like other XSLT extensions to the dynamic evaluation context,
the <a title="current group" class="termref" href=
"#dt-current-group">current group</a> is not retained as part of
the closure of a function value. This means that the expression
<code>current-group#0</code> is valid and returns a function value,
but any invocation of this function will fail with a dynamic error
<span class="error">[see <a href="#err-XTDE1061">ERR
XTDE1061</a>]</span>.</p>
</dd>
</dl>
</div>
<div class="div3">
<h4><a name="func-current-grouping-key" id=
"func-current-grouping-key"></a>14.2.2 <a href=
"#func-current-grouping-key" style=
"text-decoration: none">fn:current-grouping-key</a></h4>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Returns the grouping key of the group currently being processed
using the <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction.</p>
</dd>
<dt class="label">Signature</dt>
<dd>
<p><a name="function-current-grouping-key" id=
"function-current-grouping-key"></a></p>
<div class="proto"><code class=
"function">current-grouping-key</code>()<code class=
"as">&#160;as&#160;</code><code class=
"return-type">xs:anyAtomicType*</code></div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>The evaluation context for XPath <a title="expression" class=
"termref" href="#dt-expression">expressions</a> includes a
component called the <a title="current grouping key" class=
"termref" href="#dt-current-grouping-key">current grouping key</a>,
which is <span>a sequence of atomic values</span>. The current
grouping key is the <a title="grouping key" class="termref" href=
"#dt-grouping-key">grouping key</a> shared in common by all the
items within the <a title="current group" class="termref" href=
"#dt-current-group">current group</a>.</p>
<p>The function <a href=
"#func-current-grouping-key"><code>current-grouping-key</code></a>
returns the <a title="current grouping key" class="termref" href=
"#dt-current-grouping-key">current grouping key</a>.</p>
<p>The current grouping key is bound during evaluation of an
<a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction that has a <code>group-by</code> or
<code>group-adjacent</code> attribute. If <span>no <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction is being evaluated, the current grouping key will be
<a title="absent" class="termref" href="#dt-absent">absent</a>,
which means that any reference to it causes a dynamic error. The
current grouping key is also set to <a title="absent" class=
"termref" href="#dt-absent">absent</a> during the evaluation of an
<a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction with a <code>group-starting-with</code> or
<code>group-ending-with</code> attribute</span>.</p>
<p>The effect of <a title="invocation construct" class="termref"
href="#dt-invocation-construct">invocation constructs</a> on the
<a title="current grouping key" class="termref" href=
"#dt-current-grouping-key">current grouping key</a> is as
follows:</p>
<ul>
<li>
<p>If the <a title="invocation construct" class="termref" href=
"#dt-invocation-construct">invocation construct</a> is contained
within a <a title="declared-streamable" class="termref" href=
"#dt-declared-streamable">declared-streamable</a> <a title=
"construct" class="termref" href="#dt-construct">construct</a> (for
example, if it is within an <a href=
"#element-stream"><code>xsl:stream</code></a> instruction or a
streamable template), then the invocation construct sets the
current grouping key to <a title="absent" class="termref" href=
"#dt-absent">absent</a>. In this situation the scope of the current
group is effectively static; it can only be referenced within the
body of the <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction to which it applies.</p>
</li>
<li>
<p>If the <a title="invocation construct" class="termref" href=
"#dt-invocation-construct">invocation construct</a> is a (static or
dynamic) function call, then the invocation construct sets the
current grouping key to <a title="absent" class="termref" href=
"#dt-absent">absent</a>.</p>
</li>
<li>
<p>Otherwise the <a title="invocation construct" class="termref"
href="#dt-invocation-construct">invocation construct</a> leaves the
current grouping key unchanged. In this situation the scope of the
current group is effectively dynamic: it can be referenced within
called templates and attribute sets.</p>
</li>
</ul>
<p>The current grouping key is initially <a title="absent" class=
"termref" href="#dt-absent">absent</a> during the evaluation of
global variables and stylesheet parameters, during the evaluation
of the <code>use</code> attribute or contained sequence constructor
of <a href="#element-key"><code>xsl:key</code></a>, and during the
evaluation of the <code>initial-value</code> attribute of <a href=
"#element-accumulator"><code>xsl:accumulator</code></a> and the
<code>select</code> attribute of contained sequence constructor of
<a href=
"#element-accumulator-rule"><code>xsl:accumulator-rule</code></a>.</p>
<p>While an <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction with a <code>group-by</code> or
<code>group-adjacent</code> attribute is being evaluated, the
<a title="current grouping key" class="termref" href=
"#dt-current-grouping-key">current grouping key</a> will be a
single atomic value <span>if <code>composite="no"</code> is
specified (explicitly or implicitly), or a sequence of atomic
values if <code>composite="yes"</code> is specified.</span></p>
<p>At other times, the current grouping key will be <a title=
"absent" class="termref" href="#dt-absent">absent</a>.</p>
<p><span>The <a title="grouping key" class="termref" href=
"#dt-grouping-key">grouping keys</a> of all items in a group are
not necessarily identical. For example, one might be an
<code>xs:float</code> while another is a numerically equal
<code>xs:decimal</code></span>. The <a href=
"#func-current-grouping-key"><code>current-grouping-key</code></a>
function <span>returns</span> the grouping key of the <a title=
"initial item" class="termref" href="#dt-initial-item">initial
item</a> in the group, after atomization and casting of
<code>xs:untypedAtomic</code> values to <code>xs:string</code>.</p>
<p>The function takes no arguments.</p>
</dd>
<dt class="label">Error Conditions</dt>
<dd>
<p><a name="err-XTSE1070" id="err-XTSE1070"><span class=
"error">[ERR XTSE1070]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
<a href=
"#func-current-grouping-key"><code>current-grouping-key</code></a>
function is used within a <a title="pattern" class="termref" href=
"#dt-pattern">pattern</a>.</p>
<p><a name="err-XTDE1071" id="err-XTDE1071"><span class=
"error">[ERR XTDE1071]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<a href=
"#func-current-grouping-key"><code>current-grouping-key</code></a>
function is used when the current grouping key is <a title="absent"
class="termref" href="#dt-absent">absent</a>, <span>or when it is
invoked in the course of evaluating a pattern.</span> The error
<span class="verb">may</span> be reported statically if it can be
detected statically.</p>
</dd>
<dt class="label">Notes</dt>
<dd>
<p>Like other XSLT extensions to the dynamic evaluation context,
the <a title="current grouping key" class="termref" href=
"#dt-current-grouping-key">current grouping key</a> is not retained
as part of the closure of a function value. This means that the
expression <code>current-grouping-key#0</code> is valid and returns
a function value, but any invocation of this function will fail
with a dynamic error <span class="error">[see <a href=
"#err-XTDE1071">ERR XTDE1071</a>]</span>.</p>
</dd>
</dl>
</div>
</div>
<div class="div2">
<h3><a name="order-of-groups" id="order-of-groups"></a>14.3
<a href="#order-of-groups" style="text-decoration: none">Ordering
among Groups</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-first-appearance" id="dt-first-appearance" title=
"order of first appearance"></a>There is a <span>total</span>
ordering among <a title="group" class="termref" href=
"#dt-group">groups</a> referred to as the <b>order of first
appearance</b>. A group <var>G</var> is defined to precede a group
<var>H</var> in order of first appearance if the <a title=
"initial item" class="termref" href="#dt-initial-item">initial
item</a> of <var>G</var> precedes the initial item of <var>H</var>
in population order. If two groups <var>G</var> and <var>H</var>
have the same initial item (because the item is in both groups)
then <var>G</var> precedes <var>H</var> if the <a title=
"grouping key" class="termref" href="#dt-grouping-key">grouping
key</a> of <var>G</var> precedes the grouping key of <var>H</var>
in the sequence that results from evaluating the
<code>group-by</code> expression of this initial item.<span class=
"definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-processing-order" id="dt-processing-order" title=
"processing order"></a>There is another <span>total</span> ordering
among groups referred to as <b>processing order</b>. If group
<var>R</var> precedes group <var>S</var> in processing order, then
in the result sequence returned by the <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction the items generated by processing group <var>R</var>
will precede the items generated by processing group
<var>S</var>.<span class="definition">]</span></p>
<p>If there are no <a href=
"#element-sort"><code>xsl:sort</code></a> elements immediately
within the <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
element, the <a title="processing order" class="termref" href=
"#dt-processing-order">processing order</a> of the <a title="group"
class="termref" href="#dt-group">groups</a> is the <a title=
"order of first appearance" class="termref" href=
"#dt-first-appearance">order of first appearance</a>.</p>
<p>Otherwise, the <a href="#element-sort"><code>xsl:sort</code></a>
elements immediately within the <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
element define the processing order of the <a title="group" class=
"termref" href="#dt-group">groups</a> (see <a href="#sorting"><i>13
Sorting</i></a>). They do not affect the order of items within each
group. Multiple <a title="sort key component" class="termref" href=
"#dt-sort-key-component">sort key components</a> are allowed, and
are evaluated in major-to-minor order. If two groups have the same
values for all their sort key components, they are processed in
<a title="order of first appearance" class="termref" href=
"#dt-first-appearance">order of first appearance</a> if the
<a title="sort key specification" class="termref" href=
"#dt-sort-key-specification">sort key specification</a> is
<a title="stable" class="termref" href="#dt-stable">stable</a>,
otherwise in an <a title="implementation-dependent" class="termref"
href="#dt-implementation-dependent">implementation-dependent</a>
order.</p>
<p>The <code>select</code> <a title="expression" class="termref"
href="#dt-expression">expression</a> of an <a href=
"#element-sort"><code>xsl:sort</code></a> element is evaluated once
for each <a title="group" class="termref" href=
"#dt-group">group</a>. During this evaluation, the <a title=
"context item" class="termref" href="#dt-context-item">context
item</a> is the <a title="initial item" class="termref" href=
"#dt-initial-item">initial item</a> of the group, the <a title=
"context position" class="termref" href=
"#dt-context-position">context position</a> is the position of this
item within the set of initial items (that is, one item for each
group in the <a title="population" class="termref" href=
"#dt-population">population</a>) in <a title="population order"
class="termref" href="#dt-population-order">population order</a>,
the <a title="context size" class="termref" href=
"#dt-context-size">context size</a> is the number of groups, the
<a title="current group" class="termref" href=
"#dt-current-group">current group</a> is the group whose <a title=
"sort key value" class="termref" href="#dt-sort-key-value">sort key
value</a> is being determined, and the <a title=
"current grouping key" class="termref" href=
"#dt-current-grouping-key">current grouping key</a> is the grouping
key for that group. If the <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction uses the <code>group-starting-with</code> or
<code>group-ending-with</code> attributes, then the <a title=
"current grouping key" class="termref" href=
"#dt-current-grouping-key">current grouping key</a> is
<span><a title="absent" class="termref" href=
"#dt-absent">absent</a></span>.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e36964" id=
"d7e36964"></a>Example: Sorting Groups</div>
<p>For example, this means that if the <a title="grouping key"
class="termref" href="#dt-grouping-key">grouping key</a> is
<code>@category</code>, you can sort the groups in order of their
grouping key by writing <code>&lt;xsl:sort
select="current-grouping-key()"/&gt;</code>; or you can sort the
groups in order of size by writing <code>&lt;xsl:sort
select="count(current-group())"/&gt;</code></p>
</div>
</div>
<div class="div2">
<h3><a name="grouping-examples" id="grouping-examples"></a>14.4
<a href="#grouping-examples" style="text-decoration: none">Examples
of Grouping</a></h3>
<div class="example">
<div class="exampleHeader"><a name="d7e36998" id=
"d7e36998"></a>Example: Grouping Nodes based on Common Values</div>
<p>The following example groups a list of nodes based on common
values. The resulting groups are numbered <span>and sorted</span>,
and a total is calculated for each group.</p>
<p>Source XML document:</p>
<div class="exampleInner">
<pre>
&lt;cities&gt;
  &lt;city name="Milano"  country="Italia"      pop="5"/&gt;
  &lt;city name="Paris"   country="France"      pop="7"/&gt;
  &lt;city name="München" country="Deutschland" pop="4"/&gt;
  &lt;city name="Lyon"    country="France"      pop="2"/&gt;
  &lt;city name="Venezia" country="Italia"      pop="1"/&gt;
&lt;/cities&gt;
</pre></div>
<p>More specifically, the aim is to produce a four-column table,
containing one row for each distinct country. The four columns are
to contain first, a sequence number giving the number of the row;
second, the name of the country, third, a comma-separated
alphabetical list of the city names within that country, and
fourth, the sum of the <code>pop</code> attribute for the cities in
that country.</p>
<p>Desired output:</p>
<div class="exampleInner">
<pre>
&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Position&lt;/th&gt;
    &lt;th&gt;Country&lt;/th&gt;
    &lt;th&gt;List of Cities&lt;/th&gt;
    &lt;th&gt;Population&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;1&lt;/td&gt;
    &lt;td&gt;Italia&lt;/td&gt;
    &lt;td&gt;Milano, Venezia&lt;/td&gt;
    &lt;td&gt;6&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;2&lt;/td&gt;
    &lt;td&gt;France&lt;/td&gt;
    &lt;td&gt;Lyon, Paris&lt;/td&gt;
    &lt;td&gt;9&lt;/td&gt;
  &lt;/tr&gt;  
  &lt;tr&gt;
    &lt;td&gt;3&lt;/td&gt;
    &lt;td&gt;Deutschland&lt;/td&gt;
    &lt;td&gt;München&lt;/td&gt;
    &lt;td&gt;4&lt;/td&gt;
  &lt;/tr&gt;  
&lt;/table&gt;
</pre></div>
<p>Solution:</p>
<div class="exampleInner">
<pre>
&lt;table xsl:version="3.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;tr&gt;
    &lt;th&gt;Position&lt;/th&gt;
    &lt;th&gt;Country&lt;/th&gt;
    &lt;th&gt;City List&lt;/th&gt;
    &lt;th&gt;Population&lt;/th&gt;
  &lt;/tr&gt;
  &lt;xsl:for-each-group select="cities/city" group-by="@country"&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;xsl:value-of select="position()"/&gt;&lt;/td&gt;
      &lt;td&gt;&lt;xsl:value-of select="current-grouping-key()"/&gt;&lt;/td&gt;
      &lt;td&gt;
        &lt;xsl:for-each select="current-group()/@name"&gt;
          &lt;xsl:sort select="."/&gt;
          &lt;xsl:if test="position() ne 1"&gt;, &lt;/xsl:if&gt;
          &lt;xsl:value-of select="."/&gt;
        &lt;/xsl:for-each&gt;  
      &lt;/td&gt;
      &lt;td&gt;&lt;xsl:value-of select="sum(current-group()/@pop)"/&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/xsl:for-each-group&gt;
&lt;/table&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e37023" id=
"d7e37023"></a>Example: A Composite Grouping Key</div>
<p>Sometimes it is necessary to use a composite grouping key: for
example, suppose the source document is similar to the one used in
the previous examples, but allows multiple entries for the same
country and city, such as:</p>
<div class="exampleInner">
<pre>
&lt;cities&gt;
  &lt;city name="Milano"  country="Italia"  year="1950"   pop="5.23"/&gt;
  &lt;city name="Milano"  country="Italia"  year="1960"   pop="5.29"/&gt;  
  &lt;city name="Padova"  country="Italia"  year="1950"   pop="0.69"/&gt;
  &lt;city name="Padova"  country="Italia"  year="1960"   pop="0.93"/&gt;    
  &lt;city name="Paris"   country="France"  year="1951"   pop="7.2"/&gt;
  &lt;city name="Paris"   country="France"  year="1961"   pop="7.6"/&gt;
&lt;/cities&gt;
</pre></div>
<p>Now suppose we want to list the average value of
<code>@pop</code> for each (country, name) combination. One way to
handle this is to concatenate the parts of the key, for example
<code>&lt;xsl:for-each-group select="concat(@country, '/',
@name)"&gt;</code>. A second solution is to nest one <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
element directly inside another. XSLT 3.0 introduces a third
option, which is to define the grouping key as composite:</p>
<div class="exampleInner">
<pre>
&lt;xsl:for-each-group select="cities/city" 
                    group-by="@name, @country" 
                    composite="yes"&gt;
  &lt;p&gt;
    &lt;xsl:value-of select="current-grouping-key()[1] || ', ' ||
                          current-grouping-key()[2] || ': ' || 
                          avg(current-group/@pop)"/&gt;
  &lt;/p&gt;
&lt;/xsl:for-each-group&gt;
</pre></div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The string concatenation operator <code>||</code> is new in
XPath 3.0.</p>
</div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e37049" id=
"d7e37049"></a>Example: Identifying a Group by its Initial
Element</div>
<p>The next example identifies a group not by the presence of a
common value, but rather by adjacency in document order. A group
consists of an <code>h2</code> element, followed by all the
<code>p</code> elements up to the next <code>h2</code> element.</p>
<p>Source XML document:</p>
<div class="exampleInner">
<pre>
&lt;body&gt;
  &lt;h2&gt;Introduction&lt;/h2&gt;
  &lt;p&gt;XSLT is used to write stylesheets.&lt;/p&gt;
  &lt;p&gt;XQuery is used to query XML databases.&lt;/p&gt;
  &lt;h2&gt;What is a stylesheet?&lt;/h2&gt;
  &lt;p&gt;A stylesheet is an XML document used to define a transformation.&lt;/p&gt;
  &lt;p&gt;Stylesheets may be written in XSLT.&lt;/p&gt;
  &lt;p&gt;XSLT 2.0 introduces new grouping constructs.&lt;/p&gt;
&lt;/body&gt;
</pre></div>
<p>Desired output:</p>
<div class="exampleInner">
<pre>
&lt;chapter&gt;
  &lt;section title="Introduction"&gt;
    &lt;para&gt;XSLT is used to write stylesheets.&lt;/para&gt;
    &lt;para&gt;XQuery is used to query XML databases.&lt;/para&gt;
  &lt;/section&gt; 
  &lt;section title="What is a stylesheet?"&gt;
    &lt;para&gt;A stylesheet is used to define a transformation.&lt;/para&gt;
    &lt;para&gt;Stylesheets may be written in XSLT.&lt;/para&gt;
    &lt;para&gt;XSLT 2.0 introduces new grouping constructs.&lt;/para&gt;
  &lt;/section&gt;
&lt;/chapter&gt;
</pre></div>
<p>Solution:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="body"&gt;
  &lt;chapter&gt;
        &lt;xsl:for-each-group select="*" group-starting-with="h2"&gt;
          &lt;section title="{self::h2}"&gt;
            &lt;xsl:for-each select="current-group()[self::p]"&gt;
              &lt;para&gt;&lt;xsl:value-of select="."/&gt;&lt;/para&gt;
            &lt;/xsl:for-each&gt; 
          &lt;/section&gt;
        &lt;/xsl:for-each-group&gt;
  &lt;/chapter&gt;
&lt;/xsl:template&gt;
</pre></div>
<p>The use of <code>title="{self::h2}"</code> rather than
<code>title="{.}"</code> is to handle the case where the first
element is not an <code>h2</code> element.</p>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e37086" id=
"d7e37086"></a>Example: Identifying a Group by its Final
Element</div>
<p>The next example illustrates how a group of related elements can
be identified by the last element in the group, rather than the
first. Here the absence of the attribute
<code>continued="yes"</code> indicates the end of the group.</p>
<p>Source XML document:</p>
<div class="exampleInner">
<pre>
&lt;doc&gt;
  &lt;page continued="yes"&gt;Some text&lt;/page&gt;
  &lt;page continued="yes"&gt;More text&lt;/page&gt;    
  &lt;page&gt;Yet more text&lt;/page&gt;
  &lt;page continued="yes"&gt;Some words&lt;/page&gt;
  &lt;page continued="yes"&gt;More words&lt;/page&gt;    
  &lt;page&gt;Yet more words&lt;/page&gt;        
&lt;/doc&gt;
</pre></div>
<p>Desired output:</p>
<div class="exampleInner">
<pre>
&lt;doc&gt;
  &lt;pageset&gt;
    &lt;page&gt;Some text&lt;/page&gt;
    &lt;page&gt;More text&lt;/page&gt;    
    &lt;page&gt;Yet more text&lt;/page&gt;
  &lt;/pageset&gt;
  &lt;pageset&gt;
    &lt;page&gt;Some words&lt;/page&gt;
    &lt;page&gt;More words&lt;/page&gt;    
    &lt;page&gt;Yet more words&lt;/page&gt;
  &lt;/pageset&gt;
&lt;/doc&gt;
</pre></div>
<p>Solution:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="doc"&gt;
&lt;doc&gt;
  &lt;xsl:for-each-group select="*" 
                      group-ending-with="page[not(@continued='yes')]"&gt;
    &lt;pageset&gt;
      &lt;xsl:for-each select="current-group()"&gt;
        &lt;page&gt;&lt;xsl:value-of select="."/&gt;&lt;/page&gt;
      &lt;/xsl:for-each&gt; 
    &lt;/pageset&gt;
  &lt;/xsl:for-each-group&gt;
&lt;/doc&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e37106" id=
"d7e37106"></a>Example: Adding an Element to Several Groups</div>
<p>The next example shows how an item can be added to multiple
groups. Book titles will be added to one group for each indexing
term marked up within the title.</p>
<p>Source XML document:</p>
<div class="exampleInner">
<pre>
&lt;titles&gt;
    &lt;title&gt;A Beginner's Guide to &lt;ix&gt;Java&lt;/ix&gt;&lt;/title&gt;
    &lt;title&gt;Learning &lt;ix&gt;XML&lt;/ix&gt;&lt;/title&gt;
    &lt;title&gt;Using &lt;ix&gt;XML&lt;/ix&gt; with &lt;ix&gt;Java&lt;/ix&gt;&lt;/title&gt;
&lt;/titles&gt;
</pre></div>
<p>Desired output:</p>
<div class="exampleInner">
<pre>
&lt;h2&gt;Java&lt;/h2&gt;
    &lt;p&gt;A Beginner's Guide to Java&lt;/p&gt;
    &lt;p&gt;Using XML with Java&lt;/p&gt;
&lt;h2&gt;XML&lt;/h2&gt;
    &lt;p&gt;Learning XML&lt;/p&gt;
    &lt;p&gt;Using XML with Java&lt;/p&gt;
</pre></div>
<p>Solution:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="titles"&gt;
    &lt;xsl:for-each-group select="title" group-by="ix"&gt;
      &lt;h2&gt;&lt;xsl:value-of select="current-grouping-key()"/&gt;&lt;/h2&gt;
      &lt;xsl:for-each select="current-group()"&gt;
        &lt;p&gt;&lt;xsl:value-of select="."/&gt;&lt;/p&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:for-each-group&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e37123" id=
"d7e37123"></a>Example: Grouping Alternating Sequences of
Elements</div>
<p>In this example, the membership of a node within a group is
based both on adjacency of the nodes in document order, and on
common values. In this case, the grouping key is a boolean
condition, true or false, so the effect is that a grouping
establishes a maximal sequence of nodes for which the condition is
true, followed by a maximal sequence for which it is false, and so
on.</p>
<p>Source XML document:</p>
<div class="exampleInner">
<pre>
&lt;p&gt;Do &lt;em&gt;not&lt;/em&gt;:
    &lt;ul&gt;
    &lt;li&gt;talk,&lt;/li&gt;
    &lt;li&gt;eat, or&lt;/li&gt;
    &lt;li&gt;use your mobile telephone&lt;/li&gt;
    &lt;/ul&gt;
    while you are in the cinema.&lt;/p&gt;
</pre></div>
<p>Desired output:</p>
<div class="exampleInner">
<pre>
&lt;p&gt;Do &lt;em&gt;not&lt;/em&gt;:&lt;/p&gt;
    &lt;ul&gt;
    &lt;li&gt;talk,&lt;/li&gt;
    &lt;li&gt;eat, or&lt;/li&gt;
    &lt;li&gt;use your mobile telephone&lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;while you are in the cinema.&lt;/p&gt;
</pre></div>
<p>Solution:</p>
<p>This requires creating a <code>p</code> element around the
maximal sequence of sibling nodes that does not include a
<code>ul</code> or <code>ol</code> element.</p>
<p>This can be done by using <code>group-adjacent</code>, with a
grouping key that is true if the element is a <code>ul</code> or
<code>ol</code> element, and false otherwise:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="p"&gt;
    &lt;xsl:for-each-group select="node()" 
            group-adjacent="self::ul or self::ol"&gt;
        &lt;xsl:choose&gt;
            &lt;xsl:when test="current-grouping-key()"&gt;
                &lt;xsl:copy-of select="current-group()"/&gt;  
            &lt;/xsl:when&gt;
            &lt;xsl:otherwise&gt;
                &lt;p&gt;
                    &lt;xsl:copy-of select="current-group()"/&gt;
                &lt;/p&gt;
            &lt;/xsl:otherwise&gt;  
        &lt;/xsl:choose&gt;
    &lt;/xsl:for-each-group&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
</div>
<div class="div2">
<h3><a name="non-transitivity" id="non-transitivity"></a>14.5
<a href="#non-transitivity" style=
"text-decoration: none">Non-Transitivity</a></h3>
<p>If the population contains values of different numeric types
that differ from each other by small amounts, then the
<code>eq</code> operator is not transitive, because of rounding
effects occurring during type promotion. It is thus possible to
have three values <var>A</var>, <var>B</var>, and <var>C</var>
among the grouping keys of the population such that <code>A eq
B</code>, <code>B eq C</code>, but <code>A ne C</code>.</p>
<p>For example, this arises when computing</p>
<div class="exampleInner">
<pre>
      &lt;xsl:for-each-group group-by="." select="
             xs:float('1.0'),
             xs:decimal('1.0000000000100000000001'),
             xs:double('1.00000000001')"&gt;
</pre></div>
<p>because the values of type <code>xs:float</code> and
<code>xs:double</code> both compare equal to the value of type
<code>xs:decimal</code> but not equal to each other.</p>
<p>In this situation the results <span class="verb">must</span> be
equivalent to the results obtained by the following algorithm:</p>
<ul>
<li>
<p>For each item <var>J</var> in the <a title="population" class=
"termref" href="#dt-population">population</a> in <a title=
"population order" class="termref" href=
"#dt-population-order">population order</a>, for each of the
<a title="grouping key" class="termref" href=
"#dt-grouping-key">grouping keys</a> <var>K</var> for that item in
sequence, the processor identifies those existing groups
<var>G</var> such that the grouping key of the <a title=
"initial item" class="termref" href="#dt-initial-item">initial
item</a> of <var>G</var> is equal to <var>K</var>.</p>
</li>
<li>
<p>If there is exactly one group <var>G</var>, then <var>J</var> is
added to this group, unless <var>J</var> is already a member of
this group.</p>
</li>
<li>
<p>If there is no group <var>G</var>, then a new group is created
with <var>J</var> as its first item.</p>
</li>
<li>
<p>If there is more than one group <var>G</var> (which can only
happen in exceptional circumstances involving non-transitivity),
then one of these groups is selected in an implementation-dependent
way, and <var>J</var> is added to this group, unless <var>J</var>
is already a member of this group.</p>
</li>
</ul>
<p>The effect of these rules is that (a) every item in a
non-singleton group has a grouping key that is equal to that of at
least one other item in that group, (b) for any two distinct
groups, there is at least one pair of items (one from each group)
whose grouping keys are not equal to each other.</p>
</div>
</div>
<div class="div1">
<h2><a name="merging" id="merging"></a>15 <a href="#merging" style=
"text-decoration: none">Merging</a></h2>
<p>The <a href="#element-merge"><code>xsl:merge</code></a>
instruction allows a sorted sequence of items to be constructed by
merging several input sequences, each of which is already sorted.
Each input sequence <span class="verb">must</span> have a merge key
(one or more atomic values that can be computed as a function of
the items in the sequence); the input sequence <span class=
"verb">must</span> be pre-sorted on the value of its merge keys;
and the merge keys for the different input sequences <span class=
"verb">must</span> be compatible in the sense that <span>key values
from an item in one sequence are always comparable with key values
from an item in a different sequence</span>.</p>
<p>For example, if two log files contain details of events sorted
by date and time, then the <a href=
"#element-merge"><code>xsl:merge</code></a> instruction can be used
to combine these into a single sequence that is also sorted by date
and time.</p>
<p>The data written to the output sequence can be computed in an
arbitrary way from the data in the input sequences, provided it
follows the ordering of the input sequences.</p>
<p>The <a href="#element-merge"><code>xsl:merge</code></a>
instruction can be used to merge several sequences of items that
all have the same structure (more precisely, sequences whose merge
keys are computed in the same way): for example, log files created
by the same application running on different machines in a server
farm. Alternatively, <a href=
"#element-merge"><code>xsl:merge</code></a> can be used to merge
sequences that have different structure (sequences whose merge keys
are computed in different ways), provided that the computed merge
keys are compatible: an example might be two log files created by
different applications, using different XML vocabularies, that both
contain timestamped events but represent the timestamp in different
ways. The <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> element
represents a <span>set of input sequences that follow common
rules</span>, including the rules for computing the merge key. The
<a href="#element-merge"><code>xsl:merge</code></a> operation may
take any number of <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> elements
representing different <span>rules for</span> input sequences, and
each <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> element
may describe any number (zero or more) of input sequences. The
number of input sequences to the merging operation is thus
<span>fixed only at the time the <a href=
"#element-merge"><code>xsl:merge</code></a> instruction is
evaluated, and <span class="verb">may</span> vary from one
evaluation to another</span>.</p>
<p>The following examples illustrate some of the possibilities. The
detailed explanation of the constructs used follows later in this
section.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e37341" id=
"d7e37341"></a>Example: Merging All the Files in a Collection</div>
<p>This example takes as input a homogeneous collection of XML log
files each of which contains a sorted sequence of
<code>event</code> elements with a <code>timestamp</code> attribute
validated as an instance of <code>xs:dateTime</code>. It merges the
events from the input files into a single sorted output file.</p>
<div class="exampleInner">
<pre>
&lt;xsl:result-document href="merged-events.xml"&gt;
  &lt;events&gt;
    &lt;xsl:merge&gt;
      &lt;xsl:merge-source for-each-stream="uri-collection('log-files')"
                        select="events/event"&gt;
        &lt;xsl:merge-key select="@timestamp"/&gt;
      &lt;/xsl:merge-source&gt;
      &lt;xsl:merge-action&gt;
        &lt;xsl:copy-of select="current-merge-group()"/&gt;
      &lt;/xsl:merge-action&gt;
    &lt;/xsl:merge&gt;
  &lt;/events&gt;
&lt;/xsl:result-document&gt;
</pre></div>
<p>The example assumes that there are <span>several input files
each of which has</span> a structure similar to the following, in
which the <code>timestamp</code> attribute has a typed value that
is an instance of <code>xs:dateTime</code>:</p>
<div class="exampleInner">
<pre>
&lt;events&gt;
   &lt;event timestamp="2009-08-20T12:01:01Z"&gt;Transaction T1234 started&lt;/event&gt;
   &lt;event timestamp="2009-08-20T12:01:08Z"&gt;Transaction T1235 started&lt;/event&gt;
   &lt;event timestamp="2009-08-20T12:01:12Z"&gt;Transaction T1235 ended&lt;/event&gt;
   &lt;event timestamp="2009-08-20T12:01:15Z"&gt;Transaction T1234 ended&lt;/event&gt;
&lt;/events&gt;
</pre></div>
<p>The output file will have the same structure, and will contain
copies of all the <code>event</code> elements from all of the input
files, in sorted order. <span>Note that multiple events with the
same timestamp can occur either within a single file or across
multiple files: the order of appearance of these events in the
output file corresponds to the order of the log files within the
collection (which might or might not be predictable, depending on
the implementation).</span></p>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e37377" id=
"d7e37377"></a>Example: Merging Two Heterogeneous Files</div>
<p>This example takes as input two log files with different
structure, producing a single merged output in which the entries
have a common structure:</p>
<div class="exampleInner">
<pre>
&lt;xsl:result-document href="merged-events.xml"&gt;
  &lt;events&gt;
    &lt;xsl:merge&gt;
      &lt;xsl:merge-source select="doc('log-file-1.xml')/events/event"&gt;
        &lt;xsl:merge-key select="@timestamp"/&gt;
      &lt;/xsl:merge-source&gt;
      &lt;xsl:merge-source select="doc('log-files-2.xml')/log/day/record"&gt;
        &lt;xsl:merge-key select="dateTime(../@date, time)"/&gt;
      &lt;/xsl:merge-source&gt;
      &lt;xsl:merge-action&gt;
        &lt;xsl:apply-templates select="current-merge-group()" 
                             mode="standardize-log-entry"/&gt;
      &lt;/xsl:merge-action&gt;
    &lt;/xsl:merge&gt;
  &lt;/events&gt;
&lt;/xsl:result-document&gt;
</pre></div>
<p>Here the first input file has a structure similar to that shown
in the previous example, while the second input has a different
structure, of the form:</p>
<div class="exampleInner">
<pre>
&lt;log&gt;
  &lt;day date="2009-08-20"&gt;
    &lt;record&gt;
      &lt;time&gt;12:01:09-05:00&lt;/time&gt;
      &lt;message&gt;Temperature 15.4C&lt;/message&gt;
    &lt;/record&gt;
    &lt;record&gt;
      &lt;time&gt;12:03:00-05:00&lt;/time&gt;
      &lt;message&gt;Temperature 18.2C&lt;/message&gt;
    &lt;/record&gt;
  &lt;/day&gt;
&lt;/log&gt;
</pre></div>
<p>The templates in mode <code>standardize-log-entry</code> convert
the log entries to a common output format, for example:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="event" mode="standardize-log-entry" 
                            as="schema-element(event)"&gt;
  &lt;xsl:copy-of select="." validation="preserve"/&gt;
&lt;/xsl:template&gt;
  
&lt;xsl:template match="record" mode="standardize-log-entry" 
                             as="schema-element(event)"&gt;
  &lt;event timestamp="{dateTime(../@date, time)}" xsl:validation="strict"&gt;
    &lt;xsl:value-of select="message"/&gt;
  &lt;/event&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The <a href="#element-merge"><code>xsl:merge</code></a>
instruction is designed to enable streaming of data, so that there
is no need to allocate memory to hold the input sequences.
<span>However, it can also be used in cases where streamed
processing is not possible, for example when the input needs to be
sorted</span>.</p>
</div>
<div class="div2">
<h3><a name="merge-terminology" id="merge-terminology"></a>15.1
<a href="#merge-terminology" style=
"text-decoration: none">Terminology for Merging</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-merge-source-definition" id="dt-merge-source-definition" title=
"merge source definition"></a>A <b>merge source definition</b> is
the definition of one kind of input to the merge operation. It
selects zero or more <a title="merge input sequence" class=
"termref" href="#dt-merge-input-sequence">merge input
sequences</a>, and it includes a <a title="merge key specification"
class="termref" href="#dt-merge-key-specification">merge key
specification</a> to define how the <span><a title=
"merge key value" class="termref" href="#dt-merge-key-value">merge
key values</a></span> are computed for each such merge input
sequence.<span class="definition">]</span> A merge source
definition corresponds to an <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> element
in the stylesheet.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-merge-input-sequence" id="dt-merge-input-sequence" title=
"merge input sequence"></a>A <b>merge input sequence</b> is an
arbitrary <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-sequence">sequence</a><sup><small>DM30</small></sup>
of items which is already sorted according to the <a title=
"merge key specification" class="termref" href=
"#dt-merge-key-specification">merge key specification</a> for the
corresponding <a title="merge source definition" class="termref"
href="#dt-merge-source-definition">merge source
definition</a>.<span class="definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-merge-key-specification" id="dt-merge-key-specification" title=
"merge key specification"></a>A <b>merge key specification</b>
consists of one or more adjacent <a href=
"#element-merge-key"><code>xsl:merge-key</code></a> elements which
together define how the <a title="merge input sequence" class=
"termref" href="#dt-merge-input-sequence">merge input sequences</a>
selected by a <a title="merge source definition" class="termref"
href="#dt-merge-source-definition">merge source definition</a> are
sorted. Each <a href=
"#element-merge-key"><code>xsl:merge-key</code></a> element defines
one <a title="merge key component" class="termref" href=
"#dt-merge-key-component">merge key component</a>.<span class=
"definition">]</span> For example, a merge key specification for a
log file might specify two merge key components, <code>date</code>
and <code>time</code>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-merge-key-component" id="dt-merge-key-component" title=
"merge key component"></a>A <b>merge key component</b> specifies
one component of a <a title="merge key specification" class=
"termref" href="#dt-merge-key-specification">merge key
specification</a>; it corresponds to a single <a href=
"#element-merge-key"><code>xsl:merge-key</code></a> element in the
stylesheet.<span class="definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-merge-key-value" id="dt-merge-key-value" title=
"merge key value"></a> For each item in a <a title=
"merge input sequence" class="termref" href=
"#dt-merge-input-sequence">merge input sequence</a>, a value is
computed for each <a title="merge key component" class="termref"
href="#dt-merge-key-component">merge key component</a> within the
<a title="merge key specification" class="termref" href=
"#dt-merge-key-specification">merge key specification</a>. The
value computed for an item by using the <var>N</var>th <a title=
"merge key component" class="termref" href=
"#dt-merge-key-component">merge key component</a> is referred to as
the <var>N</var>th <b>merge key value</b> of that item.<span class=
"definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-composite-merge-key-value" id="dt-composite-merge-key-value"
title="composite merge key value"></a> The ordered collection of
<a title="merge key value" class="termref" href=
"#dt-merge-key-value">merge key values</a> computed for one item in
a <a title="merge input sequence" class="termref" href=
"#dt-merge-input-sequence">merge input sequence</a> (one for each
<a title="merge key component" class="termref" href=
"#dt-merge-key-component">merge key component</a> within the
<a title="merge key specification" class="termref" href=
"#dt-merge-key-specification">merge key specification</a>) is
referred to as a <b>composite merge key value</b>.<span class=
"definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-merge-activation" id="dt-merge-activation" title=
"merge activation"></a>A <b>merge activation</b> is a single
evaluation of the sequence constructor contained within the
<a href="#element-merge-action"><code>xsl:merge-action</code></a>
element, which occurs once for each distinct <a title=
"composite merge key value" class="termref" href=
"#dt-composite-merge-key-value">composite merge key
value</a>.<span class="definition">]</span></p>
</div>
<div class="div2">
<h3><a name="merge-instruction" id="merge-instruction"></a>15.2
<a href="#merge-instruction" style="text-decoration: none">The</a>
<a href="#element-merge"><code>xsl:merge</code></a> <a href=
"#merge-instruction" style=
"text-decoration: none">Instruction</a></h3>
<p class="element-syntax"><a name="element-merge" id=
"element-merge"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:merge&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-merge-source">xsl:merge-source</a>+, <a href=
"#element-merge-action">xsl:merge-action</a>, <a href=
"#element-fallback">xsl:fallback</a>*) --&gt;<br />
&lt;/xsl:merge&gt;</code></p>
<p>The effect of the <a href=
"#element-merge"><code>xsl:merge</code></a> instruction is to
produce a sorted result sequence from a number of input
sequences.</p>
<p>The input sequences to the merge operation are defined by the
<a href="#element-merge-source"><code>xsl:merge-source</code></a>
child elements, as described in the next section.</p>
<p>The sequence constructor contained in the <a href=
"#element-merge-action"><code>xsl:merge-action</code></a> element
is evaluated once for each distinct <a title=
"composite merge key value" class="termref" href=
"#dt-composite-merge-key-value">composite merge key value</a> to
form a partial result sequence. The result of the <a href=
"#element-merge"><code>xsl:merge</code></a> instruction is the
concatenation of these partial result sequences. For example, the
action might be to copy the items from all the input sequences to
the result sequence without change; or it might be to select the
items from one input sequence in preference to the others. In the
general case, the items in the partial result sequence are produced
by an arbitrary computation that has access to the items (from the
various input sequences) that share the same value for the
composite merge key.</p>
<p>The <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> and
<a href="#element-merge-action"><code>xsl:merge-action</code></a>
elements are described in the following sections.</p>
<p>Any <a href="#element-fallback"><code>xsl:fallback</code></a>
children of the <a href="#element-merge"><code>xsl:merge</code></a>
instruction are ignored by an XSLT 3.0 processor, but are used by
an XSLT 1.0 or XSLT 2.0 processor to <span>perform fallback
processing</span>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>An <a href="#element-merge"><code>xsl:merge</code></a>
instruction that has no input sequences returns an empty sequence.
An <a href="#element-merge"><code>xsl:merge</code></a> instruction
with a single input sequence performs processing that is very
similar in concept to <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a> with
the <code>group-adjacent</code> attribute, except that it requires
the input to be sorted on the grouping key.</p>
</div>
</div>
<div class="div2">
<h3><a name="merge-input-sequences" id=
"merge-input-sequences"></a>15.3 <a href="#merge-input-sequences"
style="text-decoration: none">Selecting the Sequences to be
Merged</a></h3>
<p class="element-syntax"><a name="element-merge-source" id=
"element-merge-source"></a><code>&lt;xsl:merge-source<br />
&#160;&#160;name? = <var>ncname</var><br />
&#160;&#160;for-each-item? = <var>expression</var><br />
&#160;&#160;for-each-stream? = <var>expression</var><br />
&#160;&#160;<b>select</b> = <var>expression</var><br />
&#160;&#160;streamable? = <var>boolean</var><br />
&#160;&#160;sort-before-merge? = <var>boolean</var><br />
&#160;&#160;validation? = "strict" | "lax" | "preserve" |
"strip"<br />
&#160;&#160;type? = <var>eqname</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <a href=
"#element-merge-key">xsl:merge-key</a>+ --&gt;<br />
&lt;/xsl:merge-source&gt;</code></p>
<p>Each <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> element
defines one or more <a title="merge input sequence" class="termref"
href="#dt-merge-input-sequence">merge input sequences</a>.</p>
<p>The <code>name</code> attribute provides a means of
distinguishing items from different merge sources within the
<a href="#element-merge-action"><code>xsl:merge-action</code></a>
instructions. If the <code>name</code> attribute is present on an
<a href="#element-merge-source"><code>xsl:merge-source</code></a>
element, then it must not be equal to the <code>name</code>
attribute of any sibling <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> element.
If the <code>name</code> attribute is absent, then an <a title=
"implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a> name,
different from all explicitly specified names, is allocated to the
merge source.</p>
<p><a name="err-XTSE3195" id="err-XTSE3195"><span class=
"error">[ERR XTSE3195]</span></a> The two attributes
<code>for-each-item</code> and <code>for-each-stream</code> are
mutually exclusive. The <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> element
may contain either or neither, but not both. It is a <a title=
"static error" class="termref" href="#dt-static-error">static
error</a> if both are present. Furthermore, if the
<code>for-each-stream</code> attribute is present, the only
permitted value (and the default value) of the
<code>streamable</code> attribute is <code>yes</code>.</p>
<p><span>If neither of <code>for-each-item</code> and
<code>for-each-stream</code> is present</span>, the <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> element
defines a single merge input sequence. This sequence is the result
of evaluating the expression in the <code>select</code> attribute.
This is evaluated using the dynamic context of the containing
<a href="#element-merge"><code>xsl:merge</code></a> instruction.
This sequence will be merged with the sequences defined by other
<a href="#element-merge-source"><code>xsl:merge-source</code></a>
elements, if present.</p>
<p>When the <code>for-each-item</code> attribute is present, the
<a href="#element-merge-source"><code>xsl:merge-source</code></a>
element defines a collection of merge input sequences. The
selection of items in these input sequences is a two-stage process:
the <code>for-each-item</code> attribute of the <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> element
is an expression that selects a sequence of <em>anchor items</em>,
and for each anchor item, the <code>select</code> attribute is
evaluated to select the items that make up one merge input
sequence. The <code>for-each-item</code> expression is evaluated
with the dynamic context of the containing <a href=
"#element-merge"><code>xsl:merge</code></a> instruction, while the
<code>select</code> attribute is evaluated with the <a title=
"focus" class="termref" href="#dt-focus">focus</a> for the
evaluation as follows:</p>
<ul>
<li>
<p>The <a title="context item" class="termref" href=
"#dt-context-item">context item</a> is the anchor item</p>
</li>
<li>
<p>The <a title="context position" class="termref" href=
"#dt-context-position">context position</a> is the position of the
anchor item within the sequence of anchor items</p>
</li>
<li>
<p>The <a title="context size" class="termref" href=
"#dt-context-size">context size</a> is the number of anchor
items.</p>
</li>
</ul>
<p>When the <code>for-each-stream</code> attribute is present, its
value must be an expression that returns a sequence of URIs. The
expected type of the expression is <code>xs:string*</code>, and the
actual result of the expression is converted to this type using the
<a title="function conversion rules" class="termref" href=
"#dt-function-conversion-rules">function conversion rules</a>. Each
of these URIs is used to obtain a document node. Each <span class=
"verb">must</span> be a valid URI reference. If it is an absolute
URI reference, it is used as is; if it is a relative URI reference,
it is made absolute by resolving it against the base URI of the
<a href="#element-merge-source"><code>xsl:merge-source</code></a>
element. The process of obtaining a document node given a URI is
the same as for the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>
function, <span>and may trigger the same error conditions</span>.
However, unlike the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>
function, the <a href="#element-merge"><code>xsl:merge</code></a>
instruction offers no guarantee that the resulting document will be
stable (that is, that multiple calls specifying the same URI will
return the same document). The resulting document nodes act as the
<b>anchor items</b>. These anchor items are then used in the same
way as a sequence of anchor items selected directly using the
<code>for-each-item</code> attribute.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Examples of expressions that return a sequence of URIs are:</p>
<ul>
<li>
<p><code>for-each-stream="'inputA.xml', 'inputB.xml'"</code></p>
</li>
<li>
<p><code>for-each-stream="(1 to $N) ! ('input' || $N ||
'.xml')"</code></p>
</li>
<li>
<p><code>for-each-stream="uri-collection('input/dir/')</code></p>
</li>
</ul>
<p>Relative URIs are resolved relative to the base URI of the
<a href="#element-merge-source"><code>xsl:merge-source</code></a>
element.</p>
</div>
<p>The attributes <code>validation</code> and <code>type</code> are
used to control schema validation of documents read by virtue of
their appearance in the result of the <code>for-each-stream</code>
expression. These attributes are mutually exclusive (<span class=
"error">[see <a href="#err-XTSE1505">ERR XTSE1505</a>]</span>). The
rules are the same as for the <a href=
"#element-stream"><code>xsl:stream</code></a> element. If the
<code>for-each-stream</code> attribute is absent, then the
<code>validation</code> and <code>type</code> attributes
<span class="verb">must</span> both be absent.</p>
<p>If the <code>sort-before-merge</code> attribute is absent or has
the value <code>no</code>, then each input sequence <span class=
"verb">must</span> already be in the correct order for merging (a
dynamic error occurs if it is not). If the attribute is present
with the value <code>yes</code>, then each input sequence will
first be sorted to ensure that it is in the correct order.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e37898" id=
"d7e37898"></a>Example: Merging Several Documents with the Same
Structure</div>
<p>The following <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> element
selects two anchor items (the root nodes of two documents), and for
each of these it selects an input sequence consisting of selected
<code>event</code> elements within the relevant document.</p>
<div class="exampleInner">
<pre>
&lt;xsl:merge-source for-each-stream="'log-A.xml', 'log-B.xml'"
                  select="events/event"&gt;
   &lt;xsl:merge-key select="@timestamp" order="ascending"/&gt;
&lt;/xsl:merge-source&gt;
</pre></div>
<p>This example can be extended to merge any number of input
documents with the same structure:</p>
<div class="exampleInner">
<pre>
&lt;xsl:merge-source for-each-stream="uri-collection('log-collection')"
                  select="events/event"&gt;
   &lt;xsl:merge-key select="@time" order="ascending"/&gt;
&lt;/xsl:merge-source&gt;
</pre></div>
<p>In both the above examples the anchor items are document nodes,
and the items in the input sequence are elements within the
document that is rooted at this node. This is a common usage
pattern, but by no means the only way in which the construct can be
used.</p>
</div>
<p>The number of anchor items selected by an <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> element,
and therefore the number of input sequences, is variable, but the
input sequences selected by one <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> element
must all use the same expressions to select the items in the input
sequence and to compute their merge keys. If different expressions
are needed for different input sequences, then multiple <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> elements
can be used.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e37928" id=
"d7e37928"></a>Example: Merging Two Documents with Different
Structure</div>
<p>The following code merges two log files having different
internal structure:</p>
<div class="exampleInner">
<pre>
&lt;xsl:merge-source for-each-stream="'event-log.xml'" select="/*/event"&gt;
  &lt;xsl:merge-key select="@timestamp"/&gt;
&lt;/xsl:merge-source&gt;
&lt;xsl:merge-source for-each-stream="'error-log.xml'" select="/*/error"&gt;
  &lt;xsl:merge-key select="dateTime(@date, @time)"/&gt;
&lt;/xsl:merge-source&gt;
</pre></div>
<p>Although the merge keys are computed in different ways for the
two input sequences, the keys must be compatible across the two
sequences: in this case they are both atomic values of type
<code>xs:dateTime</code>.</p>
</div>
<p>In the common case where there is only one input sequence of a
particular kind, the <code>for-each-item</code> attribute of
<a href="#element-merge-source"><code>xsl:merge-source</code></a>
may be omitted; the <code>select</code> expression is then
evaluated relative to the <a title="focus" class="termref" href=
"#dt-focus">focus</a> of the <a href=
"#element-merge"><code>xsl:merge</code></a> instruction itself.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e37957" id=
"d7e37957"></a>Example: Sorting before Merging</div>
<p>Where one or more of the inputs to the merging process is not
pre-sorted, a sort can be requested using the
<code>sort-before-merge</code> attribute. For example:</p>
<div class="exampleInner">
<pre>
&lt;xsl:merge-source select="doc('event-log.xml')/*/event"&gt;
  &lt;xsl:merge-key select="@timestamp"/&gt;
&lt;/xsl:merge-source&gt;
&lt;xsl:merge-source select="doc('error-log.xml')//error" 
                  sort-before-merge="yes"&gt;
  &lt;xsl:merge-key select="dateTime(current-date(), @time)"/&gt;
&lt;/xsl:merge-source&gt;
</pre></div>
</div>
<p><a name="err-XTSE3190" id="err-XTSE3190"><span class=
"error">[ERR XTSE3190]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if two
sibling <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> elements
have the same name.</p>
</div>
<div class="div2">
<h3><a name="streamable-merging" id="streamable-merging"></a>15.4
<a href="#streamable-merging" style=
"text-decoration: none">Streamable Merging</a></h3>
<p>Any input to a merging operation, provided it is selected by
means of the <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> element
with a <code>for-each-stream</code> attribute, may be designated as
streamable by including the attribute <code>streamable="yes"</code>
on the <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> element.
This is also the default value when the
<code>for-each-stream</code> attribute is present.</p>
<p>When <code>streamable="yes"</code> is specified on an <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> element,
then (whether or not streamed processing is actually used, and
whether or not the processor supports streaming) the expression
appearing in the <code>select</code> attribute is implicitly used
as the argument of a call on the <a href=
"#func-snapshot"><code>snapshot</code></a> function, which means
that merge keys for each selected node are computed with reference
to this snapshot, and the <a href=
"#func-current-merge-group"><code>current-merge-group</code></a>
function, when used within the <a href=
"#element-merge-action"><code>xsl:merge-action</code></a> sequence
constructor, delivers snapshots of the selected nodes.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>There are therefore no constraints on the navigation that may be
performed in computing the merge key, or in the course of
evaluating the <a href=
"#element-merge-action"><code>xsl:merge-action</code></a> body. An
attempt to navigate outside the portion of the source document
delivered by the <a href="#func-snapshot"><code>snapshot</code></a>
function will typically not cause an error, but will return empty
results.</p>
<p>A consequence of the use of the <a href=
"#func-snapshot"><code>snapshot</code></a> function is that a type
error occurs if the <code>select</code> expression delivers
anything other than nodes. There is no rule to prevent the
<code>select</code> expression returning grounded nodes from a
different source document, or newly constructed nodes, but they are
still processed using the <a href=
"#func-snapshot"><code>snapshot</code></a> function.</p>
</div>
<p>An <span><a href=
"#element-merge-source"><code>xsl:merge-source</code></a>
element</span> is <a title="guaranteed-streamable" class="termref"
href="#dt-guaranteed-streamable">guaranteed-streamable</a> if it
satisfies all the following conditions:</p>
<ol class="enumar">
<li>
<p>The <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> element
has the actual or defaulted attribute value
<code>streamable="yes"</code>;</p>
</li>
<li>
<p>The <code>for-each-stream</code> attribute is present on that
<a href="#element-merge-source"><code>xsl:merge-source</code></a>
element;</p>
</li>
<li>
<p>The expression in the <code>select</code> attribute of that
<a href="#element-merge-source"><code>xsl:merge-source</code></a>
element <span>has <a title="striding" class="termref" href=
"#dt-striding">striding</a> <a title="posture" class="termref"
href="#dt-posture">posture</a></span>;</p>
</li>
<li>
<p>The <code>sort-before-merge</code> attribute of that <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> element
is either absent or takes its default value of <code>no</code>;</p>
</li>
</ol>
<p>Specifying <code>streamable="yes"</code> on an <a href=
"#element-merge"><code>xsl:merge</code></a> element declares an
intent that the <a href="#element-merge"><code>xsl:merge</code></a>
instruction should be guaranteed streamable according to these
criteria. The consequences of declaring the instruction to be
streamable when it is not in fact guaranteed streamable depend on
the conformance level of the processor, and are explained in
<a href="#streamability-guarantees"><i>19.10 Streamability
Guarantees</i></a>.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e38160" id=
"d7e38160"></a>Example: Streamed Merging</div>
<p>The following example merges two log files, processing each of
them using streaming.</p>
<div class="exampleInner">
<pre>
&lt;events&gt;
   &lt;xsl:merge&gt;
      &lt;xsl:merge-source for-each-stream="'log-file-1.xml'" 
                        select="events/event" 
                        streamable="yes"&gt;
         &lt;xsl:merge-key select="@timestamp"/&gt;
      &lt;/xsl:merge-source&gt;
      &lt;xsl:merge-source for-each-stream="'log-files-2.xml'" 
                        select="log/day/record" 
                        streamable="yes"&gt;
         &lt;xsl:merge-key select="dateTime(../@date, time)"/&gt;
      &lt;/xsl:merge-source&gt;
      &lt;xsl:merge-action&gt;
         &lt;events time="{current-merge-key()}"&gt;
            &lt;xsl:copy-of select="current-merge-group()"/&gt;
         &lt;/events&gt;   
      &lt;/xsl:merge-action&gt;
   &lt;/xsl:merge&gt;
&lt;/events&gt;
</pre></div>
</div>
<p>Note that the merge key for the second merge source includes
data from a child element of the selected element and also from an
attribute of the parent element. This works because of the merge
key is evaluated on the result of implicitly applying the <a href=
"#func-snapshot"><code>snapshot</code></a> function.</p>
</div>
<div class="div2">
<h3><a name="merge-keys" id="merge-keys"></a>15.5 <a href=
"#merge-keys" style="text-decoration: none">Defining the Merge
Keys</a></h3>
<p>The keys on which the input sequences are sorted are referred to
as merge keys. If the attribute <code>sort-before-merge</code> has
the value <code>yes</code>, the input sequences will be sorted into
the correct sequence before the merge operation takes place
(alternatively, the processor <span class="verb">may</span> use an
algorithm that has the same effect as sorting followed by merging).
If the attribute is absent or has the value <code>no</code>, then
the input sequences <span class="verb">must</span> already be in
the correct order.</p>
<p>The merge key for each type of input sequence (that is, for each
<a href="#element-merge-source"><code>xsl:merge-source</code></a>
element) is defined by a sequence of <a href=
"#element-merge-key"><code>xsl:merge-key</code></a> element
children of the <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> element.
Each <a href="#element-merge-key"><code>xsl:merge-key</code></a>
element defines one merge key component. The syntax and semantics
of an <a href="#element-merge-key"><code>xsl:merge-key</code></a>
element are closely based on the rules for the <a href=
"#element-sort"><code>xsl:sort</code></a> element (the only
exception being the absence of the <code>stable</code> attribute);
the difference is that <a href=
"#element-merge-key"><code>xsl:merge-key</code></a> elements do not
cause a sort to take place, they merely declare the existing sort
order of the input sequence.</p>
<p class="element-syntax"><a name="element-merge-key" id=
"element-merge-key"></a><code>&lt;xsl:merge-key<br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;lang? = { <var>language</var> }<br />
&#160;&#160;order? = { "ascending" | "descending" }<br />
&#160;&#160;collation? = { <var>uri</var> }<br />
&#160;&#160;case-order? = { "upper-first" | "lower-first" }<br />
&#160;&#160;data-type? = { "text" | "number" | <var>eqname</var>
}&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:merge-key&gt;</code></p>
<p>The <code>select</code> attribute and the contained <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> are mutually
exclusive:</p>
<p><a name="err-XTSE3200" id="err-XTSE3200"><span class=
"error">[ERR XTSE3200]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if an
<a href="#element-merge-key"><code>xsl:merge-key</code></a> element
with a <code>select</code> attribute has non-empty content.</p>
<p>The effect of the <a href=
"#element-merge-key"><code>xsl:merge-key</code></a> elements is
defined in terms of the rules for an equivalent sequence of
<a href="#element-sort"><code>xsl:sort</code></a> elements: if the
rules for sorting (see <a href="#sorting-process"><i>13.1.1 The
Sorting Process</i></a>) with <code>stable="yes"</code> would place
an item <var>A</var> before an item <var>B</var> in the <a title=
"sorted sequence" class="termref" href="#dt-sorted-sequence">sorted
sequence</a> produced by the sorting process, then <var>A</var>
must precede <var>B</var> in the input sequence to the merging
process.</p>
<p>The merge keys of the various input sequences to a merge
operation must be compatible with each other, since the merge
operation will decide the ordering of the result sequence by
comparing merge key values across input sequences. This means that
across all the <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> children
of an <a href="#element-merge"><code>xsl:merge</code></a>
instruction:</p>
<ul>
<li>
<p>Each <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> element
<span class="verb">must</span> have the same number of <a href=
"#element-merge-key"><code>xsl:merge-key</code></a> child elements;
let this number be <var>N</var>.</p>
</li>
<li>
<p>For each integer <var>J</var> in 1..<var>N</var>, consider the
set of <a href="#element-merge-key"><code>xsl:merge-key</code></a>
elements that are in position <var>J</var> among the <a href=
"#element-merge-key"><code>xsl:merge-key</code></a> children of
their parent <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> element.
All the <a href="#element-merge-key"><code>xsl:merge-key</code></a>
elements in this set <span class="verb">must</span> have the same
<a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> for their
<code>lang</code>, <code>order</code>, <code>collation</code>,
<code>case-order</code>, and <code>data-type</code> attributes,
where having the same effective value in this case means that
either both attributes must be absent, or both must be present and
evaluate to the same value; and in addition in the case of
<code>collation</code> the absolute URI must be the same after
resolving against the base URI.</p>
</li>
</ul>
<p>If any of the attributes <code>lang</code>, <code>order</code>,
<code>collation</code>, <code>case-order</code>, or
<code>data-type</code> are <a title="attribute value template"
class="termref" href="#dt-attribute-value-template">attribute value
templates</a>, then their <a title="effective value" class=
"termref" href="#dt-effective-value">effective values</a> are
evaluated using the <a title="focus" class="termref" href=
"#dt-focus">focus</a> of the containing <a href=
"#element-merge"><code>xsl:merge</code></a> instruction.</p>
<p><a name="err-XTSE2200" id="err-XTSE2200"><span class=
"error">[ERR XTSE2200]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
number of <a href=
"#element-merge-key"><code>xsl:merge-key</code></a> children of a
<a href="#element-merge-source"><code>xsl:merge-source</code></a>
element is not equal to the number of <a href=
"#element-merge-key"><code>xsl:merge-key</code></a> children of
another <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> child of
the same <a href="#element-merge"><code>xsl:merge</code></a>
instruction.</p>
<p><a name="err-XTDE2210" id="err-XTDE2210"><span class=
"error">[ERR XTDE2210]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if there
are two <a href="#element-merge-key"><code>xsl:merge-key</code></a>
elements that occupy corresponding positions among the <a href=
"#element-merge-key"><code>xsl:merge-key</code></a> children of two
different <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> elements
and that have differing <a title="effective value" class="termref"
href="#dt-effective-value">effective values</a> for any of the
attributes <code>lang</code>, <code>order</code>,
<code>collation</code>, <code>case-order</code>, or
<code>data-type</code>. Values are considered to differ if the
attribute is present on one element and not on the other, or if it
is present on both elements with <a title="effective value" class=
"termref" href="#dt-effective-value">effective values</a> that are
not equal to each other. In the case of the <code>collation</code>
attribute, the values are compared as absolute URIs after resolving
against the base URI. The error <span class="verb">may</span> be
reported statically if it is detected statically.</p>
<p><a name="err-XTDE2220" id="err-XTDE2220"><span class=
"error">[ERR XTDE2220]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if any
input sequence to an <a href=
"#element-merge"><code>xsl:merge</code></a> instruction contains
two items that are not correctly sorted according to the merge key
values defined on the <a href=
"#element-merge-key"><code>xsl:merge-key</code></a> children of the
corresponding <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> element,
when compared using the collation rules defined by the attributes
of the corresponding <a href=
"#element-merge-key"><code>xsl:merge-key</code></a> children of the
<a href="#element-merge"><code>xsl:merge</code></a> instruction,
unless the attribute <code>sort-before-merge</code> is present with
the value <code>yes</code>.</p>
<p><a name="err-XTTE2230" id="err-XTTE2230"><span class=
"error">[ERR XTTE2230]</span></a> It is a <a title="type error"
class="termref" href="#dt-type-error">type error</a> if some item
selected by a particular merge key in one input sequence is not
comparable using the XPath <code>le</code> operator with some item
selected by the corresponding sort key in another input
sequence.</p>
</div>
<div class="div2">
<h3><a name="current-merge-group-and-key" id=
"current-merge-group-and-key"></a>15.6 <a href=
"#current-merge-group-and-key" style="text-decoration: none">The
Current Merge Group and Key</a></h3>
<p>During processing of an <a href=
"#element-merge"><code>xsl:merge</code></a> instruction, two
additional values are available within the dynamic context:</p>
<ul>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-current-merge-group" id="dt-current-merge-group" title=
"current merge group"></a>The <b>current merge group</b> is a
<a title="map" class="termref" href="#dt-map">map</a>. During
evaluation of an <a href=
"#element-merge"><code>xsl:merge</code></a> instruction, as each
group of items with equal <a title="composite merge key value"
class="termref" href="#dt-composite-merge-key-value">composite
merge key values</a> is processed, the current merge group is set
to a map whose keys are the names of the various merge sources, and
whose associated values are the items from each merge source having
the relevant composite merge key value.<span class=
"definition">]</span></p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-current-merge-key" id="dt-current-merge-key" title=
"current merge key"></a>The <b>current merge key</b> is a sequence
of atomic values. During evaluation of an <a href=
"#element-merge"><code>xsl:merge</code></a> instruction, as each
group of items with equal <a title="composite merge key value"
class="termref" href="#dt-composite-merge-key-value">composite
merge key values</a> is processed, the current merge key is set to
the composite merge key value that these items have in common.
<span class="definition">]</span></p>
</li>
</ul>
<p>On completion of the <a href=
"#element-merge"><code>xsl:merge</code></a> instruction, the
current merge group and current merge key are reset to their
previous values.</p>
<p>These values are made available through the functions <a href=
"#func-current-merge-group"><code>current-merge-group</code></a>
and <a href=
"#func-current-merge-key"><code>current-merge-key</code></a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The current merge group and key are set during the evaluation of
the sequence constructor contained in the <a href=
"#element-merge-action"><code>xsl:merge-action</code></a> element.
They are initially <a title="absent" class="termref" href=
"#dt-absent">absent</a>, and they are cleared by all <a title=
"invocation construct" class="termref" href=
"#dt-invocation-construct">invocation constructs</a>, which means
in effect that the functions <a href=
"#func-current-merge-group"><code>current-merge-group</code></a>
and <a href=
"#func-current-merge-key"><code>current-merge-key</code></a> can
only usefully be invoked from instructions appearing lexically
within the <a href=
"#element-merge-action"><code>xsl:merge-action</code></a>
element.</p>
</div>
<div class="div3">
<h4><a name="func-current-merge-group" id=
"func-current-merge-group"></a>15.6.1 <a href=
"#func-current-merge-group" style=
"text-decoration: none">fn:current-merge-group</a></h4>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Returns the group of items currently being processed by an
<a href="#element-merge"><code>xsl:merge</code></a>
instruction.</p>
</dd>
<dt class="label">Signatures</dt>
<dd>
<p><a name="function-current-merge-group" id=
"function-current-merge-group"></a></p>
<div class="proto"><code class=
"function">current-merge-group</code>()<code class=
"as">&#160;as&#160;</code><code class=
"return-type">item()*</code></div>
<div class="proto"><code class=
"function">current-merge-group</code>(<code class=
"arg">$source</code><code class=
"as">&#160;as&#160;</code><code class=
"type">xs:string</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">item()*</code></div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>The <a title="current merge group" class="termref" href=
"#dt-current-merge-group">current merge group</a> is bound during
evaluation of the <a href=
"#element-merge"><code>xsl:merge</code></a> instruction. If no
<a href="#element-merge"><code>xsl:merge</code></a> is being
evaluated, then the current merge group is <a title="absent" class=
"termref" href="#dt-absent">absent</a>, in which case the function
raises a dynamic error (see below).</p>
<p>The <a title="current merge group" class="termref" href=
"#dt-current-merge-group">current merge group</a> (if not absent)
is a <a title="map" class="termref" href="#dt-map">map</a>. It
contains the set of items, from all merge inputs, that share a
common value for the merge key. This is structured as a map so that
the items from each merge source can be identified. The key in the
map is the value of the <code>name</code> attribute of the
corresponding <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> element
(or an invented name, in its absence), and the associated value is
the set of items contributed by that merge group.</p>
<p>The map itself is not made visible, but this function returns
values derived from the map. Specifically, if the map is denoted by
<var>$G</var>:</p>
<ul>
<li>
<p>The single-argument form of this function returns the value of
the expression <code>if (map:contains($source)) then $G($source)
else error()</code>. Informally, if there is an <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> element
whose <code>name</code> attribute matches <code>$source</code>, the
function returns the items in the current merge group that are
contributed by this merge source; otherwise it raises a dynamic
error (see below).</p>
</li>
<li>
<p>The zero-argument form of the function returns the value of the
expression <code>sort(map:keys($G))!$G(.)</code>, where the
<code>sort()</code> function sorts the names of <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> elements
into the document order of the <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> elements
in the stylesheet. Informally, it returns all the items in the
current merge group regardless of which merge source they derive
from.</p>
</li>
</ul>
<p>Within the <a title="current merge group" class="termref" href=
"#dt-current-merge-group">current merge group</a>, the ordering of
items from the input sequences is as follows, in major-to-minor
order:</p>
<ul>
<li>
<p>Items are first ordered by the <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> element
that defined the input sequence from which the item was taken;
items from <a href=
"#element-merge-source"><code>xsl:merge-source</code></a>
<var>A</var> precede items from <a href=
"#element-merge-source"><code>xsl:merge-source</code></a>
<var>B</var> if <var>A</var> precedes <var>B</var> in document
order within the stylesheet.</p>
</li>
<li>
<p>Items from different input sequences selected by the same
<a href="#element-merge-source"><code>xsl:merge-source</code></a>
element are then ordered based on the order of the anchor items in
the sequence selected by evaluating the <code>select</code>
attribute of the <a href=
"#element-merge-source"><code>xsl:merge-source</code></a>
element.</p>
</li>
<li>
<p>Finally, duplicate items from the same input sequence retain
their order from the input sequence.</p>
</li>
</ul>
<p>Duplicates are not eliminated: for example, if the same node is
selected in more than one input sequence, it may appear twice in
the current <span>merge</span> group.</p>
<p>All <a title="invocation construct" class="termref" href=
"#dt-invocation-construct">invocation constructs</a> set the value
of the <a title="current merge group" class="termref" href=
"#dt-current-merge-group">current merge group</a> to <a title=
"absent" class="termref" href="#dt-absent">absent</a>.</p>
<p>The current merge group is initially <a title="absent" class=
"termref" href="#dt-absent">absent</a> during the evaluation of
global variables and stylesheet parameters, during the evaluation
of the <code>use</code> attribute or contained sequence constructor
of <a href="#element-key"><code>xsl:key</code></a>, and during the
evaluation of the <code>initial-value</code> attribute of <a href=
"#element-accumulator"><code>xsl:accumulator</code></a> and the
<code>select</code> attribute of contained sequence constructor of
<a href=
"#element-accumulator-rule"><code>xsl:accumulator-rule</code></a>.</p>
</dd>
<dt class="label">Error Conditions</dt>
<dd>
<p><a name="err-XTSE3470" id="err-XTSE3470"><span class=
"error">[ERR XTSE3470]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
<a href=
"#func-current-merge-group"><code>current-merge-group</code></a>
function is used within a <a title="pattern" class="termref" href=
"#dt-pattern">pattern</a>.</p>
<p><a name="err-XTDE3480" id="err-XTDE3480"><span class=
"error">[ERR XTDE3480]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<a href=
"#func-current-merge-group"><code>current-merge-group</code></a>
function is used when the current merge group is <a title="absent"
class="termref" href="#dt-absent">absent</a>. The error
<span class="verb">may</span> be reported statically if it can be
detected statically.</p>
<p><a name="err-XTDE3490" id="err-XTDE3490"><span class=
"error">[ERR XTDE3490]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<code>$source</code> argument of the <a href=
"#func-current-merge-group"><code>current-merge-group</code></a>
function does not match the <code>name</code> attribute of any
<a href="#element-merge-source"><code>xsl:merge-source</code></a>
element for the current merge operation. The error <span class=
"verb">may</span> be reported statically if it can be detected
statically.</p>
</dd>
<dt class="label">Notes</dt>
<dd>
<p>Because the <a title="current merge group" class="termref" href=
"#dt-current-merge-group">current merge group</a> is cleared by
function calls and template calls, the <a href=
"#func-current-merge-group"><code>current-merge-group</code></a>
function only has useful effect when the call appears as a
descendant of an <a href=
"#element-merge-action"><code>xsl:merge-action</code></a>
element.</p>
<p>If an <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> element
has no <code>name</code> attribute, then it is not possible to
discover the items in the current merge group that derive
specifically from that source, but these items will still be
present in the current merge group, and will be included in the
result when the function is called with no arguments.</p>
<p>Like other XSLT extensions to the dynamic evaluation context,
the <a title="current merge group" class="termref" href=
"#dt-current-merge-group">current merge group</a> is not retained
as part of the closure of a function value. This means that the
expression <code>current-merge-group#0</code> is valid and returns
a function value, but any invocation of this function will fail
with a dynamic error <span class="error">[see <a href=
"#err-XTDE3480">ERR XTDE3480</a>]</span>.</p>
</dd>
</dl>
</div>
<div class="div3">
<h4><a name="func-current-merge-key" id=
"func-current-merge-key"></a>15.6.2 <a href=
"#func-current-merge-key" style=
"text-decoration: none">fn:current-merge-key</a></h4>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Returns the <span>merge</span> key of the <span>merge</span>
group currently being processed using the <a href=
"#element-merge"><code>xsl:merge</code></a> instruction.</p>
</dd>
<dt class="label">Signature</dt>
<dd>
<p><a name="function-current-merge-key" id=
"function-current-merge-key"></a></p>
<div class="proto"><code class=
"function">current-merge-key</code>()<code class=
"as">&#160;as&#160;</code><code class=
"return-type">xs:anyAtomicType*</code></div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>The evaluation context for XPath <a title="expression" class=
"termref" href="#dt-expression">expressions</a> includes a
component called the <a title="current merge key" class="termref"
href="#dt-current-merge-key">current merge key</a>, which is a
sequence of atomic values. The current merge key is the <a title=
"composite merge key value" class="termref" href=
"#dt-composite-merge-key-value">composite merge key value</a>
shared in common by all the items within the <a title=
"current merge group" class="termref" href=
"#dt-current-merge-group">current merge group</a>.</p>
<p>The function <a href=
"#func-current-merge-key"><code>current-merge-key</code></a>
returns the <a title="current merge key" class="termref" href=
"#dt-current-merge-key">current merge key</a>.</p>
<p>The current merge key is initially <a title="absent" class=
"termref" href="#dt-absent">absent</a> during the evaluation of
global variables and stylesheet parameters, during the evaluation
of the <code>use</code> attribute or contained sequence constructor
of <a href="#element-key"><code>xsl:key</code></a>, and during the
evaluation of the <code>initial-value</code> attribute of <a href=
"#element-accumulator"><code>xsl:accumulator</code></a> and the
<code>select</code> attribute of contained sequence constructor of
<a href=
"#element-accumulator-rule"><code>xsl:accumulator-rule</code></a>.</p>
<p>While an <a href="#element-merge"><code>xsl:merge</code></a>
instruction is being evaluated, the <span><a title=
"current merge key" class="termref" href=
"#dt-current-merge-key">current merge key</a></span> will be a
single atomic value if there is a single merge key, or a sequence
of atomic values if there are multiple merge keys.</p>
<p>At other times, the current merge key will be <a title="absent"
class="termref" href="#dt-absent">absent</a>.</p>
<p>All <a title="invocation construct" class="termref" href=
"#dt-invocation-construct">invocation constructs</a> set the value
of the <a title="current merge group" class="termref" href=
"#dt-current-merge-group">current merge group</a> to <a title=
"absent" class="termref" href="#dt-absent">absent</a>.</p>
<p><span>The <span><a title="composite merge key value" class=
"termref" href="#dt-composite-merge-key-value">merge
keys</a></span> of all items in a group are not necessarily
identical. For example, one might be an <code>xs:float</code> while
another is a numerically equal <code>xs:decimal</code></span>. The
<span><a href=
"#func-current-merge-key"><code>current-merge-key</code></a></span>
function <span>returns</span> the <span>merge</span> key of the
first item in the group, after atomization and casting of
<code>xs:untypedAtomic</code> values to <code>xs:string</code>.</p>
</dd>
<dt class="label">Error Conditions</dt>
<dd>
<p><a name="err-XTSE3500" id="err-XTSE3500"><span class=
"error">[ERR XTSE3500]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
<a href=
"#func-current-merge-key"><code>current-merge-key</code></a>
function is used within a <a title="pattern" class="termref" href=
"#dt-pattern">pattern</a>.</p>
<p><a name="err-XTDE3510" id="err-XTDE3510"><span class=
"error">[ERR XTDE3510]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<a href=
"#func-current-merge-key"><code>current-merge-key</code></a>
function is used when the current <span>merge</span> key is
<a title="absent" class="termref" href="#dt-absent">absent</a>, or
when it is invoked in the course of evaluating a pattern. The error
<span class="verb">may</span> be reported statically if it can be
detected statically.</p>
</dd>
<dt class="label">Notes</dt>
<dd>
<p>Like other XSLT extensions to the dynamic evaluation context,
the <a title="current merge key" class="termref" href=
"#dt-current-merge-key">current merge key</a> is not retained as
part of the closure of a function value. This means that the
expression <span><code>current-merge-key#0</code></span> is valid
and returns a function value, but any invocation of this function
will fail with a dynamic error <span class="error">[see <a href=
"#err-XTDE3510">ERR XTDE3510</a>]</span>.</p>
</dd>
</dl>
</div>
</div>
<div class="div2">
<h3><a name="merge-action" id="merge-action"></a>15.7 <a href=
"#merge-action" style="text-decoration: none">The</a> <a href=
"#element-merge-action"><code>xsl:merge-action</code></a> <a href=
"#merge-action" style="text-decoration: none">Element</a></h3>
<p>The <a href=
"#element-merge-action"><code>xsl:merge-action</code></a> child of
an <a href="#element-merge"><code>xsl:merge</code></a> instruction
defines the processing to be applied for each distinct <a title=
"composite merge key value" class="termref" href=
"#dt-composite-merge-key-value">composite merge key value</a> found
in the input sequences to the <a href=
"#element-merge"><code>xsl:merge</code></a> instruction.</p>
<p class="element-syntax"><a name="element-merge-action" id=
"element-merge-action"></a><code>&lt;xsl:merge-action&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:merge-action&gt;</code></p>
<p>The merge key values for each item in an input sequence are
calculated based on the corresponding <a href=
"#element-merge-key"><code>xsl:merge-key</code></a> elements, in
the same way as <a title="sort key value" class="termref" href=
"#dt-sort-key-value">sort key values</a> are calculated using a
sequence of <a href="#element-sort"><code>xsl:sort</code></a>
elements (see <a href="#sorting-process"><i>13.1.1 The Sorting
Process</i></a>). If several items from the same or from different
input sequences have the same values for all their merge keys
(comparing pairwise), then they are considered to form a group. The
sequence constructor contained in the <a href=
"#element-merge-action"><code>xsl:merge-action</code></a> element
is evaluated once for each such group of items, and the result of
the <a href="#element-merge"><code>xsl:merge</code></a> instruction
is the concatenation of the results obtained by processing each
group in turn.</p>
<p><span>The groups are processed one by one, based on the values
of the merge keys for the group.</span> If group <var>G</var> has a
set of merge key values <var>M</var>, while group <var>H</var> has
a set of merge key values <var>N</var>, then in the result of the
<a href="#element-merge"><code>xsl:merge</code></a> instruction,
the result of processing group <var>G</var> will precede the result
of processing <var>H</var> if and only if <var>M</var> precedes
<var>N</var> in the sort order defined by the <code>lang</code>,
<code>order</code>, <code>collation</code>,
<code>case-order</code>, and <code>data-type</code> attributes of
the merge key definitions.</p>
<p>Generally, two sets of merge key values are distinct if any
corresponding items in the two sets of values do not compare equal
under the rules for the XPath <code>eq</code> operator, under the
collating rules for the corresponding merge key definition. In rare
cases, when considering more than two sets of merge key values,
ambiguities may arise because of the non-transitivity of the
<code>eq</code> operator when applied across different numeric
types. In this situation, the partitioning of items into sets
having distinct key values is handled in the same way as for
<a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a> (see
<a href="#non-transitivity"><i>14.5 Non-Transitivity</i></a>), and
is to some extent <a title="implementation-dependent" class=
"termref" href=
"#dt-implementation-dependent">implementation-dependent</a>.</p>
<p>The <a title="focus" class="termref" href="#dt-focus">focus</a>
for evaluation of the sequence constructor contained in the
<a href="#element-merge-action"><code>xsl:merge-action</code></a>
element is as follows:</p>
<ul>
<li>
<p>The <a title="context item" class="termref" href=
"#dt-context-item">context item</a> is the first item in the
current group, that is <code>current-group()[1]</code></p>
</li>
<li>
<p>The <a title="context position" class="termref" href=
"#dt-context-position">context position</a> is the position of the
current group within the sequence of groups (so the first
evaluation of <a href=
"#element-merge-action"><code>xsl:merge-action</code></a> has
<code>position()=1</code>, the second has
<code>position()=2</code>, and so on).</p>
</li>
<li>
<p>The <a title="context size" class="termref" href=
"#dt-context-size">context size</a> is the number of groups, that
is, the number of distinct sets of merge key values.</p>
</li>
</ul>
<div class="example">
<div class="exampleHeader"><a name="d7e39278" id=
"d7e39278"></a>Example: Selective Processing of Merge Inputs</div>
<p>Consider a situation where there are two merge sources, named
"master" and "update"; the master source identifies a single merge
input file (the master file), while the update source identifies a
set of <var>N</var> update files, perhaps one for each day of the
week. The required logic is that if a merge key is present only in
the master file, then the corresponding item should be copied to
the output; if it is present in a single update file then that item
replaces the corresponding item from the master file; if it is
present in several update files, then an error is raised. This can
be achieved as follows:</p>
<div class="exampleInner">
<pre>
&lt;xsl:merge&gt;
  &lt;xsl:merge-source name="master" 
                    for-each-stream="'master.xml'"
                    select="/events/event"&gt;
      &lt;xsl:merge-key select="@key"/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-source name="updates" 
                    for-each-stream="uri-collection('updates')"
                    select="/events/event-change"&gt;
      &lt;xsl:merge-key select="@affected-key"/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-action&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="empty(current-merge-group('master'))"&gt;
        &lt;xsl:message&gt;
           Error: update is present with no matching master record!
        &lt;/xsl:message&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="empty(current-merge-group('updates'))"&gt;
        &lt;xsl:copy-of select="$master"/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="count(current-merge-group('updates')) = 1"&gt;
        &lt;xsl:copy-of select="current-merge-group('updates')"/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:message&gt;
           Conflict: multiple updates for the same master record!
        &lt;/xsl:message&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:merge-action&gt;
&lt;/xsl:merge&gt;
            
</pre></div>
<p>Some words of explanation:</p>
<ul>
<li>
<p>Error messages are produced if there is an update element whose
key does not correspond to any element in the master source, or if
there is more than one update element corresponding to the same
master element.</p>
</li>
<li>
<p>In the absence of errors, if there is a single update element
then it is copied to the output; if there is none, then the master
element is copied.</p>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a name="merge-examples" id="merge-examples"></a>15.8 <a href=
"#merge-examples" style="text-decoration: none">Examples of
xsl:merge</a></h3>
<p>Previous sections introduced examples designed to illustrate
some specific features of the <a href=
"#element-merge"><code>xsl:merge</code></a> instruction. This
section provides some further examples to illustrate different ways
in which the instruction can be used.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e39305" id=
"d7e39305"></a>Example: Applying Transactions to a Master
File</div>
<p>This example applies transactions from a transaction file to a
master file. Records in the master file for which there is no
corresponding transaction are copied unchanged. The transaction
file contains instructions to delete, replace, or insert records
identified by an ID value. The master file is known to be sorted on
the ID value; the transaction file is unsorted.</p>
<p>Master file document structure:</p>
<div class="exampleInner">
<pre>
&lt;data&gt;
  &lt;record ID="A0001"&gt;&lt;...&gt;&lt;/record&gt;
  &lt;record ID="A0002"&gt;&lt;...&gt;&lt;/record&gt;
  &lt;record ID="A0003"&gt;&lt;...&gt;&lt;/record&gt;
&lt;/data&gt;
</pre></div>
<p>Transaction file document structure:</p>
<div class="exampleInner">
<pre>
&lt;transactions&gt;
  &lt;update record="A0004" action="insert"&gt;&lt;...&gt;&lt;/update&gt;
  &lt;update record="A0002" action="delete"/&gt;
  &lt;update record="A0003" action="replace"&gt;&lt;...&gt;&lt;/update&gt;
&lt;/transactions&gt;
</pre></div>
<p>Solution:</p>
<div class="exampleInner">
<pre>
 &lt;xsl:merge&gt;
  &lt;xsl:merge-source name="master" 
                    select="doc('master.xml')/data/record"&gt;
      &lt;xsl:merge-key select="@ID"/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-source name="updates"
                    sort-before-merge="yes"
                    select="doc('transactions.xml')/transactions/update"&gt;     
      &lt;xsl:merge-key select="@record"/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-action&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="empty(current-merge-group('updates'))"&gt;
        &lt;xsl:copy-of select="current-merge-group('master')"/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="current-merge-group('updates')/@action=('insert', 'replace')"&gt;
        &lt;record ID="{$merge-key}"&gt;
          &lt;xsl:copy-of select="current-merge-group('updates')/*"/&gt;
        &lt;/record&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="current-merge-group('updates')/@action='delete'"/&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:merge-action&gt;
  &lt;/xsl:merge&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e39322" id=
"d7e39322"></a>Example: Merging Two Sequences of Numbers</div>
<p>The <a href="#element-merge"><code>xsl:merge</code></a>
instruction can be used to determine the union, intersection, or
difference of two sequences of numbers (or other atomic values).
This code gives the union:</p>
<div class="exampleInner">
<pre>
&lt;xsl:merge&gt;
  &lt;xsl:merge-source select="1 to 30"&gt;
      &lt;xsl:merge-key select="."/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-source select="20 to 40"&gt;
      &lt;xsl:merge-key select="."/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-action&gt;
    &lt;xsl:value-of select="current-merge-key()"/&gt;
  &lt;/xsl:merge-action&gt;
&lt;/xsl:merge&gt;
               
</pre></div>
<p>While this gives the intersection:</p>
<div class="exampleInner">
<pre>
&lt;xsl:merge&gt;
  &lt;xsl:merge-source select="1 to 30"&gt;
      &lt;xsl:merge-key select="."/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-source select="20 to 40"&gt;
      &lt;xsl:merge-key select="."/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-action&gt;
    &lt;xsl:if test="count(current-merge-group()) eq 2"&gt;
      &lt;xsl:value-of select="current-merge-key()"/&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:merge-action&gt;
&lt;/xsl:merge&gt;
               
</pre></div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="splitting" id="splitting"></a>16 <a href="#splitting"
style="text-decoration: none">Splitting</a></h2>
<p>Sometimes it is convenient to be able to compute multiple
results during a single scan of the input data. For example, a
transformation may wish to rename selected elements, and also to
output a count of how many elements have been renamed.
Traditionally in a functional language this means computing two
separate functions of the input sequence, which (in the absence of
sophisticated optimization) will result in the input being scanned
twice. This is inconsistent with streaming, where the input is only
available to be scanned once, and it can also lead to poor
performance in non-streaming applications.</p>
<p>To meet this requirement, XSLT 3.0 introduces the instruction
<a href="#element-fork"><code>xsl:fork</code></a>. The content of
this instruction is a <span>restricted form of</span> <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>, and in a
formal sense the effect of the instruction is simply to return the
result of evaluating the sequence constructor. However, the
presence of the instruction affects the analysis of streamability
(see <a href="#streamability"><i>19 Streamability</i></a>). In
particular, when <a href="#element-fork"><code>xsl:fork</code></a>
is used in a context where streaming is required, each independent
instruction within the sequence constructor must be streamable, but
the analysis assumes that these instructions can all be evaluated
during a single pass of the streamed input document.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The semantics of the instruction require a number of result
sequences to be computed during a single pass of the input. A
processor may interpret this as a request to use multiple threads.
However, implementations using a single thread are feasible, and
this instruction is not intended primarily as a means for
stylesheet authors to express their intentions with regard to
multi-threaded execution.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Because multiple results are computed during a single pass of
the input, and then concatenated into a single sequence, this
instruction will generally involve some buffering of results. The
amount of memory used should not exceed that needed to hold the
results of the instruction. However, within this principle,
implementations may adopt a variety of strategies for evaluation;
for example, there may be cases where buffering of the input is
more efficient than buffering of output.</p>
<p>Generally, stylesheet authors indicate that buffering of input
is the preferred strategy by using the <a href=
"#func-copy-of"><code>copy-of</code></a> or <a href=
"#func-snapshot"><code>snapshot</code></a> functions, and indicate
that buffering of output is preferred by using <a href=
"#element-fork"><code>xsl:fork</code></a>. However, conformant
processors are not constrained in their choice of evaluation
strategies.</p>
</div>
<p>The content model of the <a href=
"#element-fork"><code>xsl:fork</code></a> instruction (given that
an XSLT 3.0 processor ignores <a href=
"#element-fallback"><code>xsl:fallback</code></a>) takes two
possible forms:</p>
<ol class="enumar">
<li>
<p>A sequence of <a href=
"#element-sequence"><code>xsl:sequence</code></a> instructions</p>
</li>
<li>
<p>A single <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction. This will normally use the <code>group-by</code>
attribute, because in all other cases the containing <a href=
"#element-fork"><code>xsl:fork</code></a> instruction has no useful
effect.</p>
</li>
</ol>
<p>The first form is appropriate when splitting a single input
stream into a fixed number of output streams, known statically: for
example, one output stream for credit transactions, a second for
debit transactions. The second form is appropriate when the number
of output streams depends on the data: for example, one output
stream for each distinct city name found in the input data.</p>
<p>The following section describes the <a href=
"#element-fork"><code>xsl:fork</code></a> instruction more
formally.</p>
<div class="div2">
<h3><a name="fork-instruction" id="fork-instruction"></a>16.1
<a href="#fork-instruction" style="text-decoration: none">The</a>
<code>xsl:fork</code> <a href="#fork-instruction" style=
"text-decoration: none">Instruction</a></h3>
<p class="element-syntax"><a name="element-fork" id=
"element-fork"></a><code>&lt;!-- Category: instruction --&gt;<br />
&lt;xsl:fork&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-fallback">xsl:fallback</a>*, ((<a href=
"#element-sequence">xsl:sequence</a>, <a href=
"#element-fallback">xsl:fallback</a>*)* | (<a href=
"#element-for-each-group">xsl:for-each-group</a>, <a href=
"#element-fallback">xsl:fallback</a>*))) --&gt;<br />
&lt;/xsl:fork&gt;</code></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The content model can be described as follows: there is either a
single <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction, or a sequence of zero or more <a href=
"#element-sequence"><code>xsl:sequence</code></a> instructions; in
addition, <a href="#element-fallback"><code>xsl:fallback</code></a>
instructions may be added anywhere.</p>
</div>
<p>The result of the <a href=
"#element-fork"><code>xsl:fork</code></a> instruction is the
sequence formed by concatenating the results of evaluating each of
its contained instructions, in order. That is, the result can be
determined by treating the content as a <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> and evaluating
it as such.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Any <a href="#element-fallback"><code>xsl:fallback</code></a>
children will be ignored by an XSLT 3.0 processor.</p>
</div>
<p>By using the <a href="#element-fork"><code>xsl:fork</code></a>
instruction, the stylesheet author is suggesting to the <a title=
"processor" class="termref" href="#dt-processor">processor</a> that
buffering of output is acceptable even though this might use
unbounded memory and thus violate the normal expectations of
streamable processing</p>
<p>The presence of an <a href=
"#element-fork"><code>xsl:fork</code></a> instruction affects the
analysis of streamability, as described in <a href=
"#streamability"><i>19 Streamability</i></a>.</p>
</div>
<div class="div2">
<h3><a name="splitting-examples" id="splitting-examples"></a>16.2
<a href="#splitting-examples" style=
"text-decoration: none">Examples of Splitting with Streamed
Data</a></h3>
<p>This section gives examples of how splitting using <a href=
"#element-fork"><code>xsl:fork</code></a> can be used to enable
streaming of input documents in cases where several results need to
be computed during a single pass over the input data.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e39492" id=
"d7e39492"></a>Example: Splitting a Transaction File into Credits
and Debits</div>
<p>Consider a transaction file that contains a sequence of debits
and credits:</p>
<div class="exampleInner">
<pre>
&lt;transactions&gt;
  &lt;transaction value="5.60"/&gt;
  &lt;transaction value="11.20"/&gt;
  &lt;transaction value="-3.40"/&gt;
  &lt;transaction value="8.90"/&gt;
  &lt;transaction value="-1.99"/&gt;
&lt;/transactions&gt;
</pre></div>
<p>where the requirement is to split this into two separate files
containing credits and debits respectively.</p>
<p>This can be achieved in <a title="guaranteed-streamable" class=
"termref" href=
"#dt-guaranteed-streamable">guaranteed-streamable</a> code as
follows:</p>
<div class="exampleInner">
<pre>
&lt;xsl:stream href="transactions.xml"&gt;
  &lt;xsl:fork&gt;
    &lt;xsl:sequence&gt;
      &lt;xsl:result-document href="credits.xml"&gt;
        &lt;credits&gt;
          &lt;xsl:for-each select="transactions/transaction[@value ge 0]"&gt;
            &lt;xsl:copy-of select="."/&gt;
          &lt;/xsl:for-each&gt;
        &lt;/credits&gt;
      &lt;/xsl:result-document&gt;
    &lt;/xsl:sequence&gt;
    &lt;xsl:sequence&gt;
      &lt;xsl:result-document href="debits.xml"&gt;
        &lt;debits&gt;
          &lt;xsl:for-each select="transactions/transaction[@value lt 0]"&gt;
            &lt;xsl:copy-of select="."/&gt;
          &lt;/xsl:for-each&gt;
        &lt;/debits&gt;
      &lt;/xsl:result-document&gt;
    &lt;/xsl:sequence&gt;  
  &lt;/xsl:fork&gt;
&lt;/xsl:stream&gt;
               
</pre></div>
<p>In the absence of the <a href=
"#element-fork"><code>xsl:fork</code></a> instruction, this would
not be streamable, because the sequence constructor includes two
<a title="consuming" class="termref" href=
"#dt-consuming">consuming</a> instructions. With the addition of
the <a href="#element-fork"><code>xsl:fork</code></a> instruction,
however, each <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction is allowed to make a downwards selection.</p>
<p>One possible implementation model for this is as follows: a
single thread reads the source document, and sends parsing events
such as start-element and end-element to two other threads, each of
which is writing one of the two result documents. Each of these
implements the downwards-selecting path expression using a process
that waits until the next <code>transaction</code> start-element
event is received; when this event is received, the process
examines the <code>@value</code> attribute to determine whether or
not this transaction is to be copied; if it is, then all events
until the matching <code>transaction</code> end-element event are
copied to the serializer for the result document; otherwise, these
events are discarded.</p>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e39531" id=
"d7e39531"></a>Example: Splitting a Transaction File by Customer
Account</div>
<p>Consider a transaction file that contains a sequence of debits
and credits:</p>
<div class="exampleInner">
<pre>
&lt;transactions&gt;
  &lt;transaction value="5.60" account="01826370"/&gt;
  &lt;transaction value="11.20" account="92741838"/&gt;
  &lt;transaction value="-3.40" account="01826370"/&gt;
  &lt;transaction value="8.90" account="92741838"/&gt;
  &lt;transaction value="-1.99" account="43861562"/&gt;
&lt;/transactions&gt;
</pre></div>
<p>where the requirement is to split this into a number of separate
files, one for each account number found in the input.</p>
<p>This can be achieved in <a title="guaranteed-streamable" class=
"termref" href=
"#dt-guaranteed-streamable">guaranteed-streamable</a> code as
follows:</p>
<div class="exampleInner">
<pre>
&lt;xsl:stream href="transactions.xml"&gt;
  &lt;xsl:fork&gt;
    &lt;xsl:for-each-group select="transactions/transaction" group-by="@account"&gt;
      &lt;xsl:result-document href="account{current-grouping-key()}.xml"&gt;
        &lt;transactions account="{current-grouping-key()}"&gt;
          &lt;xsl:copy-of select="current-group()"/
        &lt;/transactions&gt;
      &lt;/xsl:result-document&gt;
    &lt;/xsl:for-each-group&gt;
  &lt;/xsl:fork&gt;
&lt;/xsl:stream&gt;
               
</pre></div>
<p>In the absence of the <a href=
"#element-fork"><code>xsl:fork</code></a> instruction, this would
not be streamable, because in the general case the output of
<a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a> with
a <code>group-by</code> attribute needs to be buffered. (The
streamability rules do not recognize an <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a> whose
body comprises an <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction as a special case.) With the addition of the <a href=
"#element-fork"><code>xsl:fork</code></a> instruction, however, the
code becomes guaranteed streamable.</p>
<p>One possible implementation model for this is as follows: the
processor opens a new serializer each time a new account number is
encountered in the input, and writes the
<code>&lt;transactions&gt;</code> start tag to the serializer. When
a <code>transaction</code> element is encountered in the input, it
is copied to the relevant serializer, according to the value of the
<code>account</code> attribute. At the end of the input, a
<code>&lt;transactions&gt;</code> end tag is written to each of the
serializers, and each output file is closed.</p>
<p>In the more general case, where the body of the <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction contributes output to the principal result document,
the output generated by processing each group needs to be buffered
in memory. The requirement to use <a href=
"#element-fork"><code>xsl:fork</code></a> exists so that this use
of (potentially unbounded) memory has to be a conscious decision by
the stylesheet author.</p>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e39589" id=
"d7e39589"></a>Example: Arithmetic using Multiple Child Elements as
Operands</div>
<p>The rules for streamability do not allow two instructions in a
sequence constructor to both read child or descendant elements of
the context node, which makes it tricky to perform a calculation in
which multiple child elements act as operands. This restriction can
be avoided by using <a href=
"#element-fork"><code>xsl:fork</code></a>, as shown below, where
each of the two branches of the <a href=
"#element-fork"><code>xsl:fork</code></a> instruction selects
children of the context node.</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="order" mode="a-streamable-mode"&gt;                  
  &lt;xsl:variable name="price-and-discount" as="xs:decimal+"&gt;
    &lt;xsl:fork&gt;
      &lt;xsl:sequence select="xs:decimal(price)"/&gt;
      &lt;xsl:sequence select="xs:decimal(discount)"/&gt;
    &lt;/xsl:fork&gt;
  &lt;/xsl:variable&gt;
  &lt;xsl:value-of select="$price-and-discount[1] - $price-and-discount[2]"/&gt;
  &lt;/xsl:template&gt;
</pre></div>
<p>A possible implementation strategy here is for events from the
XML parser to be sent to two separate agents (perhaps but not
necessarily running in different threads), one of which computes
<code>xs:decimal(price)</code> and the other
<code>xs:decimal(discount)</code>; on completion the results
computed by the two agents are appended to the sequence that forms
the value of the variable.</p>
<p>With this strategy, the processor would require sufficient
memory to hold the results of evaluating each branch of the fork.
If these results (unlike this example) are large, this could defeat
the purpose of streaming by requiring large amounts of memory;
nevertheless, this code is treated as streamable.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>An alternative solution to this requirement is to use map
expressions: see <a href="#map-expressions"><i>21.1.4 Map
Expressions</i></a>.</p>
</div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e39617" id=
"d7e39617"></a>Example: Deleting Elements, and Counting
Deletions</div>
<p>In this example the input is a narrative document containing
<code>note</code> elements at any level of nesting. The requirement
is to output a copy of the input document in which (a) the
<code>note</code> elements have been removed, and (b) a
<code>footnote</code> is added at the end indicating how many
<code>note</code> elements have been deleted.</p>
<div class="exampleInner">
<pre>
&lt;xsl:mode on-no-match="shallow-copy" streamable="yes"/&gt;

&lt;xsl:template match="note"/&gt;

&lt;xsl:template match="/*"&gt;
  &lt;xsl:fork&gt;
    &lt;xsl:sequence&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/xsl:sequence&gt;
    &lt;xsl:sequence&gt;
      &lt;footnote&gt;
        &lt;p&gt;Removed &lt;xsl:value-of select="count(.//note)"/&gt; 
                 note elements.&lt;/p&gt;
      &lt;/footnote&gt;
    &lt;/xsl:sequence&gt;  
  &lt;/xsl:fork&gt;
&lt;/xsl:template&gt;
               
</pre></div>
<p>The <a href="#element-fork"><code>xsl:fork</code></a>
instruction contains two independent branches. These can therefore
be evaluated in the same pass over the input data. The first branch
(the <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction) causes everything except the <code>note</code>
elements to be copied to the result; the second instruction (the
literal result element <code>footnote</code>) outputs a count of
the number of descendant <code>note</code> elements.</p>
<p>Note that although the processing makes a single pass over the
input stream, there is some buffering of results required, because
the results of the instructions within the <a href=
"#element-fork"><code>xsl:fork</code></a> instruction need to be
concatenated. In this case an intelligent implementation might be
able to restrict the buffered data to a single integer.</p>
<p>In a formal sense, however, the result is exactly the same as if
the <a href="#element-fork"><code>xsl:fork</code></a> element were
not there.</p>
<p>An alternative way of solving this example problem would be to
count the number of <code>note</code> elements using an
accumulator: see <a href="#accumulators"><i>18.2
Accumulators</i></a>.</p>
</div>
</div>
</div>
<div class="div1">
<h2><a name="regular-expressions" id="regular-expressions"></a>17
<a href="#regular-expressions" style=
"text-decoration: none">Regular Expressions</a></h2>
<p>The <a title="core function" class="termref" href=
"#dt-core-function">core function</a> library for XPath 3.0 defines
<span>several</span> functions that make use of regular
expressions:</p>
<ul>
<li>
<p><a href=
"http://www.w3.org/TR/xpath-functions-30/#func-matches"><code>matches</code></a><sup><small>FO30</small></sup>
returns a boolean result that indicates whether or not a string
matches a given regular expression.</p>
</li>
<li>
<p><a href=
"http://www.w3.org/TR/xpath-functions-30/#func-replace"><code>replace</code></a><sup><small>FO30</small></sup>
takes a string as input and returns a string obtained by replacing
all substrings that match a given regular expression with a
replacement string.</p>
</li>
<li>
<p><a href=
"http://www.w3.org/TR/xpath-functions-30/#func-tokenize"><code>tokenize</code></a><sup><small>FO30</small></sup>
returns a sequence of strings formed by breaking a supplied input
string at any separator that matches a given regular
expression.</p>
</li>
<li>
<p><a href=
"http://www.w3.org/TR/xpath-functions-30/#func-analyze-string"><code>
analyze-string</code></a><sup><small>FO30</small></sup> returns a
tree of nodes that effectively add markup to a string indicating
the parts of the string that matched the regular expression, as
well as its captured groups.</p>
</li>
</ul>
<p>These functions are described in <a href=
"#xpath-functions-30">[Functions and Operators]</a>.</p>
<p><span>Supplementing</span> these functions, XSLT provides an
instruction <a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a>,
which is defined in this section.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The <a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a>
instruction predates the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-analyze-string"><code>
analyze-string</code></a><sup><small>FO30</small></sup> function,
and provides very similar functionality, though in a different way.
The two constructs are not precisely equivalent; for example,
<a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a>
allows a regular expression that matches a zero-length string while
the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-analyze-string"><code>
analyze-string</code></a><sup><small>FO30</small></sup> function
does not. The <a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a>
instruction (via the use of <a href=
"#func-regex-group"><code>regex-group</code></a>) provides
information about the value of captured substrings; the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-analyze-string"><code>
analyze-string</code></a><sup><small>FO30</small></sup> function
additionally provides information about the position of the
captured substrings within the original string.</p>
</div>
<p>The regular expressions used by this instruction, and the flags
that control the interpretation of these regular expressions,
<span class="verb">must</span> conform to the syntax defined in
<a href="#xpath-functions-30">[Functions and Operators]</a> (see
<a href=
"http://www.w3.org/TR/xpath-functions-30/#regex-syntax">Section
5.6.1 Regular expression syntax</a>
<sup><small>FO30</small></sup>), which is itself based on the
syntax defined in <a href="#xmlschema-2">[XML Schema Part
2]</a>.</p>
<div class="div2">
<h3><a name="analyze-string" id="analyze-string"></a>17.1 <a href=
"#analyze-string" style="text-decoration: none">The</a>
<code>xsl:analyze-string</code> <a href="#analyze-string" style=
"text-decoration: none">Instruction</a></h3>
<p class="element-syntax"><a name="element-analyze-string" id=
"element-analyze-string"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:analyze-string<br />
&#160;&#160;<b>select</b> = <var>expression</var><br />
&#160;&#160;<b>regex</b> = { <var>string</var> }<br />
&#160;&#160;flags? = { <var>string</var> }&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-matching-substring">xsl:matching-substring</a>?, <a href=
"#element-non-matching-substring">xsl:non-matching-substring</a>?,
<a href="#element-fallback">xsl:fallback</a>*) --&gt;<br />
&lt;/xsl:analyze-string&gt;</code></p>
<p class="element-syntax"><a name="element-matching-substring" id=
"element-matching-substring"></a><code>&lt;xsl:matching-substring&gt;<br />

&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:matching-substring&gt;</code></p>
<p class="element-syntax"><a name="element-non-matching-substring"
id=
"element-non-matching-substring"></a><code>&lt;xsl:non-matching-substring&gt;<br />

&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:non-matching-substring&gt;</code></p>
<p>The <a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a>
instruction takes as input a string (the result of evaluating the
expression in the <code>select</code> attribute) and a regular
expression (the effective value of the <code>regex</code>
attribute).</p>
<p>If the result of evaluating the <code>select</code> expression
<span>is an empty sequence, it is treated as a zero-length string.
If the value</span> is not a string, it is converted to a string by
applying the <a title="function conversion rules" class="termref"
href="#dt-function-conversion-rules">function conversion
rules</a>.</p>
<p>The <code>flags</code> attribute may be used to control the
interpretation of the regular expression. If the attribute is
omitted, the effect is the same as supplying a zero-length string.
This is interpreted in the same way as the <code>$flags</code>
attribute of the functions <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-matches"><code>matches</code></a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#func-replace"><code>replace</code></a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-tokenize"><code>tokenize</code></a><sup><small>FO30</small></sup>.
Specifically, if it contains the letter <code>m</code>, the match
operates in multiline mode. If it contains the letter
<code>s</code>, it operates in dot-all mode. If it contains the
letter <code>i</code>, it operates in case-insensitive mode. If it
contains the letter <code>x</code>, then whitespace within the
regular expression is ignored. For more detailed specifications of
these modes, see <a href="#xpath-functions-30">[Functions and
Operators]</a> (<a href=
"http://www.w3.org/TR/xpath-functions-30/#flags">Section 5.6.1.1
Flags</a> <sup><small>FO30</small></sup>).</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Because the <code>regex</code> attribute is an attribute value
template, curly brackets within the regular expression must be
doubled. For example, to match a sequence of one to five
characters, write <code>regex=".{{1,5}}"</code>. For regular
expressions containing many curly brackets it may be more
convenient to use a notation such as
<code>regex="{'[0-9]{1,5}[a-z]{3}[0-9]{1,2}'}"</code>, or to use a
variable.</p>
</div>
<p>The <a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a>
instruction may have two child elements: <a href=
"#element-matching-substring"><code>xsl:matching-substring</code></a>
and <a href=
"#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>.
Both elements are optional, and neither may appear more than once.
At least one of them must be present. If both are present, the
<a href=
"#element-matching-substring"><code>xsl:matching-substring</code></a>
element must come first.</p>
<p>The content of the <a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a>
instruction must take one of the following forms:</p>
<ol class="enumar">
<li>
<p>A single <a href=
"#element-matching-substring"><code>xsl:matching-substring</code></a>
instruction, followed by zero or more <a href=
"#element-fallback"><code>xsl:fallback</code></a> instructions</p>
</li>
<li>
<p>A single <a href=
"#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>
instruction, followed by zero or more <a href=
"#element-fallback"><code>xsl:fallback</code></a> instructions</p>
</li>
<li>
<p>A single <a href=
"#element-matching-substring"><code>xsl:matching-substring</code></a>
instruction, followed by a single <a href=
"#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>
instruction, followed by zero or more <a href=
"#element-fallback"><code>xsl:fallback</code></a> instructions</p>
</li>
</ol>
<p><a name="err-XTSE1130" id="err-XTSE1130"><span class=
"error">[ERR XTSE1130]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
<a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a>
instruction contains neither an <a href=
"#element-matching-substring"><code>xsl:matching-substring</code></a>
nor an <a href=
"#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>
element.</p>
<p>Any <a href="#element-fallback"><code>xsl:fallback</code></a>
elements among the children of the <a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a>
instruction are ignored by an XSLT 2.0 <span>or 3.0</span>
processor, but allow fallback behavior to be defined when the
stylesheet is used with an XSLT 1.0 processor operating with
forwards-compatible behavior.</p>
<p>This instruction is designed to process all the non-overlapping
substrings of the input string that match the regular expression
supplied.</p>
<p><a name="err-XTDE1140" id="err-XTDE1140"><span class=
"error">[ERR XTDE1140]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the <code>regex</code>
attribute does not conform to the <span class=
"verb">required</span> syntax for regular expressions, as specified
in <a href="#xpath-functions-30">[Functions and Operators]</a>. If
the regular expression is known statically (for example, if the
attribute does not contain any <a title="expression" class=
"termref" href="#dt-expression">expressions</a> enclosed in curly
brackets) then the processor <span class="verb">may</span> signal
the error as a <a title="static error" class="termref" href=
"#dt-static-error">static error</a>.</p>
<p><a name="err-XTDE1145" id="err-XTDE1145"><span class=
"error">[ERR XTDE1145]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the <code>flags</code>
attribute has a value other than the values defined in <a href=
"#xpath-functions-30">[Functions and Operators]</a>. If the value
of the attribute is known statically (for example, if the attribute
does not contain any <a title="expression" class="termref" href=
"#dt-expression">expressions</a> enclosed in curly brackets) then
the processor <span class="verb">may</span> signal the error as a
<a title="static error" class="termref" href=
"#dt-static-error">static error</a>.</p>
<p>To explain the behavior of the instruction it is useful to
consider an input string of length <var>N</var> characters as
having <var>N+1</var> inter-character positions, including one just
before the first character and one just after the last. Each of
these positions is a possible position for testing whether the
regular expression matches. These positions are numbered from zero
to <code>N</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The term <b>character</b>, here as elsewhere in this
specification, means a Unicode codepoint. When strings are held in
decomposed form, the multiple codepoints representing a composite
character are considered to be multiple characters. A codepoint
greater than 65535 is considered as one character, not as a
surrogate pair.</p>
</div>
<p>The processor starts by setting the current position to position
zero, and the current non-matching substring to a zero-length
string. It then does the following repeatedly:</p>
<ol class="enumar">
<li>
<p>Test whether the regular expression matches at the current
position.</p>
</li>
<li>
<p>If there is a match:</p>
<ol class="enumla">
<li>
<p>If the current non-matching substring has length greater than
zero, evaluate the <a href=
"#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>
sequence constructor with the current non-matching substring as the
context item.</p>
</li>
<li>
<p>Reset the current non-matching substring to a zero-length
string.</p>
</li>
<li>
<p>Evaluate the <a href=
"#element-matching-substring"><code>xsl:matching-substring</code></a>
sequence constructor with the matching substring as the context
item.</p>
</li>
<li>
<p>Do the appropriate one of the following:</p>
<ol class="enumlr">
<li>
<p>If the matching substring is non-zero length, set the current
position to coincide with the end of the matching substring, exit,
and repeat.</p>
</li>
<li>
<p>If the matching substring is zero length and the current
position is at the end of the input string, exit.</p>
</li>
<li>
<p>If the matching substring is zero length and the current
position is not at the end of the input string, add the character
that immediately follows the current position to the current
non-matching substring, set the current position to the position
immediately after this character, exit, and repeat.</p>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p>If there is no match:</p>
<ol class="enumla">
<li>
<p>If the current position is the last position (that is, just
after the last character):</p>
<ol class="enumlr">
<li>
<p>If the current non-matching substring has length greater than
zero, evaluate the <a href=
"#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>
sequence constructor with the current non-matching substring as the
context item.</p>
</li>
<li>
<p>Exit.</p>
</li>
</ol>
</li>
<li>
<p>Otherwise, add the character at the current position to the
current non-matching substring, increment the current position, and
repeat.</p>
</li>
</ol>
</li>
</ol>
<p><span>When the matcher is looking for a match at a particular
starting position and there are</span> several alternatives within
the regular expression that match at this position in the input
string, then the match that is chosen is the first alternative that
matches. For example, if the input string is <code>The quick brown
fox jumps</code> and the regular expression is
<code>jump|jumps</code>, then the match that is chosen is
<code>jump</code>.</p>
<p>The input string is thus partitioned into a sequence of
substrings, some of which match the regular expression, others
which do not match it. <span>Each non-matching substring will
contain at least one character, but a matching substring may be
zero-length.</span> This sequence of substrings is processed using
the <span>instructions within the contained <a href=
"#element-matching-substring"><code>xsl:matching-substring</code></a>
and <a href=
"#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>
elements</span>. A matching substring is processed using the
<a href=
"#element-matching-substring"><code>xsl:matching-substring</code></a>
element, a non-matching substring using the <a href=
"#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>
element. Each of these elements takes a <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> as its content.
If the element is absent, the effect is the same as if it were
present with empty content. In processing each substring, the
contents of the substring will be the <a title="context item"
class="termref" href="#dt-context-item">context item</a> (as a
value of type <code>xs:string</code>); the position of the
substring within the sequence of matching and non-matching
substrings will be the <a title="context position" class="termref"
href="#dt-context-position">context position</a>; and the number of
matching and non-matching substrings will be the <a title=
"context size" class="termref" href="#dt-context-size">context
size</a>.</p>
</div>
<div class="div2">
<h3><a name="func-regex-group" id="func-regex-group"></a>17.2
<a href="#func-regex-group" style=
"text-decoration: none">fn:regex-group</a></h3>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Returns the string captured by a parenthesized subexpression of
the regular expression used during evaluation of the <a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a>
instruction.</p>
</dd>
<dt class="label">Signature</dt>
<dd>
<p><a name="function-regex-group" id=
"function-regex-group"></a></p>
<div class="proto"><code class=
"function">regex-group</code>(<code class=
"arg">$group-number</code><code class=
"as">&#160;as&#160;</code><code class=
"type">xs:integer</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">xs:string</code></div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-current-captured-substrings" id=
"dt-current-captured-substrings" title=
"current captured substrings"></a>While the <a href=
"#element-matching-substring"><code>xsl:matching-substring</code></a>
instruction is active, a set of <b>current captured substrings</b>
is available, corresponding to the parenthesized subexpressions of
the regular expression.<span class="definition">]</span> These
captured substrings are accessible using the function <a href=
"#func-regex-group"><code>regex-group</code></a>. This function
takes an integer argument to identify the group, and returns a
string representing the captured substring.</p>
<p>The <var>N</var>th captured substring (where <var>N</var> &gt;
0) is the string matched by the subexpression contained by the
<var>N</var>th left parenthesis in the regex, <span>excluding any
non-capturing groups, which are written as
<code>(?:xxx)</code></span>. The zeroth captured substring is the
string that matches the entire regex. This means that the value of
<code>regex-group(0)</code> is initially the same as the value of
<code>.</code> (dot).</p>
<p>The function returns the zero-length string if there is no
captured substring with the relevant number. This can occur for a
number of reasons:</p>
<ol class="enumar">
<li>
<p>The number is negative.</p>
</li>
<li>
<p>The regular expression does not contain a parenthesized
subexpression with the given number.</p>
</li>
<li>
<p>The parenthesized subexpression exists, and did not match any
part of the input string.</p>
</li>
<li>
<p>The parenthesized subexpression exists, and matched a
zero-length substring of the input string.</p>
</li>
</ol>
<p>The set of captured substrings is a context variable with
dynamic scope. It is initially an empty sequence. During the
evaluation of an <a href=
"#element-matching-substring"><code>xsl:matching-substring</code></a>
instruction it is set to the sequence of matched substrings for
that regex match. During the evaluation of an <a href=
"#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>
instruction or a <a title="pattern" class="termref" href=
"#dt-pattern">pattern</a> or a <a title="stylesheet function"
class="termref" href="#dt-stylesheet-function">stylesheet
function</a> it is set to an empty sequence. On completion of an
instruction that changes the value, the variable reverts to its
previous value.</p>
<p>The value of the <a title="current captured substrings" class=
"termref" href="#dt-current-captured-substrings">current captured
substrings</a> is unaffected through calls of <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href=
"#element-call-template"><code>xsl:call-template</code></a>,
<a href="#element-apply-imports"><code>xsl:apply-imports</code></a>
or <a href="#element-next-match"><code>xsl:next-match</code></a>,
or by expansion of named <a title="attribute set" class="termref"
href="#dt-attribute-set">attribute sets</a>.</p>
</dd>
</dl>
</div>
<div class="div2">
<h3><a name="regex-examples" id="regex-examples"></a>17.3 <a href=
"#regex-examples" style="text-decoration: none">Examples of Regular
Expression Matching</a></h3>
<div class="example">
<div class="exampleHeader"><a name="d7e40310" id=
"d7e40310"></a>Example: Replacing Characters by Elements</div>
<p>Problem: replace all newline characters in the
<code>abstract</code> element by empty <code>br</code>
elements:</p>
<p>Solution:</p>
<div class="exampleInner">
<pre>
&lt;xsl:analyze-string select="abstract" regex="\n"&gt;
  &lt;xsl:matching-substring&gt;
    &lt;br/&gt;
  &lt;/xsl:matching-substring&gt;
  &lt;xsl:non-matching-substring&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:non-matching-substring&gt;
&lt;/xsl:analyze-string&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e40325" id=
"d7e40325"></a>Example: Recognizing non-XML Markup Structure</div>
<p>Problem: replace all occurrences of <code>[...]</code> in the
<code>body</code> by <code>cite</code> elements, retaining the
content between the square brackets as the content of the new
element.</p>
<p>Solution:</p>
<div class="exampleInner">
<pre>
&lt;xsl:analyze-string select="body" regex="\[(.*?)\]"&gt;
  &lt;xsl:matching-substring&gt;
    &lt;cite&gt;&lt;xsl:value-of select="regex-group(1)"/&gt;&lt;/cite&gt;
  &lt;/xsl:matching-substring&gt;
  &lt;xsl:non-matching-substring&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:non-matching-substring&gt;
&lt;/xsl:analyze-string&gt;
</pre></div>
<p>Note that this simple approach fails if the <code>body</code>
element contains markup that needs to be retained. In this case it
is necessary to apply the regular expression processing to each
text node individually. If the <code>[...]</code> constructs span
multiple text nodes (for example, because there are elements within
the square brackets) then it probably becomes necessary to make two
or more passes over the data.</p>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e40351" id=
"d7e40351"></a>Example: Parsing a Date</div>
<p>Problem: the input string contains a date such as <code>23 March
2002</code>. Convert it to the form <code>2002-03-23</code>.</p>
<p>Solution (with no error handling if the input format is
incorrect):</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="months" 
        select="'January', 'February', 'March', ..."/&gt;

&lt;xsl:analyze-string select="normalize-space($input)" 
    regex="([0-9]{{1,2}})\s([A-Z][a-z]+)\s([0-9]{{4}})"&gt;
    &lt;xsl:matching-substring&gt;
        &lt;xsl:number value="regex-group(3)" format="0001"/&gt;          
        &lt;xsl:text&gt;-&lt;/xsl:text&gt;
        &lt;xsl:number value="index-of($months, regex-group(2))" format="01"/&gt;
        &lt;xsl:text&gt;-&lt;/xsl:text&gt;
        &lt;xsl:number value="regex-group(1)" format="01"/&gt;
    &lt;/xsl:matching-substring&gt;
&lt;/xsl:analyze-string&gt;
</pre></div>
<p>Note the use of <code>normalize-space</code> to simplify the
work done by the regular expression, and the use of doubled curly
brackets because the <code>regex</code> attribute is an attribute
value template.</p>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e40374" id=
"d7e40374"></a>Example: Matching Zero-Length Strings</div>
<p>This example removes all empty and whitespace-only lines from a
file.</p>
<div class="exampleInner">
<pre>
&lt;xsl:analyze-string select="unparsed-text('in.txt')"
                    regex="^[\t ]*$" flags="m" expand-text="yes"&gt;
  &lt;xsl:non-matching-substring&gt;{.}&lt;/xsl:non-matching-substring&gt;
&lt;/xsl:analyze-string&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e40381" id=
"d7e40381"></a>Example: Parsing comma-separated values</div>
<p>There are many variants of CSV formats. This example is designed
to handle input where:</p>
<ul>
<li>
<p>Each record occupies one line.</p>
</li>
<li>
<p>Fields are separated by commas.</p>
</li>
<li>
<p>Quotation marks around a field are optional, unless the field
contains a comma or quotation mark, in which case they are
mandatory.</p>
</li>
<li>
<p>A quotation mark within the value of a field is represented by a
pair of two adjacent quotation marks.</p>
</li>
</ul>
<p>For example, the input record:</p>
<div class="exampleInner">
<pre>
Ten Thousand,10000,,"10,000","It's ""10 Grand"", mister",10K
</pre></div>
<p>contains six fields, specifically:</p>
<ul>
<li>
<p>Ten Thousand</p>
</li>
<li>
<p>10000</p>
</li>
<li>
<p>&lt;zero-length-string&gt;</p>
</li>
<li>
<p>10,000</p>
</li>
<li>
<p>It's "10 Grand", mister</p>
</li>
<li>
<p>10K</p>
</li>
</ul>
<p>The following code parses such CSV input into an XML structure
containing <code>row</code> and <code>col</code> elements:</p>
<div class="exampleInner">
<pre>
&lt;xsl:for-each select="unparsed-text-lines('in.csv')" expand-text="yes"&gt;
  &lt;row&gt;
    &lt;xsl:analyze-string select="." 
                        regex='(?:^|,)(?:"((?:[^"]|"")*)"|([^",]*))'&gt;
      &lt;xsl:matching-substring&gt;
        &lt;col&gt;{replace(regex-group(1), '""', '"')||regex-group(2)}&lt;/col&gt;
      &lt;/xsl:matching-substring&gt;
    &lt;/xsl:analyze-string&gt;
  &lt;/row&gt;
&lt;/xsl:for-each&gt;
</pre></div>
<p>Note that because this regular expression matches a zero-length
string, it is not permitted in XSLT 2.0.</p>
</div>
</div>
</div>
<div class="div1">
<h2><a name="streaming" id="streaming"></a>18 <a href="#streaming"
style="text-decoration: none">Streaming</a></h2>
<p>XSLT 3.0 introduces a number of constructs that are specifically
designed to enable streamed applications to be written, but which
are also useful in their own right; it also includes some features
that are very specialized to streaming. The constructs in this
latter category are described in this section.</p>
<div class="div2">
<h3><a name="stream-instruction" id="stream-instruction"></a>18.1
<a href="#stream-instruction" style="text-decoration: none">The</a>
<code>xsl:stream</code> <a href="#stream-instruction" style=
"text-decoration: none">Instruction</a></h3>
<p class="element-syntax"><a name="element-stream" id=
"element-stream"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:stream<br />
&#160;&#160;<b>href</b> = { <var>uri</var> }<br />
&#160;&#160;validation? = "strict" | "lax" | "preserve" |
"strip"<br />
&#160;&#160;type? = <var>eqname</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:stream&gt;</code></p>
<p>The <a href="#element-stream"><code>xsl:stream</code></a>
instruction reads a source document whose URI is supplied, and
processes the content of the document using streaming by evaluating
the contained <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>.</p>
<p>For example, if a document represents a book holding a sequence
of chapters, then the following code can be used to split the book
into multiple XML files, one per chapter, without allocating memory
to hold the entire book in memory at one time:</p>
<div class="exampleInner">
<pre>
&lt;xsl:stream href="book.xml"&gt;
  &lt;xsl:for-each select="book"&gt;             
    &lt;xsl:for-each select="chapter"&gt;
      &lt;xsl:result-document href="chapter{position()}.xml"&gt;
        &lt;xsl:copy-of select="."/&gt;
      &lt;/xsl:result-document&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:for-each&gt;  
&lt;/xsl:stream&gt;
</pre></div>
<p>The document to be read is determined by the <a title=
"effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the <code>href</code>
attribute (which is defined as an <a title=
"attribute value template" class="termref" href=
"#dt-attribute-value-template">attribute value template</a>).
<span>This <span class="verb">must</span> be a valid URI reference.
If it is an absolute URI reference, it is used as is; if it is a
relative URI reference, it is made absolute by resolving it against
the base URI of the <a href=
"#element-stream"><code>xsl:stream</code></a> element</span>. The
process of obtaining a document node given a URI is the same as for
the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>
function. However, unlike the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>
function, the <a href="#element-stream"><code>xsl:stream</code></a>
instruction offers no guarantee that the resulting document will be
stable (that is, that multiple calls specifying the same URI will
return the same document).</p>
<p>Specifically, if the <a href=
"#element-stream"><code>xsl:stream</code></a> instruction is
evaluated several times (or if different <a href=
"#element-stream"><code>xsl:stream</code></a> instructions are
evaluated) with the same URI (<span>after making it
absolute</span>) as the value of the <code>href</code> attribute,
it is <a title="implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a> whether
the same nodes or different nodes are returned on each occasion; it
is also possible that the actual document content will be
different.</p>
<p>The result of the <a href=
"#element-stream"><code>xsl:stream</code></a> instruction is the
same as the result of the following (non-streaming) process:</p>
<ol class="enumar">
<li>
<p>The source document is read from the supplied URI and parsed to
form an instance of the XDM data model. This is the <a title=
"streamed document" class="termref" href=
"#dt-streamed-document">streamed document</a>.</p>
</li>
<li>
<p>The contained sequence constructor is evaluated with the
<span>document</span> node of the <a title="streamed document"
class="termref" href="#dt-streamed-document">streamed document</a>
as the context item, and with the context position and context size
set to one, and the resulting sequence is returned as the result of
the <a href="#element-stream"><code>xsl:stream</code></a>
instruction.</p>
</li>
</ol>
<p>The <a href="#element-stream"><code>xsl:stream</code></a>
instruction is <a title="guaranteed-streamable" class="termref"
href="#dt-guaranteed-streamable">guaranteed-streamable</a> if the
contained <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> is <a title=
"grounded" class="termref" href="#dt-grounded">grounded</a>, as
assessed using the streamability analysis in <a href=
"#streamability"><i>19 Streamability</i></a>. The consequences of
being or not being guaranteed streamable depend on the processor
conformance level, and are explained in <a href=
"#streamability-guarantees"><i>19.10 Streamability
Guarantees</i></a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The name of the instruction reflects its intended usage, to
process an input document using streaming. However, a processor
that does not offer the <a title="streaming feature" class=
"termref" href="#dt-streaming-feature">streaming feature</a> must
still implement the instruction (without being required to use
streamed evaluation or to check its streamability); and processors
that do offer the <a title="streaming feature" class="termref"
href="#dt-streaming-feature">streaming feature</a> are also
required to provide a mode of execution in which the construct is
evaluated without streaming if it fails the streamability
criteria.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The rules for streamability ensure that the sequence constructor
(and therefore the <a href=
"#element-stream"><code>xsl:stream</code></a> instruction) cannot
return any nodes from the <a title="streamed document" class=
"termref" href="#dt-streamed-document">streamed document</a>. For
example, it cannot contain the instruction <code>&lt;xsl:sequence
select="//chapter"/&gt;</code>. If nodes from this document are to
be returned, they must first be copied, for example by <span>using
the <a href="#element-copy-of"><code>xsl:copy-of</code></a>
instruction or by</span> calling the <a href=
"#func-copy-of"><code>copy-of</code></a> or <a href=
"#func-snapshot"><code>snapshot</code></a> functions.</p>
<p>Because the <a href=
"#element-stream"><code>xsl:stream</code></a> instruction cannot
return nodes from the streamed document, any nodes it does return
will be conventional (unstreamed) nodes that can be processed
without restriction. For example, if <a href=
"#element-stream"><code>xsl:stream</code></a> is invoked within a
<a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet function</a>
<code>f:firstChapter</code>, and the sequence constructor consists
of the instruction <code>&lt;xsl:copy-of
select="//chapter"/&gt;</code>, then the calling code can
manipulate the resulting <code>chapter</code> elements as ordinary
trees rooted at parentless element nodes.</p>
</div>
<div class="div3">
<h4><a name="stream-validation" id="stream-validation"></a>18.1.1
<a href="#stream-validation" style=
"text-decoration: none">Validation of Streamed Documents</a></h4>
<p>The <code>validation</code> and <code>type</code> attributes of
<a href="#element-stream"><code>xsl:stream</code></a> may be used
to control schema validation of the <a title="streamed document"
class="termref" href="#dt-streamed-document">streamed document</a>.
They have the same effect as the corresponding attributes of the
<a href="#element-copy-of"><code>xsl:copy-of</code></a> instruction
when applied to a document node, except that the copy that is
produced is itself a streamed document. The process is described in
more detail in <a href="#validating-document-nodes"><i>24.4.2
Validating Document Nodes</i></a>.</p>
<p>These two attributes are both optional, and if one is specified
then the other <span class="verb">must</span> be omitted
(<span class="error">[see <a href="#err-XTSE1505">ERR
XTSE1505</a>]</span>).</p>
<p>The presence of a <code>validation</code> or <code>type</code>
attribute on an <a href=
"#element-stream"><code>xsl:stream</code></a> instruction causes
any <code>input-type-annotations</code> attribute to have no effect
on any document read using that instruction.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In effect, setting <code>validation</code> to
<code>strict</code> or <code>lax</code>, or supplying the
<code>type</code> attribute, requests document-level validation of
the input as it is read. Setting <code>validation="preserve"</code>
indicates that if the incoming document contains type annotations
(for example, produced by validating the output of a previous step
in a streaming pipeline) then they should be retained, while the
value <code>strip</code> indicates that any such type annotations
should be dropped.</p>
<p>It is a consequence of the way validation is defined in XSD that
the type annotation of an element node can be determined during the
processing of its start tag, although the actual validity of the
element is not known until the end tag is encountered. When
validation is requested, a streamed document should not present
data to the stylesheet except to the extent that such data could
form the leading part of a valid document. If the document proves
to be invalid, the processor should not pass invalid data to the
stylesheet to be processed, but should immediately signal the
appropriate error. For the purposes of <a href=
"#element-try"><code>xsl:try</code></a> and <a href=
"#element-catch"><code>xsl:catch</code></a>, this error can only be
caught at the level of the <a href=
"#element-stream"><code>xsl:stream</code></a> instruction that
initiated validation, not at a finer level. If validation errors
are caught in this way, any output that has been computed up to the
point of the error is not added to the final result tree; the
mechanisms to achieve this may use memory, which may reduce the
efficacy of streaming.</p>
<p>The analysis of guaranteed streamability (see <a href=
"#streamability"><i>19 Streamability</i></a>) takes no account of
information that might be obtained from a schema-aware static
analysis of the stylesheet. Implementations may, however, be able
to use streaming strategies for stylesheets that are not
guaranteed-streamable, by taking advantage of such information. For
example, an implementation might be able to treat the expression
<code>.//title</code> as <a title="striding" class="termref" href=
"#dt-striding">striding</a> rather than <a title="crawling" class=
"termref" href="#dt-crawling">crawling</a> if it can establish from
knowledge of the schema that two <code>title</code> elements will
never <span>be nested one inside the other</span>.</p>
</div>
</div>
<div class="div3">
<h4><a name="stream-examples" id="stream-examples"></a>18.1.2
<a href="#stream-examples" style="text-decoration: none">Examples
of</a> <code>xsl:stream</code></h4>
<p>The <a href="#element-stream"><code>xsl:stream</code></a>
instruction can be used to initiate processing of a document using
streaming with a variety of coding styles, illustrated in the
examples below.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e40720" id=
"d7e40720"></a>Example: Using <a href=
"#element-stream"><code>xsl:stream</code></a> with Aggregate
Functions</div>
<p>The following example computes the number of transactions in a
transaction file</p>
<p>Input:</p>
<div class="exampleInner">
<pre>
&lt;transactions&gt;
  &lt;transaction value="12.51"/&gt;
  &lt;transaction value="3.99"/&gt;
&lt;/transactions&gt;
</pre></div>
<p>Stylesheet code:</p>
<div class="exampleInner">
<pre>
&lt;xsl:stream href="transactions.xml"&gt;
  &lt;count&gt;
    &lt;xsl:value-of select="count(transactions/transaction)"/&gt;
  &lt;/count&gt;
&lt;/xsl:stream&gt;
</pre></div>
<p>Result:</p>
<div class="exampleInner">
<pre>
&lt;count&gt;2&lt;/count&gt;
</pre></div>
<p>Analysis:</p>
<ol class="enumar">
<li>
<p>The literal result element <code>count</code> has the same sweep
as the <a href="#element-value-of"><code>xsl:value-of</code></a>
instruction.</p>
</li>
<li>
<p>The <a href="#element-value-of"><code>xsl:value-of</code></a>
instruction has the same sweep as its <code>select</code>
expression.</p>
</li>
<li>
<p>The call to <code>count</code> has the same sweep as its
argument.</p>
</li>
<li>
<p>The argument to <code>count</code> is a
<code>RelativePathExpr</code> that takes the form of a motionless
pattern and appears in an inspection context (the argument to
<code>count()</code>); the sweep of the
<code>RelativePathExpr</code> and therefore of the entire body of
the <code>xsl:stream</code> instruction is therefore <a title=
"consuming" class="termref" href="#dt-consuming">consuming</a>.</p>
</li>
</ol>
<p>The following example computes the highest-value transaction in
the same input file:</p>
<div class="exampleInner">
<pre>
&lt;xsl:stream href="transactions.xml"&gt;
  &lt;maxValue&gt;
    &lt;xsl:value-of select="max(transactions/transaction/@value)"/&gt;
  &lt;/maxValue&gt;
&lt;/xsl:stream&gt;
</pre></div>
<p>Result:</p>
<div class="exampleInner">
<pre>
&lt;maxValue&gt;12.51&lt;/maxValue&gt;
</pre></div>
<p>Analysis:</p>
<ol class="enumar">
<li>
<p>The literal result element <code>maxValue</code> has the same
sweep as the <a href=
"#element-value-of"><code>xsl:value-of</code></a> instruction.</p>
</li>
<li>
<p>The <a href="#element-value-of"><code>xsl:value-of</code></a>
instruction has the same sweep as its <code>select</code>
expression.</p>
</li>
<li>
<p>The call to <code>max</code> has the same sweep as its
argument.</p>
</li>
<li>
<p>The argument to <code>max</code> is a
<code>RelativePathExpr</code> whose two operands are the
<code>RelativePathExpr</code> <code>transactions/transaction</code>
and the <code>AxisStep</code> <code>@value</code>. The
<span>left-hand</span> operand
<code>transactions/transaction</code> has <span><a title="striding"
class="termref" href="#dt-striding">striding</a> <a title="posture"
class="termref" href="#dt-posture">posture</a></span>. The
<span>right-hand</span> operand <code>@value</code>, given that it
appears in a node value context, is <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>. The
<code>RelativePathExpr</code> argument to <code>max</code> is
therefore consuming.</p>
</li>
<li>
<p>The entire body of the <code>xsl:stream</code> instruction is
therefore <a title="consuming" class="termref" href=
"#dt-consuming">consuming</a>.</p>
</li>
</ol>
<p>To compute both the count and the maximum value in a single pass
over the input, it is possible to use two variables.</p>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e40882" id=
"d7e40882"></a>Example: Using <a href=
"#element-stream"><code>xsl:stream</code></a> with <a href=
"#element-for-each"><code>xsl:for-each</code></a> to Process a
Collection of Input Documents</div>
<p>This example displays a list of the chapter titles extracted
from each book in a collection of books.</p>
<p>Each input document is assumed to have a structure such as:</p>
<div class="exampleInner">
<pre>
&lt;book&gt;
  &lt;chapter number-of-pages="18"&gt;
    &lt;title&gt;The first chapter of book A&lt;/title&gt;
    ...
  &lt;/chapter&gt;
  &lt;chapter number-of-pages="15"&gt;
    &lt;title&gt;The second chapter of book A&lt;/title&gt;
    ...
  &lt;/chapter&gt;
  &lt;chapter number-of-pages="12"&gt;
    &lt;title&gt;The third chapter of book A&lt;/title&gt;
    ...
  &lt;/chapter&gt;
&lt;/book&gt;
</pre></div>
<p>Stylesheet code:</p>
<div class="exampleInner">
<pre>
&lt;chapter-titles&gt;
  &lt;xsl:for-each select="uri-collection('books')"&gt;
    &lt;xsl:stream href="{.}"&gt;
      &lt;xsl:for-each select="book"&gt;
        &lt;xsl:for-each select="chapter"&gt;
           &lt;title&gt;&lt;xsl:value-of select="title"/&gt;&lt;/title&gt;
        &lt;/xsl:for-each&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:stream&gt;
  &lt;/xsl:for-each&gt;
&lt;/chapter-titles&gt;
</pre></div>
<p>Output:</p>
<div class="exampleInner">
<pre>
&lt;chapter-titles&gt;
  &lt;title&gt;The first chapter of book A&lt;/title&gt;
  &lt;title&gt;The second chapter of book A&lt;/title&gt;
  ...
  &lt;title&gt;The first chapter of book B&lt;/title&gt;
  ...
&lt;/chapter-titles&gt;
</pre></div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This example uses the function <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-uri-collection"><code>
uri-collection</code></a><sup><small>FO30</small></sup> to obtain
the document URIs of all the documents in a collection, so that
each one can be processed in turn using <a href=
"#element-stream"><code>xsl:stream</code></a>.</p>
</div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e40914" id=
"d7e40914"></a>Example: Using <a href=
"#element-stream"><code>xsl:stream</code></a> with <a href=
"#element-iterate"><code>xsl:iterate</code></a></div>
<p>This example assumes that the input is a book with multiple
chapters, as shown in the previous example, with the page count for
each chapter given as an attribute of the chapter. The
transformation determines the starting page number for each chapter
by accumulating the page counts for previous chapters, and rounding
up to an odd number if necessary.</p>
<div class="exampleInner">
<pre>
&lt;chapter-start-page&gt;
   &lt;xsl:stream href="book.xml"&gt;
      &lt;xsl:iterate select="book/chapter"&gt;
         &lt;xsl:param name="start-page" select="1"/&gt;
         &lt;chapter title="{title}" start-page="{$start-page}"/&gt;
         &lt;xsl:next-iteration&gt;
            &lt;xsl:with-param name="start-page" 
                            select="$start-page + @number-of-pages + 
                                      (@number-of-pages mod 2)"/&gt;
         &lt;/xsl:next-iteration&gt;
      &lt;/xsl:iterate&gt;
   &lt;/xsl:stream&gt;
&lt;/chapter-start-page&gt;
</pre></div>
<p>Output:</p>
<div class="exampleInner">
<pre>
&lt;chapter-start-page&gt;
  &lt;chapter title="The first chapter of book A" start-page="1"/&gt;
  &lt;chapter title="The second chapter of book A" start-page="19"/&gt;
  &lt;chapter title="The third chapter of book A" start-page="35"/&gt;
  ...
&lt;/chapter-start-page&gt;
                     
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e40931" id=
"d7e40931"></a>Example: Using <a href=
"#element-stream"><code>xsl:stream</code></a> with <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a></div>
<p>This example assumes that the input is a book with multiple
chapters, and that each chapter belongs to a part, which is present
as an attribute of the chapter (for example, chapters 1-4 might
constitute Part 1, the next three chapters forming Part 2, and so
on):</p>
<div class="exampleInner">
<pre>
&lt;book&gt;
  &lt;chapter part="1"&gt;
    &lt;title&gt;The first chapter of book A&lt;/title&gt;
    ...
  &lt;/chapter&gt;
  &lt;chapter part="1"&gt;
    &lt;title&gt;The second chapter of book A&lt;/title&gt;
    ...
  &lt;/chapter&gt;
  ...
  &lt;chapter part="2"&gt;
    &lt;title&gt;The fifth chapter of book A&lt;/title&gt;
    ...
  &lt;/chapter&gt;
&lt;/book&gt;
</pre></div>
<p>The transformation copies the full text of the chapters,
creating an extra level of hierarchy for the parts.</p>
<div class="exampleInner">
<pre>
&lt;book&gt;
   &lt;xsl:stream href="book.xml"&gt;
      &lt;xsl:for-each select="book"&gt;
         &lt;xsl:for-each-group select="chapter" group-adjacent="data(@part)"&gt;
            &lt;part number="{current-grouping-key()}"&gt;
               &lt;xsl:copy-of select="current-group()"/&gt;
            &lt;/part&gt;
         &lt;/xsl:for-each-group&gt;
      &lt;/xsl:for-each&gt;
   &lt;/xsl:stream&gt;
&lt;/book&gt;
</pre></div>
<p>Output:</p>
<div class="exampleInner">
<pre>
&lt;book&gt;
  &lt;part number="1"&gt;
    &lt;chapter title="The first chapter of book A" part="1"&gt;
      ...
    &lt;/chapter&gt;
    &lt;chapter title="The second chapter of book A" part="1"&gt;
      ...
    &lt;/chapter&gt;
    ...
  &lt;/part&gt;
  &lt;part number="2"&gt;
    &lt;chapter title="The fifth chapter of book A" part="2"&gt;
    ...
    &lt;/chapter&gt;
    ...
  &lt;/part&gt;
&lt;/book&gt;
    
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e40952" id=
"d7e40952"></a>Example: Using <a href=
"#element-stream"><code>xsl:stream</code></a> with <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a></div>
<p>This example copies an XML document while deleting all the
<code>ednote</code> elements at any level of the tree, together
with their descendants. This example is a complete stylesheet,
which is intended to be evaluated by nominating <code>main</code>
as the <a title="initial named template" class="termref" href=
"#dt-initial-named-template">initial named template</a>. The use of
<code>on-no-match="deep-copy"</code> in the <a href=
"#element-mode"><code>xsl:mode</code></a> declaration means that
the built-in template rule copies nodes unchanged, except where
overridden by a user-defined template rule.</p>
<div class="exampleInner">
<pre>
&lt;xsl:transform version="3.0" 
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:mode name="delete-ednotes" streamable="yes" 
                                on-no-match="shallow-copy"/&gt;

&lt;xsl:template name="main"&gt;
   &lt;xsl:stream href="book.xml"&gt;
      &lt;xsl:apply-templates mode="delete-ednotes"/&gt;
   &lt;/xsl:stream&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="ednote" mode="delete-ednotes"/&gt;

&lt;/xsl:transform&gt;
</pre></div>
<p>Additional template rules could be added to process other
elements and attributes in the same pass through the data: for
example, to modify the value of a <code>last-updated</code>
attribute (wherever it appears) to the current date and time, the
following rule suffices:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="@last-updated"&gt;
  &lt;xsl:attribute name="last-updated" select="current-dateTime()"/&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
</div>
<div class="div3">
<h4><a name="func-stream-available" id=
"func-stream-available"></a>18.1.3 <a href="#func-stream-available"
style="text-decoration: none">fn:stream-available</a></h4>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Determines, as far as possible, whether a document is available
for streamed processing using <a href=
"#element-stream"><code>xsl:stream</code></a>.</p>
</dd>
<dt class="label">Signature</dt>
<dd>
<p><a name="function-stream-available" id=
"function-stream-available"></a></p>
<div class="proto"><code class=
"function">stream-available</code>(<code class=
"arg">$uri</code><code class="as">&#160;as&#160;</code><code class=
"type">xs:string?</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">xs:boolean</code></div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-nondeterministic">nondeterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>.
It depends on available documents.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>The intent of the <a href=
"#func-stream-available"><code>stream-available</code></a> is to
allow a stylesheet author to determine, before calling <a href=
"#element-stream"><code>xsl:stream</code></a> with a particular URI
as the value of its <code>href</code> attribute, whether a document
is available at that location for streamed processing.</p>
<p>If the <code>$uri</code> argument is an empty sequence then the
function returns <code>false</code>.</p>
<p>If the function returns <code>true</code> then the caller can
conclude that the following conditions are true:</p>
<ol class="enumar">
<li>
<p>The supplied URI is valid;</p>
</li>
<li>
<p>A resource can be retrieved at that URI;</p>
</li>
<li>
<p>An XML representation of the resource can be delivered, which is
well-formed at least to the extent that some initial sequence of
octets can be decoded into characters and matched against the
production:</p>
<p><code>prolog (EmptyElemTag | STag )</code></p>
<p>as defined in the XML 1.0 or XML 1.1 Recommendation.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
That is, the XML is well-formed at least as far as the end of the
first element start tag; to establish this, a parser will typically
retrieve any external entities referenced in the Doctype
declaration or DTD.</div>
</li>
</ol>
<p>If the function returns <code>false</code>, the caller can
conclude that either one of the above conditions is not satisfied,
or the processor detected some other condition that would prevent a
call on <a href="#element-stream"><code>xsl:stream</code></a>
executing successfully.</p>
<p>Like <a href="#element-stream"><code>xsl:stream</code></a>
itself, the function is not deterministic, which means that
multiple calls during the execution of a stylesheet will not
necessarily return the same result. The caller cannot make any
inferences about the point in time at which the input conditions
for <a href=
"#func-stream-available"><code>stream-available</code></a> are
present, and in particular there is no guarantee that because
<a href="#func-stream-available"><code>stream-available</code></a>
returns true, <a href="#element-stream"><code>xsl:stream</code></a>
will necessarily succeed.</p>
<p>The value of the <code>$uri</code> argument <span class=
"verb">must</span> be a URI in the form of a string. If it is a
relative URI, it is resolved relative to the static base URI of the
containing stylesheet element.</p>
</dd>
<dt class="label">Error Conditions</dt>
<dd>
<p>If the URI is invalid, such that a call on <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc-available"><code>
doc-available</code></a><sup><small>FO30</small></sup> would signal
an error, then <a href=
"#func-stream-available"><code>stream-available</code></a> signals
the same error: <a href=
"http://www.w3.org/TR/xpath-functions-30/#ERRFODC0005" title=
"FODC0005"><span class="error">[ERR FODC0005]</span></a>
<sup><small>FO30</small></sup>.</p>
</dd>
</dl>
</div>
</div>
<div class="div2">
<h3><a name="accumulators" id="accumulators"></a>18.2 <a href=
"#accumulators" style="text-decoration: none">Accumulators</a></h3>
<p>Accumulators are introduced in XSLT 3.0 to enable data that is
read during streamed processing of a document to be accumulated,
processed or retained for later use. However, they may equally be
used with non-streamed processing.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-accumulator" id="dt-accumulator" title="accumulator"></a>An
<b>accumulator</b> defines a value that is computed progressively
while processing the nodes of a <span>tree</span> in document
order. The value for a given node is available via a pair of
functions, one giving the value for a node before processing its
descendants, and one giving the value for the same node after
processing its descendants.<span class="definition">]</span></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Accumulators can apply to trees rooted at any kind of node,
other than attribute and namespace nodes. But because they are most
often applied to trees rooted at a document node, this section
sometimes refers to the "document" to which an accumulator applies;
use of this term should be taken to include all trees whether or
not they are rooted at a document node.</p>
</div>
<p>The following sections give first, the syntax rules for defining
an accumulator; then an informal description of the semantics; then
a more formal definition; and finally, examples. But to illustrate
the concept intuitively, the following simple example shows how an
accumulator can be used for numbering of nodes:</p>
<div class="example">
<div class="exampleHeader"><a name="d7e41130" id=
"d7e41130"></a>Example: Numbering Figures within a Chapter</div>
<p>This example assumes document input in which <code>figure</code>
elements can appear within <code>chapter</code> elements (which we
assume are not nested), and the requirement is to render the
figures with a caption that includes the figure number within its
containing chapter.</p>
<p>When the document is processed using streaming, the <a href=
"#element-number"><code>xsl:number</code></a> instruction is not
available, so a solution using accumulators is needed.</p>
<p>The required accumulator can be defined and used like this:</p>
<div class="exampleInner">
<pre>
   &lt;xsl:accumulator name="figNr" as="xs:integer" 
                    initial-value="0" streamable="yes"&gt;
     &lt;xsl:accumulator-rule match="chapter" select="0"/&gt;
     &lt;xsl:accumulator-rule match="figure" select="$value + 1"/&gt;
   &lt;/xsl:accumulator&gt;
   
   &lt;xsl:mode streamable="yes"/&gt;
   &lt;xsl:template match="figure"&gt;
     &lt;xsl:apply-templates/&gt;
     &lt;p&gt;Figure &lt;xsl:value-of select="accumulator-before('figNr')"/&gt;&lt;/p&gt;
   &lt;/xsl:template&gt;  
                  
</pre></div>
</div>
<div class="div3">
<h4><a name="accumulator-declaration" id=
"accumulator-declaration"></a>18.2.1 <a href=
"#accumulator-declaration" style="text-decoration: none">Declaring
an Accumulator</a></h4>
<p class="element-syntax"><a name="element-accumulator" id=
"element-accumulator"></a><code>&lt;!-- Category: declaration
--&gt;<br />
&lt;xsl:accumulator<br />
&#160;&#160;<b>name</b> = <var>eqname</var><br />
&#160;&#160;applies-to? = <var>pattern</var><br />
&#160;&#160;<b>initial-value</b> = <var>expression</var><br />
&#160;&#160;as? = <var>sequence-type</var><br />
&#160;&#160;visibility? = "public" | "private" | "final" |
"abstract"<br />
&#160;&#160;streamable? = <var>boolean</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <a href=
"#element-accumulator-rule">xsl:accumulator-rule</a>+ --&gt;<br />
&lt;/xsl:accumulator&gt;</code></p>
<p class="element-syntax"><a name="element-accumulator-rule" id=
"element-accumulator-rule"></a><code>&lt;xsl:accumulator-rule<br />
&#160;&#160;<b>match</b> = <var>pattern</var><br />
&#160;&#160;phase? = "start" | "end"<br />
&#160;&#160;select? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:accumulator-rule&gt;</code></p>
<p>An <a href=
"#element-accumulator"><code>xsl:accumulator</code></a> element is
a <a title="declaration" class="termref" href=
"#dt-declaration">declaration</a> of an accumulator. The
<code>name</code> attribute defines the name of the accumulator.
The value of the <code>name</code> attribute is an <a title=
"EQName" class="termref" href="#dt-eqname">EQName</a>, which is
expanded as described in <a href="#qname"><i>5.1 Qualified
Names</i></a>.</p>
<p>An <a href=
"#element-accumulator"><code>xsl:accumulator</code></a> declaration
can only appear as a <a title="top-level" class="termref" href=
"#dt-top-level">top-level</a> element in a stylesheet module.</p>
<p>The <span>functions <a href=
"#func-accumulator-before"><code>accumulator-before</code></a> and
<a href=
"#func-accumulator-after"><code>accumulator-after</code></a></span>
return, respectively, the value of the accumulator before visiting
the descendants of a given node, and the value after visiting the
descendants of a node. Each of these functions <span>takes a single
argument, the name of the accumulator</span>, and the function
applies implicitly to the context node. The type of the return
value (for both functions) is determined by the <code>as</code>
attribute of the <a href=
"#element-accumulator"><code>xsl:accumulator</code></a>
element.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-accumulator-function" id="dt-accumulator-function" title=
"accumulator function"></a>The functions <a href=
"#func-accumulator-before"><code>accumulator-before</code></a> and
<a href=
"#func-accumulator-after"><code>accumulator-after</code></a> are
referred to as the <b>accumulator functions</b>.<span class=
"definition">]</span></p>
<p>When streaming, the <a href=
"#func-accumulator-before"><code>accumulator-before</code></a>
function for a streamed node can be called at any time the node is
available (it behaves like other properties of the node such as
<a href=
"http://www.w3.org/TR/xpath-functions-30/#func-name"><code>name</code></a><sup><small>FO30</small></sup>
or <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-base-uri"><code>base-uri</code></a><sup><small>FO30</small></sup>).
The <a href=
"#func-accumulator-after"><code>accumulator-after</code></a>
function, however, is restricted by virtue of the streamability
rules to appear after any instruction that reads the descendants of
the node in question. The constraints are expressed as static
rules: see <a href=
"#streamability-fn-accumulator-after"><i>19.8.8.1 Streamability of
the accumulator-after function</i></a> for more details.</p>
<p>If the <code>applies-to</code> attribute is present on the
<a href="#element-accumulator"><code>xsl:accumulator</code></a>
declaration then accumulator rules are applied to a particular node
only if the node has an ancestor-or-self that matches the pattern
supplied in the <code>applies-to</code> attribute.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The <code>applies-to</code> attribute can effectively be used to
enable or disable processing of an accumulator for a particular
document. This is particularly useful for streamed documents, since
it may avoid the cost of evaluating accumulator rules
unnecessarily, and avoid the risk that evaluating accumulator rules
could cause dynamic errors if applied to documents for which they
were not designed. It is not an error to call the <a href=
"#func-accumulator-before"><code>accumulator-before</code></a> or
<a href=
"#func-accumulator-after"><code>accumulator-after</code></a>
functions on a document to which the accumulator does not apply,
but if there is no node in the document that matches the
<code>applies-to</code> pattern, then the accumulator will always
take its initial value.</p>
<p>Use of a pattern that can only match a document node or the
outermost element node (for example, <code>/x:html</code>, or
<code>document-node(element(x:html))</code> may be more efficient
than using a pattern that could match anywhere within a
document.</p>
<p>When streaming, the <code>applies-to</code> pattern must be
motionless. Note that a pattern of the form
<code>document-node(element(fpml))</code> is classified as
motionless even though it involves a small amount of
look-ahead.</p>
</div>
<p>The initial value of the accumulator is obtained by evaluating
the expression in the <code>initial-value</code> attribute. The
expression in the <code>initial-value</code> attribute is evaluated
with <span>a <a title="singleton focus" class="termref" href=
"#dt-singleton-focus">singleton focus</a> based on the root node of
the streamed input tree to which the accumulator is being
applied.</span></p>
<p>The values of the accumulator for individual nodes in a tree are
obtained by applying the <a href=
"#element-accumulator-rule"><code>xsl:accumulator-rule</code></a>
rules contained within the <a href=
"#element-accumulator"><code>xsl:accumulator</code></a>
declaration, as described in subsequent sections. <span>The
<code>match</code> attribute of <a href=
"#element-accumulator-rule"><code>xsl:accumulator-rule</code></a>
is a <a title="pattern" class="termref" href=
"#dt-pattern">pattern</a> which determines which nodes trigger
execution of the rule; the <code>phase</code> attribute indicates
whether the rule fires before descendants are processed
(<code>phase="start"</code>, which is the default), or after
descendants are processed (<code>phase="end"</code>).</span></p>
<p>The <code>select</code> attribute and the contained sequence
constructor of the <a href=
"#element-accumulator-rule"><code>xsl:accumulator-rule</code></a>
element are mutually exclusive: if the <code>select</code>
attribute is present then the sequence constructor must be empty.
The expression in the <code>select</code> attribute of <a href=
"#element-accumulator-rule"><code>xsl:accumulator-rule</code></a>
<span>or the contained sequence constructor</span> is evaluated
with a static context that follows the normal rules for expressions
in stylesheets, except that:</p>
<ul>
<li>
<p>An additional variable is present in the context. The name of
this variable is <code>value</code> (in no namespace), and its type
is the type that appears in the <code>as</code> attribute of the
<a href="#element-accumulator"><code>xsl:accumulator</code></a>
declaration.</p>
</li>
<li>
<p>The context item for evaluation of the expression <span>or
sequence constructor</span> will always be a node that matches the
<a title="pattern" class="termref" href="#dt-pattern">pattern</a>
in the <code>match</code> attribute.</p>
</li>
</ul>
<p>The result of both the <code>initial-value</code> and
<span><code>select</code> expressions (or contained sequence
constructor)</span> is converted to the type declared in the
<code>as</code> attribute by applying the <a title=
"function conversion rules" class="termref" href=
"#dt-function-conversion-rules">function conversion rules</a>. A
<a title="type error" class="termref" href="#dt-type-error">type
error</a> occurs if conversion is not possible. The <code>as</code>
attribute defaults to <code>item()*</code>.</p>
<p>The effect of the <code>streamable</code> attribute is defined
in <a href="#streamability-of-accumulators"><i>18.2.7 Streamability
of Accumulators</i></a>.</p>
</div>
<div class="div3">
<h4><a name="accumulator-informal-rules" id=
"accumulator-informal-rules"></a>18.2.2 <a href=
"#accumulator-informal-rules" style=
"text-decoration: none">Informal Model for Accumulators</a></h4>
<p>Informally, an accumulator is evaluated by traversing a
<span>tree</span> in tree-walking order. Each node is visited
twice, once before processing its descendants, and once after
processing its descendants. For consistency, this applies even to
leaf nodes: each is visited twice. Attribute and namespace nodes,
however, are not visited.</p>
<p>Before the traversal starts, a variable (called the accumulator
variable) is initialized to the value of the expression given as
the <code>initial-value</code> attribute.</p>
<p>On each node visit, the <a href=
"#element-accumulator-rule"><code>xsl:accumulator-rule</code></a>
elements are examined to see if there is a matching rule. For a
match to occur, the pattern in the <code>match</code> attribute
must match the node, and the <code>phase</code> attribute must be
<code>start</code> if this is the first visit, and <code>end</code>
if it is the second visit. If there is a matching rule, then a new
value is computed for the accumulator variable using the expression
contained in that rule's <span><code>select</code> attribute or the
contained sequence constructor</span>. If there is more than one
matching rule, the last in document order is used. If there is no
matching rule, the value of the accumulator variable does not
change.</p>
<p>Each node is labeled with a pre-descent value for the
accumulator, which is the value of the accumulator variable
immediately <em>after</em> processing the first visit to that node,
and with a post-descent value for the accumulator, which is the
value of the accumulator variable immediately
<span><em>after</em></span> processing the second visit.</p>
<p>The function <a href=
"#func-accumulator-before"><code>accumulator-before</code></a>
delivers the pre-descent value of the accumulator at the context
node; the function <a href=
"#func-accumulator-after"><code>accumulator-after</code></a>
delivers the post-descent value of the accumulator at the context
node.</p>
<p>Although this description is expressed in procedural terms, it
can be seen that the two values of the accumulator for any given
node depend only on the node and its preceding and (in the case of
the post-descent value) descendant nodes. Calculation of both
values is therefore deterministic and free of side-effects;
moreover, it is clear that the values can be computed during a
streaming pass of a document, provided that the rules themselves
use only information that is available without repositioning the
input stream.</p>
<p>It is permitted for the <span><code>select</code> expression of
an accumulator rule, or the contained sequence constructor</span>,
to invoke an accumulator function. <span>For a streamable
accumulator, the rules ensure that a rule with
<code>phase="start"</code> cannot call the <a href=
"#func-accumulator-after"><code>accumulator-after</code></a>
function. When such function calls exist in an accumulator rule,
they impose a dependency of one accumulator on another, and create
the possibility of cyclic dependencies. Processors are allowed to
report the error statically if they can detect it statically.
Failing this, processors are allowed to fail catastrophically in
the event of a cycle, in the same way as they might fail in the
event of infinite function or template recursion. Catastrophic
failure might manifest itself, for example, as a stack overflow, or
as non-termination of the transformation.</span></p>
</div>
<div class="div3">
<h4><a name="accumulator-formal-rules" id=
"accumulator-formal-rules"></a>18.2.3 <a href=
"#accumulator-formal-rules" style="text-decoration: none">Formal
Model for Accumulators</a></h4>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-traversal" id="dt-traversal" title="traversal"></a>A
<b>traversal</b> of a tree is a sequence of <a title=
"traversal-event" class="termref" href=
"#dt-traversal-event">traversal events</a>.<span class=
"definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-traversal-event" id="dt-traversal-event" title=
"traversal-event"></a>a <b>traversal event</b> (shortened to
<b>event</b> in this section) is a pair comprising a phase (start
or end) and a node.<span class="definition">]</span> It is modelled
as a map with two entries: <code>map{"phase": p, "node": n}</code>
where p is the string <code>"start"</code> or <code>"end"</code>
and <code>n</code> is a node.</p>
<p>The traversal of a <span>tree</span> contains two traversal
events for each node in the tree, other than attribute and
namespace nodes. One of these events (the "start event") has phase
= "start", the other (the "end event") has phase = "end".</p>
<p>The order of traversal events within a traversal is such that,
given any two nodes <var>M</var> and <var>N</var> with start/end
events denoted by <var>M0</var>, <var>M1</var>, <var>N0</var>, and
<var>N1</var>, :</p>
<ul>
<li>
<p>For any node <var>N</var>, <var>N0</var> precedes
<var>N1</var>;</p>
</li>
<li>
<p>If <var>M</var> is an ancestor of <var>N</var> then
<var>M0</var> precedes <var>N0</var> and <var>N1</var> precedes
<var>M1</var>;</p>
</li>
<li>
<p>If <var>M</var> is on the preceding axis of <var>N</var> then
<var>M1</var> precedes <var>N0</var>.</p>
</li>
</ul>
<p>The accumulator defines a (private) delta function <var>Δ</var>.
The delta function computes the value of the accumulator for one
traversal event in terms of its value for the previous traversal
event. The function is defined as follows:</p>
<ol class="enumar">
<li>
<p>The signature of <var>Δ</var> is <code>function ($old-value as
T, $event as map(*)) as T</code>, where <var>T</var> is the
sequence type declared in the <code>as</code> attribute of the
accumulator declaration;</p>
</li>
<li>
<p>The implementation of the function is equivalent to the
following algorithm:</p>
<ol class="enumla">
<li>
<p>Let <var>R</var> be the set of <a href=
"#element-accumulator-rule"><code>xsl:accumulator-rule</code></a>
elements among the children of the accumulator declaration whose
<code>phase</code> attribute equals <code>$event("phase")</code>
and whose <code>match</code> attribute is a <a title="pattern"
class="termref" href="#dt-pattern">pattern</a> that matches
<code>$event("node")</code></p>
</li>
<li>
<p>If <var>R</var> is empty, return <code>$old-value</code></p>
</li>
<li>
<p>Let <var>Q</var> be the <a href=
"#element-accumulator-rule"><code>xsl:accumulator-rule</code></a>
in <var>R</var> that is last in document order</p>
</li>
<li>
<p>Return the value of the expression in the <code>select</code>
attribute of <code>Q</code>, <span>or the contained sequence
constructor,</span> evaluating this with a <a title=
"singleton focus" class="termref" href=
"#dt-singleton-focus">singleton focus</a> set to
<code>$event("node")</code> and with a dynamic context that binds
the variable whose name is <span><code>$value</code> (in no
namespace)</span> to the value <code>$old-value</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The argument names <code>old-value</code> and <code>event</code>
are used here purely for definitional purposes; these names are not
available for use within the <span><code>select</code> expression
or contained sequence constructor</span>.</p>
</div>
</li>
</ol>
</li>
</ol>
<p>For every node <var>N</var>, other than attribute and namespace
nodes, the accumulator defines a pre-descent value <var>B(N)</var>
and a post-descent value <var>A(N)</var> whose values are as
follows:</p>
<ol class="enumar">
<li>
<p>Let <var>T</var> be the <a title="traversal" class="termref"
href="#dt-traversal">traversal</a> of the tree rooted at
<code>fn:root(N)</code>.</p>
</li>
<li>
<p>Let <var>SB</var> be the subsequence of <var>T</var> starting at
the first event in <var>T</var> and ending with the start event for
node <var>N</var> (that is, the event <code>map{ "phase":"start",
"node":N }</code>).</p>
</li>
<li>
<p>Let <var>SA</var> be the subsequence of <var>T</var> starting at
the first event in <var>T</var>, and ending with the end event for
node <var>N</var> (that is, the event <code>map{ "phase":"end",
"node":N }</code>).</p>
</li>
<li>
<p>Let <var>Z</var> be the result of evaluating the expression
contained in the <code>initial-value</code> attribute of the
<a href="#element-accumulator"><code>xsl:accumulator</code></a>
declaration, <span>evaluated with a <a title="singleton focus"
class="termref" href="#dt-singleton-focus">singleton focus</a>
based on <code>root(N)</code></span>.</p>
</li>
<li>
<p>Then the pre-descent value <var>B(N)</var> is the value of
<code>fn:fold-left(SB, Z, Δ)</code>, and the post-descent value
<var>A(N)</var> is the value of <code>fn:fold-left(SA, Z,
Δ)</code>.</p>
</li>
</ol>
</div>
<div class="div3">
<h4><a name="func-accumulator-before" id=
"func-accumulator-before"></a>18.2.4 <a href=
"#func-accumulator-before" style=
"text-decoration: none">fn:accumulator-before</a></h4>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Returns the pre-descent value of the selected accumulator at the
context node</p>
</dd>
<dt class="label">Signature</dt>
<dd>
<p><a name="function-accumulator-before" id=
"function-accumulator-before"></a></p>
<div class="proto"><code class=
"function">accumulator-before</code>(<code class=
"arg">$name</code><code class=
"as">&#160;as&#160;</code><code class="type">xs:string</code>)<code class="as">&#160;as&#160;</code><code class="return-type">item()*</code></div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-dependent">focus-dependent</a><sup><small>FO30</small></sup>.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>The <code>$name</code> argument specifies the name of the
<a title="accumulator" class="termref" href=
"#dt-accumulator">accumulator</a>. The value of the argument
<span class="verb">must</span> be a <span>string containing an
<a title="EQName" class="termref" href=
"#dt-eqname">EQName</a>.</span> If it is a <a title="lexical QName"
class="termref" href="#dt-lexical-qname">lexical QName</a>, then it
is expanded as described in <a href="#qname"><i>5.1 Qualified
Names</i></a> (no prefix means no namespace).</p>
<p>The function returns the pre-descent value <var>B(N)</var>of the
selected accumulator where <var>N</var> is the context node, as
defined in <a href="#accumulator-formal-rules"><i>18.2.3 Formal
Model for Accumulators</i></a></p>
<p>If the context item is a node in a streamed document, then the
accumulator must be declared with
<code>streamable="yes"</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The converse is not true: an accumulator declared to be
streamable is available on both streamed and unstreamed nodes.</p>
</div>
</dd>
<dt class="label">Error Conditions</dt>
<dd>
<p><a name="err-XTDE3340" id="err-XTDE3340"><span class=
"error">[ERR XTDE3340]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
value of the first argument to the <a href=
"#func-accumulator-before"><code>accumulator-before</code></a> or
<a href=
"#func-accumulator-after"><code>accumulator-after</code></a>
function is not a valid <a title="EQName" class="termref" href=
"#dt-eqname">EQName</a>, or if there is no namespace declaration in
scope for the prefix of the QName, or if the name obtained by
expanding the QName is not the same as the expanded name of any
<a href="#element-accumulator"><code>xsl:accumulator</code></a>
declaration visible in the <a title="package" class="termref" href=
"#dt-package">package</a> in which the function call appears. If
the processor is able to detect the error statically (for example,
when the argument is supplied as a string literal), then the
processor <span class="verb">may</span> optionally signal this as a
<a title="static error" class="termref" href=
"#dt-static-error">static error</a>.</p>
<p><a name="err-XTDE3350" id="err-XTDE3350"><span class=
"error">[ERR XTDE3350]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> to call
the <a href=
"#func-accumulator-before"><code>accumulator-before</code></a> or
<a href=
"#func-accumulator-after"><code>accumulator-after</code></a>
function when there is no <a title="context item" class="termref"
href="#dt-context-item">context item</a>.</p>
<p><a name="err-XTTE3360" id="err-XTTE3360"><span class=
"error">[ERR XTTE3360]</span></a> It is a <a title="type error"
class="termref" href="#dt-type-error">type error</a> to call the
<a href=
"#func-accumulator-before"><code>accumulator-before</code></a> or
<a href=
"#func-accumulator-after"><code>accumulator-after</code></a>
function when the <a title="context item" class="termref" href=
"#dt-context-item">context item</a> is not a node, or when it is an
attribute or namespace node.</p>
<p><a name="err-XTDE3362" id="err-XTDE3362"><span class=
"error">[ERR XTDE3362]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> to call
the <a href=
"#func-accumulator-before"><code>accumulator-before</code></a> or
<a href=
"#func-accumulator-after"><code>accumulator-after</code></a>
function when the context item is a node in a streamed document,
unless the selected accumulator is declared with
<code>streamable="yes"</code>.</p>
<p><a name="err-XTDE3400" id="err-XTDE3400"><span class=
"error">[ERR XTDE3400]</span></a> It is an error if there is a
cyclic set of dependencies among accumulators such that the (pre-
or post-descent) value of an accumulator depends directly or
indirectly on itself. A processor <span class="verb">may</span>
report this as a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if it can be detected
statically. Alternatively a processor <span class="verb">may</span>
report this as a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a>. As a further option, a
processor may fail catastrophically when this error occurs.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The term <b>catastrophic failure</b> here means a failure
similar to infinite function or template recursion, which might
result in stack overflow or even in non-termination of the
transformation, rather than in a dynamic error of the kind that can
be processed using <a href=
"#element-try"><code>xsl:try</code></a>/<code>xsl:catch</code>.</p>
</div>
</dd>
<dt class="label">Examples</dt>
<dd>
<p>Given the accumulator:</p>
<div class="exampleInner">
<pre>
&lt;xsl:accumulator name="a" initial-value="0"&gt;
   &lt;xsl:accumulator-rule match="section" select="$value + 1"/&gt;
&lt;/xsl:accumulator&gt;
</pre></div>
<p>and the template rule:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="section"&gt;
   &lt;xsl:value-of select="accumulator-before('a')"/&gt;
   &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;
</pre></div>
<p>The stylesheet will precede the output from processing each
section with a section number that runs sequentially 1, 2, 3...
irrespective of the nesting of sections.</p>
</dd>
</dl>
</div>
<div class="div3">
<h4><a name="func-accumulator-after" id=
"func-accumulator-after"></a>18.2.5 <a href=
"#func-accumulator-after" style=
"text-decoration: none">fn:accumulator-after</a></h4>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Returns the post-descent value of the selected accumulator at
the context node.</p>
</dd>
<dt class="label">Signature</dt>
<dd>
<p><a name="function-accumulator-after" id=
"function-accumulator-after"></a></p>
<div class="proto"><code class=
"function">accumulator-after</code>(<code class=
"arg">$name</code><code class=
"as">&#160;as&#160;</code><code class="type">xs:string</code>)<code class="as">&#160;as&#160;</code><code class="return-type">item()*</code></div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-dependent">focus-dependent</a><sup><small>FO30</small></sup>.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>The <code>$name</code> argument specifies the name of the
<a title="accumulator" class="termref" href=
"#dt-accumulator">accumulator</a>. The value of the argument
<span class="verb">must</span> be a <span>string containing an
<a title="EQName" class="termref" href=
"#dt-eqname">EQName</a>.</span> If it is a <a title="lexical QName"
class="termref" href="#dt-lexical-qname">lexical QName</a>, then it
is expanded as described in <a href="#qname"><i>5.1 Qualified
Names</i></a> (no prefix means no namespace).</p>
<p>The function returns the post-descent value <var>A(N)</var> of
the selected accumulator where <var>N</var> is the context node, as
defined in <a href="#accumulator-formal-rules"><i>18.2.3 Formal
Model for Accumulators</i></a></p>
</dd>
<dt class="label">Error Conditions</dt>
<dd>
<p>The following errors apply: <span class="error">[see <a href=
"#err-XTDE3340">ERR XTDE3340</a>]</span>, <span class="error">[see
<a href="#err-XTDE3350">ERR XTDE3350</a>]</span>, <span class=
"error">[see <a href="#err-XTTE3360">ERR XTTE3360</a>]</span>,
<span class="error">[see <a href="#err-XTDE3362">ERR
XTDE3362</a>]</span>, <span class="error">[see <a href=
"#err-XTDE3400">ERR XTDE3400</a>]</span>.</p>
<p>For constraints on the use of <a href=
"#func-accumulator-after"><code>accumulator-after</code></a> when
streaming, see <a href=
"#streamability-fn-accumulator-after"><i>19.8.8.1 Streamability of
the accumulator-after function</i></a>.</p>
</dd>
<dt class="label">Examples</dt>
<dd>
<p>Given the accumulator:</p>
<div class="exampleInner">
<pre>
&lt;xsl:accumulator name="w" initial-value="0" streamable="true" as="xs:integer"&gt;
   &lt;xsl:accumulator-rule match="text()" 
                         select="$value + count(tokenize(., '\s+'))"/&gt;
&lt;/xsl:accumulator&gt;
</pre></div>
<p>and the template rule:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="section"&gt;
   &lt;xsl:apply-templates/&gt;
   (words: &lt;xsl:value-of select="accumulator-after('w') - accumulator-before('w')"/&gt;)
&lt;/xsl:template&gt;
</pre></div>
<p>The stylesheet will output at the end of each section a count of
the number of words in that section, irrespective of the nesting of
sections.</p>
</dd>
</dl>
</div>
<div class="div3">
<h4><a name="accumulators-visibility-and-overriding" id=
"accumulators-visibility-and-overriding"></a>18.2.6 <a href=
"#accumulators-visibility-and-overriding" style=
"text-decoration: none">Visibility and Overriding of
Accumulators</a></h4>
<p>If a <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> contains more than one <a href=
"#element-accumulator"><code>xsl:accumulator</code></a> declaration
with a particular name, then the one with the highest <a title=
"import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a> is used.</p>
<p><a name="err-XTSE3350" id="err-XTSE3350"><span class=
"error">[ERR XTSE3350]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> for a
<a title="package" class="termref" href="#dt-package">package</a>
to contain two or more non-hidden accumulators with the same
<a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> and the same <a title=
"import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a>, unless there is
another accumulator with the same <a title="expanded QName" class=
"termref" href="#dt-expanded-qname">expanded QName</a>, and a
higher import precedence.</p>
</div>
<div class="div3">
<h4><a name="streamability-of-accumulators" id=
"streamability-of-accumulators"></a>18.2.7 <a href=
"#streamability-of-accumulators" style=
"text-decoration: none">Streamability of Accumulators</a></h4>
<p>An accumulator is <a title="guaranteed-streamable" class=
"termref" href=
"#dt-guaranteed-streamable">guaranteed-streamable</a> if it
satisfies <span>all</span> the following conditions:</p>
<ol class="enumar">
<li>
<p>The <a href=
"#element-accumulator"><code>xsl:accumulator</code></a> declaration
has the attribute <code>streamable="yes"</code>.</p>
</li>
<li>
<p>The <a title="pattern" class="termref" href=
"#dt-pattern">pattern</a> in the <code>applies-to</code> attribute,
if present, is a <a title="motionless" class="termref" href=
"#dt-motionless">motionless</a> pattern.</p>
</li>
<li>
<p>In every contained <a href=
"#element-accumulator-rule"><code>xsl:accumulator-rule</code></a>,
the <a title="pattern" class="termref" href=
"#dt-pattern">pattern</a> in the <code>match</code> attribute is a
<a title="motionless" class="termref" href=
"#dt-motionless">motionless</a> pattern.</p>
</li>
<li>
<p>The <a title="expression" class="termref" href=
"#dt-expression">expression</a> in the <code>initial-value</code>
attribute is <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> and <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>.</p>
</li>
<li>
<p>The <a title="expression" class="termref" href=
"#dt-expression">expression</a> in the <span><code>select</code>
attribute or contained sequence constructor</span> is
<span><a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> and</span> <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>.</p>
</li>
</ol>
<p>Specifying <code>streamable="yes"</code> on an <a href=
"#element-accumulator"><code>xsl:accumulator</code></a> element
declares an intent that the accumulator should be guaranteed
streamable according to these criteria. The consequences of
declaring the accumulator to be streamable when it is not in fact
guaranteed streamable depend on the conformance level of the
processor, and are explained in <a href=
"#streamability-guarantees"><i>19.10 Streamability
Guarantees</i></a>.</p>
<p>When an accumulator is declared to be streamable, the stylesheet
author must ensure that the accumulator function <a href=
"#func-accumulator-after"><code>accumulator-after</code></a> is
only called at appropriate points in the processing, as explained
in <a href="#streamability-fn-accumulator-after"><i>19.8.8.1
Streamability of the accumulator-after function</i></a>.</p>
</div>
<div class="div3">
<h4><a name="accumulator-examples" id=
"accumulator-examples"></a>18.2.8 <a href="#accumulator-examples"
style="text-decoration: none">Examples of Accumulators</a></h4>
<div class="example">
<div class="exampleHeader"><a name="d7e42360" id=
"d7e42360"></a>Example: Remember the Title of a Document</div>
<p>Consider an XHTML document in which the title of the document is
represented by the content of the first <code>title</code> element
appearing as a child of the <code>head</code> element, which in
turn appears as a child of the <code>html</code> element. Suppose
that we want to process the document in streaming mode, and that we
want to avoid outputting the content of the <code>h1</code> element
if it is the same as the document title.</p>
<p>This can be achieved by remembering the value of the title in an
accumulator variable.</p>
<div class="exampleInner">
<pre>
  &lt;xsl:accumulator name="firstTitle" as="xs:string?" initial-value="()" streamable="yes"&gt;
    &lt;xsl:accumulator-rule match="/html/head/title[1]/text()" select="string(.)"/&gt;
  &lt;/xsl:accumulator&gt;
  
</pre></div>
<p>Subsequently, while processing an <code>h1</code> element
appearing later in the document, the value can be referenced:</p>
<div class="exampleInner">
<pre>
  &lt;xsl:template match="h1"&gt;
    &lt;xsl:variable name="firstTitle" select="accumulator-before('firstTitle')"/&gt;
    &lt;xsl:variable name="thisTitle" select="string(.)"/&gt;
    &lt;xsl:if test="$thisTitle ne $firstTitle"&gt;
      &lt;div class="heading-1"&gt;&lt;xsl:value-of select="$thisTitle"/&gt;&lt;/div&gt;
    &lt;/xsl:if&gt;
    &lt;/xsl:template&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e42391" id=
"d7e42391"></a>Example: Keep a Word Count</div>
<p>Suppose that there is a requirement to output, at the end of the
HTML rendition of a document, a paragraph giving the total number
of words in the document.</p>
<p>An accumulator can be used to maintain the word count:</p>
<div class="exampleInner">
<pre>
  &lt;xsl:accumulator name="word-count" 
                   as="xs:integer" 
                   initial-value="0"&gt;
    &lt;xsl:accumulator-rule match="text()" 
         select="$value + count(tokenize(string(.), '\W+'))"/&gt;
  &lt;/xsl:accumulator&gt;
  
</pre></div>
<p>The final value can be output at the end of the document:</p>
<div class="exampleInner">
<pre>
   &lt;xsl:template match="/"&gt;
     &lt;xsl:apply-templates/&gt;
     &lt;p&gt;Word count: &lt;xsl:value-of select="accumulator-after('word-count')"/&gt;&lt;/p&gt;
   &lt;/xsl:template&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e42404" id=
"d7e42404"></a>Example: Output Hierarchic Section Numbers</div>
<p>Consider a document in which <code>section</code> elements are
nested within <code>section</code> elements to arbitrary depth, and
there is a requirement to render the document with hierarchic
section numbers of the form <code>3.5.1.4</code>.</p>
<p>The current section number can be maintained in an accumulator
in the form of a sequence of integers, managed as a stack. The
number of integers represents the current level of nesting, and the
value of each integer represents the number of preceding sibling
sections encountered at that level. For convenience the first item
in the sequence represents the top of the stack.</p>
<div class="exampleInner">
<pre>
&lt;xsl:accumulator name="section-nr" as="xs:integer*" 
                 initial-value="0"&gt;
  &lt;xsl:accumulator-rule match="section" phase="start" 
                 select="0, head($value)+1, tail($value)"/&gt;
  &lt;xsl:accumulator-rule match="section" phase="end" 
                 select="tail($value) (:pop:)"/&gt;
&lt;/xsl:accumulator&gt;  
</pre></div>
<p>To illustrate this, consider the values after processing a
series of start and end tags:</p>
<table border="1" summary=
"example data illustrating the effect of parsing events on an accumulator"
cellpadding="5" width="100%">
<thead>
<tr>
<th colspan="1" align="left" valign="top">events</th>
<th colspan="1" align="left" valign="top">accumulator value</th>
<th colspan="1" align="left" valign="top">required section
number</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><code>&lt;section&gt;</code></td>
<td align="left" valign="top"><code>0, 1</code></td>
<td align="left" valign="top">1</td>
</tr>
<tr>
<td align="left" valign="top"><code>&lt;section&gt;</code></td>
<td align="left" valign="top"><code>0, 1, 1</code></td>
<td align="left" valign="top">1.1</td>
</tr>
<tr>
<td align="left" valign="top"><code>&lt;/section&gt;</code></td>
<td align="left" valign="top"><code>1, 1</code></td>
</tr>
<tr>
<td align="left" valign="top"><code>&lt;section&gt;</code></td>
<td align="left" valign="top"><code>0, 2, 1</code></td>
<td align="left" valign="top">1.2</td>
</tr>
<tr>
<td align="left" valign="top"><code>&lt;/section&gt;</code></td>
<td align="left" valign="top"><code>2, 1</code></td>
</tr>
<tr>
<td align="left" valign="top"><code>&lt;section&gt;</code></td>
<td align="left" valign="top"><code>0, 3, 1</code></td>
<td align="left" valign="top">1.3</td>
</tr>
<tr>
<td align="left" valign="top"><code>&lt;section&gt;</code></td>
<td align="left" valign="top"><code>0, 1, 3, 1</code></td>
<td align="left" valign="top">1.3.1</td>
</tr>
<tr>
<td align="left" valign="top"><code>&lt;/section&gt;</code></td>
<td align="left" valign="top"><code>1, 3, 1</code></td>
</tr>
<tr>
<td align="left" valign="top"><code>&lt;section&gt;</code></td>
<td align="left" valign="top"><code>0, 2, 3, 1</code></td>
<td align="left" valign="top">1.3.2</td>
</tr>
<tr>
<td align="left" valign="top"><code>&lt;/section&gt;</code></td>
<td align="left" valign="top"><code>2, 3, 1</code></td>
</tr>
<tr>
<td align="left" valign="top"><code>&lt;/section&gt;</code></td>
<td align="left" valign="top"><code>3, 1</code></td>
</tr>
<tr>
<td align="left" valign="top"><code>&lt;/section&gt;</code></td>
<td align="left" valign="top"><code>1</code></td>
</tr>
</tbody>
</table>
<p>The section number for a section can thus be generated as:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="section"&gt;
  &lt;p&gt;
    &lt;xsl:value-of select="reverse(tail(accumulator('section-nr')))" 
                  separator="."/&gt;
  &lt;/p&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;
                  
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e42535" id=
"d7e42535"></a>Example: Compute a Histogram showing the Number of
Books, by Publisher</div>
<div class="exampleInner">
<pre>
 &lt;xsl:accumulator name="histogram" as="map(xs:string, xs:integer)"
    initial-value="map{}"&gt;
    &lt;xsl:accumulator-rule match="book"&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test="map:contains($value, @publisher)"&gt;
          &lt;xsl:sequence select="map:put($value, @publisher, $value(@publisher)+1)"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:sequence select="map:put($value, @publisher, 1)"/&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
    &lt;/xsl:accumulator-rule&gt;  
 &lt;/xsl:accumulator&gt;
</pre></div>
<p>The <code>contained sequence constructor</code> is evaluated
with the variable <code>$value</code> set to the current value, and
with the context node as the node being visited.</p>
</div>
</div>
</div>
<div class="div2">
<h3><a name="func-copy-of" id="func-copy-of"></a>18.3 <a href=
"#func-copy-of" style="text-decoration: none">fn:copy-of</a></h3>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Returns a deep copy of the node supplied as the
<code>$node</code> argument, or of the context node if the argument
is absent.</p>
</dd>
<dt class="label">Signatures</dt>
<dd>
<p><a name="function-copy-of" id="function-copy-of"></a></p>
<div class="proto"><code class=
"function">copy-of</code>()<code class=
"as">&#160;as&#160;</code><code class=
"return-type">node()</code></div>
<div class="proto"><code class=
"function">copy-of</code>(<code class=
"arg">$nodes</code><code class=
"as">&#160;as&#160;</code><code class=
"type">node()*</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">node()*</code></div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>The zero-argument form of this function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-nondeterministic">nondeterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-dependent">focus-dependent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-independent">context-independent</a><sup><small>FO30</small></sup>.</p>
<p>The one-argument form of this function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-nondeterministic">nondeterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-independent">context-independent</a><sup><small>FO30</small></sup>.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>The zero-argument form of this function has the same effect as
calling <code>copy-of(.)</code>, that is, supplying the context
item as an implicit argument.</p>
<p>The function returns a deep copy of the node
<span>sequence</span> supplied as the argument <code>$nodes</code>.
If the argument is an empty sequence, the function returns an empty
sequence. The effect is the same as that of the function:</p>
<div class="exampleInner">
<pre>
&lt;xsl:function name="fn:copy-of" as="node()*" 
              identity-sensitive="no"&gt;
  &lt;xsl:param name="nodes" as="node()*/&gt;
  &lt;xsl:copy-of select="$nodes" 
               copy-namespaces="yes" 
               validation="preserve"/&gt;
&lt;/xsl:function&gt;
</pre></div>
<p>The streamability analysis, however, is different: see <a href=
"#classifying-built-in-functions"><i>19.8.8 Classifying Calls to
Built-In Functions</i></a>.</p>
<p>If the function is called more than once with the same argument,
it is <a title="implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a> whether
each call returns the same node, or whether multiple calls return
different nodes. That is, <span>in the case where <var>$X</var> is
a single node,</span> the result of the expression
<code>copy-of($X) is copy-of($X)</code> is <a title=
"implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a>.
<span>However, <code>copy-of($X) is $X</code> will always be
false.</span></p>
</dd>
<dt class="label">Notes</dt>
<dd>
<p>The <a href="#func-copy-of"><code>copy-of</code></a> function is
available for use (and is primarily intended for use) when a source
document is processed using streaming. It can also be used when not
streaming. The effect is to take a copy of the subtree rooted at
the current node, and to make this available as a normal tree, that
can be processed without any of the restrictions that apply while
streaming, for example only being able to process children once.
The copy, of course, does not include siblings or ancestors of the
context node, so any attempt to navigate to siblings or ancestors
will result in an empty sequence being returned.</p>
</dd>
<dt class="label">Examples</dt>
<dd>
<p>Using <code>copy-of()</code> while streaming:</p>
<p>This example copies from the source document all employees who
work in marketing and are based in Dubai. Because there are two
accesses using the child axis, it is not possible to do this
without buffering each employee in memory, which can be achieved
using the <a href="#func-copy-of"><code>copy-of</code></a>
function.</p>
<div class="exampleInner">
<pre>
&lt;xsl:stream href="employees.xml"&gt;
  &lt;xsl:sequence select="copy-of(employees/employee)
                          [department='Marketing' and location='Dubai']"/&gt;
&lt;/xsl:stream&gt;
</pre></div>
</dd>
</dl>
</div>
<div class="div2">
<h3><a name="func-snapshot" id="func-snapshot"></a>18.4 <a href=
"#func-snapshot" style="text-decoration: none">fn:snapshot</a></h3>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Returns a copy of a node together with its ancestors and
descendants and their attributes and namespaces.</p>
</dd>
<dt class="label">Signatures</dt>
<dd>
<p><a name="function-snapshot" id="function-snapshot"></a></p>
<div class="proto"><code class=
"function">snapshot</code>()<code class=
"as">&#160;as&#160;</code><code class=
"return-type">node()</code></div>
<div class="proto"><code class=
"function">snapshot</code>(<code class=
"arg">$nodes</code><code class=
"as">&#160;as&#160;</code><code class=
"type">node()*</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">node()*</code></div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>The zero-argument form of this function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-nondeterministic">nondeterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-dependent">focus-dependent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-independent">context-independent</a><sup><small>FO30</small></sup>.</p>
<p>The one-argument form of this function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-nondeterministic">nondeterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-independent">context-independent</a><sup><small>FO30</small></sup>.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>The zero-argument form of this function has the same effect as
calling <code>snapshot(.)</code>, that is, supplying the context
item as an implicit argument.</p>
<p>The function returns a <span>sequence of nodes in which each
node is a <a title="snapshot" class="termref" href=
"#dt-snapshot">snapshot</a> of the corresponding node in the input
sequence</span> supplied as the argument <code>$node</code>. If the
argument is an empty sequence, the function returns an empty
sequence.</p>
<p>If the function is called more than once with the same argument,
it is <a title="implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a> whether
each call returns the same node, or whether multiple calls return
different nodes. That is, the result of the expression
<code>snapshot($X) is snapshot($X)</code> is <a title=
"implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-snapshot" id="dt-snapshot" title="snapshot"></a>A
<b>snapshot</b> of a node <var>N</var> is a deep copy of
<var>N</var>, as produced by the <a href=
"#element-copy-of"><code>xsl:copy-of</code></a> instruction with
<code>copy-namespaces</code> set to <code>yes</code> and
<code>validation</code> set to <code>preserve</code>, with the
additional property that for every ancestor of <var>N</var>, the
copy also has a corresponding ancestor whose name, node-kind, and
base URI are the same as the corresponding ancestor of
<var>N</var>, and that has copies of the attributes and namespaces
of the corresponding ancestor of <var>N</var>. But the ancestor has
a type annotation of <code>xs:anyType</code>, has the properties
<code>nilled</code>, <code>is-id</code>, and <code>is-idref</code>
set to false, and has no children other than the child that is a
copy of <var>N</var> or one of its ancestors.<span class=
"definition">]</span></p>
<p>More formally, a <a title="snapshot" class="termref" href=
"#dt-snapshot">snapshot</a> of a node is the result of the
following function.</p>
<div class="exampleInner">
<pre>
&lt;xsl:function name="fn:snapshot" as="node()?" identity-sensitive="no"&gt;
  &lt;xsl:param name="nodes" as="node()*"/&gt;
  
  &lt;!-- create a copy of the tree containing the supplied node, retaining 
       * only the supplied node, its attributes and namespaces
       * the ancestors of the supplied node, 
       * their attributes and namespaces;
       * the descendants of the supplied node, 
       * their attributes and namespaces;
       --&gt;
  &lt;xsl:for-each select="$nodes"&gt;
    &lt;xsl:variable name="origin" select="."/&gt;
    &lt;xsl:variable name="root-copy" as="node()"&gt;
      &lt;xsl:apply-templates select="root($origin)" mode="snapshot"&gt;
        &lt;xsl:with-param name="origin" select="$origin" tunnel="yes"/&gt;
      &lt;/xsl:apply-templates&gt;
    &lt;/xsl:variable&gt;
  
    &lt;!-- find and return the node in the copied tree 
         that corresponds to the origin node
       --&gt; 
    &lt;xsl:sequence select="
         $root-copy/descendant-or-self::node()/(.|@*|namespace::*)
                              [f:corresponds(., $origin)]"/&gt;
  &lt;/xsl:for-each&gt;    
&lt;/xsl:function&gt;

&lt;xsl:template match="." mode="snapshot"&gt;
  &lt;xsl:param name="origin" as="node()" tunnel="yes"/&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test=". is $origin"&gt;
      &lt;xsl:copy-of select="." validation="preserve"/&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:when test=". intersect $origin/ancestor::node()"&gt;
      &lt;xsl:copy validation="strip"&gt;
        &lt;xsl:copy-of select="@*" validation="preserve"/&gt;
        &lt;xsl:apply-templates mode="snapshot"/&gt;
      &lt;/xsl:copy&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise/&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:template&gt;

&lt;!-- f:corresponds compares two nodes and returns true if all 
       the following are true:
     * they are at the same depth in their respective trees
     * they have the same name (or none)
     * they have the same node kind
     The tests on node name and node kind are needed only when 
     the origin node is an attribute or namespace.
     --&gt;
&lt;xsl:function name="f:corresponds" as="xs:boolean"&gt;
  &lt;xsl:param name="node1" as="node()"/&gt;
  &lt;xsl:param name="node2" as="node()"/&gt;
  &lt;xsl:sequence select="
    count($node1/ancestor::node()) = count($node2/ancestor::node()) and
    deep-equal(node-name($node1), node-name($node2)) and
    f:node-kind($node1) = f:node-kind($node2)"/&gt;    
&lt;/xsl:function&gt;

&lt;!-- f:node-kind returns the node kind of a node as a string
     --&gt;
&lt;xsl:function name="f:node-kind" as="xs:string"&gt;
  &lt;xsl:param name="node" as="node()"/&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="$node instance of document-node()"&gt;D&lt;/xsl:when&gt;
    &lt;xsl:when test="$node instance of element(*)"&gt;E&lt;/xsl:when&gt;
    &lt;xsl:when test="$node instance of attribute(*)"&gt;A&lt;/xsl:when&gt;
    &lt;xsl:when test="$node instance of text()"&gt;T&lt;/xsl:when&gt;
    &lt;xsl:when test="$node instance of comment()"&gt;C&lt;/xsl:when&gt;
    &lt;xsl:when test="$node instance of 
                          processing-instruction()"&gt;P&lt;/xsl:when&gt;
    &lt;xsl:when test="$node instance of namespace-node()"&gt;N&lt;/xsl:when&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:function&gt;
 
</pre></div>
</dd>
<dt class="label">Notes</dt>
<dd>
<p>The <a href="#func-snapshot"><code>snapshot</code></a> function
is available for use (and is primarily intended for use) when a
source document is processed using streaming. It can also be used
when not streaming. The effect is to take a copy of the subtree
rooted at the current node, along with copies of the ancestors and
their attributes, and to make this available as a normal tree, that
can be processed without any of the restrictions that apply while
streaming, for example only being able to process children once.
The copy, of course, does not include siblings of the context node
or of its ancestors, so any attempt to navigate to these siblings
will result in an empty sequence being returned.</p>
</dd>
<dt class="label">Examples</dt>
<dd>
<p>Using <code>snapshot()</code> while streaming:</p>
<p>This example copies from the source document all employees who
work in marketing and are based in Dubai. It assumes that employees
are grouped by location. Because there are two accesses using the
child axis (referencing <code>department</code> and
<code>salary</code>), it is not possible to do this without
buffering each employee in memory. The <a href=
"#func-snapshot"><code>snapshot</code></a> function is used in
preference to the simpler <a href=
"#func-copy-of"><code>copy-of</code></a> so that access to
attributes of the parent <code>location</code> element remains
possible.</p>
<div class="exampleInner">
<pre>
&lt;xsl:stream href="employees.xml"&gt;
  &lt;xsl:for-each select="snapshot(locations/location[@name='Dubai']
                          /employee)[department='Marketing']"&gt;
    &lt;employee&gt;
      &lt;location code="{../@code}"/&gt;
      &lt;salary value="{salary}"/&gt;
    &lt;/employee&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:stream&gt;
</pre></div>
</dd>
</dl>
</div>
</div>
<div class="div1">
<h2><a name="streamability" id="streamability"></a>19 <a href=
"#streamability" style=
"text-decoration: none">Streamability</a></h2>
<p>This section contains rules that can be used to determine
properties of <a title="construct" class="termref" href=
"#dt-construct">constructs</a> in the <a title="stylesheet" class=
"termref" href="#dt-stylesheet">stylesheet</a> — specifically, the
<a title="posture" class="termref" href="#dt-posture">posture</a>
and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of
a construct — which enable the streamability of the stylesheet to
be assessed.</p>
<p>These properties are used to determine the streamability of:</p>
<ul>
<li>
<p><a title="template rule" class="termref" href=
"#dt-template-rule">Template rules</a>: see <a href=
"#streamable-templates"><i>6.6.4 Streamable Templates</i></a></p>
</li>
<li>
<p>The <a href="#element-stream"><code>xsl:stream</code></a>
instruction: see <a href="#stream-instruction"><i>18.1 The
xsl:stream Instruction</i></a></p>
</li>
<li>
<p><a title="attribute set" class="termref" href=
"#dt-attribute-set">Attribute sets</a>: see <a href=
"#streamability-of-attribute-sets"><i>10.2.3 Streamability of
Attribute Sets</i></a></p>
</li>
<li>
<p><a title="accumulator" class="termref" href=
"#dt-accumulator">Accumulators</a>: see <a href=
"#streamability-of-accumulators"><i>18.2.7 Streamability of
Accumulators</i></a></p>
</li>
<li>
<p><a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">Stylesheet functions</a>: see <a href=
"#streamable-stylesheet-functions"><i>10.3.5 Streamability of
Stylesheet Functions</i></a></p>
</li>
<li>
<p>The <a href="#element-merge"><code>xsl:merge</code></a>
instruction: see <a href="#streamable-merging"><i>15.4 Streamable
Merging</i></a></p>
</li>
</ul>
<p>In each case, the conditions for constructs to be <a title=
"guaranteed-streamable" class="termref" href=
"#dt-guaranteed-streamable">guaranteed-streamable</a> are defined
in terms of these properties. The result of this analysis in turn
(see <a href="#streamability-guarantees"><i>19.10 Streamability
Guarantees</i></a>) imposes rules on how the constructs are handled
by processors that implement the <a title="streaming feature"
class="termref" href="#dt-streaming-feature">streaming feature</a>.
The analysis has no effect on the behavior of processors that do
not implement this feature.</p>
<p>The analysis is relevant to constructs such as streamable
template rules and the <a href=
"#element-stream"><code>xsl:stream</code></a> instruction that
process a single streamed input document. The <a href=
"#element-merge"><code>xsl:merge</code></a> instruction, which
processes multiple streamed inputs, has its own rules.</p>
<p>The rules in this section operate on the expression tree (more
properly, construct tree) that is typically output by the XSLT and
XPath parser. For the most part, the rules depend only on
identifying the syntactic constructs that are present.</p>
<p>The rules in this section generally consider each <a title=
"component" class="termref" href="#dt-component">component</a> in
the stylesheet (and in the case of <a title="template rule" class=
"termref" href="#dt-template-rule">template rules</a>, each
template rule) in isolation. The exception is that where a
component contains references to other components (such as global
variables, functions, or named templates), then information from
the signature of the referenced component is sometimes used. This
is invariably information that cannot be changed if a component is
overridden in a different <a title="package" class="termref" href=
"#dt-package">package</a>. The analysis thus requires as a
pre-condition that function calls and calls on named templates have
been resolved to the extent that the corresponding
function/template signature is known.</p>
<p>The detailed way in which the construct tree is derived from the
lexical form of the stylesheet is not described in this
specification. There are many ways in which the tree can be
optimized without affecting the result of the rules in this
section: for example, a sequence constructor containing a single
instruction can be replaced by that instruction, and a
parenthesized expression can be replaced by its content.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-construct" id="dt-construct" title="construct"></a>The term
<b>construct</b> refers to the union of the following: a <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>, an <a title=
"instruction" class="termref" href=
"#dt-instruction">instruction</a>, an <a title="attribute set"
class="termref" href="#dt-attribute-set">attribute set</a>, a
<a title="value template" class="termref" href=
"#dt-value-template">value template</a>, an <a title="expression"
class="termref" href="#dt-expression">expression</a>, or a
<a title="pattern" class="termref" href=
"#dt-pattern">pattern</a>.<span class="definition">]</span></p>
<p>These <a title="construct" class="termref" href=
"#dt-construct">constructs</a> are classified into <b>construct
kinds</b>: in particular, <a title="instruction" class="termref"
href="#dt-instruction">instructions</a> are classified according to
the name of the XSLT instruction, and <a title="expression" class=
"termref" href="#dt-expression">expressions</a> are classified
according to the most specific production in the XPath grammar that
the expression satisfies. (This means, for example, that
<code>2+2</code> is classified as an <code>AdditiveExpr</code>,
rather than say as a <code>UnionExpr</code>; although it also
satisfies the production rule for <code>UnionExpr</code>,
<code>AdditiveExpr</code> is more specific.)</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-operand-role" id="dt-operand-role" title="operand role"></a>For
every construct kind, there is a set of zero or more <b>operand
roles</b>.<span class="definition">]</span> For example, an
<code>AdditiveExpr</code> has two operand roles, referred to as the
left-hand operand and the right-hand operand, while an
<code>IfExpr</code> has three, referred to as the condition, the
then-clause, and the else-clause. A function call with three
arguments has three operand roles, called the first, second, and
third arguments. The names of the operand roles for each construct
kind are not formally listed, but should be clear from the
context.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-operand" id="dt-operand" title="operand"></a>In an actual
instance of a construct, there will be a number of
<b>operands</b>.<span class="definition">]</span> Each operand is
itself a <a title="construct" class="termref" href=
"#dt-construct">construct</a>; the construct tree can be defined as
the transitive relation between constructs and their operands. Each
operand is associated with exactly one of the operand roles for the
construct type. There may be operand roles where the operand is
optional (for example, the <code>separator</code> attribute of the
<a href="#element-value-of"><code>xsl:value-of</code></a>
instruction), and there may be operand roles that can be occupied
by multiple operands (for example, the <code>xsl:when/@test</code>
condition in <a href="#element-choose"><code>xsl:choose</code></a>,
or the arguments of the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-concat"><code>concat</code></a><sup><small>FO30</small></sup>
function).</p>
<p>Operand roles have a number of properties used in the
analysis:</p>
<ul>
<li>
<p>The <a title="required type" class="termref" href=
"#dt-required-type">required type</a> of the <a title="operand"
class="termref" href="#dt-operand">operand</a>. This is explicit in
the case of function calls (the required type is defined in the
function signature of the corresponding function). In other cases
it is implicit in the detailed rules for the construct in question.
In practice streamability analysis makes only modest use of the
required type; the main case where it is relevant is for a function
or template call, where knowing that the required type is atomic
enables the inference that the operand usage for a supplied node is
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>.</p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-operand-usage" id="dt-operand-usage" title=
"operand usage"></a>The <b>operand usage</b>. This gives
information, in the case where the operand value contains nodes,
about how those nodes are used. The operand usage takes one of the
values <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>, <a title="inspection" class=
"termref" href="#dt-inspection">inspection</a>, <a title=
"transmission" class="termref" href=
"#dt-transmission">transmission</a>, or <a title="navigation"
class="termref" href="#dt-navigation">navigation</a>. <span class=
"definition">]</span>The meanings of these terms are explained in
<a href="#operand-roles"><i>19.4 Operand Roles</i></a>. If the
required type of the <a title="operand" class="termref" href=
"#dt-operand">operand</a> does not permit nodes to be supplied
<span>(for example because the required type is a function item or
a map)</span>, then the operand usage is <a title="inspection"
class="termref" href="#dt-inspection">inspection</a>, because the
only run-time operation on a supplied node will be to inspect it,
discover it is a node, and raise a type error.</p>
<p>In the particular case where the required type is atomic, and
any supplied nodes are atomized, the operand usage will be
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>, because <a title="atomize" class=
"termref" href="#dt-atomization">atomize</a> is a special case of
absorption.</p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-higher-order-operand" id="dt-higher-order-operand" title=
"higher-order operand"></a>Whether or not the <a title="operand"
class="termref" href="#dt-operand">operand</a> is
<b>higher-order</b>. For this purpose an operand <var>O</var> of a
construct <var>C</var> is higher-order if the semantics of
<var>C</var> potentially require <var>O</var> to be evaluated more
than once during a single evaluation of <var>C</var>.<span class=
"definition">]</span> More specifically, <var>O</var> is a
<b>higher-order</b> operand of <var>C</var> if any of the following
conditions is true:</p>
<ul>
<li>
<p>The <a title="context item" class="termref" href=
"#dt-context-item">context item</a> for evaluation of <var>O</var>
is different from the context item for evaluation of
<var>C</var>.</p>
</li>
<li>
<p><var>C</var> is an <a title="instruction" class="termref" href=
"#dt-instruction">instruction</a> and <var>O</var> is a <a title=
"pattern" class="termref" href="#dt-pattern">pattern</a> (as with
the <code>from</code> and <code>count</code> attributes of <a href=
"#element-number"><code>xsl:number</code></a>, and the
<code>group-starting-with</code> and <code>group-ending-with</code>
attributes of <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>).</p>
</li>
<li>
<p><var>C</var> is an XPath <code>for</code>, <code>some</code>, or
<code>every</code> expression and <var>O</var> is the expression in
its <code>return</code> or <code>satisfies</code> clause.</p>
</li>
<li>
<p><var>C</var> is an inline function declaration and <var>O</var>
is the expression in its body.</p>
</li>
</ul>
</li>
</ul>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-choice-operand-group" id="dt-choice-operand-group" title=
"choice operand group"></a>For some construct kinds, one or more
operand roles may be defined to form a <b>choice operand group</b>.
This concept is used where it is known that <a title="operand"
class="termref" href="#dt-operand">operands</a> are mutually
exclusive (for example the <code>then</code> and <code>else</code>
clauses in a conditional expression).<span class=
"definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-combined-posture" id="dt-combined-posture" title=
"combined posture"></a>The <b>combined posture</b> of a <a title=
"choice operand group" class="termref" href=
"#dt-choice-operand-group">choice operand group</a> is determined
by the <a title="posture" class="termref" href=
"#dt-posture">postures</a> of the <a title="operand" class=
"termref" href="#dt-operand">operands</a> in the group <span>(the
<b>operand postures</b>)</span>, and is the first of the following
that applies:<span class="definition">]</span></p>
<ol class="enumar">
<li>
<p>If any of the <span>operand</span> postures is <a title=
"roaming" class="termref" href="#dt-roaming">roaming</a>, then the
combined posture is <a title="roaming" class="termref" href=
"#dt-roaming">roaming</a>.</p>
</li>
<li>
<p>If all of the <span>operand</span> postures are <a title=
"grounded" class="termref" href="#dt-grounded">grounded</a>, then
the combined posture is <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a>.</p>
</li>
<li>
<p>If one or more of the <span>operand</span> postures is <a title=
"climbing" class="termref" href="#dt-climbing">climbing</a> and the
remainder (if any) are <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a>, then the combined posture is <a title=
"climbing" class="termref" href="#dt-climbing">climbing</a>.</p>
</li>
<li>
<p>If one or more of the <span>operand</span> postures is <a title=
"striding" class="termref" href="#dt-striding">striding</a> and the
remainder (if any) are <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a>, then the combined posture is <a title=
"striding" class="termref" href="#dt-striding">striding</a>.</p>
</li>
<li>
<p>If one or more of the <span>operand</span> postures is <a title=
"crawling" class="termref" href="#dt-crawling">crawling</a> and
<span>each of the remainder (if any) is</span> either <a title=
"striding" class="termref" href="#dt-striding">striding</a> or
<a title="grounded" class="termref" href=
"#dt-grounded">grounded</a>, then the combined posture is <a title=
"crawling" class="termref" href="#dt-crawling">crawling</a>.</p>
</li>
<li>
<p>Otherwise (for example, if the group includes both an operand
with <a title="climbing" class="termref" href=
"#dt-climbing">climbing</a> posture and one with <a title=
"crawling" class="termref" href="#dt-crawling">crawling</a>
posture), the combined posture is <a title="roaming" class=
"termref" href="#dt-roaming">roaming</a>.</p>
</li>
</ol>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-type-determined-usage" id="dt-type-determined-usage" title=
"type-determined usage"></a>The <b>type-determined usage</b> of an
<a title="operand" class="termref" href="#dt-operand">operand</a>
is as follows: if the required type (ignoring occurrence indicator)
is <code>function(*)</code> or a subtype thereof, then <a title=
"inspection" class="termref" href="#dt-inspection">inspection</a>;
if the required type (ignoring occurrence indicator) is
<code>xs:anyAtomicType</code> or a subtype thereof, then <a title=
"absorption" class="termref" href="#dt-absorption">absorption</a>;
otherwise <a title="navigation" class="termref" href=
"#dt-navigation">navigation</a>.<span class=
"definition">]</span></p>
<p>The process of determining whether a construct is streamable
reduces to determining properties of the constructs in the
construct tree. The properties in question (which are described in
greater detail in subsequent sections) are:</p>
<ol class="enumar">
<li>
<p>The <b>static type</b> of the construct. When the construct is
evaluated, its value will always be an instance of this type. The
value is a <span><a title="U-type" class="termref" href=
"#dt-utype">U-type</a></span>; although type inferencing is capable
of determining information about the cardinality as well as the
item type, the streamability analysis makes no use of this.</p>
</li>
<li>
<p>The <b>context item type</b>: that is, the static type of the
<a title="context item" class="termref" href=
"#dt-context-item">context item</a> potentially used as input to
the construct. When the construct is evaluated, the context item
used to evaluate the construct (if it is used at all) will be an
instance of this type.</p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-posture" id="dt-posture" title="posture"></a>The <b>posture</b>
of the expression. This captures information about the way in which
the streamed input document is positioned on return from evaluating
the construct. The posture takes one of the values <a title=
"climbing" class="termref" href="#dt-climbing">climbing</a>,
<a title="striding" class="termref" href=
"#dt-striding">striding</a>, <a title="crawling" class="termref"
href="#dt-crawling">crawling</a>, <a title="roaming" class=
"termref" href="#dt-roaming">roaming</a>, or <a title="grounded"
class="termref" href="#dt-grounded">grounded</a>. <span class=
"definition">]</span> The meanings of these terms are explained in
<a href="#posture"><i>19.5 Determining the Posture of a
Construct</i></a>.</p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-context-posture" id="dt-context-posture" title=
"context posture"></a>The <b>context posture</b>. This captures
information about how the <a title="context item" class="termref"
href="#dt-context-item">context item</a> used as input to the
construct is positioned relative to the streamed input. The
<b>context posture</b> of a construct C is the posture of the
expression whose value sets the focus for the evaluation of
C.<span class="definition">]</span>. <span>Rules for determining
the context posture of any construct are given in <a href=
"#determining-context-posture"><i>19.6 Determining the Context
Posture</i></a>.</span></p>
</li>
<li>
<p>The <b>sweep</b> of the construct. The sweep of a construct
gives information about whether and how the evaluation of the
construct changes the current position in a streamed input
document. The possible values are <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>, <a title=
"consuming" class="termref" href="#dt-consuming">consuming</a>, and
<a title="free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>. These terms are explained in
<a href="#sweep"><i>19.7 The Sweep of a Construct</i></a>.</p>
</li>
</ol>
<p>The values of these properties for a top-level construct such as
the body of a template rule determine whether the construct is
streamable.</p>
<p>The values of these properties are not independent. For example,
if the static type is atomic, then the posture will always be
grounded; if the sweep is free-ranging, then the posture will
always be roaming.</p>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of a <a title="construct" class=
"termref" href="#dt-construct">construct</a>, as defined above, are
calculated in relation to a particular streamed input document. If
there is more than one streamed input document, then a construct
that is motionless with respect to one streamed input might be
consuming with respect to another. In practice, though, the
streamability analysis is only ever concerned with one particular
streamed input at a time; constructs are analyzed in relation to
the innermost containing <a href=
"#element-template"><code>xsl:template</code></a>, <a href=
"#element-stream"><code>xsl:stream</code></a>, <a href=
"#element-accumulator"><code>xsl:accumulator</code></a>, or
<a href="#element-merge-source"><code>xsl:merge-source</code></a>
element, and this container implicitly defines the streamed input
document that is relevant. The streamed input document affecting a
construct is always the document that contains the context item for
evaluation of that construct.</p>
<div class="div2">
<h3><a name="determining-static-type" id=
"determining-static-type"></a>19.2 <a href=
"#determining-static-type" style=
"text-decoration: none">Determining the Static Type of a
Construct</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-static-type" id="dt-static-type" title="static type"></a>The
<b>static type</b> of a <a title="construct" class="termref" href=
"#dt-construct">construct</a> is such that all values produced by
evaluating the construct will conform to that type. The static type
of a construct is a <a title="U-type" class="termref" href=
"#dt-utype">U-type</a>.<span class="definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-utype" id="dt-utype" title="U-type"></a>A <b>U-type</b> is a
set of <a title="fundamental item type" class="termref" href=
"#dt-fundamental-item-type">fundamental item types</a>.<span class=
"definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-fundamental-item-type" id="dt-fundamental-item-type" title=
"fundamental item type"></a>There are 28 <b>fundamental item
types</b>: the 7 node kinds defined in <a href=
"#xpath-datamodel-30">[Data Model]</a> (element, attribute, etc.),
the 19 primitive atomic types defined in <a href=
"#xmlschema-2">[XML Schema Part 2]</a>, plus the types
<code>function(*)</code> and <code>xs:untypedAtomic</code>. The
fundamental item types are disjoint, and every item is an instance
of exactly one of them.<span class="definition">]</span></p>
<p>More specifically, the fundamental item types are:</p>
<ul>
<li>
<p><code>document-node()</code>, <code>element()</code>,
<code>attribute()</code>, <code>text()</code>,
<code>comment()</code>, <code>processing-instruction()</code>,
<code>namespace-node()</code>;</p>
</li>
<li>
<p><code>xs:boolean</code>, <code>xs:double</code>,
<code>xs:decimal</code>, <code>xs:float</code>,
<code>xs:string</code>, <code>xs:dateTime</code>,
<code>xs:date</code>, <code>xs:time</code>, <code>xs:gYear</code>,
<code>xs:gYearMonth</code>, <code>xs:gMonth</code>,
<code>xs:gMonthDay</code>, <code>xs:gDay</code>,
<code>xs:anyURI</code>, <code>xs:QName</code>,
<code>xs:NOTATION</code>, <code>xs:base64Binary</code>,
<code>xs:hexBinary</code>, <code>xs:duration</code></p>
</li>
<li>
<p><code>function(*)</code></p>
</li>
<li>
<p><code>xs:untypedAtomic</code></p>
</li>
</ul>
<p>A value <var>V</var> (in general, a sequence) is an instance of
a <a title="U-type" class="termref" href="#dt-utype">U-type</a>
<var>U</var> if every item in <var>V</var> is an instance of one of
the <a title="fundamental item type" class="termref" href=
"#dt-fundamental-item-type">fundamental item types</a> in
<var>U</var>. For example, the sequence <code>(23, "Paris")</code>
is an instance of the U-type <code>U{xs:string, xs:decimal,
xs:date}</code> because both items in the sequence belong to item
types in this U-type.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>It is a consequence of this rule that the empty sequence,
<code>()</code>, is an instance of every U-type.</p>
</div>
<p>A <a title="U-type" class="termref" href="#dt-utype">U-type</a>
is represented in this specification using the notation <var>U{t1,
t2, t3, ...}</var> where <code>t1, t2, t3, ...</code> are the names
of the fundamental item types making up the U-type. The item types
are represented using the syntax of the <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-ItemType">ItemType</a><sup><small>XP30</small></sup>
production in XPath, for example <code>comment()</code> or
<code>xs:date</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This means that the order of <code>t1, t2, t3, ...</code> has no
significance: <var>U{A, B}</var> is the same U-type as <var>U{B,
A}</var>.</p>
</div>
<p>The smallest U-type is denoted <var>U{}</var>. This is not an
empty type; like every other U-type, it has the empty sequence
<code>()</code> as an instance. For convenience, the universal
U-type is represented as <var>U{*}</var>; the U-type corresponding
to the set of 7 node kinds is written <var>U{N}</var>, and the
U-type corresponding to all atomic values (that is, the 19
primitive atomic types plus <code>xs:untypedAtomic</code>) is
written <var>U{A}</var>.</p>
<p>Because a <a title="U-type" class="termref" href=
"#dt-utype">U-type</a> is a set, the operations of union,
intersection, and difference are defined over U-types, and the
result is always a U-type. If one U-type <var>U</var> is a subset
of another U-type <var>V</var>, then <var>U</var> is said to be a
subtype of <var>V</var>, and <var>V</var> is said to be a supertype
of <var>U</var>.</p>
<p>In some cases the inference of a <a title="static type" class=
"termref" href="#dt-static-type">static type</a> depends on the
declared types of variables or functions. Since declared types use
the <code>SequenceType</code> syntax, there is therefore a mapping
defined from SequenceTypes to U-types. The mapping is as
follows:</p>
<ul>
<li>
<p>The SequenceType <code>empty-sequence()</code> maps to
<var>U{}</var></p>
</li>
<li>
<p>For every other SequenceType, the mapping depends only on the
item type and ignores the occurrence indicator. The mapping from
item types is as follows:</p>
<ul>
<li>
<p><code>item()</code> maps to <var>U{*}</var></p>
</li>
<li>
<p><code>AnyKindTest</code> (<code>node()</code>) maps to
<var>U{N}</var></p>
</li>
<li>
<p><code>DocumentTest</code> maps to
<var>U{document-node()}</var></p>
</li>
<li>
<p><code>ElementTest</code> and <code>SchemaElementTest</code> map
to <var>U{element()}</var></p>
</li>
<li>
<p><code>AttributeTest</code> and <code>SchemaAttributeTest</code>
map to <var>U{attribute()}</var></p>
</li>
<li>
<p><code>TextTest</code> maps to <var>U{text()}</var></p>
</li>
<li>
<p><code>CommentTest</code> maps to <var>U{comment()}</var></p>
</li>
<li>
<p><code>PITest</code> maps to
<var>U{processing-instruction()}</var></p>
</li>
<li>
<p><code>NamespaceNodeTest</code> maps to
<var>U{namespace-node()}</var></p>
</li>
<li>
<p><code>FunctionTest</code> and <code>MapTest</code> map to
<var>U{function(*)}</var></p>
</li>
<li>
<p>The QName <code>xs:error</code> maps to <var>U{}</var></p>
</li>
<li>
<p>A QName <var>Q</var> representing an atomic type that is a
fundamental item type maps to <var>U{Q}</var></p>
</li>
<li>
<p>A QName <var>Q</var> representing an atomic type derived from a
fundamental item type <var>F</var> maps to <var>U{F}</var></p>
</li>
<li>
<p>A QName <var>Q</var> representing a pure union type maps to a
U-type containing the fundamental item types present in the
transitive membership of the union, or from which the transitive
members of the union are derived.</p>
</li>
</ul>
</li>
</ul>
<p>Although all constructs have a <a title="static type" class=
"termref" href="#dt-static-type">static type</a>, the streamability
analysis only needs to know the static type of XPath expressions,
so the rules here are confined to that case. <span>For constructs
other than <a title="expression" class="termref" href=
"#dt-expression">expressions</a>, the <a title="static type" class=
"termref" href="#dt-static-type">static type</a> for the purpose of
streamability analysis is taken as <var>U{*}</var></span>.</p>
<p>The rules given here are deliberately simple. Implementations
may well be able to compute a more precise <a title="static type"
class="termref" href="#dt-static-type">static type</a>, but this
will rarely be useful for streamability analysis. The item type for
each kind of XPath expression is determined by the rules below. In
the first column, numbers in square brackets are production numbers
from the XPath 3.0 specification. <span>In the second column, the
<b>Proforma</b> uses an informal notation used both to provide a
reminder of the syntax of the construct in question, and to attach
labels to its operand roles so that they can be referred to in the
text of the third column.</span></p>
<table summary="Inferring a Static Type for XPath Expressions"
border="1" cellpadding="5" width="100%">
<thead>
<tr>
<th colspan="1" align="left" valign="top">Construct</th>
<th colspan="1" align="left" valign="top">Proforma</th>
<th colspan="1" align="left" valign="top">Static Type</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top">Expr [6]</td>
<td align="left" valign="top"><code>E,F</code></td>
<td align="left" valign="top">the union of the static types of E
and F</td>
</tr>
<tr>
<td align="left" valign="top">ForExpr [8]</td>
<td align="left" valign="top"><code>for $x in S return
E</code></td>
<td align="left" valign="top">the static type of E</td>
</tr>
<tr>
<td align="left" valign="top">LetExpr [11]</td>
<td align="left" valign="top"><code>let $x := S return
E</code></td>
<td align="left" valign="top">the static type of E</td>
</tr>
<tr>
<td align="left" valign="top">QuantifiedExpr [14]</td>
<td align="left" valign="top"><code>some|every $x in S satisfies
C</code></td>
<td align="left" valign="top"><var>U{xs:boolean}</var></td>
</tr>
<tr>
<td align="left" valign="top">IfExpr [15]</td>
<td align="left" valign="top"><code>if (C) then T else
E</code></td>
<td align="left" valign="top">the union of the static types of T
and E</td>
</tr>
<tr>
<td align="left" valign="top">OrExpr [16]</td>
<td align="left" valign="top"><code>E or F</code></td>
<td align="left" valign="top"><var>U{xs:boolean}</var></td>
</tr>
<tr>
<td align="left" valign="top">AndExpr [17]</td>
<td align="left" valign="top"><code>E and F</code></td>
<td align="left" valign="top"><var>U{xs:boolean}</var></td>
</tr>
<tr>
<td align="left" valign="top">ComparisonExpr [18]</td>
<td align="left" valign="top"><code>E = F, E eq F, E is
F</code></td>
<td align="left" valign="top"><var>U{xs:boolean}</var></td>
</tr>
<tr>
<td align="left" valign="top">StringConcatExpr [19]</td>
<td align="left" valign="top"><code>E || F</code></td>
<td align="left" valign="top"><var>U{xs:string}</var></td>
</tr>
<tr>
<td align="left" valign="top">RangeExpr [20]</td>
<td align="left" valign="top"><code>E to F</code></td>
<td align="left" valign="top"><var>U{xs:decimal}</var></td>
</tr>
<tr>
<td align="left" valign="top">AdditiveExpr [21]</td>
<td align="left" valign="top"><code>E + F</code></td>
<td align="left" valign="top"><var>U{A}</var>. <span>But if the
expression is a predicate (that is, if it appears between square
brackets in a filter expression or axis step), then
<var>U{xs:decimal, xs:double, xs:float}</var></span></td>
</tr>
<tr>
<td align="left" valign="top">MultiplicativeExpr [22]</td>
<td align="left" valign="top"><code>E * F</code></td>
<td align="left" valign="top"><var>U{A}</var>. <span>But if the
expression is a predicate (that is, if it appears between square
brackets in a filter expression or axis step), then
<var>U{xs:decimal, xs:double, xs:float}</var></span></td>
</tr>
<tr>
<td align="left" valign="top">UnionExpr [23]</td>
<td align="left" valign="top"><code>E | F</code></td>
<td align="left" valign="top">the union of the static types of E
and F</td>
</tr>
<tr>
<td rowspan="2" align="left" valign="top">IntersectExceptExpr
[24]</td>
<td align="left" valign="top"><code>E intersect F</code></td>
<td align="left" valign="top">the intersection of the static types
of E and F</td>
</tr>
<tr>
<td align="left" valign="top"><code>E except F</code></td>
<td align="left" valign="top">the static type of E</td>
</tr>
<tr>
<td align="left" valign="top">InstanceOfExpr [25]</td>
<td align="left" valign="top"><code>E instance of T</code></td>
<td align="left" valign="top"><var>U{xs:boolean}</var></td>
</tr>
<tr>
<td align="left" valign="top">TreatExpr [26]</td>
<td align="left" valign="top"><code>E treat as T</code></td>
<td align="left" valign="top">the U-type corresponding to the
SequenceType T</td>
</tr>
<tr>
<td align="left" valign="top">CastableExpr [27]</td>
<td align="left" valign="top"><code>E castable as T</code></td>
<td align="left" valign="top"><var>U{xs:boolean}</var></td>
</tr>
<tr>
<td align="left" valign="top">CastExpr [28]</td>
<td align="left" valign="top"><code>E cast as T</code></td>
<td align="left" valign="top">if T is an atomic or pure union type,
the corresponding U-type. Otherwise, for example if T is a list
type, <var>U{A}</var>.</td>
</tr>
<tr>
<td align="left" valign="top">UnaryExpr [29]</td>
<td align="left" valign="top"><code>-N</code></td>
<td align="left" valign="top"><var>U{xs:decimal, xs:double,
xs:float}</var></td>
</tr>
<tr>
<td align="left" valign="top">SimpleMapExpr [34]</td>
<td align="left" valign="top"><code>E ! F</code></td>
<td align="left" valign="top">the static type of F</td>
</tr>
<tr>
<td rowspan="3" align="left" valign="top">PathExpr [35]</td>
<td align="left" valign="top"><code>/</code></td>
<td align="left" valign="top"><var>U{document-node()}</var></td>
</tr>
<tr>
<td align="left" valign="top"><code>/P</code></td>
<td align="left" valign="top">the static type of P</td>
</tr>
<tr>
<td align="left" valign="top"><code>//P</code></td>
<td align="left" valign="top">the static type of P</td>
</tr>
<tr>
<td align="left" valign="top">RelativePathExpr [36]</td>
<td align="left" valign="top"><code>P/Q, P//Q</code></td>
<td align="left" valign="top">the static type of P</td>
</tr>
<tr>
<td align="left" valign="top">AxisStep [36]</td>
<td align="left" valign="top"><code>E[P]</code></td>
<td align="left" valign="top">the static type of E</td>
</tr>
<tr>
<td align="left" valign="top">ForwardStep [39], ReverseStep
[42]</td>
<td align="left" valign="top"><code>Axis::NodeTest</code></td>
<td align="left" valign="top">If the <code>NodeTest</code> is a
<code>KindTest</code> <var>K</var>, then <var>U{K}</var> (for
example, <var>U{element()}</var> or <var>U{comment()}</var>).
Otherwise (the <code>NodeTest</code> is a <code>NameTest</code>),
the U-type corresponding to the principal node kind of the axis,
for example <var>U{element()}</var> or
<var>U{attribute()}</var>.</td>
</tr>
<tr>
<td rowspan="2" align="left" valign="top">PostfixExpr [48]</td>
<td align="left" valign="top">Filter Expression
<code>E[P]</code></td>
<td align="left" valign="top">the static type of E</td>
</tr>
<tr>
<td align="left" valign="top">Dynamic Function Call <code>F(X,
Y)</code></td>
<td align="left" valign="top"><var>U{*}</var>, unless ancillary
information is available about the function signature of F: see
below.</td>
</tr>
<tr>
<td align="left" valign="top">Literal [53]</td>
<td align="left" valign="top"><code>"pH"</code>,
<code>93.7</code></td>
<td align="left" valign="top"><var>U{xs:string}</var>,
<var>U{xs:decimal}</var>, or <var>U{xs:double}</var>, depending on
the form of the literal</td>
</tr>
<tr>
<td align="left" valign="top">VarRef [55]</td>
<td align="left" valign="top"><code>$V</code></td>
<td align="left" valign="top">For a variable declared using
<a href="#element-variable"><code>xsl:variable</code></a> or
<a href="#element-param"><code>xsl:param</code></a>, and for
parameters of inline function expressions: the declared type of the
variable, defaulting to <var>U{*}</var>. For variables declared
using <code>for</code>, <code>let</code>, <code>some</code>, and
<code>every</code> expressions: the static type of the expression
to which the variable is bound.</td>
</tr>
<tr>
<td rowspan="2" align="left" valign="top">ParenthesizedExpr
[57]</td>
<td align="left" valign="top"><code>(E)</code></td>
<td align="left" valign="top">the type of E</td>
</tr>
<tr>
<td align="left" valign="top"><code>()</code></td>
<td align="left" valign="top"><var>U{}</var> (a type whose only
instance is the empty sequence)</td>
</tr>
<tr>
<td align="left" valign="top">ContextItemExpr [58]</td>
<td align="left" valign="top"><code>.</code></td>
<td align="left" valign="top">the context item type: see below</td>
</tr>
<tr>
<td align="left" valign="top">FunctionCall [59]</td>
<td align="left" valign="top"><code>F(X, Y)</code></td>
<td align="left" valign="top"><span>In general: the U-type
corresponding to the declared result type of function <var>F</var>.
But if one or more of the arguments to the function have operand
usage <a title="transmission" class="termref" href=
"#dt-transmission">transmission</a>, then the intersection of the
U-type corresponding to the declared result type with the union of
the static types of the arguments having usage transmission. (For
example, the static type of the function call
<code>head(//text())</code> is <var>U{text()}</var>.)</span></td>
</tr>
<tr>
<td align="left" valign="top">NamedFunctionRef [63]</td>
<td align="left" valign="top"><code>F#n</code></td>
<td align="left" valign="top"><var>U{function(*)}</var></td>
</tr>
<tr>
<td align="left" valign="top">InlineFunctionExpr [64]</td>
<td align="left" valign="top"><code>function(P) {E}</code></td>
<td align="left" valign="top"><var>U{function(*)}</var></td>
</tr>
<tr>
<td align="left" valign="top">MapExpr [202]</td>
<td align="left" valign="top"><code>map{"A":E, "B":F}</code></td>
<td align="left" valign="top"><var>U{function(*)}</var></td>
</tr>
</tbody>
</table>
<p>Where the <a title="static type" class="termref" href=
"#dt-static-type">static type</a> of an expression is
<var>U{function(*)}</var>, it is useful to retain additional
information: specifically, the signature of the function. This may
be regarded as information ancillary to the U-type of the
expression; it does not play any role in operations such as testing
whether one U-type is a subtype of another, or forming the union of
two U-types. This ancillary information is available for a
<code>NamedFunctionRef</code>, for an
<code>InlineFunctionExpr</code>, for a <code>MapExpr</code>, for a
<code>FunctionCall</code> whose static type is
<var>U{function(*)}</var>, and for a <code>VarRef</code> if the
variable is bound to any of the forgoing, or if it has a declared
type corresponding to <var>U{function(*)}</var>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The special case type inference used for an
<code>AdditiveExpr</code> or <code>MultiplicativeExpr</code>
appearing as a predicate is possible because if an arithmetic
operation within a predicate produces any other result, for example
an <code>xs:duration</code> or <code>xs:dateTime</code>, this would
cause a type error (on the grounds that an <code>xs:duration</code>
or <code>xs:dateTime</code> has no effective boolean value), and
static type inference only needs to consider the type of non-error
results. The benefit of this special rule is that filter
expressions such as <code>/descendant::section[$i + 1]</code> can
be recognized as returning a singleton, and therefore as being
<a title="striding" class="termref" href=
"#dt-striding">striding</a>, even if the type of <code>$i</code> is
unknown.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The streamability analysis in this chapter is not schema-aware.
There are cases where use of schema type information might enable a
processor to determine that a construct is streamable when it would
be unable to make this determination otherwise. Two examples:</p>
<ul>
<li>
<p>A processor might decide that a construct such as <code>price +
salesTax</code> is streamable if both the child elements have a
simple type such as <code>xs:decimal</code>, or if the order in
which they appear in the input document is known.</p>
</li>
<li>
<p>A processor might decide that a step using the descendant axis,
such as <code>.//title</code>, has <a title="striding" class=
"termref" href="#dt-striding">striding</a> rather than <a title=
"crawling" class="termref" href="#dt-crawling">crawling</a>
<a title="posture" class="termref" href="#dt-posture">posture</a>
if it can establish that two <code>title</code> elements will never
<span>be nested</span> (that is, a <code>title</code> cannot
contain another <code>title</code>). This would allow the
instruction <code>&lt;xsl:apply-templates
select=".//title"/&gt;</code> to be used in a streaming template
rule.</p>
</li>
</ul>
<p>Although such constructs are not guaranteed streamable according
to this specification, there is nothing to prevent a processor
providing a streamed implementation if it is able to do so.</p>
</div>
</div>
<div class="div2">
<h3><a name="determining-context-item-type" id=
"determining-context-item-type"></a>19.3 <a href=
"#determining-context-item-type" style=
"text-decoration: none">Determining the Context Item Type</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-context-item-type" id="dt-context-item-type" title=
"context item type"></a>For every expression, it is possible to
establish by static analysis, information about the item type of
the context item for evaluation of that expression. This is called
the <b>context item type</b> of the expression.<span class=
"definition">]</span></p>
<p>The <a title="context item type" class="termref" href=
"#dt-context-item-type">context item type</a> of an expression is a
<a title="U-type" class="termref" href="#dt-utype">U-type</a>.</p>
<p>The semantics of every <a title="construct" class="termref"
href="#dt-construct">construct</a>, defined in this specification
or in the XPath specification, describe how the <a title="focus"
class="termref" href="#dt-focus">focus</a> for evaluating each
<a title="operand" class="termref" href="#dt-operand">operand</a>
of the construct is determined. In most cases the focus is the same
as that of the parent construct. In some cases the focus is
determined by evaluating some other expression, for example in the
expressions <code>A/B</code>, <code>A!B</code>, or
<code>A[B]</code>, the focus for evaluating <var>B</var> is
<var>A</var>. More generally:</p>
<ul>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-focus-changing-construct" id="dt-focus-changing-construct"
title="focus-changing construct"></a>A <b>focus-changing
construct</b> is a <a title="construct" class="termref" href=
"#dt-construct">construct</a> that has one or more <a title=
"operand" class="termref" href="#dt-operand">operands</a> that are
evaluated with a different <a title="focus" class="termref" href=
"#dt-focus">focus</a> from the parent construct.<span class=
"definition">]</span></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Examples of focus-changing constructs include the instructions
<a href="#element-for-each"><code>xsl:for-each</code></a>, <a href=
"#element-iterate"><code>xsl:iterate</code></a>, and <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>; path
expressions, filter expressions, and simple mapping expressions;
and all patterns.</p>
</div>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-controlling-operand" id="dt-controlling-operand" title=
"controlling operand"></a>Within a <a title=
"focus-changing construct" class="termref" href=
"#dt-focus-changing-construct">focus-changing construct</a> there
is in many cases one <a title="operand" class="termref" href=
"#dt-operand">operand</a> whose value determines the <a title=
"focus" class="termref" href="#dt-focus">focus</a> for evaluating
other operands; this is referred to as the <b>controlling
operand</b>.<span class="definition">]</span></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>For example, the controlling operand of an <a href=
"#element-for-each"><code>xsl:for-each</code></a>, <a href=
"#element-iterate"><code>xsl:iterate</code></a>, or <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction is the expression in its <code>select</code> attribute;
the controlling operand of a filter expression <code>E[P]</code> is
<code>E</code>, and the controlling operand of a simple mapping
expression <code>A!B</code> is <code>A</code>.</p>
</div>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-controlled-operand" id="dt-controlled-operand" title=
"controlled operand"></a>Within a <a title=
"focus-changing construct" class="termref" href=
"#dt-focus-changing-construct">focus-changing construct</a> there
are one or more <a title="operand" class="termref" href=
"#dt-operand">operands</a> that are evaluated with a <a title=
"focus" class="termref" href="#dt-focus">focus</a> determined by
the <a title="controlling operand" class="termref" href=
"#dt-controlling-operand">controlling operand</a> <span>(or in some
cases such as <a href=
"#element-on-completion"><code>xsl:on-completion</code></a>, with
an <a title="absent" class="termref" href="#dt-absent">absent</a>
<a title="focus" class="termref" href=
"#dt-focus">focus</a>)</span>; these are referred to as
<b>controlled operands</b>.<span class="definition">]</span></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>For example, the main controlled operand of an <a href=
"#element-for-each"><code>xsl:for-each</code></a>, <a href=
"#element-iterate"><code>xsl:iterate</code></a>, or <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction is the contained sequence constructor; the controlled
operand of a filter expression <code>E[P]</code> is <code>P</code>,
and the controlled operand of a simple mapping expression
<code>A!B</code> is <code>B</code>.</p>
</div>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-focus-setting-container" id="dt-focus-setting-container" title=
"focus-setting container"></a>The <b>focus-setting container</b> of
a construct <var>C</var> is the innermost <a title=
"focus-changing construct" class="termref" href=
"#dt-focus-changing-construct">focus-changing construct</a>
<var>F</var> (if one exists) such that <var>C</var> is directly or
indirectly contained in a <a title="controlled operand" class=
"termref" href="#dt-controlled-operand">controlled operand</a> of
<var>F</var>. <span>If there is no such construct <var>F</var>,
then the focus-setting container is the containing <a title=
"declaration" class="termref" href=
"#dt-declaration">declaration</a>, for example an <a href=
"#element-function"><code>xsl:function</code></a> or <a href=
"#element-template"><code>xsl:template</code></a>
element.</span><span class="definition">]</span></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>For example, if an instruction appears as a child of <a href=
"#element-for-each"><code>xsl:for-each</code></a>, then its
focus-setting container is the <a href=
"#element-for-each"><code>xsl:for-each</code></a> instruction; if
an expression appears within the predicate of a filter expression,
its focus-setting container is the filter expression.</p>
</div>
</li>
</ul>
<p>The <a title="context item type" class="termref" href=
"#dt-context-item-type">context item type</a> of a construct
<var>C</var> is the first of the following that applies:</p>
<ol class="enumar">
<li>
<p>If the <a title="focus-setting container" class="termref" href=
"#dt-focus-setting-container">focus-setting container</a> of
<var>C</var> is an <a href=
"#element-function"><code>xsl:function</code></a> element, an
inline function declaration, or an <a href=
"#element-on-completion"><code>xsl:on-completion</code></a>
element, then the context item type is <code>U{}</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This is essentially an error case; expressions that depend on
the focus should not normally appear within a construct that sets
the focus to <a title="absent" class="termref" href=
"#dt-absent">absent</a>.</p>
</div>
</li>
<li>
<p>If the <a title="focus-setting container" class="termref" href=
"#dt-focus-setting-container">focus-setting container</a> of
<var>C</var> is an <a href=
"#element-stream"><code>xsl:stream</code></a> instruction, then the
context item type is <code>U{document-node()}</code>.</p>
</li>
<li>
<p>If the <a title="focus-setting container" class="termref" href=
"#dt-focus-setting-container">focus-setting container</a> of
<var>C</var> is a <a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a>, then the context item type
is the <a title="match type" class="termref" href=
"#dt-match-type">match type</a> of the match pattern of the
template rule, defined below.</p>
</li>
<li>
<p>If the <a title="focus-setting container" class="termref" href=
"#dt-focus-setting-container">focus-setting container</a> of
<var>C</var> is a <code>PredicatePattern</code>, then the context
item type is <code>U{*}</code>.</p>
</li>
<li>
<p>If the <a title="focus-setting container" class="termref" href=
"#dt-focus-setting-container">focus-setting container</a> is any
other <a title="declaration" class="termref" href=
"#dt-declaration">declaration</a>, for example a global variable
declaration, the context item type is <code>U{*}</code>.</p>
</li>
<li>
<p>Otherwise, the context item type is the <a title="static type"
class="termref" href="#dt-static-type">static type</a> (see
<a href="#determining-static-type"><i>19.2 Determining the Static
Type of a Construct</i></a>) of the <a title="controlling operand"
class="termref" href="#dt-controlling-operand">controlling
operand</a> of the <a title="focus-setting container" class=
"termref" href="#dt-focus-setting-container">focus-setting
container</a> of <var>C</var>.</p>
</li>
</ol>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-match-type" id="dt-match-type" title="match type"></a>The
<b>match type</b> of a <a title="pattern" class="termref" href=
"#dt-pattern">pattern</a> is the most specific <a title="U-type"
class="termref" href="#dt-utype">U-type</a> that is known to match
all items that the pattern can match.<span class=
"definition">]</span> The match type of a pattern is the inferred
<a title="static type" class="termref" href=
"#dt-static-type">static type</a> of the pattern's equivalent
expression, determined according to the rules in <a href=
"#determining-static-type"><i>19.2 Determining the Static Type of a
Construct</i></a>. For example, the match type of the pattern
<code>para[1]</code> is <code>U{element()}</code>, while that of
the pattern <code>@code[.='x']</code> is
<code>U{attribute()}</code></p>
</div>
<div class="div2">
<h3><a name="operand-roles" id="operand-roles"></a>19.4 <a href=
"#operand-roles" style="text-decoration: none">Operand
Roles</a></h3>
<p>An <a title="operand role" class="termref" href=
"#dt-operand-role">operand role</a> gives information about the
<a title="operand" class="termref" href="#dt-operand">operands</a>
of a particular kind of construct. The two important properties of
an operand role are the required type and the operand usage.</p>
<p>The <a title="operand usage" class="termref" href=
"#dt-operand-usage">usage</a> of an operand role is relevant only
when the value of an <a title="operand" class="termref" href=
"#dt-operand">operand</a> supplied in that role is a node, or a
sequence that contains nodes. It is one of the following:</p>
<ul>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-absorption" id="dt-absorption" title="absorption"></a>An
operand usage of <b>absorption</b> indicates that the construct
reads the subtree(s) rooted at a supplied node(s).<span class=
"definition">]</span> Examples are constructs that atomize their
<a title="operand" class="termref" href="#dt-operand">operands</a>,
or that obtain the string value of a supplied node, or that copy
the supplied node to a new tree. Another example is the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-deep-equal"><code>deep-equal</code></a><sup><small>FO30</small></sup>
function, which compares the subtrees rooted at the nodes supplied
in its first two arguments.</p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-inspection" id="dt-inspection" title="inspection"></a>An
operand usage of <b>inspection</b> indicates that the construct
accesses properties of a supplied node that are available without
reading its subtree.<span class="definition">]</span> Examples are
functions such as <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-name"><code>name</code></a><sup><small>FO30</small></sup>
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-base-uri"><code>base-uri</code></a><sup><small>FO30</small></sup>,
and the <code>instance of</code> expression which tests the type of
a node (or other item), or functions such as <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-count"><code>count</code></a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#func-exists"><code>exists</code></a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-boolean"><code>boolean</code></a><sup><small>FO30</small></sup>
which are only interested in the existence of the node, and not in
its properties.</p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-transmission" id="dt-transmission" title="transmission"></a>An
operand usage of <b>transmission</b> indicates that the construct
will (potentially) return a supplied node as part of its result to
the calling construct (that is, to its parent in the construct
tree).<span class="definition">]</span> It also indicates that
document order is preserved: if the input is in document order,
then the result must be in document order. An example is a filter
expression, where nodes in the base expression (the expression
being filtered) will typically appear in the result of the filter
expression, in their original order.</p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-navigation" id="dt-navigation" title="navigation"></a>An
operand usage of <b>navigation</b> indicates that the construct may
navigate freely from the supplied node to other nodes in the same
tree, in a way that is not constrained by the streamability
rules.<span class="definition">]</span> This covers several cases:
cases where it is known that the construct performs impermissible
navigation (for example, the <a href=
"#element-number"><code>xsl:number</code></a> instruction) or
reordering (the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-reverse"><code>reverse</code></a><sup><small>FO30</small></sup>
function), or that require look-ahead (the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-innermost"><code>innermost</code></a><sup><small>FO30</small></sup>
function) and also cases where the analysis is unable to determine
what use is made of the node, for example because it is passed as
an argument to a user-defined function, or retained in a
variable.</p>
</li>
</ul>
<p>The assignment of operand usages to each operand role of each
kind of construct is defined in <a href=
"#classifying-constructs"><i>19.8 Classifying
Constructs</i></a>.</p>
<div class="div3">
<h4><a name="operand-usage-examples" id=
"operand-usage-examples"></a>19.4.1 <a href=
"#operand-usage-examples" style="text-decoration: none">Examples
showing the Effect of Operand Usage</a></h4>
<div class="example">
<div class="exampleHeader"><a name="d7e44868" id=
"d7e44868"></a>Example: The Effect of Operand Usage on the
Streamability of a Context Item Expression</div>
<p>Consider the following construct:</p>
<div class="exampleInner">
<pre>
&lt;xsl:stream href="emps.xml"&gt;
  &lt;xsl:for-each select="*/emp"&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:stream&gt;
</pre></div>
<p>To assess the streamability, we follow the following logic:</p>
<ol class="enumar">
<li>
<p>The top-level construct is a <a title="sequence constructor"
class="termref" href="#dt-sequence-constructor">sequence
constructor</a>. It is evaluated with a document node as the
context item, and with a <a title="striding" class="termref" href=
"#dt-striding">striding</a> posture.</p>
</li>
<li>
<p>The sequence constructor has one child <a title="instruction"
class="termref" href="#dt-instruction">instruction</a>, which has
an <a title="operand usage" class="termref" href=
"#dt-operand-usage">operand usage</a> of <a title="transmission"
class="termref" href="#dt-transmission">transmission</a>.</p>
</li>
<li>
<p>The <a href="#element-for-each"><code>xsl:for-each</code></a>
instruction evaluates its <code>select</code> expression, with the
context item and <a title="posture" class="termref" href=
"#dt-posture">posture</a> unchanged.</p>
</li>
<li>
<p>The step <code>child::*</code> is evaluated with this context
item and posture. The posture transition rules permit this; we now
have a sequence of child elements, and still a <a title="striding"
class="termref" href="#dt-striding">striding</a> posture.</p>
</li>
<li>
<p>The same applies to the next step, <code>child::emp</code></p>
</li>
<li>
<p>The content of the <a href=
"#element-for-each"><code>xsl:for-each</code></a> instruction is a
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> which itself
has a single <a title="operand" class="termref" href=
"#dt-operand">operand</a>, the <a href=
"#element-value-of"><code>xsl:value-of</code></a> instruction.</p>
</li>
<li>
<p>The <a href="#element-value-of"><code>xsl:value-of</code></a>
instruction is evaluated once for each <code>emp</code> child, with
that child as context item and in a <a title="striding" class=
"termref" href="#dt-striding">striding</a> posture. This
instruction uses the <a title="general streamability rules" class=
"termref" href="#dt-general-streamability-rules">general
streamability rules</a>. The <a title="operand usage" class=
"termref" href="#dt-operand-usage">operand usage</a> of the
<code>select</code> expression is <a title="absorption" class=
"termref" href="#dt-absorption">absorption</a>. This means that the
result of the <a href=
"#element-value-of"><code>xsl:value-of</code></a> instruction is
<a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> and <a title="consuming" class=
"termref" href="#dt-consuming">consuming</a>.</p>
</li>
<li>
<p>The result of the trivial sequence constructor contained in the
<a href="#element-for-each"><code>xsl:for-each</code></a>
instruction is therefore <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> and <a title="consuming" class=
"termref" href="#dt-consuming">consuming</a></p>
</li>
<li>
<p>The result of the <a href=
"#element-for-each"><code>xsl:for-each</code></a> instruction (see
<a href="#streamability-xsl-for-each"><i>19.8.4.18 Streamability of
xsl:for-each</i></a>) is therefore <a title="grounded" class=
"termref" href="#dt-grounded">grounded</a> and <a title="consuming"
class="termref" href="#dt-consuming">consuming</a></p>
</li>
<li>
<p>The result of the trivial sequence constructor contained in the
<a href="#element-stream"><code>xsl:stream</code></a> instruction
is therefore <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> and <a title="consuming" class=
"termref" href="#dt-consuming">consuming</a></p>
</li>
<li>
<p>The <a href="#element-stream"><code>xsl:stream</code></a>
instruction is therefore <a title="guaranteed-streamable" class=
"termref" href=
"#dt-guaranteed-streamable">guaranteed-streamable</a>.</p>
</li>
</ol>
<p>Now consider a slightly different construct:</p>
<div class="exampleInner">
<pre>
&lt;xsl:stream href="emps.xml"&gt;
  &lt;xsl:for-each select="*/emp"&gt;
    &lt;xsl:sequence select="."/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:stream&gt;
</pre></div>
<p>To assess the streamability, we follow the following logic:</p>
<ol class="enumar">
<li>
<p>The top-level construct is a <a title="sequence constructor"
class="termref" href="#dt-sequence-constructor">sequence
constructor</a>. It is evaluated with a document node as the
context item, and with a <a title="striding" class="termref" href=
"#dt-striding">striding</a> posture.</p>
</li>
<li>
<p>The sequence constructor has one child <a title="instruction"
class="termref" href="#dt-instruction">instruction</a>, which has
an <a title="operand usage" class="termref" href=
"#dt-operand-usage">operand usage</a> of <a title="transmission"
class="termref" href="#dt-transmission">transmission</a>.</p>
</li>
<li>
<p>The <a href="#element-for-each"><code>xsl:for-each</code></a>
instruction evaluates its <code>select</code> expression, with the
context item and <a title="posture" class="termref" href=
"#dt-posture">posture</a> unchanged.</p>
</li>
<li>
<p>The step <code>child::*</code> is evaluated with this context
item and posture. The posture transition rules permit this; we now
have a sequence of child elements, and still a <a title="striding"
class="termref" href="#dt-striding">striding</a> posture.</p>
</li>
<li>
<p>The same applies to the next step, <code>child::emp</code></p>
</li>
<li>
<p>The content of the <a href=
"#element-for-each"><code>xsl:for-each</code></a> instruction is a
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> which itself
has a single operand, the <a href=
"#element-sequence"><code>xsl:sequence</code></a> instruction.</p>
</li>
<li>
<p>The <a href="#element-sequence"><code>xsl:sequence</code></a>
instruction is evaluated once for each <code>emp</code> child, with
that child as context item and in a <a title="striding" class=
"termref" href="#dt-striding">striding</a> posture. This
instruction uses the <a title="general streamability rules" class=
"termref" href="#dt-general-streamability-rules">general
streamability rules</a>. The <a title="operand usage" class=
"termref" href="#dt-operand-usage">operand usage</a> of the
<code>select</code> expression is <a title="transmission" class=
"termref" href="#dt-transmission">transmission</a>. This means that
the result of the <a href=
"#element-sequence"><code>xsl:sequence</code></a> instruction is
<a title="striding" class="termref" href=
"#dt-striding">striding</a> and <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>.</p>
</li>
<li>
<p>The result of the trivial sequence constructor contained in the
<a href="#element-for-each"><code>xsl:for-each</code></a>
instruction is therefore also <a title="striding" class="termref"
href="#dt-striding">striding</a> and <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>.</p>
</li>
<li>
<p>The result of the <a href=
"#element-for-each"><code>xsl:for-each</code></a> instruction (see
<a href="#streamability-xsl-for-each"><i>19.8.4.18 Streamability of
xsl:for-each</i></a>) is therefore <a title="striding" class=
"termref" href="#dt-striding">striding</a> and <span><a title=
"consuming" class="termref" href="#dt-consuming">consuming</a> (the
wider of the sweeps of the <code>select</code> expression and the
sequence constructor)</span>.</p>
</li>
<li>
<p>The result of the trivial sequence constructor contained in the
<a href="#element-stream"><code>xsl:stream</code></a> instruction
is therefore <a title="striding" class="termref" href=
"#dt-striding">striding</a> and <span><a title="consuming" class=
"termref" href="#dt-consuming">consuming</a></span>.</p>
</li>
<li>
<p><span>Since the result is not <a title="grounded" class=
"termref" href="#dt-grounded">grounded</a>,</span> the <a href=
"#element-stream"><code>xsl:stream</code></a> instruction is
therefore not <a title="guaranteed-streamable" class="termref"
href="#dt-guaranteed-streamable">guaranteed-streamable</a>.</p>
</li>
</ol>
<p>Expressed informally, the result of an <a href=
"#element-stream"><code>xsl:stream</code></a> instruction (or of a
streamable template rule) must not contain streamed nodes. The
reason for this is that once streamed nodes are returned to
constructs that are not declared streamable and therefore have no
streamability constraints, there is no way to analyze what happens
to them, and thus to guarantee streamability.</p>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e45137" id=
"d7e45137"></a>Example: The Effect of Operand Roles on the
Streamability of Path Expressions</div>
<p>Consider the expression <code>.//chapter</code>.</p>
<p>When this appears as an argument to the function <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-count"><code>count</code></a><sup><small>FO30</small></sup>
or <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-exists"><code>exists</code></a><sup><small>FO30</small></sup>,
it can be streamed (it is a <a title="consuming" class="termref"
href="#dt-consuming">consuming</a> expression, meaning that the
subtree rooted at the context item needs to be read in order to
evaluate the expression). A possible strategy for performing a
streamed evaluation is to read all descendants of the context item
in document order, checking each one to see whether its name is
<code>chapter</code>. The <a title="sweep" class="termref" href=
"#dt-sweep">sweep</a> of the expression will be <a title=
"consuming" class="termref" href="#dt-consuming">consuming</a>, and
its <a title="posture" class="termref" href=
"#dt-posture">posture</a> will be <a title="crawling" class=
"termref" href="#dt-crawling">crawling</a>.</p>
<p>The <a title="operand usage" class="termref" href=
"#dt-operand-usage">operand usage</a> (the usage of the argument to
<a href=
"http://www.w3.org/TR/xpath-functions-30/#func-count"><code>count</code></a><sup><small>FO30</small></sup>
or <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-exists"><code>exists</code></a><sup><small>FO30</small></sup>)
is defined as <a title="inspection" class="termref" href=
"#dt-inspection">inspection</a>. The <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>
show that when the posture of an <a title="operand" class="termref"
href="#dt-operand">operand</a> is <a title="crawling" class=
"termref" href="#dt-crawling">crawling</a> and the <a title=
"operand usage" class="termref" href="#dt-operand-usage">operand
usage</a> is <a title="inspection" class="termref" href=
"#dt-inspection">inspection</a>, the resulting expression is
<span><a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> and <a title="consuming" class=
"termref" href="#dt-consuming">consuming</a>. This means that (in
the absence of other consuming expressions) the containing template
or function will generally be streamable.</span>.</p>
<p>In the expression <code>tail(.//chapter)</code>, the <a title=
"operand usage" class="termref" href="#dt-operand-usage">operand
usage</a> is classified as <a title="transmission" class="termref"
href="#dt-transmission">transmission</a>, meaning that the nodes
are simply passed up the tree to the next containing expression. In
general, when a <a title="crawling" class="termref" href=
"#dt-crawling">crawling</a> expression is passed as an argument and
the operand role is <a title="transmission" class="termref" href=
"#dt-transmission">transmission</a>, the containing expression will
also be <a title="crawling" class="termref" href=
"#dt-crawling">crawling</a>. However, there is an exception where
the expression is known to deliver a singleton (for example,
<code>head(.//chapter)</code>). In this case the returned sequence
cannot contain any nested nodes, so it is <a title="crawling"
class="termref" href="#dt-crawling">crawling</a>.</p>
<p>When the same expression appears as an argument to an atomizing
function <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-string-join"><code>string-join</code></a><sup><small>FO30</small></sup>,
the processor knows that it will need to access the subtree of each
selected <code>section</code> element in order to compute the
result of the function (the argument to <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-string-join"><code>string-join</code></a><sup><small>FO30</small></sup>
is classified as having <a title="operand usage" class="termref"
href="#dt-operand-usage">operand usage</a> <a title="absorption"
class="termref" href="#dt-absorption">absorption</a>). The
processor does not know whether these subtrees will be
<span>nested</span> (one <code>section</code> might contain
another). <span>In most cases they will not be nested, because
atomizing a sequence that contains nested nodes is not generally a
useful thing to do. The streamability analysis therefore makes an
optimistic assumption, by treating atomization of a <a title=
"crawling" class="termref" href="#dt-crawling">crawling</a>
expression as a streamable operation. In the worst case, where it
turns out that the selected nodes are indeed nested, the processor
must handle this, typically by buffering the content of inner nodes
until the end tag of the outer nodes is reached.</span></p>
<p>This treatment of nodes in a <a title="crawling" class="termref"
href="#dt-crawling">crawling</a> expression applies to all cases in
which the content of the nodes is handled in a way defined entirely
by the rules of this specification: for example, operations such as
atomization, obtaining the string value of nodes, deep copy of
nodes, and the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-deep-equal"><code>deep-equal</code></a><sup><small>FO30</small></sup>
function. It does not extend to cases where the processing applied
to the nodes is user-defined: for example, operations such as
<a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href="#element-for-each"><code>xsl:for-each</code></a>, or
<a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>. In
these cases, the nodes selected for processing must not be nested
(a <a title="crawling" class="termref" href=
"#dt-crawling">crawling</a> is not permitted in these
contexts).</p>
<p>When a <a title="crawling" class="termref" href=
"#dt-crawling">crawling</a> expression appears as an argument to a
call on a user-defined function, there are several cases to
consider:</p>
<ol class="enumar">
<li>
<p>If the declared type of the relevant argument is an atomic type,
then the nodes will be atomized; this is treated just like a call
on an atomizing built-in function such as <code>string-join</code>,
discussed above.</p>
</li>
<li>
<p>If the user-defined function is declared streamable and is not
recursive, then the streamability of the function call depends on
an analysis of the function body of the target function, as
described in <a href=
"#streamability-of-function-calls"><i>19.8.7.12 Streamability of
Function Calls</i></a>.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="div2">
<h3><a name="posture" id="posture"></a>19.5 <a href="#posture"
style="text-decoration: none">Determining the Posture of a
Construct</a></h3>
<p>The <b>posture</b> of a construct indicates the relationship of
the nodes selected by the <a title="construct" class="termref"
href="#dt-construct">construct</a> to a <a title=
"streamed document" class="termref" href=
"#dt-streamed-document">streamed input document</a>. The value is
one of the following:</p>
<ul>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-grounded" id="dt-grounded" title=
"grounded"></a><b>Grounded</b>: indicates that the value returned
by the construct does not contain nodes from the streamed input
document<span class="definition">]</span>. Atomic values and
function items are always grounded; nodes are grounded if it is
known that they are in a non-streamed document. For example the
expressions <code>doc('x')</code> and <code>copy-of(.)</code> both
return grounded nodes.</p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-climbing" id="dt-climbing" title=
"climbing"></a><b>Climbing</b>: indicates that nodes returned by
the construct are reached by navigating the parent,
ancestor[-or-self], attribute, and/or namespace axes from the node
at the current streaming position.<span class="definition">]</span>
When the <span><a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a></span> is climbing, use
of certain axes such as <code>parent</code> and
<code>ancestor</code> is permitted, but use of other axes such as
<code>child</code> or <code>descendant</code> violates the
streamability rules.</p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-crawling" id="dt-crawling" title=
"crawling"></a><b>Crawling</b>: typically indicates that nodes
returned by a construct are reached by navigating the
descendant[-or-self] axis.<span class="definition">]</span> Nodes
reached in this way <span>are potentially nested (one might be an
ancestor of another)</span>, so further downward navigation is not
permitted. <span>Expressions that can be statically determined to
return a singleton node (for example <code>head(.//title)</code>)
generate a result with no <span>such nesting</span>, so they are
striding rather than crawling.</span></p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-striding" id="dt-striding" title=
"striding"></a><b>Striding</b>: indicates that the result of a
construct is a sequence of nodes, in document order, that are peers
in the sense that none of them is an ancestor or descendant of any
other.<span class="definition">]</span> This is typically achieved
by using one or more steps involving the child axis only. Use of
the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-outermost"><code>outermost</code></a><sup><small>FO30</small></sup>
function can also result in a striding posture, <span>as can
functions such as <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-head"><code>head</code></a><sup><small>FO30</small></sup>
or <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-zero-or-one"><code>zero-or-one</code></a><sup><small>FO30</small></sup>
that ensure the result will be a singleton node.</span></p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-roaming" id="dt-roaming" title="roaming"></a><b>Roaming</b>:
indicates that the nodes returned by an expression could be
anywhere in the tree, which inevitably means that the construct
cannot be evaluated using streaming.<span class=
"definition">]</span> For example, the <a title="posture" class=
"termref" href="#dt-posture">posture</a> of an axis step using the
<code>following</code> or <code>preceding</code> axis will
typically be <a title="roaming" class="termref" href=
"#dt-roaming">roaming</a>, which leads the analysis to conclude
that the construct is not streamable.</p>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>One way to think about the posture values is as labels for
states in a finite state automaton, where the alphabet of symbols
accepted by the automaton is the set of 13 XPath axes, and the
sentence being parsed is a path expression containing a sequence of
axis steps. For example, use of the <code>descendant</code> axis
when the current state is <b>striding</b> moves the new state to
<b>crawling</b>, and use of the <code>parent</code> axis then takes
it to <b>climbing</b>.</p>
</div>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> of a construct is determined in one of
several ways:</p>
<ul>
<li>
<p>For axis steps, the posture of the expression is determined by
the <span><a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a></span> and the choice of
axis. For example, an axis step using the ancestor axis always has
a posture of <a title="climbing" class="termref" href=
"#dt-climbing">climbing</a>, while an axis step using the child
axis, if the <span><a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a></span> is <a title=
"striding" class="termref" href="#dt-striding">striding</a>, will
itself have a posture of <a title="striding" class="termref" href=
"#dt-striding">striding</a>. The rules for the posture transitions
produced by axis steps are given in <a href=
"#streamability-of-axis-steps"><i>19.8.7.7 Streamability of Axis
Steps</i></a>.</p>
</li>
<li>
<p>For many other constructs, the posture is determined by the
<a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
These determine the result posture in terms of the <a title=
"operand" class="termref" href="#dt-operand">operands</a> of the
construct and the way in which each operand is used. For example, a
construct that accepts a streamed node as the value of an operand,
and atomizes that node, will generally have a posture of <a title=
"grounded" class="termref" href="#dt-grounded">grounded</a>.</p>
</li>
<li>
<p>Other constructs have their own special rules, which are all
listed in this chapter. For example, a call on the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-root"><code>root</code></a><sup><small>FO30</small></sup>
function behaves analogously to an axis step, and is described in
<a href="#streamability-fn-root"><i>19.8.8.18 Streamability of the
root function</i></a>. Special rules are needed for:</p>
<ul>
<li>
<p>Constructs that evaluate an <a title="operand" class="termref"
href="#dt-operand">operand</a> more than once, such as an XPath
<code>for</code> expression;</p>
</li>
<li>
<p>Constructs that have alternatives among their operands, such as
an XPath <code>if</code> expression;</p>
</li>
<li>
<p>Constructs that navigate relative to the context item, such as
axis steps;</p>
</li>
<li>
<p>Constructs with implicit inputs, such as the context item
expression <code>.</code> (dot);</p>
</li>
<li>
<p>Constructs that change the focus, such as a filter
expression;</p>
</li>
<li>
<p>Constructs that invoke functions or templates.</p>
</li>
</ul>
</li>
</ul>
</div>
<div class="div2">
<h3><a name="determining-context-posture" id=
"determining-context-posture"></a>19.6 <a href=
"#determining-context-posture" style=
"text-decoration: none">Determining the Context Posture</a></h3>
<p>In the same way as the type of the context item can be
determined for any construct C by reference to the type of the
construct that establishes the context for the evaluation of C, so
the posture of the context item C can be determined by reference to
the posture of the construct that establishes the context.</p>
<p>The <a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a> of a construct
<var>C</var> is the first of the following that applies:</p>
<ol class="enumar">
<li>
<p>If the <a title="focus-setting container" class="termref" href=
"#dt-focus-setting-container">focus-setting container</a> of
<var>C</var> is an <a href=
"#element-function"><code>xsl:function</code></a> declaration, an
inline function declaration, or an <a href=
"#element-on-completion"><code>xsl:on-completion</code></a>
element, then the context posture is <a title="roaming" class=
"termref" href="#dt-roaming">roaming</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This is essentially an error case; expressions that depend on
the context item should not normally appear within these
constructs.</p>
</div>
</li>
<li>
<p>If the <a title="focus-setting container" class="termref" href=
"#dt-focus-setting-container">focus-setting container</a> of
<var>C</var> is an <a href=
"#element-stream"><code>xsl:stream</code></a> instruction, then the
context posture is <a title="striding" class="termref" href=
"#dt-striding">striding</a>.</p>
</li>
<li>
<p>If the <a title="focus-setting container" class="termref" href=
"#dt-focus-setting-container">focus-setting container</a> of
<var>C</var> is a <a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a> whose mode is declared with
<code>streamable="yes"</code>, then the context posture is
<a title="striding" class="termref" href=
"#dt-striding">striding</a>.</p>
</li>
<li>
<p>If the <a title="focus-setting container" class="termref" href=
"#dt-focus-setting-container">focus-setting container</a> of
<var>C</var> is a <a title="pattern" class="termref" href=
"#dt-pattern">pattern</a>, then the context posture is <a title=
"striding" class="termref" href="#dt-striding">striding</a>.</p>
</li>
<li>
<p>If the <a title="focus-setting container" class="termref" href=
"#dt-focus-setting-container">focus-setting container</a> of
<var>C</var> is an <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a>
declaration with the attribute <code>streamable="yes"</code>, then
the context posture is <a title="striding" class="termref" href=
"#dt-striding">striding</a>.</p>
</li>
<li>
<p>If the <a title="focus-setting container" class="termref" href=
"#dt-focus-setting-container">focus-setting container</a> is any
other <a title="declaration" class="termref" href=
"#dt-declaration">declaration</a>, for example a global variable
declaration, a <a title="named template" class="termref" href=
"#dt-named-template">named template</a>, or a template rule or
attribute set that does not specify <code>streamable="yes"</code>,
then the context posture is <a title="roaming" class="termref"
href="#dt-roaming">roaming</a>.</p>
</li>
<li>
<p>Otherwise, the context posture is the <a title="posture" class=
"termref" href="#dt-posture">posture</a> of the <a title=
"controlling operand" class="termref" href=
"#dt-controlling-operand">controlling operand</a> of the <a title=
"focus-setting container" class="termref" href=
"#dt-focus-setting-container">focus-setting container</a> of
<var>C</var>.</p>
</li>
</ol>
</div>
<div class="div2">
<h3><a name="sweep" id="sweep"></a>19.7 <a href="#sweep" style=
"text-decoration: none">The Sweep of a Construct</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-sweep" id="dt-sweep" title="sweep"></a>Every construct has a
<b>sweep</b>, which is a measure of the extent to which the current
position in the input stream moves during the evaluation of the
expression. The sweep is one of: <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>, <a title=
"consuming" class="termref" href="#dt-consuming">consuming</a>, or
<a title="free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a> .<span class=
"definition">]</span> This list of values is ordered: a <a title=
"free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a> expression has <b>wider
sweep</b> than a <a title="consuming" class="termref" href=
"#dt-consuming">consuming</a> expression, which has <b>wider
sweep</b> than a <a title="motionless" class="termref" href=
"#dt-motionless">motionless</a> expression.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-motionless" id="dt-motionless" title="motionless"></a>A
<b>motionless</b> construct is any <a title="construct" class=
"termref" href="#dt-construct">construct</a> deemed motionless by
the rules in this section (<a href="#streamability"><i>19
Streamability</i></a>).<span class="definition">]</span>
Informally, a motionless construct is one that can be evaluated
without changing the current position in the input stream.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The context item expression <code>.</code> is classified as
motionless; however a construct that uses <code>.</code> as an
<a title="operand" class="termref" href="#dt-operand">operand</a>
(for example, <code>string(.)</code>) might be <a title="consuming"
class="termref" href="#dt-consuming">consuming</a>. The
streamability rules effectively consider expressions such as
<code>.</code> within the context of the containing construct.</p>
</div>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-consuming" id="dt-consuming" title="consuming"></a>A
<b>consuming</b> construct is any <a title="construct" class=
"termref" href="#dt-construct">construct</a> deemed consuming by
the rules in this section (<a href="#streamability"><i>19
Streamability</i></a>).<span class="definition">]</span>
Informally, a consuming construct is one whose evaluation requires
repositioning of the input stream from the start of the current
node to the end of the current node.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-free-ranging" id="dt-free-ranging" title="free-ranging"></a>A
<b>free-ranging</b> construct is any <a title="construct" class=
"termref" href="#dt-construct">construct</a> deemed free-ranging by
the rules in this section (<a href="#streamability"><i>19
Streamability</i></a>).<span class="definition">]</span>
Informally, a free-ranging construct is one whose evaluation may
require access to information that is not available from the
subtree rooted at the current node, together with information about
ancestors of the current node and their attributes.</p>
<p>Not all combinations of <a title="sweep" class="termref" href=
"#dt-sweep">sweep</a> and <a title="posture" class="termref" href=
"#dt-posture">posture</a> are possible. The table below shows
examples of expressions for each valid combination; table cells
marked "N/A" represent combinations that do not arise.</p>
<table summary="Combinations of Sweep and Posture" border="1"
cellpadding="5" width="100%">
<thead>
<tr>
<th colspan="1" align="left" valign="top"></th>
<th colspan="1" align="left" valign="top">Motionless</th>
<th colspan="1" align="left" valign="top">Consuming</th>
<th colspan="1" align="left" valign="top">Free-Ranging</th>
</tr>
</thead>
<tbody>
<tr>
<th colspan="1" align="left" valign="top">Grounded</th>
<td align="left" valign="top"><code>name()</code></td>
<td align="left" valign="top"><code>string(title)</code></td>
<td align="left" valign="top"><code>count(preceding::*)</code></td>
</tr>
<tr>
<th colspan="1" align="left" valign="top">Climbing</th>
<td align="left" valign="top"><code>@status</code></td>
<td align="left" valign="top"><code>N/A</code></td>
<td align="left" valign="top"><code>N/A</code></td>
</tr>
<tr>
<th colspan="1" align="left" valign="top">Striding</th>
<td align="left" valign="top"><code>self::node()</code></td>
<td align="left" valign="top"><code>child::*</code></td>
<td align="left" valign="top">N/A</td>
</tr>
<tr>
<th colspan="1" align="left" valign="top">Crawling</th>
<td align="left" valign="top">The subexpression <code>.</code> in
<code>//a/.</code></td>
<td align="left" valign="top"><code>descendant::*</code></td>
<td align="left" valign="top">N/A</td>
</tr>
<tr>
<th colspan="1" align="left" valign="top">Roaming</th>
<td align="left" valign="top">The predicate <code>.</code> in
<code>preceding::*/.</code></td>
<td align="left" valign="top">N/A</td>
<td align="left" valign="top">preceding::*</td>
</tr>
</tbody>
</table>
</div>
<div class="div2">
<h3><a name="classifying-constructs" id=
"classifying-constructs"></a>19.8 <a href="#classifying-constructs"
style="text-decoration: none">Classifying Constructs</a></h3>
<p>This section defines the properties of every kind of <a title=
"construct" class="termref" href="#dt-construct">construct</a> that
may appear in a <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a>. It identifies the <a title=
"operand role" class="termref" href="#dt-operand-role">operand
roles</a> and their <a title="operand usage" class="termref" href=
"#dt-operand-usage">usage</a>, and it gives the rules that define
the <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of the construct. In cases where the
<a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>
apply, there is still an entry for the construct in order to define
its <a title="operand" class="termref" href=
"#dt-operand">operands</a> and their usages, since this information
is needed by the general rules.</p>
<p>The following sections describe this categorization for each
kind of construct:</p>
<ul>
<li>
<p>Sequence constructors: see <a href=
"#classifying-sequence-constructors"><i>19.8.3 Classifying Sequence
Constructors</i></a></p>
</li>
<li>
<p>Instructions: see <a href="#classifying-instructions"><i>19.8.4
Classifying Instructions</i></a></p>
</li>
<li>
<p>Attribute sets: see <a href=
"#classifying-attribute-sets"><i>19.8.5 Classifying Attribute
Sets</i></a></p>
</li>
<li>
<p>Value templates: see <a href="#classifying-vts"><i>19.8.6
Classifying Value Templates</i></a></p>
</li>
<li>
<p>Expressions: see <a href="#classifying-expressions"><i>19.8.7
Classifying Expressions</i></a></p>
</li>
<li>
<p>Patterns: see <a href="#classifying-patterns"><i>19.8.9
Classifying Patterns</i></a></p>
</li>
<li>
<p>Calls to built-in functions: see <a href=
"#classifying-built-in-functions"><i>19.8.8 Classifying Calls to
Built-In Functions</i></a></p>
</li>
</ul>
<div class="div3">
<h4><a name="general-streamability-rules" id=
"general-streamability-rules"></a>19.8.1 <a href=
"#general-streamability-rules" style=
"text-decoration: none">General Rules for Streamability</a></h4>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-general-streamability-rules" id=
"dt-general-streamability-rules" title=
"general streamability rules"></a>Many <a title="construct" class=
"termref" href="#dt-construct">constructs</a> share the same
streamability rules. These rules, referred to as the <b>general
streamability rules</b>, are defined here.<span class=
"definition">]</span></p>
<p>Examples of constructs that use these rules are: an arithmetic
expression, an <a title="attribute value template" class="termref"
href="#dt-attribute-value-template">attribute value template</a>, a
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>, the <a href=
"#element-value-of"><code>xsl:value-of</code></a> instruction, and
a call to the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>
function.</p>
<p>The rules determine both the <a title="posture" class="termref"
href="#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of a construct. To determine the posture
and sweep of a construct <var>C</var>, assuming these general rules
are applicable to that kind of construct:</p>
<ol class="enumar">
<li>
<p>For each <a title="operand" class="termref" href=
"#dt-operand">operand</a> of <var>C</var>:</p>
<ol class="enumla">
<li>
<p>Establish:</p>
<ol class="enumlr">
<li>
<p>The <a title="static type" class="termref" href=
"#dt-static-type">static type</a> <var>T</var> of the operand (see
<a href="#determining-static-type"><i>19.2 Determining the Static
Type of a Construct</i></a>).</p>
</li>
<li>
<p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a>
<var>S</var> and <a title="posture" class="termref" href=
"#dt-posture">posture</a> <var>P</var> of the operand (by applying
the rules in this section <span><a href=
"#classifying-constructs"><i>19.8 Classifying
Constructs</i></a></span> to that operand, recursively).</p>
</li>
<li>
<p>The <a title="operand usage" class="termref" href=
"#dt-operand-usage">operand usage</a> <var>U</var> corresponding to
the <a title="operand role" class="termref" href=
"#dt-operand-role">role</a> of the operand within <var>C</var>
(from the information in this section <span><a href=
"#classifying-constructs"><i>19.8 Classifying
Constructs</i></a></span>).</p>
</li>
</ol>
</li>
<li>
<p>Compute the adjusted sweep <var>S'</var> of the <a title=
"operand" class="termref" href="#dt-operand">operand</a> by taking
the first of the following that applies:</p>
<ol class="enumlr">
<li>
<p>If <var>S</var> is <a title="free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a> or <var>P</var> is <a title=
"roaming" class="termref" href="#dt-roaming">roaming</a>, then
<var>S'</var> is <a title="free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>. (In this case the posture and
sweep of <var>C</var> are <a title="roaming" class="termref" href=
"#dt-roaming">roaming</a> and <a title="free-ranging" class=
"termref" href="#dt-free-ranging">free-ranging</a>, regardless of
any other operands.)</p>
</li>
<li>
<p>If <var>P</var> is <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a>, then <var>S'</var> is
<var>S</var>.</p>
</li>
<li>
<p>Otherwise (<var>P</var> is not <a title="grounded" class=
"termref" href="#dt-grounded">grounded</a>, which implies that the
<a title="operand" class="termref" href="#dt-operand">operand</a>
is <span>capable of</span> returning streamed nodes), compute
<var>S'</var> as follows:</p>
<ol class="enumua">
<li>
<p>Compute the adjusted usage <var>U'</var> as follows:</p>
<ol class="enumur">
<li>
<p>If <var>U</var> is <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a> and <span>the intersection of
<var>T</var> with <var>U{element(), document-node()}</var> is
<var>U{}</var> (that is, if <var>T</var> is a type that does not
allow nodes with children)</span>, then <var>U'</var> is <a title=
"inspection" class="termref" href=
"#dt-inspection">inspection</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This is because the entire subtree of nodes such as text nodes
is available without reading further data from the input
stream.</p>
</div>
</li>
<li>
<p>Otherwise, <var>U'</var> is <var>U</var>.</p>
</li>
</ol>
</li>
<li>
<p>Compute the adjusted <a title="sweep" class="termref" href=
"#dt-sweep">sweep</a> <var>S'</var> from the table below:</p>
<table summary="Computing the Adjusted Sweep of an Expression"
border="1" cellpadding="5" width="100%">
<thead>
<tr>
<th rowspan="2" colspan="1" align="left" valign="top">Posture
(P)</th>
<th colspan="4" align="left" valign="top">Adjusted Usage (U')</th>
</tr>
<tr>
<th colspan="1" align="left" valign="top">Absorption</th>
<th colspan="1" align="left" valign="top">Inspection</th>
<th colspan="1" align="left" valign="top">Transmission</th>
<th colspan="1" align="left" valign="top">Navigation</th>
</tr>
</thead>
<tbody>
<tr>
<th colspan="1" align="left" valign="top">Climbing</th>
<td align="left" valign="top">Free-ranging</td>
<td align="left" valign="top"><var>S</var></td>
<td align="left" valign="top"><var>S</var></td>
<td align="left" valign="top">Free-ranging</td>
</tr>
<tr>
<th colspan="1" align="left" valign="top">Striding</th>
<td align="left" valign="top">Consuming</td>
<td align="left" valign="top"><var>S</var></td>
<td align="left" valign="top"><var>S</var></td>
<td align="left" valign="top">Free-ranging</td>
</tr>
<tr>
<th colspan="1" align="left" valign="top">Crawling</th>
<td align="left" valign="top"><span>Consuming</span></td>
<td align="left" valign="top"><var>S</var></td>
<td align="left" valign="top"><var>S</var></td>
<td align="left" valign="top">Free-ranging</td>
</tr>
</tbody>
</table>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-potentially-consuming" id="dt-potentially-consuming" title=
"potentially consuming"></a>An <a title="operand" class="termref"
href="#dt-operand">operand</a> is <b>potentially consuming</b> if
either or both of the following conditions applies:<span class=
"definition">]</span></p>
<ol class="enumlr">
<li>
<p>The operand's adjusted <a title="sweep" class="termref" href=
"#dt-sweep">sweep</a> <var>S'</var> is <a title="consuming" class=
"termref" href="#dt-consuming">consuming</a>.</p>
</li>
<li>
<p>The <a title="operand usage" class="termref" href=
"#dt-operand-usage">operand usage</a> is <a title="transmission"
class="termref" href="#dt-transmission">transmission</a> and the
operand is not <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a>.</p>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p>Having computed the adjusted sweep <var>S'(o)</var> of each
<a title="operand" class="termref" href="#dt-operand">operand</a>
<var>o</var>, the <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <var>C</var> are the first of the
following that applies:</p>
<ol class="enumla">
<li>
<p>If <var>C</var> has no operands, then <a title="grounded" class=
"termref" href="#dt-grounded">grounded</a> and <a title=
"motionless" class="termref" href=
"#dt-motionless">motionless</a>.</p>
</li>
<li>
<p>If any operand <var>o</var> has an adjusted sweep
<var>S'(o)</var> of <a title="free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>, then <a title="roaming" class=
"termref" href="#dt-roaming">roaming</a> and <a title=
"free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>.</p>
</li>
<li>
<p>If more than one operand <span>is <a title=
"potentially consuming" class="termref" href=
"#dt-potentially-consuming">potentially consuming</a></span>,
then:</p>
<ol class="enumlr">
<li>
<p>If all these operands form part of a <a title=
"choice operand group" class="termref" href=
"#dt-choice-operand-group">choice operand group</a>, then the
<a title="posture" class="termref" href="#dt-posture">posture</a>
of <var>C</var> is the <a title="combined posture" class="termref"
href="#dt-combined-posture">combined posture</a> of the operands in
this group, and the <a title="sweep" class="termref" href=
"#dt-sweep">sweep</a> of <var>C</var> is the widest <a title=
"sweep" class="termref" href="#dt-sweep">sweep</a> of the operands
in this group</p>
</li>
<li>
<p>Otherwise, <a title="roaming" class="termref" href=
"#dt-roaming">roaming</a> and <a title="free-ranging" class=
"termref" href="#dt-free-ranging">free-ranging</a>.</p>
</li>
</ol>
</li>
<li>
<p>If exactly one operand <var>o</var> <span>is <a title=
"potentially consuming" class="termref" href=
"#dt-potentially-consuming">potentially consuming</a></span>,
then:</p>
<ol class="enumlr">
<li>
<p>If <var>o</var> is a <a title="higher-order operand" class=
"termref" href="#dt-higher-order-operand">higher-order operand</a>
of <var>C</var>, then <a title="roaming" class="termref" href=
"#dt-roaming">roaming</a> and <a title="free-ranging" class=
"termref" href="#dt-free-ranging">free-ranging</a>.</p>
</li>
<li>
<p>If the <a title="operand usage" class="termref" href=
"#dt-operand-usage">operand usage</a> of <var>o</var> is <a title=
"absorption" class="termref" href="#dt-absorption">absorption</a>
or <a title="inspection" class="termref" href=
"#dt-inspection">inspection</a>, then <a title="grounded" class=
"termref" href="#dt-grounded">grounded</a> and <a title="consuming"
class="termref" href="#dt-consuming">consuming</a>.</p>
</li>
<li>
<p>If the <a title="posture" class="termref" href=
"#dt-posture">posture</a> of <var>o</var> is <a title="crawling"
class="termref" href="#dt-crawling">crawling</a> and <var>C</var>
is a function call of a <span>built-in</span> function whose
signature indicates a return type with a maximum cardinality of one
then <a title="striding" class="termref" href=
"#dt-striding">striding</a> and the adjusted <a title="sweep"
class="termref" href="#dt-sweep">sweep</a> of <var>o</var>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Although this rule is written in general terms, the only
functions that it applies to (at the time of publication) are
<a href=
"http://www.w3.org/TR/xpath-functions-30/#func-head"><code>head</code></a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#func-exactly-one"><code>exactly-one</code></a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-zero-or-one"><code>zero-or-one</code></a><sup><small>FO30</small></sup>).
This rule only applies if the argument usage is transmission (other
cases having been handled by earlier rules); of the built-in
functions, the three functions listed are the only ones having an
argument with usage transmission and a return type with maximum
cardinality one.</p>
</div>
</li>
<li>
<p>Otherwise (the <a title="operand usage" class="termref" href=
"#dt-operand-usage">operand usage</a> of <var>o</var> is <a title=
"transmission" class="termref" href=
"#dt-transmission">transmission</a>), the <a title="posture" class=
"termref" href="#dt-posture">posture</a> and adjusted <a title=
"sweep" class="termref" href="#dt-sweep">sweep</a> of
<var>o</var>.</p>
</li>
</ol>
</li>
<li>
<p>Otherwise (all operands are <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>) <a title="grounded"
class="termref" href="#dt-grounded">grounded</a> and <a title=
"motionless" class="termref" href=
"#dt-motionless">motionless</a>.</p>
</li>
</ol>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The rules ensure that if more than one <a title="operand" class=
"termref" href="#dt-operand">operand</a> is <a title="consuming"
class="termref" href="#dt-consuming">consuming</a>, that is, if
more than one operand reads the subtree of the context node in a
way that would cause the current position of the input stream to
change, then the construct is not streamable.</p>
<p>The rules also prevent multiple streamed nodes being returned in
the result of an expression unless they arise from the same axis
traversal. For example, the expression <code>count((@*, *))</code>
is not streamable. The same applies to <code>if (X) then @name else
name</code>. This is to make static analysis possible: the posture
needs to be statically determined to ensure that streaming does not
fail at execution time. It is permitted, however, for streamed
nodes to be mixed in a sequence with non-streamed nodes or with
atomic values; in this case the posture of the result will be that
of the streamed nodes.</p>
</div>
</div>
<div class="div3">
<h4><a name="general-streamability-examples" id=
"general-streamability-examples"></a>19.8.2 <a href=
"#general-streamability-examples" style=
"text-decoration: none">Examples of the General Streamability
Rules</a></h4>
<p>This section provides some examples of how the general
streamability rules operate. In each example, the emphasis is on
the outermost construct shown; explanations for how the sweep and
posture of its operands are derived are not given, though in many
cases they are explained in earlier examples.</p>
<p>The examples assume that the context item type for evaluation of
the expression shown is an element node, and that its posture is
striding.</p>
<ul>
<li>
<p><code>2 + 2</code> is grounded and motionless, because both the
operands are grounded and motionless.</p>
</li>
<li>
<p><code>price * 2</code> is grounded and consuming, because one of
the operands is consuming and the relevant operand usage is
absorption.</p>
</li>
<li>
<p><code>price - discount</code> is roaming and free-ranging,
because both the operands are consuming (and they are not members
of a parallel operand group).</p>
</li>
<li>
<p><code>price * @discount</code> is grounded and consuming. The
<span>left-hand</span> operand is consuming and the corresponding
operand usage is absorption, while the <span>right-hand</span>
operand is motionless, again with an operand usage of absorption,
and its item type is <code>attribute()</code> which changes the
effective usage to inspection.</p>
</li>
<li>
<p><code>a/b/c</code> is striding and consuming. This is determined
not by the general streamability rules, but by the rules for path
expressions in <a href=
"#streamability-of-path-expressions"><i>19.8.7.6 Streamability of
Path Expressions</i></a>.</p>
</li>
<li>
<p><code>a//c</code> is crawling and consuming. This is similarly
determined by the rules for path expressions in <a href=
"#streamability-of-path-expressions"><i>19.8.7.6 Streamability of
Path Expressions</i></a>.</p>
</li>
<li>
<p><code>count(a/b/c)</code> is grounded and consuming, because the
operand (the argument to the count function) is striding and
consuming (see earlier example) and the operand usage is
inspection.</p>
</li>
<li>
<p><code>sum(a/b/c)</code> is grounded and consuming, because the
operand (the argument to the <span><code>sum</code></span>
function) is striding and consuming (see earlier example) and the
operand usage is absorption.</p>
</li>
<li>
<p><code>count(descendant::c)</code> is grounded and consuming,
because the operand (the argument to the <code>count</code>
function) is crawling and consuming (see earlier example) and the
operand usage is inspection.</p>
</li>
<li>
<p><code>tail(descendant::c)</code> is crawling and consuming. The
operand is crawling, the operand usage is transmission, so the
posture and sweep of the result are the same as the posture and
sweep of the consuming operand.</p>
</li>
<li>
<p><code>unordered(a|b)</code> is crawling and consuming. The
operand (the argument to the <code>unordered</code> function is
crawling (see <a href=
"#streamability-of-union-expressions"><i>19.8.7.4 Streamability of
union, intersect, and except expressions</i></a>), and the operand
usage is transmission, so the posture and sweep of the result are
the same as the posture and sweep of the consuming operand.</p>
</li>
<li>
<p><code>zero-or-one(descendant::c)</code> is striding and
consuming. Although the operand is crawling, the operand usage is
transmission and the cardinality of the expression is zero or one,
so the posture of the result is striding. The same analysis applies
to <code>exactly-one(descendant::c)</code> and to
<code>head(descendant::c)</code>.</p>
</li>
<li>
<p><code>sum(descendant::c)</code> is grounded and consuming,
because the operand (the argument to the <code>sum</code> function)
is crawling and consuming (see earlier example) and the operand
usage is absorption. In theory (although it is unlikely in
practice) the selected <code>c</code> elements might <span>be
nested one inside another</span>. The processor is expected to
handle this situation, which may require some buffering. For
example, given the untyped source document
<code>&lt;a&gt;&lt;c&gt;&lt;c&gt;1&lt;/c&gt;&lt;c&gt;2&lt;/c&gt;&lt;c&gt;3&lt;/c&gt;&lt;/c&gt;&lt;/a&gt;</code>,
the result of the expression is <code>129</code> (123 + 1 + 2 + 3),
and to evaluate this, a streaming processor will typically maintain
a stack of buffers to accumulate the typed values of each of the
four <code>c</code> elements during a single pass of the source
document.</p>
</li>
<li>
<p><code>"Q{" || namespace-uri(.) || "}" || local-name(.)</code> is
grounded and motionless. The two literal operands are grounded and
motionless because they have no operands; the two function calls
are grounded and motionless because they have a single operand that
is striding and motionless, with an operand usage of
inspection.</p>
</li>
<li>
<p><code>copy-of(.)/head/following-sibling::*</code> is grounded
and consuming. The <span>left-hand</span> operand
<code>copy-of(.)/head</code> is grounded and consuming because,
under the rules in <a href=
"#streamability-of-path-expressions"><i>19.8.7.6 Streamability of
Path Expressions</i></a>, its <span>left-hand</span> operand
<code>copy-of(.)</code> is grounded and consuming. This in turn is
because <code>.</code> is striding and motionless, and the operand
usage is absorption.</p>
</li>
<li>
<p><code>distinct-values((., @code))</code> is roaming and
free-ranging. Although it is not difficult to identify a strategy
for evaluating this in a streaming manner, the static analysis
rules make an expression free-ranging if it has two operands with
different posture. This is because in general this prevents
streamability being determined statically.</p>
</li>
<li>
<p><code>if ($discounted) then price else discounted-price</code>
is striding and consuming, because the two branches of the
conditional are both striding and consuming, and they form a
<a title="choice operand group" class="termref" href=
"#dt-choice-operand-group">choice operand group</a> with usage
transmission.</p>
</li>
<li>
<p><code>if ($gratis) then 0 else price</code> is striding and
consuming because there is only one consuming operand (the fact
that it is part of a <a title="choice operand group" class=
"termref" href="#dt-choice-operand-group">choice operand group</a>
does not affect the reasoning).</p>
</li>
<li>
<p><code>count((author, editor))</code> is roaming and
free-ranging. The first argument to the <code>count</code> function
is an expression with two operands, both having usage=transmission,
and neither being grounded.</p>
</li>
<li>
<p><code>count((author | editor))</code> is grounded and consuming.
A union expression is not subject to the general streamability
rules; it has its own rules, defined in <a href=
"#streamability-of-union-expressions"><i>19.8.7.4 Streamability of
union, intersect, and except expressions</i></a>, which establish
in this case that the argument to the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-count"><code>count</code></a><sup><small>FO30</small></sup>
is <a title="crawling" class="termref" href=
"#dt-crawling">crawling</a> and <a title="consuming" class=
"termref" href="#dt-consuming">consuming</a>. The <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-count"><code>count</code></a><sup><small>FO30</small></sup>
function does follow the general streamability rules, with an
operand usage of <a title="inspection" class="termref" href=
"#dt-inspection">inspection</a>: under rule 1(b)(iii)(B) the
adjusted sweep is <a title="consuming" class="termref" href=
"#dt-consuming">consuming</a>, and rule 2(d)(iii) then applies.</p>
</li>
<li>
<p><code>('{', author, '}')</code> is striding and consuming.
Exactly one operand is consuming; it has usage <a title=
"transmission" class="termref" href=
"#dt-transmission">transmission</a>, so the result has the posture
and sweep of that operand. (The formal analysis treats comma as a
binary operator, but the same result can be obtained by treating
the content of the parenthesized expression as an expression with
three operands.)</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="classifying-sequence-constructors" id=
"classifying-sequence-constructors"></a>19.8.3 <a href=
"#classifying-sequence-constructors" style=
"text-decoration: none">Classifying Sequence Constructors</a></h4>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of a <a title="sequence constructor"
class="termref" href="#dt-sequence-constructor">sequence
constructor</a> are determined by the <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability
rules</a>.</p>
<p>The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <span><a title=
"operand usage" class="termref" href=
"#dt-operand-usage">usages</a></span> are:</p>
<ol class="enumar">
<li>
<p>The <span>immediately</span> contained <a title="instruction"
class="termref" href="#dt-instruction">instructions</a>. The
<a title="operand usage" class="termref" href=
"#dt-operand-usage">operand usage</a> for these operands is
<a title="transmission" class="termref" href=
"#dt-transmission">transmission</a>.</p>
</li>
<li>
<p>Any <a title="text value template" class="termref" href=
"#dt-text-value-template">text value templates</a> appearing in
text nodes within the sequence constructor, if text value templates
are enabled. The <a title="operand usage" class="termref" href=
"#dt-operand-usage">operand usage</a> for these operands is
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Some consequences of these rules are:</p>
<ol class="enumar">
<li>
<p>An empty sequence constructor is <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>, and its <a title=
"posture" class="termref" href="#dt-posture">posture</a> is
<a title="grounded" class="termref" href=
"#dt-grounded">grounded</a>.</p>
</li>
<li>
<p>A sequence constructor containing a single instruction has the
same <a title="sweep" class="termref" href="#dt-sweep">sweep</a>
and <a title="posture" class="termref" href=
"#dt-posture">posture</a> as that instruction.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This means that sequence constructors containing a single
instruction can usefully be dropped from the construct tree.</p>
</div>
</li>
<li>
<p>Informally, a sequence constructor is not streamable if it
contains more than one instruction that moves the position of the
input stream.</p>
</li>
</ol>
</div>
<p>Instructions within a sequence constructor are further
classified to control the use of <a title="accumulator function"
class="termref" href="#dt-accumulator-function">accumulator
functions:</a></p>
<ol class="enumar">
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-pre-descent-instruction" id="dt-pre-descent-instruction" title=
"pre-descent instruction"></a>A <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a> <a title=
"instruction" class="termref" href=
"#dt-instruction">instruction</a> having no <a title="consuming"
class="termref" href="#dt-consuming">consuming</a> instruction as a
preceding sibling is referred to as a <b>pre-descent
instruction</b>.<span class="definition">]</span></p>
</li>
<li>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-post-descent-instruction" id="dt-post-descent-instruction"
title="post-descent instruction"></a>A <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a> <a title=
"instruction" class="termref" href=
"#dt-instruction">instruction</a> having no <a title="consuming"
class="termref" href="#dt-consuming">consuming</a> instruction as a
following sibling is referred to as a <b>post-descent
instruction</b>.<span class="definition">]</span></p>
</li>
<li>
<p>In addition, the following are classified as <a title=
"post-descent instruction" class="termref" href=
"#dt-post-descent-instruction">post-descent instructions</a>:</p>
<ol class="enumla">
<li>
<p>Any instruction whose parent is an <a href=
"#element-if"><code>xsl:if</code></a> instruction, if the
<code>test</code> expression is a <a title="consuming" class=
"termref" href="#dt-consuming">consuming</a> expression;</p>
</li>
<li>
<p>Any instruction whose parent is an <a href=
"#element-when"><code>xsl:when</code></a> instruction, if the
<code>test</code> expression of the parent <a href=
"#element-when"><code>xsl:when</code></a> or of any preceding
sibling of the parent <a href=
"#element-when"><code>xsl:when</code></a> is a <a title="consuming"
class="termref" href="#dt-consuming">consuming</a> expression</p>
</li>
</ol>
</li>
</ol>
<p>In the above rules, an instruction is considered to be <a title=
"consuming" class="termref" href="#dt-consuming">consuming</a> if
its adjusted sweep <var>S'</var> is <a title="consuming" class=
"termref" href="#dt-consuming">consuming</a>, as defined by the
<a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>
when applied to the containing sequence constructor.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This means that for templates that match text or attribute
nodes, an instruction such as <code>&lt;xsl:value-of
select="."/&gt;</code> is not consuming, which means that all
instructions in the template rule qualify as both pre-descent and
post-descent instructions. The same can happen in a template rule
that does not access the string value or typed value of the context
item.</p>
</div>
</div>
<div class="div3">
<h4><a name="classifying-instructions" id=
"classifying-instructions"></a>19.8.4 <a href=
"#classifying-instructions" style=
"text-decoration: none">Classifying Instructions</a></h4>
<p>This section describes how <a title="instruction" class=
"termref" href="#dt-instruction">instructions</a> are classified
with respect to their streamability. The criteria are given first
for <a title="literal result element" class="termref" href=
"#dt-literal-result-element">literal result elements</a> and
<a title="extension instruction" class="termref" href=
"#dt-extension-instruction">extension instructions</a>,, then for
each XSLT instruction, listed alphabetically.</p>
<div class="div4">
<h5><a name="streamability-literal-result-elements" id=
"streamability-literal-result-elements"></a>19.8.4.1 <a href=
"#streamability-literal-result-elements" style=
"text-decoration: none">Streamability of Literal Result
Elements</a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of a <a title="literal result element"
class="termref" href="#dt-literal-result-element">literal result
element</a> follow the <a title="general streamability rules"
class="termref" href="#dt-general-streamability-rules">general
streamability rules</a>. The <a title="operand role" class=
"termref" href="#dt-operand-role">operand roles</a> and their
<a title="operand usage" class="termref" href=
"#dt-operand-usage">usages</a> are:</p>
<ol class="enumar">
<li>
<p>The contained sequence constructor (usage <a title="absorption"
class="termref" href="#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>Any expressions contained in <a title="attribute value template"
class="termref" href="#dt-attribute-value-template">attribute value
templates</a> among the literal result element's attributes (usage
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>Any <a title="attribute set" class="termref" href=
"#dt-attribute-set">attribute sets</a> named in the
<code>xsl:use-attribute-sets</code> attribute (usage <a title=
"absorption" class="termref" href=
"#dt-absorption">absorption</a>).</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="streamability-extension-instructions" id=
"streamability-extension-instructions"></a>19.8.4.2 <a href=
"#streamability-extension-instructions" style=
"text-decoration: none">Streamability of extension
instructions</a></h5>
<p>For a processor that recognizes an <a title=
"extension instruction" class="termref" href=
"#dt-extension-instruction">extension instruction</a>, the
<a title="posture" class="termref" href="#dt-posture">posture</a>
and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of
the instruction are <a title="implementation-defined" class=
"termref" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
<p>For a processor that does not recognize an <a title=
"extension instruction" class="termref" href=
"#dt-extension-instruction">extension instruction</a>, the
<a title="posture" class="termref" href="#dt-posture">posture</a>
and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of
the instruction are determined by applying the <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>,
The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are:</p>
<ol class="enumar">
<li>
<p>The <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructors</a> contained in
any <a href="#element-fallback"><code>xsl:fallback</code></a>
children (usage <a title="transmission" class="termref" href=
"#dt-transmission">transmission</a>)</p>
</li>
</ol>
<p>Instructions in the XSLT namespace that are present under the
provisions for <a title="forwards compatible behavior" class=
"termref" href="#dt-forwards-compatible-behavior">forwards
compatible behavior</a> are treated in the same way as unrecognized
extension instructions.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>These rules mean that if there is no <a href=
"#element-fallback"><code>xsl:fallback</code></a> child
instruction, the containing construct will be classified as
streamable. However, any attempt to execute the instruction will
lead to a dynamic error, so in fact, neither streamed nor
unstreamed evaluation is possible.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-xsl-analyze-string" id=
"streamability-xsl-analyze-string"></a>19.8.4.3 <a href=
"#streamability-xsl-analyze-string" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a>
follow the <a title="general streamability rules" class="termref"
href="#dt-general-streamability-rules">general streamability
rules</a>. The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are:</p>
<ol class="enumar">
<li>
<p>the <code>select</code> expression (usage <a title="absorption"
class="termref" href="#dt-absorption">absorption</a>);</p>
</li>
<li>
<p>the <code>regex</code> attribute value template (usage <a title=
"absorption" class="termref" href=
"#dt-absorption">absorption</a>);</p>
</li>
<li>
<p>the sequence constructors contained in the <a href=
"#element-matching-substring"><code>xsl:matching-substring</code></a>
and <a href=
"#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>
elements. These have usage <a title="navigation" class="termref"
href="#dt-navigation">navigation</a>, because they can be evaluated
more than once. The <span><a title="context posture" class=
"termref" href="#dt-context-posture">context posture</a></span> for
the two sequence constructors is <a title="grounded" class=
"termref" href="#dt-grounded">grounded</a>, reflecting the fact
that their context item type is <code>xs:string</code>.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In practice, the <a title="sweep" class="termref" href=
"#dt-sweep">sweep</a> of the instruction will usually be the same
as the sweep of the <code>select</code> expression, and its
<a title="posture" class="termref" href="#dt-posture">posture</a>
will be <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a>. Exceptions occur for example if the
<code>regex</code> attribute is not <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>, or if the contained
sequence constructors refer to a grouping variable bound in a
contained <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-xsl-apply-imports" id=
"streamability-xsl-apply-imports"></a>19.8.4.4 <a href=
"#streamability-xsl-apply-imports" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a></h5>
<p>The rules in this section apply also to <a href=
"#element-next-match"><code>xsl:next-match</code></a>.</p>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of these two instructions follow the
<a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are:</p>
<ol class="enumar">
<li>
<p>An implicit operand: a context item expression (<code>.</code>),
with usage <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>;</p>
</li>
<li>
<p>The <code>select</code> attribute or contained <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> of each
<a href="#element-with-param"><code>xsl:with-param</code></a> child
element, with <a title="type-determined usage" class="termref"
href="#dt-type-determined-usage">type-determined usage</a> based on
the type declared in the <code>xsl:with-param/@as</code> attribute,
or <code>item()*</code> if absent.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The instruction will normally be <a title="grounded" class=
"termref" href="#dt-grounded">grounded</a> and <a title="consuming"
class="termref" href="#dt-consuming">consuming</a>, provided that
nodes in a streamed document are not passed as parameters to the
called template rule.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-xsl-apply-templates" id=
"streamability-xsl-apply-templates"></a>19.8.4.5 <a href=
"#streamability-xsl-apply-templates" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a></h5>
<p>If there is no <code>select</code> attribute, the following
analysis assumes the presence of an implicit operand
<code>select="child::node()"</code>.</p>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of the <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction are the first of the following that apply:</p>
<ol class="enumar">
<li>
<p>If the <code>select</code> expression is <a title="grounded"
class="termref" href="#dt-grounded">grounded</a>, then the
<a title="posture" class="termref" href="#dt-posture">posture</a>
and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of
the <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction follow the <a title="general streamability rules"
class="termref" href="#dt-general-streamability-rules">general
streamability rules</a>, with the <a title="operand role" class=
"termref" href="#dt-operand-role">operand roles</a> and their
<a title="operand usage" class="termref" href=
"#dt-operand-usage">usages</a> as follows:</p>
<ol class="enumla">
<li>
<p>The <code>select</code> expression (the <a title="operand usage"
class="termref" href="#dt-operand-usage">operand usage</a> is
irrelevant, but can be taken as <a title="absorption" class=
"termref" href="#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The <code>select</code> expressions and contained sequence
constructors of any child <a href=
"#element-with-param"><code>xsl:with-param</code></a> elements
(usage <a title="type-determined usage" class="termref" href=
"#dt-type-determined-usage">type-determined</a>, based on the type
in the <code>xsl:with-param/@as</code> attribute, defaulting to
<code>item()*</code>)</p>
</li>
<li>
<p>Any attribute value templates appearing in attributes of a child
<a href="#element-sort"><code>xsl:sort</code></a> instruction
(usage <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The <code>select</code> expression or contained sequence
constructor of any <a href=
"#element-sort"><code>xsl:sort</code></a> children, assessed with a
<a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a> of <a title="grounded"
class="termref" href="#dt-grounded">grounded</a> (usage <a title=
"absorption" class="termref" href=
"#dt-absorption">absorption</a>).</p>
</li>
</ol>
<p>For example, <code>&lt;xsl:apply-templates
select="copy-of(.)"/&gt;</code> is <a title="grounded" class=
"termref" href="#dt-grounded">grounded</a> and <a title="consuming"
class="termref" href="#dt-consuming">consuming</a>.</p>
</li>
<li>
<p>If there is an <a href="#element-sort"><code>xsl:sort</code></a>
child element, then <a title="roaming" class="termref" href=
"#dt-roaming">roaming</a> and <a title="free-ranging" class=
"termref" href="#dt-free-ranging">free-ranging</a>.</p>
</li>
<li>
<p>If the implicit or explicit <code>mode</code> attribute
identifies a <a title="mode" class="termref" href=
"#dt-mode">mode</a> that is not declared with
<code>streamable="yes"</code>, then <a title="roaming" class=
"termref" href="#dt-roaming">roaming</a> and <a title=
"free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>When <code>mode="#current"</code> is specified, this is treated
as equivalent to specifying a streamable mode; although it is not
known statically what the mode will be, it is always the case that
if the template is invoked with a streamed node as the context
item, then the current mode must be a streamable mode.</p>
</div>
</li>
<li>
<p>If the <code>select</code> expression is <a title="climbing"
class="termref" href="#dt-climbing">climbing</a> or <a title=
"crawling" class="termref" href="#dt-crawling">crawling</a>, then
<a title="roaming" class="termref" href="#dt-roaming">roaming</a>
and <a title="free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a></p>
</li>
<li>
<p>Otherwise, the <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of the <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction follow the <a title="general streamability rules"
class="termref" href="#dt-general-streamability-rules">general
streamability rules</a>. The <a title="operand role" class=
"termref" href="#dt-operand-role">operand roles</a> and their
<a title="operand usage" class="termref" href=
"#dt-operand-usage">usages</a> are as follows:</p>
<ol class="enumla">
<li>
<p>The (explicit or implicit) <code>select</code> expression, with
usage <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>;</p>
</li>
<li>
<p>The <code>select</code> attribute or contained <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> of each
<a href="#element-with-param"><code>xsl:with-param</code></a> child
element, with <a title="type-determined usage" class="termref"
href="#dt-type-determined-usage">type-determined usage</a> based on
the type declared in the <code>xsl:with-param/@as</code> attribute,
or <code>item()*</code> if absent.</p>
</li>
</ol>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="streamability-xsl-assert" id=
"streamability-xsl-assert"></a>19.8.4.6 <a href=
"#streamability-xsl-assert" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-assert"><code>xsl:assert</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-assert"><code>xsl:assert</code></a> follow the <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are as follows:</p>
<ol class="enumar">
<li>
<p>The <code>test</code> expression (usage <a title="inspection"
class="termref" href="#dt-inspection">inspection</a>)</p>
</li>
<li>
<p>The <code>select</code> expression (usage <a title="absorption"
class="termref" href="#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The <code>error-code</code> attribute value template (usage
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The contained <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> (usage
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>).</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="streamability-xsl-attribute" id=
"streamability-xsl-attribute"></a>19.8.4.7 <a href=
"#streamability-xsl-attribute" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-attribute"><code>xsl:attribute</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-attribute"><code>xsl:attribute</code></a> follow the
<a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are as follows:</p>
<ol class="enumar">
<li>
<p>The <code>name</code> attribute value template (usage <a title=
"absorption" class="termref" href=
"#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The <code>namespace</code> attribute value template (usage
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The <code>select</code> expression (usage <a title="absorption"
class="termref" href="#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The <code>separator</code> attribute value template (usage
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The contained <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> (usage
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>).</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="streamability-xsl-break" id=
"streamability-xsl-break"></a>19.8.4.8 <a href=
"#streamability-xsl-break" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-break"><code>xsl:break</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-break"><code>xsl:break</code></a> follow the <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are as follows:</p>
<ol class="enumar">
<li>
<p>The <code>select</code> expression (usage <a title=
"transmission" class="termref" href=
"#dt-transmission">transmission</a>)</p>
</li>
<li>
<p>The contained <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> (usage
<a title="transmission" class="termref" href=
"#dt-transmission">transmission</a>).</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="streamability-xsl-call-template" id=
"streamability-xsl-call-template"></a>19.8.4.9 <a href=
"#streamability-xsl-call-template" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-call-template"><code>xsl:call-template</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-call-template"><code>xsl:call-template</code></a> follow
the <a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are as follows:</p>
<ol class="enumar">
<li>
<p>Unless the referenced template has a child <a href=
"#element-context-item"><code>xsl:context-item</code></a> element
with the attribute <code>use="prohibited"</code>, there is an
implicit operand, a context item expression (<code>.</code>): its
<a title="operand usage" class="termref" href=
"#dt-operand-usage">operand usage</a> is the <a title=
"type-determined usage" class="termref" href=
"#dt-type-determined-usage">type-determined usage</a> based on the
type declared in the <code>xsl:context-item/@as</code> attribute of
the target named template, defaulting to <code>item()*</code> if
absent.</p>
</li>
<li>
<p>The <code>select</code> expression or sequence constructor
content of any contained <a href=
"#element-with-param"><code>xsl:with-param</code></a> child
element: its <a title="operand usage" class="termref" href=
"#dt-operand-usage">operand usage</a> is the <a title=
"type-determined usage" class="termref" href=
"#dt-type-determined-usage">type-determined usage</a> based on the
type declared in the <code>xsl:with-param/@as</code> attribute, or
the <code>xsl:param/@as</code> attribute of the corresponding
parameter on the target named template, whichever is more
restrictive, defaulting to <code>item()*</code> if both are
absent.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Calling <a href=
"#element-call-template"><code>xsl:call-template</code></a> will
usually make stylesheet code unstreamable if a streamed node is
passed explicitly or implicitly to the called template, unless it
is atomized by declaring the expected type to be atomic.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-xsl-choose" id=
"streamability-xsl-choose"></a>19.8.4.10 <a href=
"#streamability-xsl-choose" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-choose"><code>xsl:choose</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-choose"><code>xsl:choose</code></a> follow the <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are as follows:</p>
<ol class="enumar">
<li>
<p>The <code>test</code> attribute of contained <a href=
"#element-when"><code>xsl:when</code></a> elements (usage <a title=
"inspection" class="termref" href=
"#dt-inspection">inspection</a>).</p>
</li>
<li>
<p>The sequence constructors contained within <a href=
"#element-when"><code>xsl:when</code></a> and <a href=
"#element-otherwise"><code>xsl:otherwise</code></a> child elements
(usage <a title="transmission" class="termref" href=
"#dt-transmission">transmission</a>). These sequence constructor
operands form a <a title="choice operand group" class="termref"
href="#dt-choice-operand-group">choice operand group</a>.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The effect is to allow any of the following:</p>
<ol class="enumar">
<li>
<p>Every sequence constructor in an <a href=
"#element-when"><code>xsl:when</code></a> or <a href=
"#element-otherwise"><code>xsl:otherwise</code></a> branch may read
the input stream. In this situation the <code>test</code>
expressions must be <a title="motionless" class="termref" href=
"#dt-motionless">motionless</a>.</p>
</li>
<li>
<p>Alternatively, the first <code>test</code> expression may
consume the input stream, in which case the sequence constructors
(and any subsequent <code>test</code> expressions) must be
<a title="motionless" class="termref" href=
"#dt-motionless">motionless</a>.</p>
</li>
</ol>
</div>
</div>
<div class="div4">
<h5><a name="streamability-xsl-comment" id=
"streamability-xsl-comment"></a>19.8.4.11 <a href=
"#streamability-xsl-comment" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-comment"><code>xsl:comment</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-comment"><code>xsl:comment</code></a> follow the
<a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are as follows:</p>
<ol class="enumar">
<li>
<p>The <code>select</code> expression (usage <a title="absorption"
class="termref" href="#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The contained <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> (usage
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>).</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="streamability-xsl-copy" id=
"streamability-xsl-copy"></a>19.8.4.12 <a href=
"#streamability-xsl-copy" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-copy"><code>xsl:copy</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-copy"><code>xsl:copy</code></a> follow the <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are as follows:</p>
<ol class="enumar">
<li>
<p>The expression in the <code>select</code> attribute, defaulting
to a context item expression (<code>.</code>) (usage <a title=
"inspection" class="termref" href=
"#dt-inspection">inspection</a>)</p>
</li>
<li>
<p>The contained sequence constructor (usage <a title="absorption"
class="termref" href="#dt-absorption">absorption</a>), assessed
with <a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a> and context item type
based on the <code>select</code> expression if present, or the
outer focus otherwise.</p>
</li>
<li>
<p>Any <a title="attribute set" class="termref" href=
"#dt-attribute-set">attribute-sets</a> named in the
<code>use-attribute-sets</code> attribute (usage <a title=
"absorption" class="termref" href=
"#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The expression contained in the <code>on-empty</code> attribute,
if present (usage <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>).</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="streamability-xsl-copy-of" id=
"streamability-xsl-copy-of"></a>19.8.4.13 <a href=
"#streamability-xsl-copy-of" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-copy-of"><code>xsl:copy-of</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-copy-of"><code>xsl:copy-of</code></a> follow the
<a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are as follows:</p>
<ol class="enumar">
<li>
<p>The <code>select</code> expression (usage <a title="absorption"
class="termref" href="#dt-absorption">absorption</a>).</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="streamability-xsl-document" id=
"streamability-xsl-document"></a>19.8.4.14 <a href=
"#streamability-xsl-document" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-document"><code>xsl:document</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-document"><code>xsl:document</code></a> follow the
<a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are as follows:</p>
<ol class="enumar">
<li>
<p>The contained <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> (usage
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>).</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="streamability-xsl-element" id=
"streamability-xsl-element"></a>19.8.4.15 <a href=
"#streamability-xsl-element" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-element"><code>xsl:element</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-element"><code>xsl:element</code></a> follow the
<a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are as follows:</p>
<ol class="enumar">
<li>
<p>The <code>name</code> attribute value template (usage <a title=
"absorption" class="termref" href=
"#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The <code>namespace</code> attribute value template (usage
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The <code>on-empty</code> expression (usage <a title=
"absorption" class="termref" href=
"#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The attribute sets named in the <code>use-attribute-sets</code>
attribute (usage <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The contained <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> (usage
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>).</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="streamability-xsl-evaluate" id=
"streamability-xsl-evaluate"></a>19.8.4.16 <a href=
"#streamability-xsl-evaluate" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-evaluate"><code>xsl:evaluate</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-evaluate"><code>xsl:evaluate</code></a> follow the
<a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are as follows:</p>
<ol class="enumar">
<li>
<p>The <code>xpath</code> expression (usage <a title="absorption"
class="termref" href="#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The <code>context-item</code> expression (usage <a title=
"navigation" class="termref" href=
"#dt-navigation">navigation</a>)</p>
</li>
<li>
<p>The <code>with-params</code> expression (usage <a title=
"navigation" class="termref" href=
"#dt-navigation">navigation</a>)</p>
</li>
<li>
<p>The <code>base-uri</code> attribute value template (usage
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The <code>namespace-context</code> expression (usage <a title=
"inspection" class="termref" href=
"#dt-inspection">inspection</a>)</p>
</li>
<li>
<p>The <code>schema-aware</code> attribute value template (usage
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The <code>select</code> attributes and contained <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructors</a> of any
<a href="#element-with-param"><code>xsl:with-param</code></a> child
elements (usage <a title="type-determined usage" class="termref"
href="#dt-type-determined-usage">type-determined</a>, based on the
type in the <code>xsl:with-param/@as</code> attribute, defaulting
to <code>item()*</code>)</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In practice, code containing an <a href=
"#element-evaluate"><code>xsl:evaluate</code></a> instruction will
usually be streamable provided that streamed nodes are not passed
to the dynamic expression either as the context item or as the
value of a parameter.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-xsl-fallback" id=
"streamability-xsl-fallback"></a>19.8.4.17 <a href=
"#streamability-xsl-fallback" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-fallback"><code>xsl:fallback</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of the <a href=
"#element-fallback"><code>xsl:fallback</code></a> instruction
depend on whether the processor is performing fallback (which is
known statically).</p>
<p>If the processor is performing fallback, then the <a title=
"posture" class="termref" href="#dt-posture">posture</a> and
<a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the
<a href="#element-fallback"><code>xsl:fallback</code></a>
instruction are the posture and sweep of the contained sequence
constructor.</p>
<p>If the processor is not performing fallback, then the
instruction is <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> and <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>.</p>
</div>
<div class="div4">
<h5><a name="streamability-xsl-for-each" id=
"streamability-xsl-for-each"></a>19.8.4.18 <a href=
"#streamability-xsl-for-each" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-for-each"><code>xsl:for-each</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of the <a href=
"#element-for-each"><code>xsl:for-each</code></a> instruction are
the first of the following that applies:</p>
<ol class="enumar">
<li>
<p>If the <code>select</code> expression is <a title="grounded"
class="termref" href="#dt-grounded">grounded</a>, then the
<a title="posture" class="termref" href="#dt-posture">posture</a>
and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of
the <a href="#element-for-each"><code>xsl:for-each</code></a>
instruction follow the <a title="general streamability rules"
class="termref" href="#dt-general-streamability-rules">general
streamability rules</a>, with the <a title="operand role" class=
"termref" href="#dt-operand-role">operand roles</a> and their
<a title="operand usage" class="termref" href=
"#dt-operand-usage">usages</a> as follows:</p>
<ol class="enumla">
<li>
<p>The <code>select</code> expression (the <a title="operand usage"
class="termref" href="#dt-operand-usage">operand usage</a> is
irrelevant, but can be taken as <a title="inspection" class=
"termref" href="#dt-inspection">inspection</a>)</p>
</li>
<li>
<p>The contained <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> (usage
<a title="transmission" class="termref" href=
"#dt-transmission">transmission</a>). This is a <a title=
"higher-order operand" class="termref" href=
"#dt-higher-order-operand">higher-order operand</a>; its context
posture is <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a>.</p>
</li>
<li>
<p>Any attribute value templates appearing in attributes of a child
<a href="#element-sort"><code>xsl:sort</code></a> instruction
(usage <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The <code>select</code> expression or contained sequence
constructor of any <a href=
"#element-sort"><code>xsl:sort</code></a> children, assessed with a
<a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a> of <a title="grounded"
class="termref" href="#dt-grounded">grounded</a> (usage <a title=
"absorption" class="termref" href="#dt-absorption">absorption</a>).
These are <a title="higher-order operand" class="termref" href=
"#dt-higher-order-operand">higher-order operands</a>; their context
posture is <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a>.</p>
</li>
</ol>
</li>
<li>
<p>If there is an <a href="#element-sort"><code>xsl:sort</code></a>
child element, then <a title="roaming" class="termref" href=
"#dt-roaming">roaming</a> and <a title="free-ranging" class=
"termref" href="#dt-free-ranging">free-ranging</a>.</p>
</li>
<li>
<p>If the <a title="posture" class="termref" href=
"#dt-posture">posture</a> of the <code>select</code> expression is
<a title="crawling" class="termref" href=
"#dt-crawling">crawling</a> and the <a title="sweep" class=
"termref" href="#dt-sweep">sweep</a> of the contained <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> is <a title=
"consuming" class="termref" href="#dt-consuming">consuming</a>,
then <a title="roaming" class="termref" href=
"#dt-roaming">roaming</a> and <a title="free-ranging" class=
"termref" href="#dt-free-ranging">free-ranging</a>.</p>
</li>
<li>
<p>Otherwise:</p>
<ol class="enumla">
<li>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> of the instruction is the <a title=
"posture" class="termref" href="#dt-posture">posture</a> of the
contained <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>, assessed with
the <span><a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a></span> and context item
type set to the <a title="posture" class="termref" href=
"#dt-posture">posture</a> and type of the <code>select</code>
expression.</p>
</li>
<li>
<p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a>
of the instruction is the wider of the <a title="sweep" class=
"termref" href="#dt-sweep">sweep</a> of the <code>select</code>
expression and the <a title="sweep" class="termref" href=
"#dt-sweep">sweep</a> of the contained <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The ordering of sweep values is in increasing order: <a title=
"motionless" class="termref" href="#dt-motionless">motionless</a>,
<a title="consuming" class="termref" href=
"#dt-consuming">consuming</a>, <a title="free-ranging" class=
"termref" href="#dt-free-ranging">free-ranging</a>.</p>
</div>
</li>
</ol>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="streamability-xsl-for-each-group" id=
"streamability-xsl-for-each-group"></a>19.8.4.19 <a href=
"#streamability-xsl-for-each-group" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of the <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction are the first of the following that applies:</p>
<ol class="enumar">
<li>
<p>If the <code>select</code> expression is <a title="grounded"
class="termref" href="#dt-grounded">grounded</a>, then the
<a title="posture" class="termref" href="#dt-posture">posture</a>
and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of
the <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction follow the <a title="general streamability rules"
class="termref" href="#dt-general-streamability-rules">general
streamability rules</a>, with the <a title="operand role" class=
"termref" href="#dt-operand-role">operand roles</a> and their
<a title="operand usage" class="termref" href=
"#dt-operand-usage">usages</a> as follows:</p>
<ol class="enumla">
<li>
<p>The <code>select</code> expression (the <a title="operand usage"
class="termref" href="#dt-operand-usage">operand usage</a> is
irrelevant, but can be taken as <a title="inspection" class=
"termref" href="#dt-inspection">inspection</a>)</p>
</li>
<li>
<p>The <code>collation</code> attribute value template (usage
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>Any attribute value templates appearing in attributes of a child
<a href="#element-sort"><code>xsl:sort</code></a> instruction
(usage <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The <code>group-by</code> or <code>group-adjacent</code>
expression, assessed with a <a title="context posture" class=
"termref" href="#dt-context-posture">context posture</a> of
<a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> (usage <a title="absorption" class=
"termref" href="#dt-absorption">absorption</a>).</p>
</li>
<li>
<p>The <code>select</code> expression or contained sequence
constructor of any <a href=
"#element-sort"><code>xsl:sort</code></a> children, assessed with a
<a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a> of <a title="grounded"
class="termref" href="#dt-grounded">grounded</a> (usage <a title=
"absorption" class="termref" href=
"#dt-absorption">absorption</a>).</p>
</li>
<li>
<p>The <code>group-starting-with</code> or
<code>group-ending-with</code> patterns if present; these are
<a title="higher-order operand" class="termref" href=
"#dt-higher-order-operand">higher-order operands</a> with usage
<a title="inspection" class="termref" href=
"#dt-inspection">inspection</a>.</p>
</li>
</ol>
</li>
<li>
<p>If there is a <code>group-by</code> attribute <span>and the
instruction is not a child of <a href=
"#element-fork"><code>xsl:fork</code></a></span>, then <a title=
"roaming" class="termref" href="#dt-roaming">roaming</a> and
<a title="free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>.</p>
</li>
<li>
<p>If there is a <span><code>group-by</code> or</span>
<code>group-adjacent</code> attribute that is not <a title=
"motionless" class="termref" href="#dt-motionless">motionless</a>,
then <a title="roaming" class="termref" href=
"#dt-roaming">roaming</a> and <a title="free-ranging" class=
"termref" href="#dt-free-ranging">free-ranging</a>.</p>
</li>
<li>
<p>If there is an <a href="#element-sort"><code>xsl:sort</code></a>
child element, then <a title="roaming" class="termref" href=
"#dt-roaming">roaming</a> and <a title="free-ranging" class=
"termref" href="#dt-free-ranging">free-ranging</a>.</p>
</li>
<li>
<p>If the <a title="posture" class="termref" href=
"#dt-posture">posture</a> of the <code>select</code> expression is
<a title="crawling" class="termref" href=
"#dt-crawling">crawling</a> and the <a title="sweep" class=
"termref" href="#dt-sweep">sweep</a> of the contained <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> is <a title=
"consuming" class="termref" href="#dt-consuming">consuming</a>,
then <a title="roaming" class="termref" href=
"#dt-roaming">roaming</a> and <a title="free-ranging" class=
"termref" href="#dt-free-ranging">free-ranging</a>.</p>
</li>
<li>
<p>Otherwise:</p>
<ol class="enumla">
<li>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> of the instruction is the <a title=
"posture" class="termref" href="#dt-posture">posture</a> of the
contained <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>, assessed with
the <span><a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a></span> and context item
type set to the <a title="posture" class="termref" href=
"#dt-posture">posture</a> and type of the <code>select</code>
expression.</p>
</li>
<li>
<p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a>
of the instruction is the wider of the <a title="sweep" class=
"termref" href="#dt-sweep">sweeps</a> of the <code>select</code>
expression and the contained <a title="sequence constructor" class=
"termref" href="#dt-sequence-constructor">sequence constructor</a>,
where the ordering of increasing width is <a title="motionless"
class="termref" href="#dt-motionless">motionless</a>, <a title=
"consuming" class="termref" href="#dt-consuming">consuming</a>,
<a title="free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>.</p>
</li>
</ol>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The above rules do not explicitly mention any constraints on the
presence or absence of call on the <a href=
"#func-current-group"><code>current-group</code></a> function. In
practice, however, this plays an important role. In the most common
case, the <code>select</code> expression of <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a> is
likely to be striding, for example an expression such as
<code>select="*"</code>. Any call on <a href=
"#func-current-group"><code>current-group</code></a> associated
with this <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction will ordinarily be <a title="striding" class="termref"
href="#dt-striding">striding</a> and <a title="consuming" class=
"termref" href="#dt-consuming">consuming</a>, which is consistent
with streaming provided there is only one such call, and if it
appears in a suitable context (for example, not within a
predicate). If there is more than one call, or if it appears in an
unsuitable context (for example, within a predicate), then this
will have the same effect as multiple appearances of other
consuming expressions: the construct as a whole will be
free-ranging. These rules are not spelled out explicitly, but
rather emerge as a consequence of the general streamability
rules.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-xsl-fork" id=
"streamability-xsl-fork"></a>19.8.4.20 <a href=
"#streamability-xsl-fork" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-fork"><code>xsl:fork</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-fork"><code>xsl:fork</code></a> are the first of the
following that applies:</p>
<ol class="enumar">
<li>
<p>If there are no child <span><a href=
"#element-sequence"><code>xsl:sequence</code></a></span>
instructions (other than <a href=
"#element-fallback"><code>xsl:fallback</code></a>), then <a title=
"grounded" class="termref" href="#dt-grounded">grounded</a> and
<a title="motionless" class="termref" href=
"#dt-motionless">motionless</a>.</p>
</li>
<li>
<p>If there is a child <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction, then the <a title="posture" class="termref" href=
"#dt-posture">posture</a> and the <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of that instruction.</p>
</li>
<li>
<p>If there is a child <a href=
"#element-sequence"><code>xsl:sequence</code></a> instructions
whose <a title="posture" class="termref" href=
"#dt-posture">posture</a> is not <a title="grounded" class=
"termref" href="#dt-grounded">grounded</a>, then <a title="roaming"
class="termref" href="#dt-roaming">roaming</a> and <a title=
"free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>.</p>
</li>
<li>
<p>Otherwise, the <a title="posture" class="termref" href=
"#dt-posture">posture</a> is <a title="grounded" class="termref"
href="#dt-grounded">grounded</a>, and the <a title="sweep" class=
"termref" href="#dt-sweep">sweep</a> is the widest sweep of the
<a href="#element-sequence"><code>xsl:sequence</code></a> child
instructions.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>None of the branches of <a href=
"#element-fork"><code>xsl:fork</code></a> can return streamed
nodes. The reason for this is that <a href=
"#element-fork"><code>xsl:fork</code></a> has to assemble its
results in the correct order, and streamed nodes cannot be
re-ordered.</p>
<p>The effect of the rules is that each of the child <a href=
"#element-sequence"><code>xsl:sequence</code></a> instructions can
independently consume the streamed input document, provided that
the result of each child instruction is <a title="grounded" class=
"termref" href="#dt-grounded">grounded</a>.</p>
<p>Thus the following example is streamable:</p>
<div class="exampleInner">
<pre>
&lt;xsl:fork&gt;
   &lt;xsl:sequence select="copy-of(author)"/&gt;
   &lt;xsl:sequence select="copy-of(editor)"/&gt;
&lt;/xsl:fork&gt;
</pre></div>
<p>While the following is not streamable, because it returns
streamed nodes in an order that might not be document order:</p>
<div class="exampleInner">
<pre>
&lt;xsl:fork&gt;
   &lt;xsl:sequence select="author"/&gt;
   &lt;xsl:sequence select="editor"/&gt;
&lt;/xsl:fork&gt;
</pre></div>
</div>
</div>
<div class="div4">
<h5><a name="streamability-xsl-if" id=
"streamability-xsl-if"></a>19.8.4.21 <a href=
"#streamability-xsl-if" style="text-decoration: none">Streamability
of</a> <a href="#element-if"><code>xsl:if</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-if"><code>xsl:if</code></a> follow the <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are as follows:</p>
<ol class="enumar">
<li>
<p>The <code>test</code> expression (usage <a title="inspection"
class="termref" href="#dt-inspection">inspection</a>)</p>
</li>
<li>
<p>The contained <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> (usage
<a title="transmission" class="termref" href=
"#dt-transmission">transmission</a>).</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="streamability-xsl-iterate" id=
"streamability-xsl-iterate"></a>19.8.4.22 <a href=
"#streamability-xsl-iterate" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-iterate"><code>xsl:iterate</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of the <a href=
"#element-iterate"><code>xsl:iterate</code></a> instruction are the
first of the following that applies:</p>
<ol class="enumar">
<li>
<p>If the <code>select</code> expression is <a title="grounded"
class="termref" href="#dt-grounded">grounded</a>, then the
<a title="posture" class="termref" href="#dt-posture">posture</a>
and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of
the <a href="#element-iterate"><code>xsl:iterate</code></a>
instruction follow the <a title="general streamability rules"
class="termref" href="#dt-general-streamability-rules">general
streamability rules</a>, with the <a title="operand role" class=
"termref" href="#dt-operand-role">operand roles</a> and their
<a title="operand usage" class="termref" href=
"#dt-operand-usage">usages</a> as follows:</p>
<ol class="enumla">
<li>
<p>The <code>select</code> expression (the <a title="operand usage"
class="termref" href="#dt-operand-usage">operand usage</a> is
irrelevant, but can be taken as <a title="inspection" class=
"termref" href="#dt-inspection">inspection</a>)</p>
</li>
<li>
<p>The <code>select</code> expression or contained sequence
constructor of any <a href=
"#element-param"><code>xsl:param</code></a> children (usage
<a title="navigation" class="termref" href=
"#dt-navigation">navigation</a>)</p>
</li>
<li>
<p>The sequence constructor contained within the <a href=
"#element-iterate"><code>xsl:iterate</code></a> instruction itself,
assessed with its context item type and <a title="context posture"
class="termref" href="#dt-context-posture">context posture</a>
based on the <code>select</code> expression (usage <a title=
"transmission" class="termref" href=
"#dt-transmission">transmission</a>)</p>
</li>
<li>
<p>The <code>select</code> expression or contained sequence
constructor of any child <a href=
"#element-on-completion"><code>xsl:on-completion</code></a>
element, assessed with a context item type of <code>xs:error</code>
and a <a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a> of <a title="roaming"
class="termref" href="#dt-roaming">roaming</a> to reflect the fact
that any attempt to reference the context item within the <a href=
"#element-on-completion"><code>xsl:on-completion</code></a> element
is an error (usage <a title="transmission" class="termref" href=
"#dt-transmission">transmission</a>)</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The <code>on-completion</code> element can cause the instruction
to become non-streamable if, for example, it contains calls on
<a href="#func-current-group"><code>current-group</code></a> or
variable references bound to parameters of a streamable stylesheet
function.</p>
</div>
</li>
</ol>
</li>
<li>
<p>If there is an <a href=
"#element-param"><code>xsl:param</code></a> child whose
initializing <code>select</code> expression or <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> is not
<a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> and <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>, then <a title=
"roaming" class="termref" href="#dt-roaming">roaming</a> and
<a title="free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>.</p>
</li>
<li>
<p>If there is an <a href=
"#element-on-completion"><code>xsl:on-completion</code></a> child
whose <code>select</code> expression or <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> is not
<a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> and <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>, then <a title=
"roaming" class="termref" href="#dt-roaming">roaming</a> and
<a title="free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>.</p>
</li>
<li>
<p>If the <a title="posture" class="termref" href=
"#dt-posture">posture</a> of the <code>select</code> expression is
<a title="crawling" class="termref" href=
"#dt-crawling">crawling</a> and the <a title="sweep" class=
"termref" href="#dt-sweep">sweep</a> of the contained <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> is <a title=
"consuming" class="termref" href="#dt-consuming">consuming</a>,
then <a title="roaming" class="termref" href=
"#dt-roaming">roaming</a> and <a title="free-ranging" class=
"termref" href="#dt-free-ranging">free-ranging</a>.</p>
</li>
<li>
<p>Otherwise:</p>
<ol class="enumla">
<li>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> of the instruction is the <a title=
"posture" class="termref" href="#dt-posture">posture</a> of the
contained <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>, assessed with
the <span><a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a></span> and context item
type set to the <a title="posture" class="termref" href=
"#dt-posture">posture</a> and type of the <code>select</code>
expression.</p>
</li>
<li>
<p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a>
of the instruction is the wider of the <a title="sweep" class=
"termref" href="#dt-sweep">sweeps</a> of <span>the
<code>select</code> expression and the contained <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a></span>, where
the ordering of increasing width is <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>, <a title=
"consuming" class="termref" href="#dt-consuming">consuming</a>,
<a title="free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>.</p>
</li>
</ol>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>If any <a href="#element-break"><code>xsl:break</code></a> or
<a href=
"#element-next-iteration"><code>xsl:next-iteration</code></a>
instructions appear within the sequence constructor, their
<a title="posture" class="termref" href="#dt-posture">posture</a>
and <a title="sweep" class="termref" href="#dt-sweep">sweep</a>
will be assessed in the course of evaluating the <a title="posture"
class="termref" href="#dt-posture">posture</a> and <a title="sweep"
class="termref" href="#dt-sweep">sweep</a> of the sequence
constructor, by reference to the rules in <a href=
"#streamability-xsl-break"><i>19.8.4.8 Streamability of
xsl:break</i></a> and <a href=
"#streamability-xsl-next-iteration"><i>19.8.4.28 Streamability of
xsl:next-iteration</i></a> respectively.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-xsl-map" id=
"streamability-xsl-map"></a>19.8.4.23 <a href=
"#streamability-xsl-map" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-map"><code>xsl:map</code></a></h5>
<p>The <span><a title="posture" class="termref" href=
"#dt-posture">posture</a></span> and <a title="sweep" class=
"termref" href="#dt-sweep">sweep</a> of the <a href=
"#element-map"><code>xsl:map</code></a> instruction are determined
by the first of the following that applies:</p>
<ol class="enumar">
<li>
<p>If the sequence constructor within the instruction consists
exclusively of <a href=
"#element-map-entry"><code>xsl:map-entry</code></a> instructions
(and <a href="#element-fallback"><code>xsl:fallback</code></a>
instructions, which are ignored), then:</p>
<ol class="enumla">
<li>
<p>If any of these <a href=
"#element-map-entry"><code>xsl:map-entry</code></a> children is
<a title="roaming" class="termref" href="#dt-roaming">roaming</a>
or <a title="free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>, then <a title="roaming" class=
"termref" href="#dt-roaming">roaming</a> and <a title=
"free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>;</p>
</li>
<li>
<p>Otherwise, <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> and the widest sweep of the <a href=
"#element-map-entry"><code>xsl:map-entry</code></a> children.</p>
</li>
</ol>
</li>
<li>
<p>Otherwise, the <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of the <a href=
"#element-map"><code>xsl:map</code></a> instruction are the posture
and sweep of the contained <a title="sequence constructor" class=
"termref" href="#dt-sequence-constructor">sequence
constructor</a>.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>See discussion in <a href="#maps-streaming"><i>21.1.5 Maps and
Streaming</i></a>.</p>
<p>The effect of the rules is that it is possible to compute
multiple map entries in a single pass of the streamed input
document. For example, the following is streamable:</p>
<div class="exampleInner">
<pre>
&lt;xsl:map&gt;
  &lt;xsl:map-entry key="'authors'" select="copy-of(author)"/&gt;
  &lt;xsl:map-entry key="'editors'" select="copy-of(editor)"/&gt;
&lt;/xsl:map&gt;  
</pre></div>
<p>The call on <a href="#func-copy-of"><code>copy-of</code></a> is
necessary to ensure that the content of the map entry is grounded;
it is not possible to create a map whose entries contain references
to streamed nodes.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-xsl-map-entry" id=
"streamability-xsl-map-entry"></a>19.8.4.24 <a href=
"#streamability-xsl-map-entry" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-map-entry"><code>xsl:map-entry</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-map-entry"><code>xsl:map-entry</code></a> follow the
<a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are as follows:</p>
<ol class="enumar">
<li>
<p>The <code>key</code> expression (usage <a title="absorption"
class="termref" href="#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The <code>select</code> expression (usage <a title="navigation"
class="termref" href="#dt-navigation">navigation</a>)</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This effectively means that the <code>select</code> expression
must not return nodes from a streamed input document.</p>
</div>
</li>
<li>
<p>The contained <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> (usage
<a title="navigation" class="termref" href=
"#dt-navigation">navigation</a>).</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="streamability-xsl-merge" id=
"streamability-xsl-merge"></a>19.8.4.25 <a href=
"#streamability-xsl-merge" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-merge"><code>xsl:merge</code></a></h5>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This section is concerned with the (not very interesting) impact
of the <a href="#element-merge"><code>xsl:merge</code></a>
instruction on the streamability of its containing template rule or
<a href="#element-stream"><code>xsl:stream</code></a>
instruction.</p>
<p>For the (more important) rules concerning the way in which
<a href="#element-merge"><code>xsl:merge</code></a> performs
streamed processing of its own inputs, see <a href=
"#streamable-merging"><i>15.4 Streamable Merging</i></a>.</p>
</div>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-merge"><code>xsl:merge</code></a> are as follows:</p>
<ol class="enumar">
<li>
<p>If every <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> child
element satisfies all the following conditions:</p>
<ol class="enumla">
<li>
<p>The expression in the <code>for-each-item</code> attribute is
either absent, or <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> and <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>;</p>
</li>
<li>
<p>The expression in the <code>for-each-stream</code> attribute is
either absent, or <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> and <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>;</p>
</li>
<li>
<p>Either at least one of the attributes <code>for-each-item</code>
and <code>for-each-stream</code> is present, or the expression in
the <code>select</code> attribute is <a title="grounded" class=
"termref" href="#dt-grounded">grounded</a> and <a title=
"motionless" class="termref" href=
"#dt-motionless">motionless</a></p>
</li>
</ol>
<p>then the <a href="#element-merge"><code>xsl:merge</code></a>
instruction is <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> and <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>.</p>
</li>
<li>
<p>Otherwise, the <a href=
"#element-merge"><code>xsl:merge</code></a> instruction <a title=
"roaming" class="termref" href="#dt-roaming">roaming</a> and
<a title="free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>.</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="streamability-xsl-message" id=
"streamability-xsl-message"></a>19.8.4.26 <a href=
"#streamability-xsl-message" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-message"><code>xsl:message</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-message"><code>xsl:message</code></a> follow the
<a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are as follows:</p>
<ol class="enumar">
<li>
<p>The <code>select</code> expression (usage <a title="absorption"
class="termref" href="#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The <code>terminate</code> attribute value template (usage
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The <code>error-code</code> attribute value template (usage
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The contained <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> (usage
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>).</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="streamability-xsl-namespace" id=
"streamability-xsl-namespace"></a>19.8.4.27 <a href=
"#streamability-xsl-namespace" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-namespace"><code>xsl:namespace</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-namespace"><code>xsl:namespace</code></a> follow the
<a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are as follows:</p>
<ol class="enumar">
<li>
<p>The <code>name</code> attribute value template (usage <a title=
"absorption" class="termref" href=
"#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The <code>select</code> expression (usage <a title="absorption"
class="termref" href="#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The contained <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> (usage
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>).</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="streamability-xsl-next-iteration" id=
"streamability-xsl-next-iteration"></a>19.8.4.28 <a href=
"#streamability-xsl-next-iteration" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-next-iteration"><code>xsl:next-iteration</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-next-iteration"><code>xsl:next-iteration</code></a>
follow the <a title="general streamability rules" class="termref"
href="#dt-general-streamability-rules">general streamability
rules</a>. The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are as follows:</p>
<ol class="enumar">
<li>
<p>The <code>select</code> expression or <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> content of any
contained <a href=
"#element-with-param"><code>xsl:with-param</code></a> child
element: its <a title="operand usage" class="termref" href=
"#dt-operand-usage">operand usage</a> is the <a title=
"type-determined usage" class="termref" href=
"#dt-type-determined-usage">type-determined usage</a> based on the
type declared in the <code>xsl:with-param/@as</code> attribute, or
the <code>xsl:param/@as</code> attribute of the corresponding
parameter on the containing <a href=
"#element-iterate"><code>xsl:iterate</code></a> instruction,
whichever is more restrictive, defaulting to <code>item()*</code>
if both are absent.</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="streamability-xsl-next-match" id=
"streamability-xsl-next-match"></a>19.8.4.29 <a href=
"#streamability-xsl-next-match" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-next-match"><code>xsl:next-match</code></a></h5>
<p>The rules are the same as for <a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a>: see
<a href="#streamability-xsl-apply-imports"><i>19.8.4.4
Streamability of xsl:apply-imports</i></a>.</p>
</div>
<div class="div4">
<h5><a name="streamability-xsl-number" id=
"streamability-xsl-number"></a>19.8.4.30 <a href=
"#streamability-xsl-number" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-number"><code>xsl:number</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-number"><code>xsl:number</code></a> follow the <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are as follows:</p>
<ol class="enumar">
<li>
<p>The <code>value</code> attribute if present (usage <a title=
"absorption" class="termref" href=
"#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The <code>select</code> attribute if present (usage <a title=
"navigation" class="termref" href=
"#dt-navigation">navigation</a>)</p>
</li>
<li>
<p>The attribute value templates in the <code>format</code>,
<code>lang</code>, <code>letter-value</code>, <code>ordinal</code>,
<code>start-at</code>, <code>grouping-separator</code>, and
<code>grouping-size</code> attributes (usage <a title="absorption"
class="termref" href="#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The <code>from</code> and <code>count</code> patterns if
present; these are <a title="higher-order operand" class="termref"
href="#dt-higher-order-operand">higher-order operands</a> with
usage <a title="inspection" class="termref" href=
"#dt-inspection">inspection</a>.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The effect of these rules is that <a href=
"#element-number"><code>xsl:number</code></a> can be used for
formatting of numbers supplied directly, and for numbering of nodes
in a non-streamed document, but cannot be used for numbering
streamed nodes.</p>
<p>In practice the rules depend very little on the
<code>from</code> and <code>count</code> patterns. This is because
when the instruction is applied to a streamed node, the instruction
will be <a title="free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a> regardless of these patterns;
while if it is applied to a grounded node or atomic value, the
instruction will normally be <a title="motionless" class="termref"
href="#dt-motionless">motionless</a> regardless of the values of
these patterns. <span>The pattern does matter, however, if it
contains a variable reference bound to the streaming argument of a
stylesheet function that is declared streamable; because such a
reference occurs within a higher-order operand of the <a href=
"#element-number"><code>xsl:number</code></a> instruction, its
presence automatically makes the variable reference free-ranging,
which in turn ensures that the containing stylesheet function is
not <a title="guaranteed-streamable" class="termref" href=
"#dt-guaranteed-streamable">guaranteed-streamable</a>.</span></p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-xsl-perform-sort" id=
"streamability-xsl-perform-sort"></a>19.8.4.31 <a href=
"#streamability-xsl-perform-sort" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-perform-sort"><code>xsl:perform-sort</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-perform-sort"><code>xsl:perform-sort</code></a> follow
the <a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are as follows:</p>
<ol class="enumar">
<li>
<p>The expression in the <code>select</code> attribute: usage
<a title="navigation" class="termref" href=
"#dt-navigation">navigation</a> (because order is not
preserved)</p>
</li>
<li>
<p>The expressions in the attribute value templates of <a href=
"#element-sort"><code>xsl:sort</code></a> child elements: usage
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a></p>
</li>
<li>
<p>The expression in the <code>select</code> attribute <span>or
contained sequence constructor</span> in child <a href=
"#element-sort"><code>xsl:sort</code></a> child elements, with
usage <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>, assessed with <span><a title=
"context posture" class="termref" href=
"#dt-context-posture">context posture</a></span> based on the
expression in the <code>xsl:perform-sort/@select</code>
attribute.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In practice, the <a href=
"#element-perform-sort"><code>xsl:perform-sort</code></a>
instruction cannot be used to sort nodes from the streamed input
document, but it can be used to sort atomic values or <a title=
"grounded" class="termref" href="#dt-grounded">grounded</a> nodes,
for example a copy of nodes from the streamed document made using
the <a href="#func-copy-of"><code>copy-of</code></a> function.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-xsl-processing-instruction" id=
"streamability-xsl-processing-instruction"></a>19.8.4.32 <a href=
"#streamability-xsl-processing-instruction" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-processing-instruction"><code>xsl:processing-instruction</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-processing-instruction"><code>xsl:processing-instruction</code></a>
follow the <a title="general streamability rules" class="termref"
href="#dt-general-streamability-rules">general streamability
rules</a>. The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are as follows:</p>
<ol class="enumar">
<li>
<p>The <code>name</code> attribute value template (usage <a title=
"absorption" class="termref" href=
"#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The <code>select</code> expression (usage <a title="absorption"
class="termref" href="#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The contained <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> (usage
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>).</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="streamability-xsl-result-document" id=
"streamability-xsl-result-document"></a>19.8.4.33 <a href=
"#streamability-xsl-result-document" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-result-document"><code>xsl:result-document</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-result-document"><code>xsl:result-document</code></a>
follow the <a title="general streamability rules" class="termref"
href="#dt-general-streamability-rules">general streamability
rules</a>. The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are as follows:</p>
<ol class="enumar">
<li>
<p>The <code>href</code> attribute value template (usage <a title=
"absorption" class="termref" href=
"#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The attribute value templates containing serialization
properties (usage <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The contained <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> (usage
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>).</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="streamability-xsl-sequence" id=
"streamability-xsl-sequence"></a>19.8.4.34 <a href=
"#streamability-xsl-sequence" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-sequence"><code>xsl:sequence</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-sequence"><code>xsl:sequence</code></a> follow the
<a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are as follows:</p>
<ol class="enumar">
<li>
<p>The <code>select</code> attribute value template (usage
<a title="transmission" class="termref" href=
"#dt-transmission">transmission</a>)</p>
</li>
<li>
<p>The contained <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> (usage
<a title="transmission" class="termref" href=
"#dt-transmission">transmission</a>).</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="streamability-xsl-stream" id=
"streamability-xsl-stream"></a>19.8.4.35 <a href=
"#streamability-xsl-stream" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-stream"><code>xsl:stream</code></a></h5>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The concern here is with the impact of <a href=
"#element-stream"><code>xsl:stream</code></a> on any streaming
template, or ancestor <a href=
"#element-stream"><code>xsl:stream</code></a> instruction, and not
with the streamed processing of the document accessed using the
<code>xsl:stream/@href</code> attribute.</p>
<p>The streamability of the document opened by the <a href=
"#element-stream"><code>xsl:stream</code></a> instruction is not
assessed using the rules in this section; it depends only on the
streamability properties of the contained sequence constructor, as
described in <a href="#stream-instruction"><i>18.1 The xsl:stream
Instruction</i></a></p>
</div>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-stream"><code>xsl:stream</code></a> are the first of the
following that applies:</p>
<ol class="enumar">
<li>
<p>If the contained sequence constructor contains, at any depth, a
<span>call on the <a href=
"#func-current-group"><code>current-group</code></a> function whose
nearest containing <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a></span>
instruction exists and is an ancestor of the <a href=
"#element-stream"><code>xsl:stream</code></a> instruction, then
<a title="roaming" class="termref" href="#dt-roaming">roaming</a>
and <a title="free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>.</p>
</li>
<li>
<p>If the contained sequence constructor contains, at any depth, a
<span>call on the <a href=
"#func-current-merge-group"><code>current-merge-group</code></a>
function whose nearest containing <a href=
"#element-merge"><code>xsl:merge</code></a></span> instruction
exists and is an ancestor of the <a href=
"#element-stream"><code>xsl:stream</code></a> instruction, then
<a title="roaming" class="termref" href="#dt-roaming">roaming</a>
and <a title="free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>.</p>
</li>
<li>
<p>Otherwise, the <a title="posture" class="termref" href=
"#dt-posture">posture</a> is <a title="grounded" class="termref"
href="#dt-grounded">grounded</a> and the <a title="sweep" class=
"termref" href="#dt-sweep">sweep</a> is the <a title="sweep" class=
"termref" href="#dt-sweep">sweep</a> of the <code>href</code>
attribute value template.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The effective prohibition on grouping variable references is
largely to avoid complicating the analysis. It means that posture
and sweep for the constructs within <a href=
"#element-stream"><code>xsl:stream</code></a> need to be computed
only with respect to the <a href=
"#element-stream"><code>xsl:stream</code></a> instruction itself,
and not with respect to the containing template, or an outer
<a href="#element-stream"><code>xsl:stream</code></a>
instruction.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-xsl-text" id=
"streamability-xsl-text"></a>19.8.4.36 <a href=
"#streamability-xsl-text" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-text"><code>xsl:text</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-text"><code>xsl:text</code></a> follow the <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
There are no operands.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The instruction is therefore <a title="grounded" class="termref"
href="#dt-grounded">grounded</a> and <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-xsl-try" id=
"streamability-xsl-try"></a>19.8.4.37 <a href=
"#streamability-xsl-try" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-try"><code>xsl:try</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of the <a href=
"#element-try"><code>xsl:try</code></a> instruction follow the
<a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and <a title="operand usage"
class="termref" href="#dt-operand-usage">usages</a> are as
follows:</p>
<ol class="enumar">
<li>
<p>The <code>select</code> expression or contained <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> of the <a href=
"#element-try"><code>xsl:try</code></a> element. This has <a title=
"operand usage" class="termref" href="#dt-operand-usage">operand
usage</a> <a title="transmission" class="termref" href=
"#dt-transmission">transmission</a>. (Note that the <a href=
"#element-catch"><code>xsl:catch</code></a> children of <a href=
"#element-try"><code>xsl:try</code></a> are not part of the
sequence constructor and therefore not part of this operand.)</p>
</li>
<li>
<p>The <code>select</code> expressions and/or contained <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> of the <a href=
"#element-catch"><code>xsl:catch</code></a> child elements. These
form a <a title="choice operand group" class="termref" href=
"#dt-choice-operand-group">choice operand group</a> with <a title=
"operand usage" class="termref" href="#dt-operand-usage">operand
usage</a> <a title="transmission" class="termref" href=
"#dt-transmission">transmission</a>.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The overall effect of these rules is that either the
<code>xsl:try</code> branch or the <code>xsl:catch</code> branch
may consume the streamed input, but not both. If there is more than
one <code>xsl:catch</code> branch then they may all consume the
input, since only one of these branches can be evaluated.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-xsl-value-of" id=
"streamability-xsl-value-of"></a>19.8.4.38 <a href=
"#streamability-xsl-value-of" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-value-of"><code>xsl:value-of</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-value-of"><code>xsl:value-of</code></a> follow the
<a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are as follows:</p>
<ol class="enumar">
<li>
<p>The <code>select</code> expression (usage <a title="absorption"
class="termref" href="#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The <code>separator</code> attribute value template (usage
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>)</p>
</li>
<li>
<p>The contained <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> (usage
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>).</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="streamability-xsl-variable" id=
"streamability-xsl-variable"></a>19.8.4.39 <a href=
"#streamability-xsl-variable" style=
"text-decoration: none">Streamability of</a> <a href=
"#element-variable"><code>xsl:variable</code></a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a href=
"#element-variable"><code>xsl:variable</code></a> follow the
<a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
<span>depend on the <code>as</code> attribute,</span> as
follows:</p>
<ol class="enumar">
<li>
<p>If there is an <code>as</code> attribute, then:</p>
<ol class="enumla">
<li>
<p>The <code>select</code> expression (with <a title=
"type-determined usage" class="termref" href=
"#dt-type-determined-usage">type-determined usage</a> based on the
<code>as</code> attribute).</p>
</li>
<li>
<p>The contained <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> (with
<a title="type-determined usage" class="termref" href=
"#dt-type-determined-usage">type-determined usage</a> based on the
<code>as</code> attribute).</p>
</li>
</ol>
</li>
<li>
<p>If there is no <code>as</code> attribute, then:</p>
<ol class="enumla">
<li>
<p>The <code>select</code> expression (usage <a title="navigation"
class="termref" href="#dt-navigation">navigation</a>).</p>
</li>
<li>
<p>The contained <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> (usage
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>).</p>
</li>
</ol>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The effect of the initialization expression having usage
<a title="navigation" class="termref" href=
"#dt-navigation">navigation</a> is that it is not possible in
streamable constructs to bind a variable to a node in a streamed
document.</p>
</div>
</div>
</div>
<div class="div3">
<h4><a name="classifying-attribute-sets" id=
"classifying-attribute-sets"></a>19.8.5 <a href=
"#classifying-attribute-sets" style=
"text-decoration: none">Classifying Attribute Sets</a></h4>
<p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a>
and <a title="posture" class="termref" href=
"#dt-posture">posture</a> of an <a title="attribute set" class=
"termref" href="#dt-attribute-set">attribute set</a> are determined
by the <a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> and their <a title=
"operand usage" class="termref" href="#dt-operand-usage">usages</a>
are:</p>
<ol class="enumar">
<li>
<p>Any <a href="#element-attribute"><code>xsl:attribute</code></a>
instruction contained in <span>any of the <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a>
declarations making up</span> the attribute set. (Usage <a title=
"transmission" class="termref" href=
"#dt-transmission">transmission</a>)</p>
</li>
<li>
<p>Any attribute set referenced by a
<span><code>use-attribute-sets</code> attribute in any of the
<a href="#element-attribute-set"><code>xsl:attribute-set</code></a>
declarations making up</span> the attribute set. (Usage <a title=
"transmission" class="termref" href=
"#dt-transmission">transmission</a>)</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Attribute sets will always be <a title="grounded" class=
"termref" href="#dt-grounded">grounded</a>, because they return
newly constructed attribute nodes.</p>
<p>Attribute sets will very often be <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>, but if they access
the context item, they may be <a title="consuming" class="termref"
href="#dt-consuming">consuming</a> or <a title="free-ranging"
class="termref" href="#dt-free-ranging">free-ranging</a>.</p>
<p>Because attribute sets can be overridden in another <a title=
"package" class="termref" href="#dt-package">package</a>, the
streamability of a construct such as an <a href=
"#element-element"><code>xsl:element</code></a> instruction
containing a <code>use-attribute-sets</code> attribute is based on
the declared streamability of the named attribute sets, as defined
by the <code>streamable</code> attribute of the <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a>
element. If <code>streamable="yes"</code> is specified, then there
is a requirement that any overriding attribute set should also
specify <code>streamable="yes"</code>, and a streaming processor is
required to check that an attribute set containing such a
declaration does in fact satisfy the streamability rules.</p>
</div>
</div>
<div class="div3">
<h4><a name="classifying-vts" id="classifying-vts"></a>19.8.6
<a href="#classifying-vts" style=
"text-decoration: none">Classifying Value Templates</a></h4>
<p>A <a title="value template" class="termref" href=
"#dt-value-template">value template</a> (that is, an <a title=
"attribute value template" class="termref" href=
"#dt-attribute-value-template">attribute value template</a> or
<a title="text value template" class="termref" href=
"#dt-text-value-template">text value template</a>) is a <a title=
"construct" class="termref" href="#dt-construct">construct</a>
whose operands are the expressions contained within curly braces.
The required type for this operand role is <code>xs:string</code>
and the <a title="operand usage" class="termref" href=
"#dt-operand-usage">usage</a> is <a title="absorption" class=
"termref" href="#dt-absorption">absorption</a>.</p>
<p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a>
and <a title="posture" class="termref" href=
"#dt-posture">posture</a> of a value template are determined using
the general rules in <a href=
"#general-streamability-rules"><i>19.8.1 General Rules for
Streamability</i></a>.</p>
<p>If there are no expressions contained within curly braces, the
value template is <a title="motionless" class="termref" href=
"#dt-motionless">motionless</a>.</p>
</div>
<div class="div3">
<h4><a name="classifying-expressions" id=
"classifying-expressions"></a>19.8.7 <a href=
"#classifying-expressions" style=
"text-decoration: none">Classifying Expressions</a></h4>
<p>XPath expressions are classified using the rules in this
section.</p>
<p>In the analysis that follows, <a title="expression" class=
"termref" href="#dt-expression">expressions</a> are classified
according to the most specific production rule that they match for
which there is an entry in this section. A production <var>P</var>
is considered more specific than a production <var>Q</var>
(<var>Q</var> ≠ <var>P</var>) if every expression that matches
<var>P</var> also matches <var>Q</var>. For example:</p>
<ul>
<li>
<p>The expression <code>3</code> satisfies the productions
<code>NumericLiteral</code>, <code>Literal</code>, and
<code>ArithmeticExpression</code>; the most specific of these for
which there is an entry in this section is
<code>Literal</code>.</p>
</li>
<li>
<p>The expression <code>text()</code> (appearing as an expression)
is a <code>TextTest</code>, and therefore a <code>KindTest</code>,
which is itself a <code>NodeTest</code>, and therefore an
<code>AxisStep</code> with a defaulted <code>ForwardAxis</code>.
The most specific of these for which there is an entry in this
section is <code>AxisStep</code>. Although the expression is also a
<code>RelativePathExpr</code>, that production is less specific
than <code>AxisStep</code> so its rules do not apply.</p>
</li>
<li>
<p>The expression <code>section/title</code> is a
<code>RelativePathExpr</code>, for which there is an entry in this
section. Although the expression is also a <code>PathExpr</code>,
that production is less specific than <code>RelativePathExpr</code>
so its rules do not apply.</p>
</li>
</ul>
<p>The production rules for different kinds of expression are
listed (with their names and numbers) in the order in which they
appear in Appendix A.1 of the XPath 3.0 specification.</p>
<p>Many expressions can be analyzed using the <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
These are indicated in the table below by means of a simple
proforma in which the <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> are represented by a short
code (A = <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>, I = <a title="inspection" class=
"termref" href="#dt-inspection">inspection</a>, T = <a title=
"transmission" class="termref" href=
"#dt-transmission">transmission</a>, N = <a title="navigation"
class="termref" href="#dt-navigation">navigation</a>). For example
the proforma <code>A + A</code> indicates that for an arithmetic
expression, both operands have <a title="operand usage" class=
"termref" href="#dt-operand-usage">operand usage</a> <a title=
"absorption" class="termref" href="#dt-absorption">absorption</a>,
while <code>I or I</code> indicates that for an <code>or</code>
expression, both operands have <a title="operand usage" class=
"termref" href="#dt-operand-usage">operand usage</a> <a title=
"inspection" class="termref" href="#dt-inspection">inspection</a>.
For expressions where further explanation is needed, the table
contains a link to the relevant section.</p>
<table summary="Operand Roles for XPath Expressions" border="1"
cellpadding="5" width="100%">
<thead>
<tr>
<th colspan="1" align="left" valign="top">Construct</th>
<th colspan="1" align="left" valign="top">Proforma or Reference to
Detailed Rules</th>
<th colspan="1" align="left" valign="top">Further Information</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top">Expr [6]</td>
<td align="left" valign="top"><code>T, T</code></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">ForExpr [8]</td>
<td align="left" valign="top">See <a href=
"#streamability-of-for-expressions"><i>19.8.7.1 Streamability of
for expressions</i></a></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">LetExpr [11]</td>
<td align="left" valign="top"><code>let $var := N return
T</code></td>
<td align="left" valign="top">Binding of variables to streamed
nodes is not allowed.</td>
</tr>
<tr>
<td align="left" valign="top">QuantifiedExpr [14]</td>
<td align="left" valign="top">See <a href=
"#streamability-of-quantified-expressions"><i>19.8.7.2
Streamability of Quantified Expressions</i></a></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">IfExpr [15]</td>
<td align="left" valign="top"><span><code>if (I) then T else
T</code></span></td>
<td align="left" valign="top">The then-clause and else-clause form
a <a title="choice operand group" class="termref" href=
"#dt-choice-operand-group">choice operand group</a> with usage
<a title="transmission" class="termref" href=
"#dt-transmission">transmission</a></td>
</tr>
<tr>
<td align="left" valign="top">OrExpr [16]</td>
<td align="left" valign="top"><code>I or I</code></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">AndExpr [17]</td>
<td align="left" valign="top"><code>I and I</code></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">StringConcatExpr [19]</td>
<td align="left" valign="top"><code>A || A</code></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">RangeExpr [20]</td>
<td align="left" valign="top"><code>A to A</code></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">AdditiveExpr [21]</td>
<td align="left" valign="top"><code>A + A</code>, <code>A -
A</code></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">MultiplicativeExpr [22]</td>
<td align="left" valign="top"><code>A * A</code>, <code>A div
A</code>, etc.</td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">UnionExpr [23]</td>
<td align="left" valign="top">See <a href=
"#streamability-of-union-expressions"><i>19.8.7.4 Streamability of
union, intersect, and except expressions</i></a></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">IntersectExceptExpr [24]</td>
<td align="left" valign="top">See <a href=
"#streamability-of-union-expressions"><i>19.8.7.4 Streamability of
union, intersect, and except expressions</i></a></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">InstanceOfExpr [25]</td>
<td align="left" valign="top"><code>I instance of TYPE</code></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">TreatExpr [26]</td>
<td align="left" valign="top"><code>T treat as TYPE</code></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">CastableExpr [27]</td>
<td align="left" valign="top"><code>A castable as TYPE</code></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">CastExpr [28]</td>
<td align="left" valign="top"><code>A cast as TYPE</code></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">UnaryExpr [29]</td>
<td align="left" valign="top"><code>+A</code>, <code>-A</code></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">GeneralComp [31]</td>
<td align="left" valign="top"><code>A = A</code>, <code>A &lt;
A</code>, <code>A != A</code>, etc.</td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">ValueComp [32]</td>
<td align="left" valign="top"><code>A eq A</code>, <code>A lt
A</code>, <code>A ne A</code>, etc.</td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">NodeComp [33]</td>
<td align="left" valign="top"><span><code>I is I</code>, <code>I
&lt;&lt; I</code>, <code>I &gt;&gt; I</code></span></td>
<td align="left" valign="top"><span>See Note 1 below</span></td>
</tr>
<tr>
<td align="left" valign="top">SimpleMapExpr [34]</td>
<td align="left" valign="top">See <a href=
"#streamability-of-simple-mapping-expressions"><i>19.8.7.5
Streamability of Simple Mapping Expressions</i></a></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">PathExpr [35]</td>
<td align="left" valign="top">See <a href=
"#streamability-of-path-expressions"><i>19.8.7.6 Streamability of
Path Expressions</i></a></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">RelativePathExpr [36]</td>
<td align="left" valign="top">See <a href=
"#streamability-of-path-expressions"><i>19.8.7.6 Streamability of
Path Expressions</i></a></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">AxisStep [38]</td>
<td align="left" valign="top">See <a href=
"#streamability-of-axis-steps"><i>19.8.7.7 Streamability of Axis
Steps</i></a></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">ForwardStep [39], ReverseStep
[42]</td>
<td align="left" valign="top">See <a href=
"#streamability-of-axis-steps"><i>19.8.7.7 Streamability of Axis
Steps</i></a></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">PostfixExpr [48]: Filter
Expression</td>
<td align="left" valign="top">See <a href=
"#streamability-of-filter-expressions"><i>19.8.7.8 Streamability of
Filter Expressions</i></a></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">PostfixExpr [48]: Dynamic Function
Call</td>
<td align="left" valign="top">See <a href=
"#streamability-of-dynamic-function-calls"><i>19.8.7.9
Streamability of Dynamic Function Calls</i></a></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">Literal [53]</td>
<td align="left" valign="top"></td>
<td align="left" valign="top">There are no operands, so the
construct is <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> and <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a></td>
</tr>
<tr>
<td align="left" valign="top">VarRef [55]</td>
<td align="left" valign="top">See <a href=
"#streamability-of-variable-references"><i>19.8.7.10 Streamability
of Variable References</i></a></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td rowspan="2" align="left" valign="top">ParenthesizedExpr
[57]</td>
<td align="left" valign="top"><code>(T)</code></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top"><code>()</code></td>
<td align="left" valign="top">There are no operands, so the
construct is <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> and <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a></td>
</tr>
<tr>
<td align="left" valign="top">ContextItemExpr [58]</td>
<td align="left" valign="top">See <a href=
"#streamability-of-context-item-expression"><i>19.8.7.11
Streamability of the Context Item Expression</i></a></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">FunctionCall [59]</td>
<td align="left" valign="top">See <a href=
"#streamability-of-function-calls"><i>19.8.7.12 Streamability of
Function Calls</i></a></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">NamedFunctionRef [63]</td>
<td align="left" valign="top"><span>See <a href=
"#streamability-of-named-function-ref"><i>19.8.7.13 Streamability
of Named Function References</i></a></span></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">InlineFunctionExpr [64]</td>
<td align="left" valign="top"><span>See <a href=
"#streamability-of-inline-functions"><i>19.8.7.14 Streamability of
Inline Function Declarations</i></a></span></td>
<td align="left" valign="top"></td>
</tr>
<tr>
<td align="left" valign="top">MapExpr [202]</td>
<td align="left" valign="top">See <a href=
"#streamability-of-map-expressions"><i>19.8.7.15 Streamability of
map expressions</i></a></td>
<td align="left" valign="top"></td>
</tr>
</tbody>
</table>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<ol class="enumar">
<li>
<p>The operators <code>is</code>, <code>&lt;&lt;</code>, and
<code>&gt;&gt;</code> apply to streamed nodes just as to any other
nodes, though there are few practical situations where they will be
useful. A streamed document conforms to the rules of the XDM data
model, and its nodes are therefore distinct and ordered. They
follow the usual rules, for example that a parent node precedes its
children in document order. Expressions such as <code>.. is
parent::X</code> or <code>ancestor::x[1] &lt;&lt;
ancestor::y[1]</code> are therefore perfectly meaningful. The
usefulness of the operators is limited by the fact that variables
cannot be bound to nodes in a streamed document. It is permitted,
though perhaps not useful, for one of the operands to be consuming:
one can write <code>. &lt;&lt; child::x</code>, and the resulting
expression is (by applying the general rules) consuming and
grounded.</p>
<p>The restriction that variables cannot be bound to streamed nodes
prevents writing of expressions such as <code>let $x := . return
descendant::x[ancestor::y[1] is $x]</code>. As a workaround, the
intended effect can be achieved by comparing node identity using
the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-generate-id"><code>generate-id</code></a><sup><small>FO30</small></sup>
function: <code>let $x := generate-id(.) return
descendant::x[generate-id(ancestor::y[1]) = $x]</code></p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="streamability-of-for-expressions" id=
"streamability-of-for-expressions"></a>19.8.7.1 <a href=
"#streamability-of-for-expressions" style=
"text-decoration: none">Streamability of</a> <code>for</code>
<a href="#streamability-of-for-expressions" style=
"text-decoration: none">expressions</a></h5>
<p>Writing the expression as <code>for $v in S return R</code>, the
two operand roles are <var>S</var> and <var>R</var>.</p>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> are determined by the first of the
following that applies:</p>
<ol class="enumar">
<li>
<p>If <var>R</var> is not <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a>, then <a title="roaming" class=
"termref" href="#dt-roaming">roaming</a> and <a title=
"free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>.</p>
</li>
<li>
<p>Otherwise, the <a title="general streamability rules" class=
"termref" href="#dt-general-streamability-rules">general
streamability rules</a> apply. The operand roles are:</p>
<ol class="enumla">
<li>
<p>The <code>in</code> expression (<code>S</code>). This has
<a title="operand usage" class="termref" href=
"#dt-operand-usage">usage</a> <a title="navigation" class="termref"
href="#dt-navigation">navigation</a>.</p>
</li>
<li>
<p>The <code>return</code> expression (<code>R</code>). This is a
<a title="higher-order operand" class="termref" href=
"#dt-higher-order-operand">higher-order operand</a> with <a title=
"operand usage" class="termref" href="#dt-operand-usage">usage</a>
<a title="transmission" class="termref" href=
"#dt-transmission">transmission</a>.</p>
</li>
</ol>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Expressions of the form <code>for $i in 1 to 3 return
$i*2</code>, where there is no reference to a streamed node, are
clearly streamable.</p>
<p>The <code>in</code> expression can also be consuming, for
example <code>for $e in copy-of(emp)</code> return $e/salary.</p>
<p>The rule that <var>R</var> must be grounded prevents the
variable being bound to a node in a streamed document. This
disallows expressions of the form <code>for $x in child::section
return $x/para</code>, because this requires data flow analysis
(tracing from the binding of a variable to its usages), rather than
purely syntactic analysis. Some implementations may be able to
stream such constructs.</p>
<p>The fact that the return clause is a higher-order operand
prevents it from being a consuming expression, for example
<code>for $i in 1 to 3 return salary</code>. Use of a motionless
expression that accesses streamed nodes is however allowed, for
example <code>for $i in 1 to 3 return
name(ancestor::x[$i])</code>.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-of-quantified-expressions" id=
"streamability-of-quantified-expressions"></a>19.8.7.2 <a href=
"#streamability-of-quantified-expressions" style=
"text-decoration: none">Streamability of Quantified
Expressions</a></h5>
<p>An expression with multiple in-clauses is first rewritten using
nested quantified expressions: for example <code>some $i in X, $j
in Y satisfies $i eq $j</code> can be rewritten as <code>some $i in
X satisfies (some $j in Y satisfies $i eq $j)</code>. The analysis
therefore only needs to consider expressions with a single
in-clause.</p>
<p>Writing such an expression as <code>some|every $v in S satisfies
C</code>, the two operand roles are <var>S</var> and
<var>C</var>.</p>
<p>The <a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>
apply. The <a title="operand role" class="termref" href=
"#dt-operand-role">operand roles</a> are:</p>
<ol class="enumar">
<li>
<p>The <code>in</code> expression (<var>S</var>). This has usage
<a title="navigation" class="termref" href=
"#dt-navigation">navigation</a>.</p>
</li>
<li>
<p>The <code>satisfies</code> expression (<var>C</var>). This is a
<a title="higher-order operand" class="termref" href=
"#dt-higher-order-operand">higher-order operand</a> with usage
<a title="inspection" class="termref" href=
"#dt-inspection">inspection</a>.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Expressions of the form some <code>$i in 1 to 3 satisfies $i lt
2</code>, where there is no reference to a streamed node, are
clearly streamable.</p>
<p>The expression <var>S</var> can be consuming, so long as it is
grounded: for example <code>some $e in emp/salary/number(.)
satisifies $e gt 10000</code>.</p>
<p>The rule that <var>S</var> has usage <a title="navigation"
class="termref" href="#dt-navigation">navigation</a> prevents the
variable being bound to a node in a streamed document. This
disallows expressions of the form <code>some $x in child::section
satisfies has-children($x)</code>, because this requires data flow
analysis (tracing from the binding of a variable to its usages),
rather than purely syntactic analysis. Some implementations may be
able to stream such constructs.</p>
<p>The fact that <var>C</var> is a higher-order operand prevents it
from being a consuming expression: for example <code>some $i in 1
to 3 satisfies author[$i] eq "Kay"</code> is not streamable. Use of
a motionless expression that accesses streamed nodes is however
allowed, for example <code>some $i in 1 to 3 satisfies @grade =
$i</code>.</p>
<p>Quantified expressions that fail the streamability rules can
often be rewritten as filter expresions. For example, the
expression <code>some $x in child::section satisfies
has-children($x)</code> can be rewritten as
<code>exists(child::section[has-children(.)])</code>, which is
grounded and consuming.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-of-if-expressions" id=
"streamability-of-if-expressions"></a>19.8.7.3 <a href=
"#streamability-of-if-expressions" style=
"text-decoration: none">Streamability of</a> <code>if</code>
<a href="#streamability-of-if-expressions" style=
"text-decoration: none">expressions</a></h5>
<p>Writing the expression as <code>if (C) then T else E</code>,
there are three operand roles: <var>C</var>, <var>T</var>, and
<var>E</var>. The <a title="operand usage" class="termref" href=
"#dt-operand-usage">usage</a> of <var>C</var> is <a title=
"inspection" class="termref" href="#dt-inspection">inspection</a>,
while the <a title="operand usage" class="termref" href=
"#dt-operand-usage">usage</a> of <var>T</var> and <var>E</var> is
<a title="transmission" class="termref" href=
"#dt-transmission">transmission</a>. Operands <var>T</var> and
<var>E</var> form a <a title="choice operand group" class="termref"
href="#dt-choice-operand-group">choice operand group</a>, meaning
that they can both consume the input stream, provided they have
consistent <a title="posture" class="termref" href=
"#dt-posture">posture</a>. The <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>
apply.</p>
</div>
<div class="div4">
<h5><a name="streamability-of-union-expressions" id=
"streamability-of-union-expressions"></a>19.8.7.4 <a href=
"#streamability-of-union-expressions" style=
"text-decoration: none">Streamability of</a>
<code>union</code><a href="#streamability-of-union-expressions"
style="text-decoration: none">,</a> <code>intersect</code><a href=
"#streamability-of-union-expressions" style=
"text-decoration: none">, and</a> <code>except</code> <a href=
"#streamability-of-union-expressions" style=
"text-decoration: none">expressions</a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> are the first of the following that
applies:</p>
<ol class="enumar">
<li>
<p>If either of the two operands is <a title="free-ranging" class=
"termref" href="#dt-free-ranging">free-ranging</a>, then <a title=
"roaming" class="termref" href="#dt-roaming">roaming</a> and
<a title="free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a> (Example: <code>. |
following-sibling::*</code>).</p>
</li>
<li>
<p>If either of the two operands is <a title="grounded" class=
"termref" href="#dt-grounded">grounded</a> and <a title=
"motionless" class="termref" href="#dt-motionless">motionless</a>,
then the <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of the other operand (Example: <code>. |
doc('abc.com')//x</code>)</p>
</li>
<li>
<p>If both operands are <a title="climbing" class="termref" href=
"#dt-climbing">climbing</a>, then <a title="climbing" class=
"termref" href="#dt-climbing">climbing</a> and and the wider of the
sweeps of the two operands (Example: <code>@* | */@*</code>).</p>
</li>
<li>
<p>If <span>the <span>left-hand</span> operand is <a title=
"striding" class="termref" href="#dt-striding">striding</a> or
<a title="crawling" class="termref" href=
"#dt-crawling">crawling</a> and the <span>right-hand</span> operand
is also <a title="striding" class="termref" href=
"#dt-striding">striding</a> or <a title="crawling" class="termref"
href="#dt-crawling">crawling</a></span>, then <a title="crawling"
class="termref" href="#dt-crawling">crawling</a> and the wider of
the sweeps of the two operands (Example: <code>* | */*</code>).</p>
</li>
<li>
<p>Otherwise, <a title="roaming" class="termref" href=
"#dt-roaming">roaming</a> and <a title="free-ranging" class=
"termref" href="#dt-free-ranging">free-ranging</a> (Example:
<code>name | @name</code>).</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Essentially the principle is that if both operands are
streamable, then the result is streamable (this assumes an
evaluation strategy where both operands are evaluated during the
same pass of the streamed input document, and the results merged).
But there are caveats because of the need for static streamability
analysis of the result. This prevents constructs such as <code>.. |
*</code> that have heterogeneous posture.</p>
<p>Where the two operands are both <a title="striding" class=
"termref" href="#dt-striding">striding</a>, there are cases where
an implementation could determine that the result is also <a title=
"striding" class="termref" href="#dt-striding">striding</a>: for
example <code>(author | editor)</code>. In general, however, the
combination of two striding operands may produce a sequence of
nodes that have <span>nested</span> subtrees (consider <code>author
| author/name</code>), so the result is classified as <a title=
"crawling" class="termref" href="#dt-crawling">crawling</a>.</p>
<p>The expression <code>(author | editor)</code>, although it is
not <a title="striding" class="termref" href=
"#dt-striding">striding</a>, can be rewritten in the form
<code>*[self::author or self::editor]</code>, which is <a title=
"striding" class="termref" href="#dt-striding">striding</a>.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-of-simple-mapping-expressions" id=
"streamability-of-simple-mapping-expressions"></a>19.8.7.5 <a href=
"#streamability-of-simple-mapping-expressions" style=
"text-decoration: none">Streamability of Simple Mapping
Expressions</a></h5>
<p>The mapping operator <code>!</code> is treated as a
left-associative binary operator, so the expression
<code>a!b!c</code> is processed as <code>(a!b)!c</code>.</p>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of the expression are the <a title=
"posture" class="termref" href="#dt-posture">posture</a> and
<a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the
right-hand operand, assessed with a <span><a title=
"context posture" class="termref" href=
"#dt-context-posture">context posture</a></span> and type set to
the <a title="posture" class="termref" href=
"#dt-posture">posture</a> and type of the <span>left-hand</span>
operand.</p>
</div>
<div class="div4">
<h5><a name="streamability-of-path-expressions" id=
"streamability-of-path-expressions"></a>19.8.7.6 <a href=
"#streamability-of-path-expressions" style=
"text-decoration: none">Streamability of Path Expressions</a></h5>
<p>The streamability analysis applies after the expansion of the
<code>//</code> pseudo-operator to
<code>/descendant-or-self::node()/</code>, and after expanding
<code>..</code> to <code>parent::node()</code>, <code>@X</code> to
<code>attribute::X</code>, and an omitted axis to
<code>child::</code>.</p>
<p>Following the rules in XPath, a leading <code>"/"</code> is
converted to <code>(root(self::node()) treat as
document-node())/</code> (with the final <code>"/"</code> omitted
for the expression <code>"/"</code> on its own). This is followed
by a rewrite of the call on <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-root"><code>root</code></a><sup><small>FO30</small></sup>,
as described in <a href="#streamability-fn-root"><i>19.8.8.18
Streamability of the root function</i></a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Taken together, these rewrites have the effect that a path
expression such as <code>//a</code> is streamable only if the
statically-determined context item type is
<code>document-node()</code>, which will be the case for example
immediately within <a href=
"#element-stream"><code>xsl:stream</code></a>, or in a template
rule with <code>match="/"</code>.</p>
</div>
<p>A <code>RelativePathExpr</code> with more than two operands
(such as <code>a/b/c</code>) is taken as a tree of binary
expressions (that is, <code>(a/b)/c</code>).</p>
<p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a>
of a relative path expression is the wider <a title="sweep" class=
"termref" href="#dt-sweep">sweep</a> of the two operands, where the
ordering of increasing width is <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>, <a title=
"consuming" class="termref" href="#dt-consuming">consuming</a>,
<a title="free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Examples:</p>
<ul>
<li>
<p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a>
of <code>a/@code</code> is <a title="consuming" class="termref"
href="#dt-consuming">consuming</a> (the wider of <a title=
"consuming" class="termref" href="#dt-consuming">consuming</a> and
<a title="motionless" class="termref" href=
"#dt-motionless">motionless</a>).</p>
</li>
<li>
<p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a>
of <code>a/descendant::b</code> is <a title="consuming" class=
"termref" href="#dt-consuming">consuming</a> (the wider of
<a title="consuming" class="termref" href=
"#dt-consuming">consuming</a> and <a title="consuming" class=
"termref" href="#dt-consuming">consuming</a>).</p>
</li>
<li>
<p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a>
of <code>./@code</code> is <a title="motionless" class="termref"
href="#dt-motionless">motionless</a> (the wider of <a title=
"motionless" class="termref" href="#dt-motionless">motionless</a>
and <a title="motionless" class="termref" href=
"#dt-motionless">motionless</a>).</p>
</li>
<li>
<p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a>
of <code>./a</code> is <a title="consuming" class="termref" href=
"#dt-consuming">consuming</a> (the wider of <a title="motionless"
class="termref" href="#dt-motionless">motionless</a> and <a title=
"consuming" class="termref" href=
"#dt-consuming">consuming</a>).</p>
</li>
<li>
<p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a>
of <code>a/following::b</code> is <a title="free-ranging" class=
"termref" href="#dt-free-ranging">free-ranging</a> (the wider of
<a title="consuming" class="termref" href=
"#dt-consuming">consuming</a> and <a title="free-ranging" class=
"termref" href="#dt-free-ranging">free-ranging</a>).</p>
</li>
<li>
<p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a>
of <code>./.</code> is <a title="motionless" class="termref" href=
"#dt-motionless">motionless</a> (the wider of <a title="motionless"
class="termref" href="#dt-motionless">motionless</a> and <a title=
"motionless" class="termref" href=
"#dt-motionless">motionless</a>).</p>
</li>
</ul>
</div>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> of a relative path expression is assessed
in two phases, as follows:</p>
<ol class="enumar">
<li>
<p>First, the provisional posture is determined as follows: The
provisional posture of the expression is the <a title="posture"
class="termref" href="#dt-posture">posture</a> of the right-hand
operand, assessed with a <span><a title="context posture" class=
"termref" href="#dt-context-posture">context posture</a></span> and
type set to the <a title="posture" class="termref" href=
"#dt-posture">posture</a> and type of the <span>left-hand</span>
operand; and the provisional sweep is the wider of the sweeps of
the two operands.</p>
</li>
<li>
<p>If the provisional posture is <a title="free-ranging" class=
"termref" href="#dt-free-ranging">free-ranging</a>, then it is
reassessed as follows:</p>
<ol class="enumla">
<li>
<p>A <b>scanning expression</b> is any of the following:</p>
<ol class="enumlr">
<li>
<p>An <code>AxisStep</code> whose axis is <code>child</code>,
<code>descendant</code>, <code>descendant-or-self</code>, or
<code>self</code>, in which every <code>Predicate</code> (if any)
is <a title="motionless" class="termref" href=
"#dt-motionless">motionless</a> and <a title=
"non-positional predicate" class="termref" href=
"#dt-non-positional-predicate">non-positional</a>.</p>
</li>
<li>
<p>A <code>RelativePathExpr</code> in the form <code>L/R</code>
where both <code>L</code> and <code>R</code> are <b>scanning
expressions</b>.</p>
</li>
<li>
<p>A <b>filter expression</b> (see <a href=
"http://www.w3.org/TR/xpath-30/#id-filter-expression">Section 3.2.1
Filter Expressions</a> <sup><small>XP30</small></sup>) in the form
<code>E[P]</code> where <var>E</var> is a <b>scanning
expression</b> and the predicate <var>P</var> is <a title=
"motionless" class="termref" href="#dt-motionless">motionless</a>
and <a title="non-positional predicate" class="termref" href=
"#dt-non-positional-predicate">non-positional</a>.</p>
</li>
<li>
<p>A <code>union</code>, <code>intersect</code>, or
<code>except</code> expression in which both operands are
<b>scanning expressions</b>.</p>
</li>
</ol>
</li>
<li>
<p>If the expression is a <b>scanning expression</b> then its
<a title="posture" class="termref" href="#dt-posture">posture</a>
is <a title="crawling" class="termref" href=
"#dt-crawling">crawling</a>.</p>
</li>
</ol>
</li>
<li>
<p>Otherwise (if the provisional posture is not <a title=
"free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>, or the expression is not a
<b>scanning expression</b>), the posture of the expression is the
provisional posture.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The subset of expressions that qualify as scanning expressions
is very similar to the subset that qualify as motionless patterns,
and a possible evaluation strategy for scanning expressions is to
examine each descendant of the context node and test whether it
matches the corresponding pattern.</p>
<p>An effect of the rules is that positional predicates (such as
<code>[1]</code>) are allowed in the left-hand operand of a
relative path expression if it uses the child axis, but not if it
uses the descendant axis.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Examples:</p>
<p>In each of the following cases, assume that the <a title=
"context posture" class="termref" href=
"#dt-context-posture">context posture</a> is striding.</p>
<ul>
<li>
<p>The posture of the expression <code>a/b/c</code> is striding,
because (under the rules for AxisStep [38]) a child axis step
evaluated with striding context posture creates a new striding
posture.</p>
</li>
<li>
<p>The posture of the expression <code>a/descendant::c</code> is
crawling, because a descendant axis step evaluated with striding
context posture creates a new crawling posture.</p>
</li>
<li>
<p>The posture of the expression <code>../@status</code> is
climbing, because a parent axis step evaluated with striding
context posture creates a new climbing posture, and an attribute
axis step evaluated with climbing context posture creates a new
climbing posture.</p>
</li>
<li>
<p>The posture of the expression
<code>copy-of(.)//a/following-sibling::*</code> is grounded,
because the <a href="#func-copy-of"><code>copy-of</code></a>
evaluated with striding posture creates a grounded posture, and all
subsequent axis steps leave this posture unchanged.</p>
</li>
<li>
<p>The expression <code>section//head</code> expands to
<code>(section/descendant-or-self::node())/child::head</code>. The
posture of the left-hand operand
<code>section/descendant-or-self::node()</code> is crawling,
because a descendant axis step evaluated with striding context
posture creates a new crawling posture. The provisional posture of
the expression as a whole is therefore free-ranging, because a
child axis step evaluated with crawling context posture gives a
resulting free-ranging posture. However, both operands are scanning
expressions, so the expression as a whole has crawling posture.</p>
</li>
<li>
<p>The expression <code>section//head[1]</code> is free-ranging:
unlike the previous example, it contains a positional predicate,
which means that the operands do not satisfy the rules for scanning
expressions.</p>
</li>
</ul>
</div>
</div>
<div class="div4">
<h5><a name="streamability-of-axis-steps" id=
"streamability-of-axis-steps"></a>19.8.7.7 <a href=
"#streamability-of-axis-steps" style=
"text-decoration: none">Streamability of Axis Steps</a></h5>
<p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a>
and <a title="posture" class="termref" href=
"#dt-posture">posture</a> of the expression <var>S</var> are
determined by the first of the following rules that applies:</p>
<ol class="enumar">
<li>
<p>If the <span><a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a></span> is <a title=
"grounded" class="termref" href="#dt-grounded">grounded</a>, then
the sweep is <a title="motionless" class="termref" href=
"#dt-motionless">motionless</a> and the posture is <a title=
"grounded" class="termref" href="#dt-grounded">grounded</a>;</p>
</li>
<li>
<p>If the <span><a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a></span> is <a title=
"roaming" class="termref" href="#dt-roaming">roaming</a>, then the
sweep is <a title="free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a> and the posture is <a title=
"roaming" class="termref" href="#dt-roaming">roaming</a>;</p>
</li>
<li>
<p>If the statically-inferred <a title="context item type" class=
"termref" href="#dt-context-item-type">context item type</a> is
such that the axis will always be empty (for example, applying the
child axis to a text node or the parent axis to a document node),
<span>or if the <code>NodeTest</code> is one that can never select
nodes on the chosen axis (for example, selecting attribute nodes on
the child axis),</span> then the sweep is <a title="motionless"
class="termref" href="#dt-motionless">motionless</a> and the
posture is <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> (because the expression is statically
known to return an empty sequence);</p>
</li>
<li>
<p>If all the following conditions are satisfied:</p>
<ol class="enumla">
<li>
<p>The <a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a> is <a title="striding"
class="termref" href="#dt-striding">striding</a></p>
</li>
<li>
<p>The axis is <code>descendant</code> or
<code>descendant-or-self</code></p>
</li>
<li>
<p>There is a predicate <var>P</var> in the
<code>PredicateList</code> that satisfies all the following
conditions:</p>
<ol class="enumlr">
<li>
<p>The static type of <var>P</var> is a subtype of
<code>U{xs:decimal, xs:double, xs:float}</code></p>
</li>
<li>
<p>Neither <var>P</var>, nor any operand of <var>P</var>, at any
depth provided it has the Axis Step <var>S</var> as its <a title=
"focus-setting container" class="termref" href=
"#dt-focus-setting-container">focus-setting container</a>, is a
context item expression, an axis expression, or a call on a
focus-dependent function;</p>
</li>
</ol>
</li>
</ol>
<p>then <a title="striding" class="termref" href=
"#dt-striding">striding</a> and <a title="consuming" class=
"termref" href="#dt-consuming">consuming</a></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Examples are <code>descendant::section[1]</code>,
<code>descendant::section[$i+1]</code>,
<code>descendant::section[count($x)]</code>. The significance of
this rule is that it detects cases where the descendant axis
selects a singleton, and where the posture of the result can
therefore be striding rather than consuming.</p>
</div>
</li>
<li>
<p>If the <code>PredicateList</code> contains a
<code>Predicate</code> that is not <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>, then the sweep is
<a title="free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a> and the posture is <a title=
"roaming" class="termref" href="#dt-roaming">roaming</a>;</p>
</li>
<li>
<p>Otherwise, the <a title="sweep" class="termref" href=
"#dt-sweep">sweep</a> and <a title="posture" class="termref" href=
"#dt-posture">posture</a> of the expression are as determined by
the table below, based on the <span><a title="context posture"
class="termref" href="#dt-context-posture">context
posture</a></span> and the choice of axis:</p>
<table summary=
"Streamability of Axis Steps Based on Context Posture" border="1"
cellpadding="5" width="100%">
<thead>
<tr>
<th colspan="1" align="left" valign="top">Context posture</th>
<th colspan="1" align="left" valign="top">Axis</th>
<th colspan="1" align="left" valign="top">Result posture</th>
<th colspan="1" align="left" valign="top">Sweep</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top">Grounded</td>
<td align="left" valign="top">any</td>
<td align="left" valign="top">Grounded</td>
<td align="left" valign="top">Motionless</td>
</tr>
<tr>
<td align="left" valign="top">Climbing</td>
<td align="left" valign="top">self, parent, ancestor-or-self,
ancestor, attribute, namespace</td>
<td align="left" valign="top">Climbing</td>
<td align="left" valign="top">Motionless</td>
</tr>
<tr>
<td align="left" valign="top">Striding</td>
<td align="left" valign="top"><span>parent</span>,
ancestor-or-self, ancestor, attribute, namespace</td>
<td align="left" valign="top">Climbing</td>
<td align="left" valign="top">Motionless</td>
</tr>
<tr>
<td align="left" valign="top">Striding</td>
<td align="left" valign="top">self</td>
<td align="left" valign="top">Striding</td>
<td align="left" valign="top">Motionless</td>
</tr>
<tr>
<td align="left" valign="top">Striding</td>
<td align="left" valign="top">child</td>
<td align="left" valign="top">Striding</td>
<td align="left" valign="top">Consuming</td>
</tr>
<tr>
<td align="left" valign="top">Striding</td>
<td align="left" valign="top">descendant, descendant-or-self</td>
<td align="left" valign="top">Crawling</td>
<td align="left" valign="top">Consuming</td>
</tr>
<tr>
<td align="left" valign="top">Crawling</td>
<td align="left" valign="top"><span>parent</span>,
ancestor-or-self, ancestor, attribute, namespace</td>
<td align="left" valign="top">Climbing</td>
<td align="left" valign="top">Motionless</td>
</tr>
<tr>
<td align="left" valign="top">Crawling</td>
<td align="left" valign="top">self</td>
<td align="left" valign="top">Crawling</td>
<td align="left" valign="top">Motionless</td>
</tr>
<tr>
<td colspan="2" align="left" valign="top">Any other
combination</td>
<td align="left" valign="top">Roaming</td>
<td align="left" valign="top">Free-ranging</td>
</tr>
</tbody>
</table>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This analysis does not attempt to classify
<code>para[title]</code> as a consuming expression; an
implementation might choose to do so.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-of-filter-expressions" id=
"streamability-of-filter-expressions"></a>19.8.7.8 <a href=
"#streamability-of-filter-expressions" style=
"text-decoration: none">Streamability of Filter
Expressions</a></h5>
<p>For a filter expression <var>F</var> of the form
<code>B[P]</code> (where <var>B</var> might itself be a filter
expression), the <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> are the first of the following that
applies:</p>
<ol class="enumar">
<li>
<p>If all the following conditions are satisfied:</p>
<ol class="enumla">
<li>
<p><var>B</var> is crawling;</p>
</li>
<li>
<p>The static type of <var>P</var> is a subtype of
<code>U{xs:decimal, xs:double, xs:float}</code>, and</p>
</li>
<li>
<p>Neither <var>P</var>, nor any operand of <var>P</var>, at any
depth provided it has <var>F</var> as its focus-setting container,
is a context item expression, an axis expression, or a call on a
focus-dependent function</p>
</li>
</ol>
<p>then the <a title="posture" class="termref" href=
"#dt-posture">posture</a> is <a title="striding" class="termref"
href="#dt-striding">striding</a> and the <a title="sweep" class=
"termref" href="#dt-sweep">sweep</a> is the sweep of
<var>B</var>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This rule captures cases where it can be statically determined
that the predicate is numeric and is independent of the focus. In
such cases, the filter expression selects at most one node, and the
posture can therefore be changed from crawling to striding (if
there is only one node, there can be no overlapping trees).
Examples of filter expressions that satisfy this test are
<code>(//x)[3]</code>, <code>(//x)[$i+1]</code>,
<code>(//x)[index-of($a, $b)[last()]]</code>, and <code>(//x)[1 to
5]</code>. The last example will actually raise a type error
because <code>1 to 5</code> has no effective boolean value; but if
expressions are going to fail, it does not matter what their
streamability properties are.</p>
</div>
</li>
<li>
<p>If <var>P</var> is <a title="motionless" class="termref" href=
"#dt-motionless">motionless</a>, then the <a title="posture" class=
"termref" href="#dt-posture">posture</a> and <a title="sweep"
class="termref" href="#dt-sweep">sweep</a> of <var>B</var>;</p>
</li>
<li>
<p>Otherwise, <a title="roaming" class="termref" href=
"#dt-roaming">roaming</a> and <a title="free-ranging" class=
"termref" href="#dt-free-ranging">free-ranging</a>.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The first rule allows a construct such as
<code>&lt;xsl:apply-templates select="(//title)[1]"/&gt;</code>,
where a <a title="crawling" class="termref" href=
"#dt-crawling">crawling</a> operand would not be guaranteed
streamable.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This section is not applicable to predicates forming part of an
axis step, such as <code>//title[1]</code>, as these are not
technically filter expressions. See <a href=
"#streamability-of-axis-steps"><i>19.8.7.7 Streamability of Axis
Steps</i></a>.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-of-dynamic-function-calls" id=
"streamability-of-dynamic-function-calls"></a>19.8.7.9 <a href=
"#streamability-of-dynamic-function-calls" style=
"text-decoration: none">Streamability of Dynamic Function
Calls</a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of a dynamic function call such as
<code>$F(X, Y)</code> are determined by the <a href=
"#general-streamability-rules"><i>19.8.1 General Rules for
Streamability</i></a>. The operands and their usages are as
follows:</p>
<ol class="enumar">
<li>
<p>The base expression that computes the function value itself
(here <code>$F</code>). This has usage <a title="inspection" class=
"termref" href="#dt-inspection">inspection</a>.</p>
</li>
<li>
<p>The argument expressions <span>excluding any <code>?</code>
placeholders</span> (here <code>X</code> and <code>Y</code>). These
have <a title="type-determined usage" class="termref" href=
"#dt-type-determined-usage">type-determined usage</a> dependent on
<span>ancillary information associated with the <a title=
"static type" class="termref" href="#dt-static-type">static
type</a> of the base expression, where available (see <a href=
"#determining-static-type"><i>19.2 Determining the Static Type of a
Construct</i></a>). If this information indicates that the base
expression is a function with signature</span> <code>function(A, B,
...) as R</code>, then the first argument <code>X</code> has
type-determined usage based on the first argument type
<code>A</code>, the second argument <code>Y</code> has
type-determined usage based on the second argument type
<code>B</code>, and so on. If <span>no function signature is
available</span>, then the usage of each of the argument
expressions is <a title="navigation" class="termref" href=
"#dt-navigation">navigation</a>.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>As explained in <a href="#function-lookup"><i>10.3.6 Dynamic
Access to Functions</i></a>, use of a dynamic function call where
the function value is bound to a focus-dependent function such as
<code>name#0</code>, <code>lang#1</code>, or <code>last#0</code> is
likely to lead to a dynamic error if the context item is a node in
a streamed document, but this does not affect the static
streamability analysis.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-of-variable-references" id=
"streamability-of-variable-references"></a>19.8.7.10 <a href=
"#streamability-of-variable-references" style=
"text-decoration: none">Streamability of Variable
References</a></h5>
<p>The following rules apply to a variable reference that is bound
to a parameter of a <a title="stylesheet function" class="termref"
href="#dt-stylesheet-function">stylesheet function</a> declared
with <code>streamable="yes"</code> where the declared type permits
nodes. The declared type permits nodes if the <code>as</code>
attribute on the <a href=
"#element-param"><code>xsl:param</code></a> element is absent, or
if it is a SequenceType that maps to a <a title="U-type" class=
"termref" href="#dt-utype">U-type</a> that has a non-empty
intersection with <var>U{N}</var> (see <a href=
"#determining-static-type"><i>19.2 Determining the Static Type of a
Construct</i></a>):</p>
<ul>
<li>
<p>If the path in the construct tree that connects the variable
reference to the <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> forming
the body of the stylesheet function contains a <a title="construct"
class="termref" href="#dt-construct">construct</a> that is a
<a title="higher-order operand" class="termref" href=
"#dt-higher-order-operand">higher-order operand</a> of its parent
construct, then the variable reference is <a title="roaming" class=
"termref" href="#dt-roaming">roaming</a> and <a title=
"free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>.</p>
</li>
<li>
<p>Otherwise, the variable reference is <a title="striding" class=
"termref" href="#dt-striding">striding</a> and <a title=
"motionless" class="termref" href=
"#dt-motionless">motionless</a>.</p>
</li>
</ul>
<p>All other variable references are <a title="grounded" class=
"termref" href="#dt-grounded">grounded</a> and <a title=
"motionless" class="termref" href=
"#dt-motionless">motionless</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p><span>These rules reflect the fact that a node in a streamed
document can never be bound to a variable</span>, <span>except in
the special case of a streamed node that is passed as a parameter
to a streamable stylesheet function, as explained in <a href=
"#streamable-stylesheet-functions"><i>10.3.5 Streamability of
Stylesheet Functions</i></a></span>.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-of-context-item-expression" id=
"streamability-of-context-item-expression"></a>19.8.7.11 <a href=
"#streamability-of-context-item-expression" style=
"text-decoration: none">Streamability of the Context Item
Expression</a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> of the expression is the <span><a title=
"context posture" class="termref" href=
"#dt-context-posture">context posture</a></span>, and the <a title=
"sweep" class="termref" href="#dt-sweep">sweep</a> is <a title=
"motionless" class="termref" href=
"#dt-motionless">motionless</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Although <code>.</code> is intrinsically motionless, when used
in certain contexts (such as <code>data(.)</code>) the containing
expression will be <a title="consuming" class="termref" href=
"#dt-consuming">consuming</a>. This arises because of the <a title=
"operand usage" class="termref" href="#dt-operand-usage">operand
usage</a>: the argument to <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-data"><code>data</code></a><sup><small>FO30</small></sup>
has usage <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>, and the combination of a <a title=
"motionless" class="termref" href="#dt-motionless">motionless</a>
operand with usage <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a> leads to the containing expression
being <a title="consuming" class="termref" href=
"#dt-consuming">consuming</a>.</p>
<p>Similarly, if <code>.</code> is used where the operand usage is
<a title="navigation" class="termref" href=
"#dt-navigation">navigation</a>, the containing expression will be
<a title="free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-of-function-calls" id=
"streamability-of-function-calls"></a>19.8.7.12 <a href=
"#streamability-of-function-calls" style=
"text-decoration: none">Streamability of Function Calls</a></h5>
<p>For calls to built-in functions, see <a href=
"#classifying-built-in-functions"><i>19.8.8 Classifying Calls to
Built-In Functions</i></a>.</p>
<p>For partial function applications (where one or more of the
arguments is supplied as a <code>?</code> placeholder), see the
rules at the end of this section.</p>
<p>For a call to a constructor function, the <a href=
"#general-streamability-rules"><i>19.8.1 General Rules for
Streamability</i></a> apply. There is a single operand role (the
argument to the function), with <a title="operand usage" class=
"termref" href="#dt-operand-usage">operand usage</a> <a title=
"absorption" class="termref" href=
"#dt-absorption">absorption</a>.</p>
<p>For a call to a <a title="stylesheet function" class="termref"
href="#dt-stylesheet-function">stylesheet function</a>, the
<span>following rules apply, in order:</span></p>
<ol class="enumar">
<li>
<p>If the referenced function is declared with
<code>streamable="yes"</code>:</p>
<ol class="enumla">
<li>
<p>At most one argument of a streamable function is allowed to
accept nodes; call this the streaming argument.</p>
</li>
<li>
<p>If the expression supplied as the streaming argument is
<a title="grounded" class="termref" href=
"#dt-grounded">grounded</a>, then the <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>
apply. There is one <a title="operand role" class="termref" href=
"#dt-operand-role">operand role</a> for each argument in the
function signature, and its <a title="operand usage" class=
"termref" href="#dt-operand-usage">operand usage</a> is the
<a title="type-determined usage" class="termref" href=
"#dt-type-determined-usage">type-determined usage</a> based on the
declared type of that argument.</p>
</li>
<li>
<p>A streamable function is said to be analyzable if it is not
recursive. For this purpose a function <var>F</var> is recursive if
it contains a call on <var>F</var>, or on a potential caller of
<var>F</var>; a function is a potential caller of <var>F</var> if
it either (a) contains a call on <var>F</var>, or (b) contains a
call on a potential caller of <var>F</var>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Any dynamic function call could also be treated as a potential
caller of <var>F</var>; however, functions containing dynamic
function calls that could jeopardize streamability will be deemed
non-streamable as a consequence of other rules.</p>
</div>
</li>
<li>
<p>If the target function is analyzable then the <a title="posture"
class="termref" href="#dt-posture">posture</a> of the function call
is the posture of the sequence constructor making up the body of
the target function, and the <a title="sweep" class="termref" href=
"#dt-sweep">sweep</a> of the function call is the wider of the
sweep of the expression supplied as the streaming argument, and the
sweep of the sequence constructor making up the body of the target
function.</p>
</li>
<li>
<p>If the expression supplied as the streaming argument is
<a title="climbing" class="termref" href=
"#dt-climbing">climbing</a> or <a title="crawling" class="termref"
href="#dt-crawling">crawling</a>, the function call is <a title=
"roaming" class="termref" href="#dt-roaming">roaming</a> and
<a title="free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>.</p>
</li>
<li>
<p>Otherwise, the function call is <a title="striding" class=
"termref" href="#dt-striding">striding</a> and <a title="consuming"
class="termref" href="#dt-consuming">consuming</a>.</p>
</li>
</ol>
</li>
<li>
<p>Otherwise, the <a title="general streamability rules" class=
"termref" href="#dt-general-streamability-rules">general
streamability rules</a> apply. There is one <a title="operand role"
class="termref" href="#dt-operand-role">operand role</a> for each
argument in the function signature, and its <a title=
"operand usage" class="termref" href="#dt-operand-usage">operand
usage</a> is the <a title="type-determined usage" class="termref"
href="#dt-type-determined-usage">type-determined usage</a> based on
the declared type of that argument.</p>
</li>
</ol>
<p>For a call to an <a title="extension function" class="termref"
href="#dt-extension-function">extension function</a>, the <a title=
"posture" class="termref" href="#dt-posture">posture</a> and
<a title="sweep" class="termref" href="#dt-sweep">sweep</a> are
<a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
<p>If the function call is a partial function application (that is,
one or more of the arguments is given as <code>?</code>), then:</p>
<ol class="enumar">
<li>
<p>If the function is focus-dependent <span>and the <a title=
"context posture" class="termref" href=
"#dt-context-posture">context posture</a> is not <a title=
"grounded" class="termref" href="#dt-grounded">grounded</a></span>,
then the function call is <span><a title="roaming" class="termref"
href="#dt-roaming">roaming</a> and</span> <a title="free-ranging"
class="termref" href="#dt-free-ranging">free-ranging</a>.</p>
</li>
<li>
<p>If the target of the function call is a <a title=
"stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet function</a> declared with
<code>streamable="yes"</code>, and if the argument of the function
that is allowed to accept streamed nodes is actually supplied (that
is, this argument is not supplied as a <code>?</code> placeholder),
then the function call is <a title="roaming" class="termref" href=
"#dt-roaming">roaming</a> and <a title="free-ranging" class=
"termref" href="#dt-free-ranging">free-ranging</a>.</p>
</li>
<li>
<p>If the target is an <a title="extension function" class=
"termref" href="#dt-extension-function">extension function</a>, the
<a title="posture" class="termref" href="#dt-posture">posture</a>
and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> are
<a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
</li>
<li>
<p>Otherwise, the <a title="general streamability rules" class=
"termref" href="#dt-general-streamability-rules">general
streamability rules</a> apply. <span>The operands of a partial
function application are the expressions actually supplied as
arguments to the function, ignoring <code>?</code> place-holders;
the corresponding <a title="operand usage" class="termref" href=
"#dt-operand-usage">operand usage</a> is the <a title=
"type-determined usage" class="termref" href=
"#dt-type-determined-usage">type-determined usage</a> based on the
declared type of that argument.</span></p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="streamability-of-named-function-ref" id=
"streamability-of-named-function-ref"></a>19.8.7.13 <a href=
"#streamability-of-named-function-ref" style=
"text-decoration: none">Streamability of Named Function
References</a></h5>
<p>Let <var>F</var> be the function to which the
<code>NamedFunctionRef</code> refers.</p>
<p>If <var>F</var> is focus-dependent <span>and the <a title=
"context posture" class="termref" href=
"#dt-context-posture">context posture</a> is not <a title=
"grounded" class="termref" href="#dt-grounded">grounded</a></span>,
then the <code>NamedFunctionRef</code> is <span><a title="roaming"
class="termref" href="#dt-roaming">roaming</a> and</span> <a title=
"free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>.</p>
<p>If <var>F</var> is an <a title="extension function" class=
"termref" href="#dt-extension-function">extension function</a>, the
<a title="posture" class="termref" href="#dt-posture">posture</a>
and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> are
<a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
<p>Otherwise, the <code>NamedFunctionRef</code> is <span><a title=
"grounded" class="termref" href="#dt-grounded">grounded</a>
and</span> <a title="motionless" class="termref" href=
"#dt-motionless">motionless</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The main intent behind these rules is to ensure that the
function item returned by a named function reference does not
encapsulate a reference to a streamed node.</p>
<p>In the case of an expression such as <code>local-name#0</code>,
implementations might be able to do better by pre-evaluating the
function at the point where the named function reference
occurs.</p>
<p>In the case of extension functions, implementations may be able
to distinguish whether the function is focus-dependent, and decide
the streamability of the named function reference accordingly.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-of-inline-functions" id=
"streamability-of-inline-functions"></a>19.8.7.14 <a href=
"#streamability-of-inline-functions" style=
"text-decoration: none">Streamability of Inline Function
Declarations</a></h5>
<p>An inline function declaration that appears textually within a
<a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet function</a> declared with
<code>streamable="yes"</code> is <a title="roaming" class="termref"
href="#dt-roaming">roaming</a> and <a title="free-ranging" class=
"termref" href="#dt-free-ranging">free-ranging</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>However, this makes no difference if the containing stylesheet
function has no parameter that accepts nodes, because such a
function is guaranteed streamable regardless of its body: see
<a href="#streamable-stylesheet-functions"><i>10.3.5 Streamability
of Stylesheet Functions</i></a>.</p>
</div>
<p>All other inline function declarations are <a title="grounded"
class="termref" href="#dt-grounded">grounded</a> and <a title=
"motionless" class="termref" href=
"#dt-motionless">motionless</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The reason that inline function declarations within a streamed
stylesheet function are not streamable is that they may include
references to streamed nodes in the function's closure.
Implementations may be able to do better by detecting cases where
there are in fact no such references.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-of-map-expressions" id=
"streamability-of-map-expressions"></a>19.8.7.15 <a href=
"#streamability-of-map-expressions" style=
"text-decoration: none">Streamability of map expressions</a></h5>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of a map expression are the same as the
<a title="posture" class="termref" href="#dt-posture">posture</a>
and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of
the equivalent <a href="#element-map"><code>xsl:map</code></a>
instruction. The equivalent <a href=
"#element-map"><code>xsl:map</code></a> instruction is formed by
creating a sequence of <a href=
"#element-map-entry"><code>xsl:map-entry</code></a> instructions,
one for each key/value pair in the map expression, where the key
expression becomes the value of <code>xsl:map-entry/@key</code>,
and the value expression becomes the value of
<code>xsl:map-entry/@select</code>; this sequence of <a href=
"#element-map-entry"><code>xsl:map-entry</code></a> instructions is
then wrapped in an <a href="#element-map"><code>xsl:map</code></a>
parent instruction.</p>
<p>For example, the map expression <code>map{'red':false(),
'green':true()}</code> translates to the instruction:</p>
<div class="exampleInner">
<pre>
&lt;xsl:map&gt;
  &lt;xsl:map-entry key="'red'" select="false()"/&gt;
  &lt;xsl:map-entry key="'green'" select="true()"/&gt;
&lt;/xsl:map&gt;
</pre></div>
<p>The rules for the streamability of <a href=
"#element-map"><code>xsl:map</code></a> appear in <a href=
"#streamability-xsl-map"><i>19.8.4.23 Streamability of
xsl:map</i></a>.</p>
<p>See also <a href="#maps-streaming"><i>21.1.5 Maps and
Streaming</i></a>.</p>
</div>
</div>
<div class="div3">
<h4><a name="classifying-built-in-functions" id=
"classifying-built-in-functions"></a>19.8.8 <a href=
"#classifying-built-in-functions" style=
"text-decoration: none">Classifying Calls to Built-In
Functions</a></h4>
<p>This section describes the rules that determine the
streamability of calls to built-in functions. These differ from
user-written functions because it is known (defined in the
specification) how nodes supplied as operands are used. Knowledge
of the usage of each operand, together with the <a title="posture"
class="termref" href="#dt-posture">posture</a> of the actual
operands, is in most cases enough to determine the <a title=
"posture" class="termref" href="#dt-posture">posture</a> and
<a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the
function result.</p>
<p>All the built-in functions are listed below. For most functions,
a simple proforma is shown that indicates the operand usage of each
argument, using the code (A = <a title="absorption" class="termref"
href="#dt-absorption">absorption</a>, I = <a title="inspection"
class="termref" href="#dt-inspection">inspection</a>, T = <a title=
"transmission" class="termref" href=
"#dt-transmission">transmission</a>, N = <a title="navigation"
class="termref" href="#dt-navigation">navigation</a>). So, for
example, the entry <code>fn:remove(T, A)</code> means that for the
function <code>fn:remove#2</code>, the operand usage of the first
argument is <a title="transmission" class="termref" href=
"#dt-transmission">transmission</a>, and the operand usage of the
second argument is <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>. By reference to the general rules
in <a href="#general-streamability-rules"><i>19.8.1 General Rules
for Streamability</i></a>, this demonstrates that if the
<span><a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a></span> is <a title=
"striding" class="termref" href="#dt-striding">striding</a>, the
posture and sweep of the expression <code>sum(remove(*,1))</code>
will be <code>grounded</code> and <code>consuming</code>
respectively.</p>
<p>For functions that default one of their arguments (typically to
the context item), the relevant entry shows the equivalence, and
the posture and sweep can in these cases be computed by filling in
the default value for the relevant argument.</p>
<p>Some functions do not follow the general rules, and these are
listed with a link to the section where the particular rules for
that function are described.</p>
<ul>
<li>
<p><code>fn:abs(A)</code></p>
</li>
<li>
<p><code>fn:accumulator-after</code> – See <a href=
"#streamability-fn-accumulator-after"><i>19.8.8.1 Streamability of
the accumulator-after function</i></a></p>
</li>
<li>
<p><code>fn:accumulator-before</code> – See <a href=
"#streamability-fn-accumulator-before"><i>19.8.8.2 Streamability of
the accumulator-before function</i></a></p>
</li>
<li>
<p><code>fn:adjust-date-to-timezone(A)</code></p>
</li>
<li>
<p><code>fn:adjust-date-to-timezone(A, A)</code></p>
</li>
<li>
<p><code>fn:adjust-dateTime-to-timezone(A)</code></p>
</li>
<li>
<p><code>fn:adjust-dateTime-to-timezone(A, A)</code></p>
</li>
<li>
<p><code>fn:adjust-time-to-timezone(A)</code></p>
</li>
<li>
<p><code>fn:adjust-time-to-timezone(A, A)</code></p>
</li>
<li>
<p><code>fn:analyze-string(A, A)</code></p>
</li>
<li>
<p><code>fn:analyze-string(A, A, A)</code></p>
</li>
<li>
<p><code>fn:available-environment-variables()</code></p>
</li>
<li>
<p><code>fn:avg(A)</code></p>
</li>
<li>
<p><code>fn:base-uri()</code> – Equivalent to
<code>fn:base-uri(.)</code></p>
</li>
<li>
<p><code>fn:base-uri(I)</code></p>
</li>
<li>
<p><code>fn:boolean(I)</code></p>
</li>
<li>
<p><code>fn:ceiling(A)</code></p>
</li>
<li>
<p><code>fn:codepoint-equal(A, A)</code></p>
</li>
<li>
<p><code>fn:codepoints-to-string(A)</code></p>
</li>
<li>
<p><code>fn:collation-key(A)</code></p>
</li>
<li>
<p><code>fn:collation-key(A, A)</code></p>
</li>
<li>
<p><code>fn:collection()</code></p>
</li>
<li>
<p><code>fn:collection(A)</code></p>
</li>
<li>
<p><code>fn:compare(A, A)</code></p>
</li>
<li>
<p><code>fn:compare(A, A, A)</code></p>
</li>
<li>
<p><code>fn:concat(A, A, A)</code></p>
</li>
<li>
<p><code>fn:contains(A, A)</code></p>
</li>
<li>
<p><code>fn:contains(A, A, A)</code></p>
</li>
<li>
<p><code>fn:copy-of()</code> – Equivalent to
<code>fn:copy-of(.)</code></p>
</li>
<li>
<p><code>fn:copy-of(A)</code></p>
</li>
<li>
<p><code>fn:count(I)</code></p>
</li>
<li>
<p><code>fn:current</code> – See <a href=
"#streamability-fn-current"><i>19.8.8.3 Streamability of the
current function</i></a></p>
</li>
<li>
<p><code>fn:current-date()</code></p>
</li>
<li>
<p><code>fn:current-dateTime()</code></p>
</li>
<li>
<p><code>fn:current-group</code> – See <a href=
"#streamability-fn-current-group"><i>19.8.8.4 Streamability of the
current-group function</i></a></p>
</li>
<li>
<p><code>fn:current-grouping-key</code> – See <a href=
"#streamability-fn-current-grouping-key"><i>19.8.8.5 Streamability
of the current-grouping-key function</i></a></p>
</li>
<li>
<p><code>fn:current-merge-group</code> – See <a href=
"#streamability-fn-current-merge-group"><i>19.8.8.6 Streamability
of the current-merge-group function</i></a></p>
</li>
<li>
<p><code>fn:current-merge-key</code> – See <a href=
"#streamability-fn-current-merge-key"><i>19.8.8.7 Streamability of
the current-merge-key function</i></a></p>
</li>
<li>
<p><code>fn:current-output-uri()</code></p>
</li>
<li>
<p><code>fn:current-time()</code></p>
</li>
<li>
<p><code>fn:data()</code> – Equivalent to
<code>fn:data(.)</code></p>
</li>
<li>
<p><code>fn:data(A)</code></p>
</li>
<li>
<p><code>fn:dateTime(A, A)</code></p>
</li>
<li>
<p><code>fn:day-from-date(A)</code></p>
</li>
<li>
<p><code>fn:day-from-dateTime(A)</code></p>
</li>
<li>
<p><code>fn:days-from-duration(A)</code></p>
</li>
<li>
<p><code>fn:deep-equal(A, A)</code></p>
</li>
<li>
<p><code>fn:deep-equal(A, A, A)</code></p>
</li>
<li>
<p><code>fn:default-collation()</code></p>
</li>
<li>
<p><code>fn:distinct-values(A)</code></p>
</li>
<li>
<p><code>fn:distinct-values(A, A)</code></p>
</li>
<li>
<p><code>fn:doc(A)</code></p>
</li>
<li>
<p><code>fn:doc-available(A)</code></p>
</li>
<li>
<p><code>fn:document(A)</code></p>
</li>
<li>
<p><code>fn:document(A, I)</code></p>
</li>
<li>
<p><code>fn:document-uri()</code> – Equivalent to
<code>fn:document-uri(.)</code></p>
</li>
<li>
<p><code>fn:document-uri(I)</code></p>
</li>
<li>
<p><code>fn:element-available(A)</code></p>
</li>
<li>
<p><code>fn:element-with-id(x)</code> – Equivalent to
<code>fn:element-with-id(x, .)</code></p>
</li>
<li>
<p><code>fn:element-with-id(A, N)</code></p>
</li>
<li>
<p><code>fn:empty(I)</code></p>
</li>
<li>
<p><code>fn:encode-for-uri(A)</code></p>
</li>
<li>
<p><code>fn:ends-with(A, A)</code></p>
</li>
<li>
<p><code>fn:ends-with(A, A, A)</code></p>
</li>
<li>
<p><code>fn:environment-variable(A)</code></p>
</li>
<li>
<p><code>fn:error()</code></p>
</li>
<li>
<p><code>fn:error(A)</code></p>
</li>
<li>
<p><code>fn:error(A, A)</code></p>
</li>
<li>
<p><code>fn:error(A, A, N)</code></p>
</li>
<li>
<p><code>fn:escape-html-uri(A)</code></p>
</li>
<li>
<p><code>fn:exactly-one(T)</code></p>
</li>
<li>
<p><code>fn:exists(I)</code></p>
</li>
<li>
<p><code>fn:false()</code></p>
</li>
<li>
<p><code>fn:filter(N, I)</code></p>
</li>
<li>
<p><code>fn:floor(A)</code></p>
</li>
<li>
<p><code>fn:fold-left(N, A, I)</code></p>
</li>
<li>
<p><code>fn:fold-right</code> – See <a href=
"#streamability-fn-fold-right"><i>19.8.8.9 Streamability of the
fold-right function</i></a></p>
</li>
<li>
<p><code>fn:for-each(N, I)</code></p>
</li>
<li>
<p><code>fn:for-each-pair(N, N, I)</code></p>
</li>
<li>
<p><code>fn:format-date(A, A)</code></p>
</li>
<li>
<p><code>fn:format-date(A, A, A, A, A)</code></p>
</li>
<li>
<p><code>fn:format-dateTime(A, A)</code></p>
</li>
<li>
<p><code>fn:format-dateTime(A, A, A, A, A)</code></p>
</li>
<li>
<p><code>fn:format-integer(A, A)</code></p>
</li>
<li>
<p><code>fn:format-integer(A, A, A)</code></p>
</li>
<li>
<p><code>fn:format-number(A, A)</code></p>
</li>
<li>
<p><code>fn:format-number(A, A, A)</code></p>
</li>
<li>
<p><code>fn:format-time(A, A)</code></p>
</li>
<li>
<p><code>fn:format-time(A, A, A, A, A)</code></p>
</li>
<li>
<p><code>fn:function-arity(A)</code></p>
</li>
<li>
<p><code>fn:function-available(A)</code></p>
</li>
<li>
<p><code>fn:function-available(A, A)</code></p>
</li>
<li>
<p><code>fn:function-lookup</code> – See <a href=
"#streamability-fn-function-lookup"><i>19.8.8.12 Streamability of
the function-lookup function</i></a></p>
</li>
<li>
<p><code>fn:function-name(A)</code></p>
</li>
<li>
<p><code>fn:generate-id()</code> – Equivalent to
<code>fn:generate-id(.)</code></p>
</li>
<li>
<p><code>fn:generate-id(I)</code></p>
</li>
<li>
<p><code>fn:has-children()</code> – Equivalent to
<code>fn:has-children(.)</code></p>
</li>
<li>
<p><code>fn:has-children(I)</code></p>
</li>
<li>
<p><code>fn:head(T)</code></p>
</li>
<li>
<p><code>fn:hours-from-dateTime(A)</code></p>
</li>
<li>
<p><code>fn:hours-from-duration(A)</code></p>
</li>
<li>
<p><code>fn:hours-from-time(A)</code></p>
</li>
<li>
<p><code>fn:id(x)</code> – Equivalent to <code>fn:id(x,
.)</code></p>
</li>
<li>
<p><code>fn:id(A, N)</code></p>
</li>
<li>
<p><code>fn:idref(x)</code> – Equivalent to <code>fn:idref(x,
.)</code></p>
</li>
<li>
<p><code>fn:idref(A, N)</code></p>
</li>
<li>
<p><code>fn:implicit-timezone()</code></p>
</li>
<li>
<p><code>fn:in-scope-prefixes(I)</code></p>
</li>
<li>
<p><code>fn:index-of(A, A)</code></p>
</li>
<li>
<p><code>fn:index-of(A, A, A)</code></p>
</li>
<li>
<p><code>fn:innermost</code> – See <a href=
"#streamability-fn-innermost"><i>19.8.8.13 Streamability of the
innermost function</i></a></p>
</li>
<li>
<p><code>fn:insert-before(T, A, T)</code></p>
</li>
<li>
<p><code>fn:iri-to-uri(A)</code></p>
</li>
<li>
<p><code>fn:json-to-xml(A)</code></p>
</li>
<li>
<p><code>fn:json-to-xml(A, A)</code></p>
</li>
<li>
<p><code>fn:key(x, x)</code> – Equivalent to <code>fn:key(x, x,
/)</code></p>
</li>
<li>
<p><code>fn:key(A, A, N)</code></p>
</li>
<li>
<p><code>fn:lang(x)</code> – Equivalent to <code>fn:lang(x,
.)</code></p>
</li>
<li>
<p><code>fn:lang(A, I)</code></p>
</li>
<li>
<p><code>fn:last</code> – See <a href=
"#streamability-fn-last"><i>19.8.8.14 Streamability of the last
function</i></a></p>
</li>
<li>
<p><code>fn:local-name()</code> – Equivalent to
<code>fn:local-name(.)</code></p>
</li>
<li>
<p><code>fn:local-name(I)</code></p>
</li>
<li>
<p><code>fn:local-name-from-QName(A)</code></p>
</li>
<li>
<p><code>fn:lower-case(A)</code></p>
</li>
<li>
<p><code>fn:matches(A, A)</code></p>
</li>
<li>
<p><code>fn:matches(A, A, A)</code></p>
</li>
<li>
<p><code>fn:max(A)</code></p>
</li>
<li>
<p><code>fn:max(A, A)</code></p>
</li>
<li>
<p><code>fn:min(A)</code></p>
</li>
<li>
<p><code>fn:min(A, A)</code></p>
</li>
<li>
<p><code>fn:minutes-from-dateTime(A)</code></p>
</li>
<li>
<p><code>fn:minutes-from-duration(A)</code></p>
</li>
<li>
<p><code>fn:minutes-from-time(A)</code></p>
</li>
<li>
<p><code>fn:month-from-date(A)</code></p>
</li>
<li>
<p><code>fn:month-from-dateTime(A)</code></p>
</li>
<li>
<p><code>fn:months-from-duration(A)</code></p>
</li>
<li>
<p><code>fn:name()</code> – Equivalent to
<code>fn:name(.)</code></p>
</li>
<li>
<p><code>fn:name(I)</code></p>
</li>
<li>
<p><code>fn:namespace-uri()</code> – Equivalent to
<code>fn:namespace-uri(.)</code></p>
</li>
<li>
<p><code>fn:namespace-uri(I)</code></p>
</li>
<li>
<p><code>fn:namespace-uri-for-prefix(A, I)</code></p>
</li>
<li>
<p><code>fn:namespace-uri-from-QName(A)</code></p>
</li>
<li>
<p><code>fn:nilled()</code> – Equivalent to
<code>fn:nilled(.)</code></p>
</li>
<li>
<p><code>fn:nilled(I)</code></p>
</li>
<li>
<p><code>fn:node-name()</code> – Equivalent to
<code>fn:node-name(.)</code></p>
</li>
<li>
<p><code>fn:node-name(I)</code></p>
</li>
<li>
<p><code>fn:normalize-space()</code></p>
</li>
<li>
<p><code>fn:normalize-space(A)</code></p>
</li>
<li>
<p><code>fn:normalize-unicode(A)</code></p>
</li>
<li>
<p><code>fn:normalize-unicode(A, A)</code></p>
</li>
<li>
<p><code>fn:not(I)</code></p>
</li>
<li>
<p><code>fn:number()</code> – Equivalent to
<code>fn:number(.)</code></p>
</li>
<li>
<p><code>fn:number(A)</code></p>
</li>
<li>
<p><code>fn:one-or-more(T)</code></p>
</li>
<li>
<p><code>fn:outermost</code> – See <a href=
"#streamability-fn-outermost"><i>19.8.8.15 Streamability of the
outermost function</i></a></p>
</li>
<li>
<p><code>fn:parse-xml(A)</code></p>
</li>
<li>
<p><code>fn:parse-xml-fragment(A)</code></p>
</li>
<li>
<p><code>fn:path()</code> – Equivalent to
<code>fn:path(.)</code></p>
</li>
<li>
<p><code>fn:path(N)</code></p>
</li>
<li>
<p><code>fn:position</code> – See <a href=
"#streamability-fn-position"><i>19.8.8.16 Streamability of the
position function</i></a></p>
</li>
<li>
<p><code>fn:prefix-from-QName(A)</code></p>
</li>
<li>
<p><code>fn:QName(A, A)</code></p>
</li>
<li>
<p><code>fn:regex-group(A)</code></p>
</li>
<li>
<p><code>fn:remove(T, A)</code></p>
</li>
<li>
<p><code>fn:replace(A, A, A)</code></p>
</li>
<li>
<p><code>fn:replace(A, A, A, A)</code></p>
</li>
<li>
<p><code>fn:resolve-QName(A, I)</code></p>
</li>
<li>
<p><code>fn:resolve-uri(A)</code></p>
</li>
<li>
<p><code>fn:resolve-uri(A, A)</code></p>
</li>
<li>
<p><code>fn:reverse</code> – See <a href=
"#streamability-fn-reverse"><i>19.8.8.17 Streamability of the
reverse function</i></a></p>
</li>
<li>
<p><code>fn:root</code> – See <a href=
"#streamability-fn-root"><i>19.8.8.18 Streamability of the root
function</i></a></p>
</li>
<li>
<p><code>fn:round(A)</code></p>
</li>
<li>
<p><code>fn:round(A, A)</code></p>
</li>
<li>
<p><code>fn:round-half-to-even(A)</code></p>
</li>
<li>
<p><code>fn:round-half-to-even(A, A)</code></p>
</li>
<li>
<p><code>fn:seconds-from-dateTime(A)</code></p>
</li>
<li>
<p><code>fn:seconds-from-duration(A)</code></p>
</li>
<li>
<p><code>fn:seconds-from-time(A)</code></p>
</li>
<li>
<p><code>fn:serialize(A)</code></p>
</li>
<li>
<p><code>fn:serialize(A, A)</code></p>
</li>
<li>
<p><code>fn:snapshot()</code> – Equivalent to
<code>fn:snapshot(.)</code></p>
</li>
<li>
<p><code>fn:snapshot(A)</code></p>
</li>
<li>
<p><code>fn:starts-with(A, A)</code></p>
</li>
<li>
<p><code>fn:starts-with(A, A, A)</code></p>
</li>
<li>
<p><code>fn:static-base-uri()</code></p>
</li>
<li>
<p><code>fn:stream-available(A)</code></p>
</li>
<li>
<p><code>fn:string()</code> – Equivalent to
<code>fn:string(.)</code></p>
</li>
<li>
<p><code>fn:string(A)</code></p>
</li>
<li>
<p><code>fn:string-join(A)</code></p>
</li>
<li>
<p><code>fn:string-join(A, A)</code></p>
</li>
<li>
<p><code>fn:string-length()</code> – Equivalent to
<code>fn:string-length(.)</code></p>
</li>
<li>
<p><code>fn:string-length(A)</code></p>
</li>
<li>
<p><code>fn:string-to-codepoints(A)</code></p>
</li>
<li>
<p><code>fn:subsequence(T, A)</code></p>
</li>
<li>
<p><code>fn:subsequence(T, A, A)</code></p>
</li>
<li>
<p><code>fn:substring(A, A)</code></p>
</li>
<li>
<p><code>fn:substring(A, A, A)</code></p>
</li>
<li>
<p><code>fn:substring-after(A, A)</code></p>
</li>
<li>
<p><code>fn:substring-after(A, A, A)</code></p>
</li>
<li>
<p><code>fn:substring-before(A, A)</code></p>
</li>
<li>
<p><code>fn:substring-before(A, A, A)</code></p>
</li>
<li>
<p><code>fn:sum(A)</code></p>
</li>
<li>
<p><code>fn:sum(A, A)</code></p>
</li>
<li>
<p><code>fn:system-property(A)</code></p>
</li>
<li>
<p><code>fn:tail(T)</code></p>
</li>
<li>
<p><code>fn:timezone-from-date(A)</code></p>
</li>
<li>
<p><code>fn:timezone-from-dateTime(A)</code></p>
</li>
<li>
<p><code>fn:timezone-from-time(A)</code></p>
</li>
<li>
<p><code>fn:tokenize(A, A)</code></p>
</li>
<li>
<p><code>fn:tokenize(A, A, A)</code></p>
</li>
<li>
<p><code>fn:trace(T, A)</code></p>
</li>
<li>
<p><code>fn:translate(A, A, A)</code></p>
</li>
<li>
<p><code>fn:true()</code></p>
</li>
<li>
<p><code>fn:type-available(A)</code></p>
</li>
<li>
<p><code>fn:unordered(T)</code></p>
</li>
<li>
<p><code>fn:unparsed-entity-public-id</code> – See <a href=
"#streamability-fn-unparsed-entity-public-id"><i>19.8.8.19
Streamability of the unparsed-entity-public-id function</i></a></p>
</li>
<li>
<p><code>fn:unparsed-entity-uri</code> – See <a href=
"#streamability-fn-unparsed-entity-uri"><i>19.8.8.20 Streamability
of the unparsed-entity-uri function</i></a></p>
</li>
<li>
<p><code>fn:unparsed-text(A)</code></p>
</li>
<li>
<p><code>fn:unparsed-text(A, A)</code></p>
</li>
<li>
<p><code>fn:unparsed-text-available(A)</code></p>
</li>
<li>
<p><code>fn:unparsed-text-available(A, A)</code></p>
</li>
<li>
<p><code>fn:unparsed-text-lines(A)</code></p>
</li>
<li>
<p><code>fn:unparsed-text-lines(A, A)</code></p>
</li>
<li>
<p><code>fn:upper-case(A)</code></p>
</li>
<li>
<p><code>fn:uri-collection()</code></p>
</li>
<li>
<p><code>fn:uri-collection(A)</code></p>
</li>
<li>
<p><code>fn:xml-to-json(A)</code></p>
</li>
<li>
<p><code>fn:xml-to-json(A, A)</code></p>
</li>
<li>
<p><code>fn:year-from-date(A)</code></p>
</li>
<li>
<p><code>fn:year-from-dateTime(A)</code></p>
</li>
<li>
<p><code>fn:years-from-duration(A)</code></p>
</li>
<li>
<p><code>fn:zero-or-one(T)</code></p>
</li>
<li>
<p><code>map:contains(A, A)</code></p>
</li>
<li>
<p><code>map:entry(A, N)</code></p>
</li>
<li>
<p><code>map:for-each(A, A)</code></p>
</li>
<li>
<p><code>map:get(A, A)</code></p>
</li>
<li>
<p><code>map:keys(A)</code></p>
</li>
<li>
<p><code>map:merge(A)</code></p>
</li>
<li>
<p><code>map:put(A, A, N)</code></p>
</li>
<li>
<p><code>map:remove(A, A)</code></p>
</li>
<li>
<p><code>map:size(A)</code></p>
</li>
<li>
<p><code>math:acos(A)</code></p>
</li>
<li>
<p><code>math:asin(A)</code></p>
</li>
<li>
<p><code>math:atan(A)</code></p>
</li>
<li>
<p><code>math:atan2(A, A)</code></p>
</li>
<li>
<p><code>math:cos(A)</code></p>
</li>
<li>
<p><code>math:exp(A)</code></p>
</li>
<li>
<p><code>math:exp10(A)</code></p>
</li>
<li>
<p><code>math:log(A)</code></p>
</li>
<li>
<p><code>math:log10(A)</code></p>
</li>
<li>
<p><code>math:pi()</code></p>
</li>
<li>
<p><code>math:pow(A, A)</code></p>
</li>
<li>
<p><code>math:sin(A)</code></p>
</li>
<li>
<p><code>math:sqrt(A)</code></p>
</li>
<li>
<p><code>math:tan(A)</code></p>
</li>
</ul>
<div class="div4">
<h5><a name="streamability-fn-accumulator-after" id=
"streamability-fn-accumulator-after"></a>19.8.8.1 <a href=
"#streamability-fn-accumulator-after" style=
"text-decoration: none">Streamability of the</a> <a href=
"#func-accumulator-after"><code>accumulator-after</code></a>
<a href="#streamability-fn-accumulator-after" style=
"text-decoration: none">function</a></h5>
<p>See also <a href="#streamability-of-accumulators"><i>18.2.7
Streamability of Accumulators</i></a>.</p>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> of the function call is in all cases
<a title="grounded" class="termref" href=
"#dt-grounded">grounded</a>.</p>
<p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a>
is determined by applying the following rules, in order:</p>
<ol class="enumar">
<li>
<p>If the first argument (the accumulator name) is not <a title=
"motionless" class="termref" href="#dt-motionless">motionless</a>,
the function is <a title="free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>.</p>
</li>
<li>
<p>If the <a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a> is <a title="grounded"
class="termref" href="#dt-grounded">grounded</a>, the function is
<a title="motionless" class="termref" href=
"#dt-motionless">motionless</a>.</p>
</li>
<li>
<p>If the <a title="context item type" class="termref" href=
"#dt-context-item-type">context item type</a> has an empty
intersection with <var>U{document-node(), element()}</var> (that
is, if the context item cannot have children), the function is
<a title="motionless" class="termref" href=
"#dt-motionless">motionless</a>.</p>
</li>
<li>
<p>If the function call is contained in the <code>select</code>
expression or contained sequence constructor of an <a href=
"#element-accumulator-rule"><code>xsl:accumulator-rule</code></a>
specifying <code>phase="start"</code>, then it is <a title=
"free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>.</p>
</li>
<li>
<p>If the function call is contained in the <code>select</code>
expression or contained sequence constructor of an <a href=
"#element-accumulator-rule"><code>xsl:accumulator-rule</code></a>
specifying <code>phase="end"</code>, then it is <a title=
"motionless" class="termref" href=
"#dt-motionless">motionless</a>.</p>
</li>
<li>
<p>If the function call is not contained in an <a title=
"instruction" class="termref" href=
"#dt-instruction">instruction</a>, then it is <a title=
"free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>.</p>
</li>
<li>
<p>If the <a title="focus-setting container" class="termref" href=
"#dt-focus-setting-container">focus-setting container</a> of the
function call is different from the <a title=
"focus-setting container" class="termref" href=
"#dt-focus-setting-container">focus-setting container</a> of the
innermost containing <a title="instruction" class="termref" href=
"#dt-instruction">instruction</a>, then the function is <a title=
"free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>.</p>
</li>
<li>
<p>If no containing <a title="instruction" class="termref" href=
"#dt-instruction">instruction</a> has a preceding sibling
instruction within the same sequence constructor whose <a title=
"sweep" class="termref" href="#dt-sweep">sweep</a> is <a title=
"consuming" class="termref" href="#dt-consuming">consuming</a>,
then the function call is <a title="consuming" class="termref"
href="#dt-consuming">consuming</a>.</p>
</li>
<li>
<p>Otherwise, the function call is <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The following notes apply to the above rules with matching
numbers:</p>
<ol class="enumar">
<li>
<p>This rule prevents the accumulator name being computed by
reading the streamed source document. This is disallowed primarily
because there is no conceivable use case for doing it.</p>
</li>
<li>
<p>If the context posture is grounded, then the target of the
accumulator is not a streamed node, so no streaming restrictions
apply.</p>
</li>
<li>
<p>If the context item is a childless node (such as a text node),
then both the pre-descent and post-descent values of the
accumulator can be computed before evaluating any user-written
constructs that access this node; there are therefore no
constraints on where a call to <a href=
"#func-accumulator-after"><code>accumulator-after</code></a> can
appear.</p>
</li>
<li>
<p>This rule ensures that when computing the pre-descent value of
an accumulator for a particular streamed node, the post-descent
values of accumulators for that node are not available.</p>
</li>
<li>
<p>This rule states that the post-descent value of an accumulator
is allowed to depend on the post-descent values of other
accumulators for the same node. There is a rule preventing cycles
<span class="error">[see <a href="#err-XTDE3400">ERR
XTDE3400</a>]</span>.</p>
</li>
<li>
<p>This rule prevents the use of the function (when applied to a
streamed node) in contexts like the <code>use</code> attribute of
<a href="#element-key"><code>xsl:key</code></a>.</p>
</li>
<li>
<p>This rule prevents the use of the function (when applied to a
streamed node) in contexts such as predicates, or the right-hand
side of the "/" operator. The focus for evaluation of the function
must be the same as the focus for a containing sequence
constructor. Sequence constructors are treated differently from all
other constructs for this purpose in that their operands (the
contained instructions) are treated as ordered: in conjunction with
the next rule, this rule is assuming that instructions in a
sequence constructor that follow a consuming instruction are
evaluated after the consuming instruction and therefore have access
to the post-descent accumulator value.</p>
</li>
<li>
<p>This rule is subtle, and has a number of consequences:</p>
<ul>
<li>
<p>In a sequence constructor that contains a consuming instruction
such as <code>&lt;xsl:apply-templates/&gt;</code>, it allows any
number of calls on <a href=
"#func-accumulator-after"><code>accumulator-after</code></a> to
appear in instructions that follow the call on
<code>&lt;xsl:apply-templates/&gt;</code>.</p>
</li>
<li>
<p>In such a sequence constructor it prevents a call on <a href=
"#func-accumulator-after"><code>accumulator-after</code></a> from
appearing in an instruction that precedes the
<code>&lt;xsl:apply-templates/&gt;</code>, because there would then
be two consuming instructions.</p>
</li>
<li>
<p>In a sequence constructor that contains calls on <a href=
"#func-accumulator-after"><code>accumulator-after</code></a>, and
contains no other consuming construct, the first instruction that
contains a call on <a href=
"#func-accumulator-after"><code>accumulator-after</code></a> is
consuming (unless it contains more than one such call, in which
case it is free-ranging), and subsequent instructions containing
such a call are motionless. So it is possible to have two or more
calls on <a href=
"#func-accumulator-after"><code>accumulator-after</code></a>
provided they appear in different instructions, which allows the
analysis to assume an order of execution.</p>
</li>
<li>
<p>It prevents a call on <a href=
"#func-accumulator-after"><code>accumulator-after</code></a> from
appearing in the same instruction as another consuming construct:
for example it disallows <code>concat(child::p,
accumulator-after('a'))</code>. This rule preserves the ability to
evaluate the arguments of the <code>concat</code> function in any
order.</p>
</li>
<li>
<p>It disallows a call on <a href=
"#func-accumulator-after"><code>accumulator-after</code></a> from
appearing in a sequence constructor that is required to be
motionless, for example within <a href=
"#element-sort"><code>xsl:sort</code></a>.</p>
</li>
<li>
<p>The reference to a "preceding sibling instruction within the
same sequence constructor" is carefully worded to ensure that
preceding siblings among the children of <a href=
"#element-fork"><code>xsl:fork</code></a> are not taken into
account; the children of <a href=
"#element-fork"><code>xsl:fork</code></a> are sibling instructions,
but do not constitute a sequence constructor.</p>
</li>
</ul>
</li>
<li>
<p>The final rule states that if none of the previous rules apply,
the function is considered motionless. This applies when the
<a href=
"#func-accumulator-after"><code>accumulator-after</code></a>
appears after a consuming instruction within the same sequence
constructor.</p>
<p>Note also that a call to <a href=
"#func-accumulator-after"><code>accumulator-after</code></a> can
safely appear within a construct such as a named template or
(non-streamable) stylesheet function; this is safe because the
rules ensure that in such situations, the context item cannot be a
streamed node.</p>
</li>
</ol>
</div>
<p>Dynamic invocation of <a href=
"#func-accumulator-after"><code>accumulator-after</code></a> is
covered by the rules in <a href="#function-lookup"><i>10.3.6
Dynamic Access to Functions</i></a>. These rules ensure that a
function item cannot include a streamed node in its closure;
circumventing the streamability rules for <a href=
"#func-accumulator-after"><code>accumulator-after</code></a> by
making a dynamic call is therefore not possible.</p>
</div>
<div class="div4">
<h5><a name="streamability-fn-accumulator-before" id=
"streamability-fn-accumulator-before"></a>19.8.8.2 <a href=
"#streamability-fn-accumulator-before" style=
"text-decoration: none">Streamability of the</a> <a href=
"#func-accumulator-before"><code>accumulator-before</code></a>
<a href="#streamability-fn-accumulator-before" style=
"text-decoration: none">function</a></h5>
<p>See also <a href="#streamability-of-accumulators"><i>18.2.7
Streamability of Accumulators</i></a>.</p>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of the function call are assessed as
follows:</p>
<ol class="enumar">
<li>
<p>If the argument to <a href=
"#func-accumulator-before"><code>accumulator-before</code></a> is
motionless, the function call is <a title="grounded" class=
"termref" href="#dt-grounded">grounded</a> and <a title=
"motionless" class="termref" href=
"#dt-motionless">motionless</a>.</p>
</li>
<li>
<p>Otherwise, the function call is <a title="roaming" class=
"termref" href="#dt-roaming">roaming</a> and <a title=
"free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>.</p>
</li>
</ol>
</div>
<div class="div4">
<h5><a name="streamability-fn-current" id=
"streamability-fn-current"></a>19.8.8.3 <a href=
"#streamability-fn-current" style=
"text-decoration: none">Streamability of the</a> <a href=
"#func-current"><code>current</code></a> <a href=
"#streamability-fn-current" style=
"text-decoration: none">function</a></h5>
<p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a>
of the function is <span><a title="motionless" class="termref"
href="#dt-motionless">motionless</a></span>; the <a title="posture"
class="termref" href="#dt-posture">posture</a> is the
<span><a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a></span> for evaluation of
the outermost containing XPath expression (that is, the
<span><a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a></span> that would obtain
if the entire XPath expression were replaced with
<code>"."</code>).</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Although the <a href="#func-current"><code>current</code></a>
function is supported for streaming, it needs to be used with care.
Some common use cases such as <code>select="$lookup[@name =
current()/name]</code> will fail, because the streamability rules
require a predicate to be motionless. A workaround is to extract
the relevant value into a variable: <code>select="let $n :=
string(name) return $lookup[@name = $n]</code>; in turn this
removes the need for the <a href=
"#func-current"><code>current</code></a> function.</p>
<p>The use of the <a href="#func-current"><code>current</code></a>
function within a pattern is supported with similar restrictions.
In this case the <span><a title="context posture" class="termref"
href="#dt-context-posture">context posture</a></span> is always
<a title="striding" class="termref" href=
"#dt-striding">striding</a>.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-fn-current-group" id=
"streamability-fn-current-group"></a>19.8.8.4 <a href=
"#streamability-fn-current-group" style=
"text-decoration: none">Streamability of the</a> <a href=
"#func-current-group"><code>current-group</code></a> <a href=
"#streamability-fn-current-group" style=
"text-decoration: none">function</a></h5>
<p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a>
and <a title="posture" class="termref" href=
"#dt-posture">posture</a> of a call <var>C</var> to the <a href=
"#func-current-group"><code>current-group</code></a> function are
as follows:</p>
<ol class="enumar">
<li>
<p>If all the following conditions are true:</p>
<ol class="enumla">
<li>
<p><var>C</var> has a containing <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction (call it <var>F</var>)</p>
</li>
<li>
<p>The path in the construct tree that connects <var>C</var> to the
sequence constructor forming the body of <var>F</var> is such that
no child construct is a <a title="higher-order operand" class=
"termref" href="#dt-higher-order-operand">higher-order operand</a>
of its parent</p>
</li>
<li>
<p>The <a title="focus-setting container" class="termref" href=
"#dt-focus-setting-container">focus-setting container</a> of
<var>C</var> is <var>F</var></p>
</li>
</ol>
<p>then the <a title="sweep" class="termref" href=
"#dt-sweep">sweep</a> and <a title="posture" class="termref" href=
"#dt-posture">posture</a> of <var>C</var> are the <a title="sweep"
class="termref" href="#dt-sweep">sweep</a> and <a title="posture"
class="termref" href="#dt-posture">posture</a> of the
<code>select</code> expression of <var>F</var>.</p>
</li>
<li>
<p>Otherwise, <a title="roaming" class="termref" href=
"#dt-roaming">roaming</a> and <a title="free-ranging" class=
"termref" href="#dt-free-ranging">free-ranging</a>.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Informally, for streamed evaluation to be possible, a call to
<a href="#func-current-group"><code>current-group</code></a> must
not appear in a construct that is evaluated repeatedly. For
example, the expression <code>for $i in 1 to 10 return
current-group()</code> would not be streamable.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-fn-current-grouping-key" id=
"streamability-fn-current-grouping-key"></a>19.8.8.5 <a href=
"#streamability-fn-current-grouping-key" style=
"text-decoration: none">Streamability of the</a> <a href=
"#func-current-grouping-key"><code>current-grouping-key</code></a>
<a href="#streamability-fn-current-grouping-key" style=
"text-decoration: none">function</a></h5>
<p>A call to the <a href=
"#func-current-grouping-key"><code>current-grouping-key</code></a>
function is grounded and motionless.</p>
</div>
<div class="div4">
<h5><a name="streamability-fn-current-merge-group" id=
"streamability-fn-current-merge-group"></a>19.8.8.6 <a href=
"#streamability-fn-current-merge-group" style=
"text-decoration: none">Streamability of the</a> <a href=
"#func-current-merge-group"><code>current-merge-group</code></a>
<a href="#streamability-fn-current-merge-group" style=
"text-decoration: none">function</a></h5>
<p>A call to the <a href=
"#func-current-merge-group"><code>current-merge-group</code></a>
function is <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> and <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This is because the nodes to be merged are always snapshots, and
therefore <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a>: see <a href=
"#streamable-merging"><i>15.4 Streamable Merging</i></a>.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-fn-current-merge-key" id=
"streamability-fn-current-merge-key"></a>19.8.8.7 <a href=
"#streamability-fn-current-merge-key" style=
"text-decoration: none">Streamability of the</a> <a href=
"#func-current-merge-key"><code>current-merge-key</code></a>
<a href="#streamability-fn-current-merge-key" style=
"text-decoration: none">function</a></h5>
<p>A call to the <a href=
"#func-current-merge-key"><code>current-merge-key</code></a>
function is <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> and <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>.</p>
</div>
<div class="div4">
<h5><a name="streamability-fn-fold-left" id=
"streamability-fn-fold-left"></a>19.8.8.8 <a href=
"#streamability-fn-fold-left" style=
"text-decoration: none">Streamability of the</a> <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-fold-left"><code>fold-left</code></a><sup><small>FO30</small></sup>
<a href="#streamability-fn-fold-left" style=
"text-decoration: none">function</a></h5>
<p>The function call <code>fold-left($seq, $zero, $f)</code>,
follows the <a title="general streamability rules" class="termref"
href="#dt-general-streamability-rules">general streamability
rules</a>, with the first argument <code>$seq</code> having
<a title="type-determined usage" class="termref" href=
"#dt-type-determined-usage">type-determined usage</a> based on the
type of the second argument of the function supplied as
<code>$f</code>.</p>
<p>For example, given the call <code>fold-left(/*/transaction, 0,
function($x as xs:decimal, $y as xs:decimal) as xs:decimal
{$x+$y}))</code>, the operand usage of the argument
<code>/*/transaction</code> is determined by the declared type of
<code>$y</code>, namely <code>xs:decimal</code>. Since this is an
atomic type, the type determined usage is <a title="absorption"
class="termref" href="#dt-absorption">absorption</a>. Applying this
to the general streamability rules, the function call is <a title=
"grounded" class="termref" href="#dt-grounded">grounded</a> and
<a title="consuming" class="termref" href=
"#dt-consuming">consuming</a>.</p>
</div>
<div class="div4">
<h5><a name="streamability-fn-fold-right" id=
"streamability-fn-fold-right"></a>19.8.8.9 <a href=
"#streamability-fn-fold-right" style=
"text-decoration: none">Streamability of the</a> <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-fold-right"><code>fold-right</code></a><sup><small>FO30</small></sup>
<a href="#streamability-fn-fold-right" style=
"text-decoration: none">function</a></h5>
<p>The function follows the <a title="general streamability rules"
class="termref" href="#dt-general-streamability-rules">general
streamability rules</a>, with the first argument having <a title=
"operand usage" class="termref" href="#dt-operand-usage">operand
usage</a> <a title="navigation" class="termref" href=
"#dt-navigation">navigation</a> to reflect the fact that the
supplied sequence is processed in reverse order.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The same considerations apply as for the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-reverse"><code>reverse</code></a><sup><small>FO30</small></sup>
function: see <a href="#streamability-fn-reverse"><i>19.8.8.17
Streamability of the reverse function</i></a>.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-fn-for-each" id=
"streamability-fn-for-each"></a>19.8.8.10 <a href=
"#streamability-fn-for-each" style=
"text-decoration: none">Streamability of the</a> <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-for-each"><code>for-each</code></a><sup><small>FO30</small></sup>
<a href="#streamability-fn-for-each" style=
"text-decoration: none">function</a></h5>
<p>The function call <code>for-each($seq, $f)</code>, follows the
<a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>,
with the first argument <code>$seq</code> having <a title=
"type-determined usage" class="termref" href=
"#dt-type-determined-usage">type-determined usage</a> based on the
type of the (single) argument of the function supplied as
<code>$f</code>.</p>
<p>For example, given the call <code>for-each(/*/transaction,
function($x as xs:decimal) as xs:decimal {abs($x)}))</code>, the
operand usage of the argument <code>/*/transaction</code> is
determined by the declared type of <code>$x</code>, namely
<code>xs:decimal</code>. Since this is an atomic type, the type
determined usage is <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>. Applying this to the general
streamability rules, the function call is <a title="grounded"
class="termref" href="#dt-grounded">grounded</a> and <a title=
"consuming" class="termref" href="#dt-consuming">consuming</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In practice, the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-filter"><code>filter</code></a><sup><small>FO30</small></sup>
function is streamable if either (a) the supplied sequence is
grounded, or (b) the supplied function is statically known to
atomize its argument.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-fn-for-each-pair" id=
"streamability-fn-for-each-pair"></a>19.8.8.11 <a href=
"#streamability-fn-for-each-pair" style=
"text-decoration: none">Streamability of the</a> <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-for-each-pair"><code>
for-each-pair</code></a><sup><small>FO30</small></sup> <a href=
"#streamability-fn-for-each-pair" style=
"text-decoration: none">function</a></h5>
<p>The function call <code>for-each($seq1, $seq2, $f)</code>,
follows the <a title="general streamability rules" class="termref"
href="#dt-general-streamability-rules">general streamability
rules</a>, where:</p>
<ol class="enumar">
<li>
<p>The first argument <code>$seq1</code> has <a title=
"type-determined usage" class="termref" href=
"#dt-type-determined-usage">type-determined usage</a> based on the
type of the first argument of the function supplied as
<code>$f</code>.</p>
</li>
<li>
<p>The second argument <code>$seq2</code> has <a title=
"type-determined usage" class="termref" href=
"#dt-type-determined-usage">type-determined usage</a> based on the
type of the second argument of the function supplied as
<code>$f</code></p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In practice, the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-for-each-pair"><code>
for-each-pair</code></a><sup><small>FO30</small></sup> function is
streamable provided (a) at most one of the input sequences is
consuming, and (b) either (i) that input sequence is grounded, or
(ii) the supplied function is statically known to atomize the
relevant argument.</p>
<p>If it is necessary to combine two sequences that are both
streamed, consider using <a href=
"#element-merge"><code>xsl:merge</code></a>.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-fn-function-lookup" id=
"streamability-fn-function-lookup"></a>19.8.8.12 <a href=
"#streamability-fn-function-lookup" style=
"text-decoration: none">Streamability of the</a> <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>
function-lookup</code></a><sup><small>FO30</small></sup> <a href=
"#streamability-fn-function-lookup" style=
"text-decoration: none">function</a></h5>
<p>See <a href="#function-lookup"><i>10.3.6 Dynamic Access to
Functions</i></a> for special rules that relate to streamability of
calls to the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>
function-lookup</code></a><sup><small>FO30</small></sup>
function.</p>
<p>With the caveats given there, the function follows the <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>,
for a function with two arguments that both have <a title=
"operand usage" class="termref" href="#dt-operand-usage">operand
usage</a> <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>.</p>
</div>
<div class="div4">
<h5><a name="streamability-fn-innermost" id=
"streamability-fn-innermost"></a>19.8.8.13 <a href=
"#streamability-fn-innermost" style=
"text-decoration: none">Streamability of the</a> <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-innermost"><code>innermost</code></a><sup><small>FO30</small></sup>
<a href="#streamability-fn-innermost" style=
"text-decoration: none">function</a></h5>
<p>The function follows the <a title="general streamability rules"
class="termref" href="#dt-general-streamability-rules">general
streamability rules</a>, with the first argument having <a title=
"operand usage" class="termref" href="#dt-operand-usage">operand
usage</a> <a title="navigation" class="termref" href=
"#dt-navigation">navigation</a>. This is to reflect the fact that
the processing is not strictly sequential: it cannot be determined
that a node is part of the result sequence of <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-innermost"><code>innermost</code></a><sup><small>FO30</small></sup>
until all its descendants have been read.</p>
</div>
<div class="div4">
<h5><a name="streamability-fn-last" id=
"streamability-fn-last"></a>19.8.8.14 <a href=
"#streamability-fn-last" style=
"text-decoration: none">Streamability of the</a> <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-last"><code>last</code></a><sup><small>FO30</small></sup>
<a href="#streamability-fn-last" style=
"text-decoration: none">function</a></h5>
<p>If the <a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a> for a call on the
<a href="http://www.w3.org/TR/xpath-functions-30/#func-last"><code>last</code></a><sup><small>FO30</small></sup>
function is <a title="striding" class="termref" href=
"#dt-striding">striding</a>, <a title="crawling" class="termref"
href="#dt-crawling">crawling</a>, or <a title="roaming" class=
"termref" href="#dt-roaming">roaming</a>, then the <a title=
"posture" class="termref" href="#dt-posture">posture</a> of the
function is <a title="roaming" class="termref" href=
"#dt-roaming">roaming</a>, and the <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> is <a title="free-ranging" class=
"termref" href="#dt-free-ranging">free-ranging</a>.</p>
<p>In all other cases the function is <a title="grounded" class=
"termref" href="#dt-grounded">grounded</a> and <a title=
"motionless" class="termref" href=
"#dt-motionless">motionless</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The cases where <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-last"><code>last</code></a><sup><small>FO30</small></sup>
can be used without affecting streamability are where the context
item is either <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> or <a title="climbing" class="termref"
href="#dt-climbing">climbing</a>. The latter condition makes
expressions like <code>ancestor::*[@xml:space][last()]</code>
streamable.</p>
<p>There are special rules restricting the use of <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-last"><code>last</code></a><sup><small>FO30</small></sup>
in the predicate of a pattern: see <a href=
"#classifying-patterns"><i>19.8.9 Classifying Patterns</i></a>.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-fn-outermost" id=
"streamability-fn-outermost"></a>19.8.8.15 <a href=
"#streamability-fn-outermost" style=
"text-decoration: none">Streamability of the</a> <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-outermost"><code>outermost</code></a><sup><small>FO30</small></sup>
<a href="#streamability-fn-outermost" style=
"text-decoration: none">function</a></h5>
<p>The single argument to this function has <a title=
"operand usage" class="termref" href="#dt-operand-usage">operand
usage</a> <a title="transmission" class="termref" href=
"#dt-transmission">transmission</a>.</p>
<p>The streamability of the function call follows the <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>
with one exception: if the <a title="posture" class="termref" href=
"#dt-posture">posture</a> of the argument is <a title="crawling"
class="termref" href="#dt-crawling">crawling</a>, then the posture
of the result is <a title="striding" class="termref" href=
"#dt-striding">striding</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>There are cases where the streaming rules allow the construct
<code>outermost(//para)</code> but do not allow
<code>//para</code>; the function can therefore be useful in cases
where it is known that <code>para</code> elements will not be
nested, as well as cases where the application actually wishes to
process all <code>para</code> elements except those that are nested
within another.</p>
<p>By contrast, the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-innermost"><code>innermost</code></a><sup><small>FO30</small></sup>
function offers no streaming benefits. Although it delivers a
subset of the input nodes as its result, in the correct order, it
is classed as navigational because it needs to look ahead in the
input stream before deciding whether a node can be included in the
result.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-fn-position" id=
"streamability-fn-position"></a>19.8.8.16 <a href=
"#streamability-fn-position" style=
"text-decoration: none">Streamability of the</a> <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-position"><code>position</code></a><sup><small>FO30</small></sup>
<a href="#streamability-fn-position" style=
"text-decoration: none">function</a></h5>
<p>The <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-position"><code>position</code></a><sup><small>FO30</small></sup>
function follows the <a title="general streamability rules" class=
"termref" href="#dt-general-streamability-rules">general
streamability rules</a>. Since it has no operands, this means it is
<a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> and <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Within an expression, there are no special difficulties in
evaluating the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-position"><code>position</code></a><sup><small>FO30</small></sup>
function.</p>
<p>It does have special treatment within a predicate of a <a title=
"pattern" class="termref" href="#dt-pattern">pattern</a>, however:
a pattern is not motionless if it contains a call to <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-position"><code>position</code></a><sup><small>FO30</small></sup>,
as explained in <a href="#classifying-patterns"><i>19.8.9
Classifying Patterns</i></a>.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-fn-reverse" id=
"streamability-fn-reverse"></a>19.8.8.17 <a href=
"#streamability-fn-reverse" style=
"text-decoration: none">Streamability of the</a> <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-reverse"><code>reverse</code></a><sup><small>FO30</small></sup>
<a href="#streamability-fn-reverse" style=
"text-decoration: none">function</a></h5>
<p>The <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-reverse"><code>reverse</code></a><sup><small>FO30</small></sup>
function follows the <a title="general streamability rules" class=
"termref" href="#dt-general-streamability-rules">general
streamability rules</a>, with its operand classified as having
<a title="operand usage" class="termref" href=
"#dt-operand-usage">operand usage</a> <a title="navigation" class=
"termref" href="#dt-navigation">navigation</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This means in effect that a call on <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-reverse"><code>reverse</code></a><sup><small>FO30</small></sup>
is not streamable unless the operand is grounded. This may cause
few surprises:</p>
<ul>
<li>
<p>The expression <code>reverse(/*/emp/copy-of())</code> is
considered streamable, although all the <code>emp</code> elements
will typically need to be in memory at the same time. The
explanation here is that the streamability rules do not attempt to
restrict the amount of memory used for data that is explicitly
copied by use of a function such as <a href=
"#func-copy-of"><code>copy-of</code></a>.</p>
</li>
<li>
<p>The expression <code>reverse(ancestor::*)/name()</code> is
considered non-streamable, because the operand is not grounded.
This problem can be circumvented by rewriting the expression as
<code>reverse(ancestor::*/name())</code></p>
</li>
</ul>
</div>
</div>
<div class="div4">
<h5><a name="streamability-fn-root" id=
"streamability-fn-root"></a>19.8.8.18 <a href=
"#streamability-fn-root" style=
"text-decoration: none">Streamability of the</a> <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-root"><code>root</code></a><sup><small>FO30</small></sup>
<a href="#streamability-fn-root" style=
"text-decoration: none">function</a></h5>
<p>The zero-argument function <code>root()</code> is equivalent to
<code>root(.)</code>.</p>
<p>Given the expression <code>root(X)</code>, if the <a title=
"static type" class="termref" href="#dt-static-type">static
type</a> of <code>X</code> is <var>U{document-node()}</var>, and if
its <a title="posture" class="termref" href=
"#dt-posture">posture</a> is <a title="striding" class="termref"
href="#dt-striding">striding</a>, then <code>root(X)</code> is
rewritten as <code>X</code>. Otherwise, it is rewritten as
<code>head((X)/ancestor-or-self::node())</code>. Streamability
analysis is then applied to the rewritten expression.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Because path expressions starting with <code>/</code> are
rewritten to use the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-root"><code>root</code></a><sup><small>FO30</small></sup>
function, this ensures that a leading slash is ignored if the
context item is a document node, for example within a template rule
with <code>match="/"</code>. This improves streamability, because
upwards navigation followed by downward navigation is
disallowed.</p>
</div>
</div>
<div class="div4">
<h5><a name="streamability-fn-unparsed-entity-public-id" id=
"streamability-fn-unparsed-entity-public-id"></a>19.8.8.19 <a href=
"#streamability-fn-unparsed-entity-public-id" style=
"text-decoration: none">Streamability of the</a> <a href=
"#func-unparsed-entity-public-id"><code>unparsed-entity-public-id</code></a>
<a href="#streamability-fn-unparsed-entity-public-id" style=
"text-decoration: none">function</a></h5>
<p>The function <a href=
"#func-unparsed-entity-public-id"><code>unparsed-entity-public-id</code></a>
has an implicit dependency on the context item.</p>
<p>If the context item type is anything other than a document node,
the function works without difficulty in streaming mode: in the
same way as attributes of ancestor elements are retained and are
available while processing descendant elements, the unparsed
entities declared in the DTD are retained while processing the body
of the document.</p>
<p>While processing the document node itself, however, the contents
of the DTD might not yet be available. An arbitrary number of
comments and processing instructions are allowed to precede the
DTD.</p>
<p>So the rules are:</p>
<ul>
<li>
<p>If the <span><a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a></span> is grounded, the
posture is grounded and the sweep is motionless</p>
</li>
<li>
<p>If the <span><a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a></span> is roaming, the
posture is roaming and the sweep is free-ranging</p>
</li>
<li>
<p>If the <span><a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a></span> is climbing,
striding, or crawling, the context item type permits a document
node, then the posture is crawling and the sweep is consuming</p>
</li>
<li>
<p>If the <span><a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a></span> is climbing,
striding, or crawling, the context item type does not permit a
document node, then the posture is grounded and the sweep is
motionless</p>
</li>
</ul>
</div>
<div class="div4">
<h5><a name="streamability-fn-unparsed-entity-uri" id=
"streamability-fn-unparsed-entity-uri"></a>19.8.8.20 <a href=
"#streamability-fn-unparsed-entity-uri" style=
"text-decoration: none">Streamability of the</a> <a href=
"#func-unparsed-entity-uri"><code>unparsed-entity-uri</code></a>
<a href="#streamability-fn-unparsed-entity-uri" style=
"text-decoration: none">function</a></h5>
<p>The streamability characteristics of this function are the same
as <a href=
"#func-unparsed-entity-public-id"><code>unparsed-entity-public-id</code></a>:
see <a href=
"#streamability-fn-unparsed-entity-public-id"><i>19.8.8.19
Streamability of the unparsed-entity-public-id
function</i></a>.</p>
</div>
</div>
<div class="div3">
<h4><a name="classifying-patterns" id=
"classifying-patterns"></a>19.8.9 <a href="#classifying-patterns"
style="text-decoration: none">Classifying Patterns</a></h4>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Patterns differ from other kinds of construct in that they are
not composable in the same way. It is best to think of a pattern as
specialized syntax for a function that takes an item as its
argument and returns a boolean: true if the pattern matches the
item, otherwise false. When we refer to the type of a pattern,
however, this refers to the types of item that the pattern is
capable of matching, not to the type of value that evaluation of
the pattern returns.</p>
</div>
<p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a>
of a <a title="pattern" class="termref" href=
"#dt-pattern">pattern</a> is either <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a> or <a title=
"free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>. (Although there are patterns
that could in principle be evaluated by consuming the element node
that they match, these are of no interest in the analysis, so they
are classified as free-ranging.)</p>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> of a <a title="pattern" class="termref"
href="#dt-pattern">pattern</a> is <a title="grounded" class=
"termref" href="#dt-grounded">grounded</a> if the pattern is
<a title="motionless" class="termref" href=
"#dt-motionless">motionless</a>, or <a title="roaming" class=
"termref" href="#dt-roaming">roaming</a> otherwise. (This reflects
the fact that a pattern always returns a boolean result; it never
returns a node in a streamed document.)</p>
<p>Informally, a <a title="motionless" class="termref" href=
"#dt-motionless">motionless</a> pattern is one that can be
evaluated by a streaming processor when the input stream is
positioned at the start <span>of the node being matched</span>,
without advancing the input stream.</p>
<p>A pattern is <a title="motionless" class="termref" href=
"#dt-motionless">motionless</a> if <span>and only if it satisfies
<span>all</span> the following conditions:</span></p>
<ol class="enumar">
<li>
<p>The pattern does not contain a <a href=
"#doc-xslt30-patterns-RootedPath">RootedPath</a>.</p>
</li>
<li>
<p>If the pattern contains predicates, then every top-level
<code>Predicate</code> in the pattern satisfies both the following
conditions:</p>
<ol class="enumla">
<li>
<p>The expression immediately contained in the predicate is
<a title="motionless" class="termref" href=
"#dt-motionless">motionless</a>, <span>when assessed with a
<a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a> of <a title="striding"
class="termref" href="#dt-striding">striding</a>, and a context
item type set to the <a title="static type" class="termref" href=
"#dt-static-type">static type</a> of the expression to which the
predicate applies, determined using the rules in <a href=
"#determining-static-type"><i>19.2 Determining the Static Type of a
Construct</i></a>.</span></p>
</li>
<li>
<p>The predicate is a <a title="non-positional predicate" class=
"termref" href="#dt-non-positional-predicate">non-positional
predicate</a>.</p>
</li>
</ol>
<p>The use of the term <b>top-level</b> in this rule means that
predicates that are nested within other predicates do not
themselves have to be non-positional, though they may play a role
in the analysis of top-level predicates.</p>
</li>
</ol>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-non-positional-predicate" id="dt-non-positional-predicate"
title="non-positional predicate"></a>A predicate is a
<b>non-positional predicate</b> if it satisfies both of the
following conditions:<span class="definition">]</span></p>
<ol class="enumar">
<li>
<p>The predicate does not contain a function call or named function
reference to any of the following functions, unless that call or
reference occurs within a nested predicate:</p>
<ol class="enumla">
<li>
<p><a href=
"http://www.w3.org/TR/xpath-functions-30/#func-position"><code>position</code></a><sup><small>FO30</small></sup></p>
</li>
<li>
<p><a href=
"http://www.w3.org/TR/xpath-functions-30/#func-last"><code>last</code></a><sup><small>FO30</small></sup></p>
</li>
<li>
<p><a href=
"http://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>
function-lookup</code></a><sup><small>FO30</small></sup>.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The exception for nested predicates is to avoid disqualifying
patterns such as <code>match="p[@code =
$status[last()]]</code>.</p>
</div>
</li>
<li>
<p>The expression immediately contained in the predicate is a
non-numeric expression. An expression is non-numeric if <span>the
intersection of its <a title="static type" class="termref" href=
"#dt-static-type">static type</a> (see <a href=
"#determining-static-type"><i>19.2 Determining the Static Type of a
Construct</i></a>) with <var>U{xs:decimal, xs:double,
xs:float}</var> is <var>U{}</var></span>.</p>
</li>
</ol>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>A non-positional predicate can be evaluated by considering each
item in the filtered sequence independently; the result never
depends on the position of other items in the sequence or the
length of the sequence.</p>
</div>
<p>A pattern that is not <a title="motionless" class="termref"
href="#dt-motionless">motionless</a> is classified as <a title=
"free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a>.</p>
<p>The following list shows examples of motionless patterns:</p>
<ul>
<li>
<p><code>/</code></p>
</li>
<li>
<p><code>*</code></p>
</li>
<li>
<p><code>/*</code></p>
</li>
<li>
<p><code>p</code></p>
</li>
<li>
<p><code>p|q</code></p>
</li>
<li>
<p><code>p/q</code></p>
</li>
<li>
<p><code>p[@status='red']</code></p>
</li>
<li>
<p><code>p[base-uri()]</code></p>
</li>
<li>
<p><code>p[@class or @style]</code></p>
</li>
<li>
<p><code>p[@status]</code></p>
</li>
<li>
<p><code>p[@status = $status-codes[1]]</code></p>
</li>
<li>
<p><code>p[@class | @style]</code></p>
</li>
<li>
<p><code>p[contains(@class, ':')]</code></p>
</li>
<li>
<p><code>p[substring-after(@class, ':')]</code></p>
</li>
<li>
<p><code>p[ancestor::*[@xml:lang]]</code></p>
</li>
<li>
<p><code>text()[starts-with(., '$')]</code></p>
</li>
<li>
<p><code>@price</code></p>
</li>
<li>
<p><code>@price[starts-with(., '$')]</code></p>
</li>
<li>
<p><code>//p/text()[. = 'Introduction']</code></p>
</li>
<li>
<p><code>document-node(element(html))</code> (Note: this is
classified as motionless even though testing a document node
against the pattern might require a small amount of
look-ahead.)</p>
</li>
</ul>
<p>The following list shows examples of patterns that are not
motionless, explaining why not:</p>
<ul>
<li>
<p><code>id('abc')</code> (contains a <code>RootedPath</code>)</p>
</li>
<li>
<p><code>$doc//p</code> (contains a <code>RootedPath</code>)</p>
</li>
<li>
<p><code>p[b]</code> (the predicate is not motionless)</p>
</li>
<li>
<p><code>p[. = 'Introduction']</code> (the predicate is not
motionless)</p>
</li>
<li>
<p><code>p[starts-with(., '$')]</code> (the predicate is not
motionless)</p>
</li>
<li>
<p><code>p[preceding-sibling::p[1] = '']</code> (the predicate is
not motionless)</p>
</li>
<li>
<p><code>p[1]</code> (contains a positional predicate: return type
is numeric)</p>
</li>
<li>
<p><code>p[$pnum + 1]</code> (contains a positional predicate:
return type is numeric)</p>
</li>
<li>
<p><code>p[data(@status)]</code> (contains a positional predicate:
return type is potentially numeric)</p>
</li>
<li>
<p><code>p[position() gt 2]</code> (contains a positional
predicate: calls <code>position()</code>)</p>
</li>
<li>
<p><code>p[last()]</code> (contains a positional predicate: calls
<code>last()</code>)</p>
</li>
</ul>
</div>
</div>
<div class="div2">
<h3><a name="streamability-analysis-examples" id=
"streamability-analysis-examples"></a>19.9 <a href=
"#streamability-analysis-examples" style=
"text-decoration: none">Examples of Streamability Analysis</a></h3>
<p>The examples in this section are intended to illustrate how the
streamability rules are applied "top down" to establish whether
template rules are guaranteed streamable.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e54995" id=
"d7e54995"></a>Example: A recursive-descent template rule</div>
<p>Consider the following template rule, where mode <code>s</code>
is defined with <code>streamable="yes"</code>:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="para" mode="s"&gt;
  &lt;div class="para"&gt;
    &lt;xsl:apply-templates mode="s"/&gt;
  &lt;/div&gt;
&lt;/xsl:template&gt;
</pre></div>
<p>The processor is required to establish that this template meets
the streamability rules. Specifically, as stated in <a href=
"#streamable-templates"><i>6.6.4 Streamable Templates</i></a>, it
must satisfy three conditions:</p>
<ol class="enumar">
<li>
<p>The match pattern must be <a title="motionless" class="termref"
href="#dt-motionless">motionless</a>.</p>
</li>
<li>
<p>The body of the template rule must be <a title="grounded" class=
"termref" href="#dt-grounded">grounded</a>.</p>
</li>
<li>
<p>The initializers of any template parameters must be <a title=
"motionless" class="termref" href=
"#dt-motionless">motionless</a>.</p>
</li>
</ol>
<p>The third condition is satisfied trivially because there are no
parameters.</p>
<p>The first rule depends on the rules for assessing patterns,
which are given in <a href="#classifying-patterns"><i>19.8.9
Classifying Patterns</i></a>. This pattern is motionless because
(a) it does not contain a <code>RootedPath</code>, and (b) it
contains no predicates.</p>
<p>So it remains to determine that the body of the template is
<a title="grounded" class="termref" href=
"#dt-grounded">grounded</a>. The proof of this is as follows:</p>
<ol class="enumar">
<li>
<p>The sequence constructor forming the body of the template is
assessed according to the rules in <a href=
"#classifying-sequence-constructors"><i>19.8.3 Classifying Sequence
Constructors</i></a>, which tell us that there is a single operand
(the <code>&lt;div&gt;</code> <a title="literal result element"
class="termref" href="#dt-literal-result-element">literal result
element</a>) which has <a title="operand usage" class="termref"
href="#dt-operand-usage">operand usage</a> <var>U</var> = <a title=
"transmission" class="termref" href=
"#dt-transmission">transmission</a>.</p>
</li>
<li>
<p>The assessment of the sequence constructor uses the <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>.
These rules require us to determine the type <var>T</var>, sweep
<var>S</var>, posture <var>P</var>, and usage <var>U</var> of each
operand. We have already established that there is a single
operand, with <var>U</var> = <a title="transmission" class=
"termref" href="#dt-transmission">transmission</a>. Section
<a href="#determining-static-type"><i>19.2 Determining the Static
Type of a Construct</i></a> tells us that for all instructions, we
can take <var>T</var> = <var>U{*}</var>. The <a title="posture"
class="termref" href="#dt-posture">posture</a> <var>P</var> and
<a title="sweep" class="termref" href="#dt-sweep">sweep</a>
<var>S</var> of the literal result element are established as
follows:</p>
<ol class="enumla">
<li>
<p>The rules for literal result elements (specifically the
<code>&lt;div&gt;</code> element) are given in <a href=
"#streamability-literal-result-elements"><i>19.8.4.1 Streamability
of Literal Result Elements</i></a>. This particular literal result
element has only one operand (its contained sequence constructor),
with operand usage <var>U</var> = <a title="absorption" class=
"termref" href="#dt-absorption">absorption</a>.</p>
</li>
<li>
<p>The <a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>
again apply. Again the <a title="static type" class="termref" href=
"#dt-static-type">static type</a> <var>T</var> of the operand is
<code>U{*}</code>, and we need to determine the <a title="posture"
class="termref" href="#dt-posture">posture</a> <var>P</var> and
<a title="sweep" class="termref" href="#dt-sweep">sweep</a>
<var>S</var>.</p>
</li>
<li>
<p>To determine the posture and sweep of this sequence constructor
(the one that contains the <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction) we refer again to the <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability
rules</a>.</p>
<ol class="enumlr">
<li>
<p>The sequence constructor has a single operand (the <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction); again <var>U</var> = <a title="transmission" class=
"termref" href="#dt-transmission">transmission</a>, <var>T</var> =
<var>U{*}</var>.</p>
</li>
<li>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> <var>P</var> and <a title="sweep" class=
"termref" href="#dt-sweep">sweep</a> <var>S</var> of the <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction are established as follows:</p>
<ol class="enumua">
<li>
<p>The rules that apply are in <a href=
"#streamability-xsl-apply-templates"><i>19.8.4.5 Streamability of
xsl:apply-templates</i></a>.</p>
</li>
<li>
<p>Rule 1 does not apply because the <code>select</code> expression
(which defaults to <code>child::node()</code>) is not <a title=
"grounded" class="termref" href="#dt-grounded">grounded</a>. This
is a consequence of the rules in <a href=
"#streamability-of-axis-steps"><i>19.8.7.7 Streamability of Axis
Steps</i></a>, specifically:</p>
<ol class="enumur">
<li>
<p>The <a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a> of the axis step is
established by the template rule as a whole, as <a title="striding"
class="termref" href="#dt-striding">striding</a>.</p>
</li>
<li>
<p>Therefore rules 1 and 2 do not apply.</p>
</li>
<li>
<p>The statically-inferred context item type is derived from the
match pattern (<code>match="para"</code>). This gives a type of
<var>U{element()}</var>. The child axis for element nodes is not
necessarily empty, so rule 3 does not apply.</p>
</li>
<li>
<p>Rule 4 does not apply because there are no predicates.</p>
</li>
<li>
<p>So the <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of the axis step
<code>child::node()</code> are given by the table in rule 5. The
entry for (context posture = striding, axis = child) gives a
posture of <a title="striding" class="termref" href=
"#dt-striding">striding</a> and a <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of <a title="consuming" class="termref"
href="#dt-consuming">consuming</a>.</p>
</li>
<li>
<p>So the <code>select</code> expression is not <a title="grounded"
class="termref" href="#dt-grounded">grounded</a>. (The same result
can be reached intuitively: an expression that selects streamed
nodes will never be <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a>.)</p>
</li>
</ol>
</li>
<li>
<p>Rule 2 does not apply because there is no <a href=
"#element-sort"><code>xsl:sort</code></a> element.</p>
</li>
<li>
<p>Rule 3 does not apply because the mode is declared with
<code>streamable="yes"</code>.</p>
</li>
<li>
<p>So the <a title="posture" class="termref" href=
"#dt-posture">posture</a> <var>P</var> and <a title="sweep" class=
"termref" href="#dt-sweep">sweep</a> <var>S</var> of the <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction are established by the <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>,
as follows:</p>
<ol class="enumur">
<li>
<p>There is a single operand, the implicit
<code>select="child::node()"</code> expression, with usage
<var>U</var> = <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>.</p>
</li>
<li>
<p>We have already established that for this operand, the posture
<var>P</var> = <a title="striding" class="termref" href=
"#dt-striding">striding</a> and the <a title="sweep" class=
"termref" href="#dt-sweep">sweep</a> <var>S</var> = <a title=
"consuming" class="termref" href="#dt-consuming">consuming</a>.</p>
</li>
<li>
<p>By the rules in <a href="#determining-static-type"><i>19.2
Determining the Static Type of a Construct</i></a>, the type
<var>T</var> of the <code>select</code> expression is
<code>node()</code>.</p>
</li>
<li>
<p>In the <a title="general streamability rules" class="termref"
href="#dt-general-streamability-rules">general streamability
rules</a>, the adjusted sweep <var>S'</var> for an operand with
(<var>P</var> = <a title="striding" class="termref" href=
"#dt-striding">striding</a>, <var>U</var> = <a title="absorption"
class="termref" href="#dt-absorption">absorption</a>) is <a title=
"consuming" class="termref" href="#dt-consuming">consuming</a>,</p>
</li>
<li>
<p>Rule 2(d) then applies, so the <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction is <a title="consuming" class="termref" href=
"#dt-consuming">consuming</a> and <a title="grounded" class=
"termref" href="#dt-grounded">grounded</a>.</p>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p>So the sequence constructor that contains the <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction has one operand with <var>U</var> = <a title=
"transmission" class="termref" href=
"#dt-transmission">transmission</a>, <var>T</var> =
<code>item()</code>, <var>P</var> = <a title="grounded" class=
"termref" href="#dt-grounded">grounded</a>, <var>S</var> =
<a title="consuming" class="termref" href=
"#dt-consuming">consuming</a>. Rule 2(d) of the <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>
applies, so the sequence constructor itself has <var>P</var> =
<a title="grounded" class="termref" href=
"#dt-grounded">grounded</a>, <var>S</var> = <a title="consuming"
class="termref" href="#dt-consuming">consuming</a>.</p>
</li>
</ol>
</li>
<li>
<p>So the literal result element has one operand with <var>U</var>
= <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>, <var>T</var> =
<code>item()</code>, <var>P</var> = <a title="grounded" class=
"termref" href="#dt-grounded">grounded</a>, <var>S</var> =
<a title="consuming" class="termref" href=
"#dt-consuming">consuming</a>. Rule 2(d) of the <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>
applies, so the literal result element has <var>P</var> = <a title=
"grounded" class="termref" href="#dt-grounded">grounded</a>,
<var>S</var> = <a title="consuming" class="termref" href=
"#dt-consuming">consuming</a>.</p>
</li>
</ol>
</li>
<li>
<p>So the sequence constructor containing the literal result
element has one operand with <var>U</var> = <a title="transmission"
class="termref" href="#dt-transmission">transmission</a>,
<var>T</var> = <code>item()</code>, <var>P</var> = <a title=
"grounded" class="termref" href="#dt-grounded">grounded</a>,
<var>S</var> = <a title="consuming" class="termref" href=
"#dt-consuming">consuming</a>. Rule 2(d) of the <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>
applies, so this sequence constructor itself has <var>P</var> =
<a title="grounded" class="termref" href=
"#dt-grounded">grounded</a>, <var>S</var> = <a title="consuming"
class="termref" href="#dt-consuming">consuming</a>.</p>
</li>
<li>
<p>So we have established that the sequence constructor forming the
body of the template rule is <a title="grounded" class="termref"
href="#dt-grounded">grounded</a>.</p>
</li>
</ol>
<p>Therefore, since the other conditions are also satisfied, the
template is <a title="guaranteed-streamable" class="termref" href=
"#dt-guaranteed-streamable">guaranteed-streamable</a>.</p>
<p>The analysis presented above could have been simplified by
taking into account the fact that the streamability properties of a
sequence constructor containing a single instruction are identical
to the properties of that instruction. This simplification will be
exploited in the next example.</p>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e55482" id=
"d7e55482"></a>Example: An aggregating template rule</div>
<p>Consider the following template rule, where mode <code>s</code>
is defined with <code>streamable="yes"</code>:</p>
<div class="exampleInner">
<pre>
&lt;xsl:template match="transactions[@currency='USD']" mode="s"&gt;
  &lt;total&gt;&lt;xsl:value-of select="sum(transaction/@value)"/&gt;&lt;/total&gt;
&lt;/xsl:template&gt;
</pre></div>
<p>Again, as stated in <a href="#streamable-templates"><i>6.6.4
Streamable Templates</i></a>, it must satisfy three conditions:</p>
<ol class="enumar">
<li>
<p>The match pattern must be <a title="motionless" class="termref"
href="#dt-motionless">motionless</a>.</p>
</li>
<li>
<p>The body of the template rule must be <a title="grounded" class=
"termref" href="#dt-grounded">grounded</a>.</p>
</li>
<li>
<p>The initializers of any template parameters must be <a title=
"motionless" class="termref" href=
"#dt-motionless">motionless</a>.</p>
</li>
</ol>
<p>The third condition is satisfied trivially because there are no
parameters.</p>
<p>The first rule depends on the rules for assessing patterns,
which are given in <a href="#classifying-patterns"><i>19.8.9
Classifying Patterns</i></a>. This pattern is motionless because
(a) it is not a <code>RootedPath</code>, and (b) every predicate is
<a title="motionless" class="termref" href=
"#dt-motionless">motionless</a> and <a title=
"non-positional predicate" class="termref" href=
"#dt-non-positional-predicate">non-positional</a>. The analysis
that proves the predicate is motionless and non-positional proceeds
as follows:</p>
<ol class="enumar">
<li>
<p>First establish that that the expression
<code>@currency='USD'</code> is <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>, as follows:</p>
<ol class="enumla">
<li>
<p>The predicate is a general comparison (<code>GeneralComp</code>)
which follows the <a title="general streamability rules" class=
"termref" href="#dt-general-streamability-rules">general
streamability rules</a>.</p>
</li>
<li>
<p>There are two operands: an <code>AxisStep</code> with a
defaulted <code>ForwardAxis</code>, and a <code>Literal</code>.
Both operand roles are <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>.</p>
</li>
<li>
<p>The <span>left-hand</span> operand has type <var>T</var> =
<code>attribute()</code>. Its <a title="posture" class="termref"
href="#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> are determined by the rules in <a href=
"#streamability-of-axis-steps"><i>19.8.7.7 Streamability of Axis
Steps</i></a>. The <a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a> is <a title="striding"
class="termref" href="#dt-striding">striding</a>, so the <a title=
"posture" class="termref" href="#dt-posture">posture</a> and
<a title="sweep" class="termref" href="#dt-sweep">sweep</a> are
determined by the entry in the table (rule 5) with context posture
= <a title="striding" class="termref" href=
"#dt-striding">striding</a>, axis = <code>attribute</code>: that
is, the result posture is <a title="climbing" class="termref" href=
"#dt-climbing">climbing</a> and the <a title="sweep" class=
"termref" href="#dt-sweep">sweep</a> is <a title="motionless"
class="termref" href="#dt-motionless">motionless</a>.</p>
</li>
<li>
<p>The <span>right-hand</span> operand, being a literal, is
<a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> and <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>.</p>
</li>
<li>
<p>In the <a title="general streamability rules" class="termref"
href="#dt-general-streamability-rules">general streamability
rules</a>, rule 2(e) applies, so the predicate is <a title=
"grounded" class="termref" href="#dt-grounded">grounded</a> and
<a title="motionless" class="termref" href=
"#dt-motionless">motionless</a></p>
</li>
</ol>
</li>
<li>
<p>Now establish that that the expression
<code>@currency='USD'</code> is <a title="non-positional predicate"
class="termref" href=
"#dt-non-positional-predicate">non-positional</a>, as follows:</p>
<ol class="enumla">
<li>
<p>Rule 1 is satisfied: the predicate does not call <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-position"><code>position</code></a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#func-last"><code>last</code></a><sup><small>FO30</small></sup>,
or <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>
function-lookup</code></a><sup><small>FO30</small></sup>.</p>
</li>
<li>
<p>Rule 2 is satisfied: the expression <code>@currency='USD'</code>
is non-numeric. The <a title="static type" class="termref" href=
"#dt-static-type">static type</a> of the expression is determined
using the rules in <a href="#determining-static-type"><i>19.2
Determining the Static Type of a Construct</i></a> as
<var>U{xs:boolean}</var>, and this has no intersection with
<var>U{xs:decimal, xs:double, xs:float}</var>.</p>
</li>
</ol>
</li>
</ol>
<p>So both conditions in <a href="#classifying-patterns"><i>19.8.9
Classifying Patterns</i></a> are satisfied, and the pattern is
therefore <a title="motionless" class="termref" href=
"#dt-motionless">motionless</a>.</p>
<p>It remains to show that the body of the template rule is
<a title="grounded" class="termref" href=
"#dt-grounded">grounded</a>. The proof of this is as follows.
Unlike the previous example, the analysis is shown in simplified
form; in particular the two sequence constructors which each
contain a single instruction are ignored, and replaced in the
construct tree by their contained instruction.</p>
<ol class="enumar">
<li>
<p>We need to show that the <code>&lt;total&gt;</code> <a title=
"literal result element" class="termref" href=
"#dt-literal-result-element">literal result element</a> is
<a title="grounded" class="termref" href=
"#dt-grounded">grounded</a>.</p>
</li>
<li>
<p>The rules that apply are in <a href=
"#streamability-literal-result-elements"><i>19.8.4.1 Streamability
of Literal Result Elements</i></a>.</p>
</li>
<li>
<p>These rules refer to the <a title="general streamability rules"
class="termref" href="#dt-general-streamability-rules">general
streamability rules</a>. There is one operand, the <a href=
"#element-value-of"><code>xsl:value-of</code></a> child element,
which has <a title="operand usage" class="termref" href=
"#dt-operand-usage">operand usage</a> <var>U</var> = <a title=
"absorption" class="termref" href="#dt-absorption">absorption</a>,
and type <var>T</var> = <code>item()</code>.</p>
</li>
<li>
<p>So we need to determine the <a title="posture" class="termref"
href="#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of the <a href=
"#element-value-of"><code>xsl:value-of</code></a> instruction.</p>
<ol class="enumla">
<li>
<p>The rules are given in <a href=
"#streamability-xsl-value-of"><i>19.8.4.38 Streamability of
xsl:value-of</i></a>.</p>
</li>
<li>
<p>The <a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>
apply. There is one operand, the expression
<code>sum(transaction/@value)</code>, which has <a title=
"operand usage" class="termref" href="#dt-operand-usage">operand
usage</a> <var>U</var> = <a title="absorption" class="termref"
href="#dt-absorption">absorption</a>.</p>
</li>
<li>
<p>The type <var>T</var> of this operand is the return type defined
in the signature of the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-sum"><code>sum</code></a><sup><small>FO30</small></sup>
function, that is, <code>xs:anyAtomicType</code>.</p>
</li>
<li>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> <var>P</var> and <a title="sweep" class=
"termref" href="#dt-sweep">sweep</a> <var>S</var> are established
as follows:</p>
<ol class="enumlr">
<li>
<p>The rules that apply to the call on <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-sum"><code>sum</code></a><sup><small>FO30</small></sup>
are given in <a href="#classifying-built-in-functions"><i>19.8.8
Classifying Calls to Built-In Functions</i></a>.</p>
</li>
<li>
<p>The relevant proforma is <code>fn:sum(A)</code>, indicating that
the <a title="general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>
apply, and that there is a single operand with usage <var>U</var> =
<a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>.</p>
</li>
<li>
<p>The type <var>T</var> of the operand
<code>transaction/@value</code> is determined (by the rules in
<a href="#determining-static-type"><i>19.2 Determining the Static
Type of a Construct</i></a>) as <code>attribute()</code>.</p>
</li>
<li>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> <var>P</var> and <a title="sweep" class=
"termref" href="#dt-sweep">sweep</a> <var>S</var> of the operand
<code>transaction/@value</code> are determined by the rules in
<a href="#streamability-of-path-expressions"><i>19.8.7.6
Streamability of Path Expressions</i></a>, as follows:</p>
<ol class="enumua">
<li>
<p>The expression is expanded to
<code>child::transaction/attribute::value</code>.</p>
</li>
<li>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of the <span>left-hand</span> operand
<code>child::transaction</code> are determined by the rules in
<a href="#streamability-of-axis-steps"><i>19.8.7.7 Streamability of
Axis Steps</i></a>, as follows:</p>
<ol class="enumur">
<li>
<p>The <a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a> is <a title="striding"
class="termref" href="#dt-striding">striding</a>, because the
<a title="focus-setting container" class="termref" href=
"#dt-focus-setting-container">focus-setting container</a> is the
template rule itself.</p>
</li>
<li>
<p>The <a title="context item type" class="termref" href=
"#dt-context-item-type">context item type</a> is
<code>element()</code>, based on the <a title="match type" class=
"termref" href="#dt-match-type">match type</a> of the pattern
<code>match="transactions[@currency='USD']"</code>.</p>
</li>
<li>
<p>Rules 1 and 2 do not apply because the <a title=
"context posture" class="termref" href=
"#dt-context-posture">context posture</a> is <a title="striding"
class="termref" href="#dt-striding">striding</a>.</p>
</li>
<li>
<p>Rule 3 does not apply because the <code>child</code> axis
applied to an element node is not necessarily empty.</p>
</li>
<li>
<p>Rule 4 does not apply because there are no predicates.</p>
</li>
<li>
<p>Rule 5 applies, and the table entry with context posture =
<a title="striding" class="termref" href=
"#dt-striding">striding</a>, axis = <code>child</code> gives a
result <a title="posture" class="termref" href=
"#dt-posture">posture</a> of <a title="striding" class="termref"
href="#dt-striding">striding</a> and a <a title="sweep" class=
"termref" href="#dt-sweep">sweep</a> of <a title="consuming" class=
"termref" href="#dt-consuming">consuming</a>.</p>
</li>
</ol>
</li>
<li>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> of the relative path expression
<code>child::transaction/attribute::value</code> is therefore the
<a title="posture" class="termref" href="#dt-posture">posture</a>
of its <span>right-hand</span> operand
<code>attribute::value</code>, assessed with a <a title=
"context posture" class="termref" href=
"#dt-context-posture">context posture</a> of <a title="striding"
class="termref" href="#dt-striding">striding</a>. This is
determined by the rules in <a href=
"#streamability-of-axis-steps"><i>19.8.7.7 Streamability of Axis
Steps</i></a>, as follows:</p>
<ol class="enumur">
<li>
<p>The <a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a>, as we have seen, is
<a title="striding" class="termref" href=
"#dt-striding">striding</a>.</p>
</li>
<li>
<p>The <a title="context item type" class="termref" href=
"#dt-context-item-type">context item type</a> is
<code>element()</code>, based on the type of the
<span>left-hand</span> operand <code>child::transaction</code>.</p>
</li>
<li>
<p>Rules 1 and 2 do not apply because the <a title=
"context posture" class="termref" href=
"#dt-context-posture">context posture</a> is <a title="striding"
class="termref" href="#dt-striding">striding</a>.</p>
</li>
<li>
<p>Rule 3 does not apply because the <code>attribute</code> axis
applied to an element node is not necessarily empty.</p>
</li>
<li>
<p>Rule 4 does not apply because there are no predicates.</p>
</li>
<li>
<p>Rule 5 applies, and the table entry with context posture =
<a title="striding" class="termref" href=
"#dt-striding">striding</a>, axis = <code>attribute</code> gives a
result <a title="posture" class="termref" href=
"#dt-posture">posture</a> of <a title="climbing" class="termref"
href="#dt-climbing">climbing</a> and a <a title="sweep" class=
"termref" href="#dt-sweep">sweep</a> of <a title="motionless"
class="termref" href="#dt-motionless">motionless</a>.</p>
</li>
</ol>
</li>
<li>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> of the relative path expression
<code>child::transaction/attribute::value</code> is therefore
<a title="climbing" class="termref" href=
"#dt-climbing">climbing</a>.</p>
</li>
<li>
<p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a>
of the relative path expression
<code>child::transaction/attribute::value</code> is the wider of
the sweeps of its two operands, namely <a title="consuming" class=
"termref" href="#dt-consuming">consuming</a> and <a title=
"motionless" class="termref" href="#dt-motionless">motionless</a>.
That is, it is <a title="consuming" class="termref" href=
"#dt-consuming">consuming</a>.</p>
</li>
</ol>
</li>
<li>
<p>So the first and only operand to the call on <code>sum()</code>
has <var>U</var> = <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>, <var>T</var> =
<code>attribute()</code>, <var>P</var> = <a title="climbing" class=
"termref" href="#dt-climbing">climbing</a>, and <var>S</var> =
<a title="consuming" class="termref" href=
"#dt-consuming">consuming</a></p>
</li>
<li>
<p>Rule 1(b) of the <a title="general streamability rules" class=
"termref" href="#dt-general-streamability-rules">general
streamability rules</a> computes the adjusted sweep <var>S'</var>.
Rule 1(b)(iii)(A) applies, so the effective <a title=
"operand usage" class="termref" href="#dt-operand-usage">operand
usage</a> <var>U'</var> is <a title="inspection" class="termref"
href="#dt-inspection">inspection</a>. Rule 1(b)(iii)(A) then
computes the adjusted sweep from the table entry for <var>P</var> =
<a title="climbing" class="termref" href=
"#dt-climbing">climbing</a>, <var>U'</var> = <a title="inspection"
class="termref" href="#dt-inspection">inspection</a>; this shows
<var>S'</var> = <var>S</var>, that is, <a title="consuming" class=
"termref" href="#dt-consuming">consuming</a>.</p>
</li>
<li>
<p>Rule 2(d) now applies, so the call on <code>sum()</code> is
<a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> and <a title="consuming" class=
"termref" href="#dt-consuming">consuming</a>.</p>
</li>
</ol>
</li>
<li>
<p>Since the <a href=
"#element-value-of"><code>xsl:value-of</code></a> instruction has
one operand with <var>U</var> = <a title="absorption" class=
"termref" href="#dt-absorption">absorption</a>, <var>T</var> =
<code>xs:anyAtomicType</code>, <var>P</var> = <a title="grounded"
class="termref" href="#dt-grounded">grounded</a>, and <var>S</var>
= <a title="consuming" class="termref" href=
"#dt-consuming">consuming</a>, rule 2(d) again applies, and the
<a href="#element-value-of"><code>xsl:value-of</code></a>
instruction is <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> and <a title="consuming" class=
"termref" href="#dt-consuming">consuming</a>.</p>
</li>
</ol>
</li>
<li>
<p>Since the literal result element has one operand with
<var>U</var> = <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>, <var>T</var> =
<code>item()</code>, <var>P</var> = <a title="grounded" class=
"termref" href="#dt-grounded">grounded</a>, and <var>S</var> =
<a title="consuming" class="termref" href=
"#dt-consuming">consuming</a>, rule 2(d) again applies, and the
literal result element is <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> and <a title="consuming" class=
"termref" href="#dt-consuming">consuming</a>.</p>
</li>
<li>
<p>Therefore the body of the template rule is <a title="grounded"
class="termref" href="#dt-grounded">grounded</a>, and since the
other conditions are also satisfied, it is <a title=
"guaranteed-streamable" class="termref" href=
"#dt-guaranteed-streamable">guaranteed-streamable</a>.</p>
</li>
</ol>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e56139" id=
"d7e56139"></a>Example: Streamed Grouping</div>
<p>Consider the following code, which is designed to process a
transaction file containing transactions in chronological order,
and output the total value of the transactions for each day.</p>
<div class="exampleInner">
<pre>
&lt;xsl:template name="go"&gt;
  &lt;out&gt;
    &lt;xsl:stream href="transactions.xml"&gt;
      &lt;xsl:for-each-group select="/account/transaction" 
                          group-adjacent="xs:date(@timestamp)"&gt;
         &lt;total date="{current-grouping-key()}" value="{sum(current-group()/@value)}"/&gt;
      &lt;/xsl:for-each-group&gt;
    &lt;/xsl:stream&gt;
  &lt;/out&gt;
&lt;/xsl:template&gt;
</pre></div>
<p>The rules for <a href=
"#element-stream"><code>xsl:stream</code></a> say that the
instruction is <a title="guaranteed-streamable" class="termref"
href="#dt-guaranteed-streamable">guaranteed-streamable</a> if the
contained <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> is <a title=
"grounded" class="termref" href="#dt-grounded">grounded</a>, and
the task of streamability analysis is to prove that this is the
case. As in the previous example, we will take a short-cut by
making the assumption that a sequence constructor containing a
single instruction can be replaced by that instruction in the
construct tree.</p>
<p>So the task is to show that the <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction is <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a>, which we can do as follows:</p>
<ol class="enumar">
<li>
<p>The relevant rules are to be found in <a href=
"#streamability-xsl-for-each-group"><i>19.8.4.19 Streamability of
xsl:for-each-group</i></a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Rule numbers may be different in a version of the specification
with change markings.</p>
</div>
</li>
<li>
<p>Rule 1 applies only if the <code>select</code> expression is
<a title="grounded" class="termref" href=
"#dt-grounded">grounded</a>. It is easy to see informally that this
is not the case (an expression that returns streamed nodes is never
grounded). More formally:</p>
<ol class="enumla">
<li>
<p>The <code>select</code> expression is a path expression; the
rules in <a href="#streamability-of-path-expressions"><i>19.8.7.6
Streamability of Path Expressions</i></a> apply.</p>
</li>
<li>
<p>The expression is rewritten as <code>((root(.) treat as
document-node())/child::account)/child::transaction</code></p>
</li>
<li>
<p>The left-hand operand <code>(root(.) treat as
document-node())/child::account</code> is also a path expression,
so the rules in <a href=
"#streamability-of-path-expressions"><i>19.8.7.6 Streamability of
Path Expressions</i></a> apply recursively:</p>
<ol class="enumlr">
<li>
<p>The left-hand operand <code>root(.) treat as
document-node()</code> follows the rules for a
<code>TreatExpr</code> in <a href=
"#classifying-expressions"><i>19.8.7 Classifying
Expressions</i></a>; the proforma <code>T treat as TYPE</code>
indicates that the <a title="general streamability rules" class=
"termref" href="#dt-general-streamability-rules">general
streamability rules</a> apply with a single operand having usage
<a title="transmission" class="termref" href=
"#dt-transmission">transmission</a>.</p>
</li>
<li>
<p>This single operand <code>root(.)</code> follows the rules in
<a href="#streamability-fn-root"><i>19.8.8.18 Streamability of the
root function</i></a>. The item type of the operand <code>.</code>
is the <a title="context item type" class="termref" href=
"#dt-context-item-type">context item type</a>, which is the type
established by the <a href=
"#element-stream"><code>xsl:stream</code></a> instruction, namely
<code>document-node()</code>. Under these conditions
<code>root(.)</code> is rewritten as <code>.</code>, so the
<a title="posture" class="termref" href="#dt-posture">posture</a>
is the <a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a> established by the
<a href="#element-stream"><code>xsl:stream</code></a> instruction,
namely <a title="striding" class="termref" href=
"#dt-striding">striding</a>. The <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> is <a title="motionless" class="termref"
href="#dt-motionless">motionless</a>.</p>
</li>
<li>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of the expression <code>root(.) treat as
document-node()</code> are the same as the <a title="posture"
class="termref" href="#dt-posture">posture</a> and <a title="sweep"
class="termref" href="#dt-sweep">sweep</a> of <code>root(.)</code>,
namely <a title="striding" class="termref" href=
"#dt-striding">striding</a> and <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a></p>
</li>
<li>
<p>The right-hand operand <code>child::account</code> is governed
by the rules in <a href="#streamability-of-axis-steps"><i>19.8.7.7
Streamability of Axis Steps</i></a>. The <a title="context posture"
class="termref" href="#dt-context-posture">context posture</a> is
<a title="striding" class="termref" href=
"#dt-striding">striding</a>, and the axis is <code>child</code>, so
the result posture is <a title="striding" class="termref" href=
"#dt-striding">striding</a> and the sweep is <a title="consuming"
class="termref" href="#dt-consuming">consuming</a>.</p>
</li>
<li>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> of the path expression is the <a title=
"posture" class="termref" href="#dt-posture">posture</a> of the
right-hand operand, that is <a title="striding" class="termref"
href="#dt-striding">striding</a>, and its sweep is the wider sweep
of the two operands, that is <a title="consuming" class="termref"
href="#dt-consuming">consuming</a></p>
</li>
</ol>
</li>
<li>
<p>Returning to the outer path expression, the <a title="posture"
class="termref" href="#dt-posture">posture</a> of the right hand
operand <code>child::transaction</code> is <a title="striding"
class="termref" href="#dt-striding">striding</a>, and its sweep is
<a title="consuming" class="termref" href=
"#dt-consuming">consuming</a>.</p>
</li>
<li>
<p>So the <a title="posture" class="termref" href=
"#dt-posture">posture</a> of the <code>select</code> expression as
a whole is the posture of the right hand operand, that is <a title=
"striding" class="termref" href="#dt-striding">striding</a>; and
its sweep is the wider of the sweeps of the operands, which is
<a title="consuming" class="termref" href=
"#dt-consuming">consuming</a>.</p>
</li>
</ol>
</li>
<li>
<p>Rule 2 does not apply: there is no <code>group-by</code>
attribute.</p>
</li>
<li>
<p>Rule 3 does not apply: there is a <code>group-adjacent</code>
attribute, but it is <a title="motionless" class="termref" href=
"#dt-motionless">motionless</a>. The reasoning is as follows:</p>
<ol class="enumla">
<li>
<p>The value is a call to the constructor function
<code>xs:date</code>. The rules in <a href=
"#streamability-of-function-calls"><i>19.8.7.12 Streamability of
Function Calls</i></a> apply. There is a single operand, whose
required type is atomic, so the <a title="operand usage" class=
"termref" href="#dt-operand-usage">operand usage</a> is <a title=
"absorption" class="termref" href=
"#dt-absorption">absorption</a>.</p>
</li>
<li>
<p>These rules refer to the <a title="general streamability rules"
class="termref" href="#dt-general-streamability-rules">general
streamability rules</a>, so we need to determine the <a title=
"context item type" class="termref" href=
"#dt-context-item-type">context item type</a>, <a title="posture"
class="termref" href="#dt-posture">posture</a>, and <a title=
"sweep" class="termref" href="#dt-sweep">sweep</a> of the operand
expression <code>@timestamp</code>. This is done as follows:</p>
<ol class="enumlr">
<li>
<p>The expression is an <code>AxisStep</code>, so the relevant
rules are in <a href="#streamability-of-axis-steps"><i>19.8.7.7
Streamability of Axis Steps</i></a>.</p>
</li>
<li>
<p>The <a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a> is the <a title="posture"
class="termref" href="#dt-posture">posture</a> of the <a title=
"controlling operand" class="termref" href=
"#dt-controlling-operand">controlling operand</a> of the <a title=
"focus-setting container" class="termref" href=
"#dt-focus-setting-container">focus-setting container</a>, that is,
is the <code>select</code> expression of the containing <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction, which as established above is <a title="striding"
class="termref" href="#dt-striding">striding</a>. The <a title=
"context item type" class="termref" href=
"#dt-context-item-type">context item type</a> is similarly the
inferred type of the <code>select</code> expression, and is
<code>element()</code>.</p>
</li>
<li>
<p>Rules 1 and 2 do not apply because the <a title=
"context posture" class="termref" href=
"#dt-context-posture">context posture</a> is <a title="striding"
class="termref" href="#dt-striding">striding</a>.</p>
</li>
<li>
<p>Rule 3 does not apply because the attribute axis for an element
node is not necessarily empty.</p>
</li>
<li>
<p>Rule 4 does not apply because there is no predicate.</p>
</li>
<li>
<p>So the <a title="sweep" class="termref" href=
"#dt-sweep">sweep</a> and <a title="posture" class="termref" href=
"#dt-posture">posture</a> of the expression <code>@timestamp</code>
are given by the table in Rule 5 as <a title="climbing" class=
"termref" href="#dt-climbing">climbing</a> and <a title=
"motionless" class="termref" href=
"#dt-motionless">motionless</a>.</p>
</li>
</ol>
</li>
<li>
<p>Returning to the <a title="general streamability rules" class=
"termref" href="#dt-general-streamability-rules">general
streamability rules</a> for the expression
<code>xs:date(@timestamp)</code>, the <span>operand
<code>@timestamp</code></span> has <var>U</var> = <a title=
"absorption" class="termref" href="#dt-absorption">absorption</a>,
<var>T</var> = <code>attribute()</code>, <var>P</var> = <a title=
"climbing" class="termref" href="#dt-climbing">climbing</a>,
<var>S</var> = <a title="motionless" class="termref" href=
"#dt-motionless">motionless</a>.</p>
</li>
<li>
<p>Under Rule 1(b)(iii)(A), because <var>T</var> =
<code>attribute()</code>, the operand usage <var>U'</var> becomes
<a title="inspection" class="termref" href=
"#dt-inspection">inspection</a>.</p>
</li>
<li>
<p>Under Rule 1(b)(iii)(A), <var>S'</var> = <var>S</var> =
<a title="motionless" class="termref" href=
"#dt-motionless">motionless</a>.</p>
</li>
<li>
<p>Under Rule 2(e), the expression <code>xs:date(@timestamp)</code>
is <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> and <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>.</p>
</li>
</ol>
</li>
<li>
<p>Rule 4 (under <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>) does
not apply, because there is no <a href=
"#element-sort"><code>xsl:sort</code></a> child.</p>
</li>
<li>
<p>So Rule 5 applies. This relies on knowing the <a title="posture"
class="termref" href="#dt-posture">posture</a> of the sequence
constructor contained in the <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction: that is, the <a title="posture" class="termref" href=
"#dt-posture">posture</a> of the <code>total</code> <a title=
"literal result element" class="termref" href=
"#dt-literal-result-element">literal result element</a>. This is
calculated as follows:</p>
<ol class="enumla">
<li>
<p>The rules that apply are in <a href=
"#streamability-literal-result-elements"><i>19.8.4.1 Streamability
of Literal Result Elements</i></a>. The <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>
apply; there are two operands, the attribute value templates
<code>{current-grouping-key()}</code> and
<code>{sum(current-group()/@value}</code>, and in each case the
usage is <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>. We can simplify the analysis by
observing that the empty <a title="sequence constructor" class=
"termref" href="#dt-sequence-constructor">sequence constructor</a>
contained in the literal result element can be ignored, since it is
<a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> and <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>.</p>
</li>
<li>
<p>Consider first the operand
<code>{current-grouping-key()}</code>.</p>
<ol class="enumlr">
<li>
<p>Section <a href="#classifying-vts"><i>19.8.6 Classifying Value
Templates</i></a> applies. This refers to the <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>;
there is a single operand, the expression
<code>current-grouping-key()</code>, with usage <a title=
"absorption" class="termref" href=
"#dt-absorption">absorption</a>.</p>
</li>
<li>
<p>Section <a href=
"#streamability-fn-current-grouping-key"><i>19.8.8.5 Streamability
of the current-grouping-key function</i></a> applies. This
establishes that the expression is <a title="grounded" class=
"termref" href="#dt-grounded">grounded</a> and <a title=
"motionless" class="termref" href=
"#dt-motionless">motionless</a>.</p>
</li>
<li>
<p>It follows that the operand
<code>{current-grouping-key()}</code> expression is also <a title=
"grounded" class="termref" href="#dt-grounded">grounded</a> and
<a title="motionless" class="termref" href=
"#dt-motionless">motionless</a>.</p>
</li>
</ol>
</li>
<li>
<p>Now consider the operand
<code>{sum(current-group()/@value)}</code>.</p>
</li>
<li>
<p>Section <a href="#classifying-vts"><i>19.8.6 Classifying Value
Templates</i></a> applies. This refers to the <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>;
there is a single operand, the expression
<code>sum(current-group()/@value)</code>, with usage <a title=
"absorption" class="termref" href=
"#dt-absorption">absorption</a>.</p>
</li>
<li>
<p>The rules for the <code>sum</code> function appear in <a href=
"#classifying-built-in-functions"><i>19.8.8 Classifying Calls to
Built-In Functions</i></a>. The proforma is given there as
<code>fn:sum(A)</code>, which means that the <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>
apply, and that the single operand
<code>current-group()/@value</code> has usage <a title="absorption"
class="termref" href="#dt-absorption">absorption</a>. So we need to
establish the <a title="posture" class="termref" href=
"#dt-posture">posture</a>, <a title="sweep" class="termref" href=
"#dt-sweep">sweep</a>, and type of this expression, which we can do
as follows:</p>
<ol class="enumlr">
<li>
<p>The expression is a <code>RelativePathExpr</code>, so section
<a href="#streamability-of-path-expressions"><i>19.8.7.6
Streamability of Path Expressions</i></a> applies.</p>
</li>
<li>
<p>The expression is expanded to
<code>current-group()/attribute::value</code>.</p>
</li>
<li>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of the left-hand operand
<code>current-group()</code> are defined in <a href=
"#streamability-fn-current-group"><i>19.8.8.4 Streamability of the
current-group function</i></a>. Since all the required conditions
are satisfied, the <a title="posture" class="termref" href=
"#dt-posture">posture</a> of <code>current-group()</code> is the
<a title="posture" class="termref" href="#dt-posture">posture</a>
of the <code>select</code> expression, that is <a title="striding"
class="termref" href="#dt-striding">striding</a>, and its <a title=
"sweep" class="termref" href="#dt-sweep">sweep</a> is the <a title=
"sweep" class="termref" href="#dt-sweep">sweep</a> of the
<code>select</code> expression, that is <a title="consuming" class=
"termref" href="#dt-consuming">consuming</a>.</p>
</li>
<li>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> and <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of the right hand operand
<code>@value</code> are defined in <a href=
"#streamability-of-axis-steps"><i>19.8.7.7 Streamability of Axis
Steps</i></a>. The <a title="context posture" class="termref" href=
"#dt-context-posture">context posture</a> is the <a title="posture"
class="termref" href="#dt-posture">posture</a> of the left-hand
operand <code>current-group()</code>, namely <a title="striding"
class="termref" href="#dt-striding">striding</a>; the table in Rule
5 applies, giving the result <a title="climbing" class="termref"
href="#dt-climbing">climbing</a> and <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a></p>
</li>
<li>
<p>The <a title="posture" class="termref" href=
"#dt-posture">posture</a> of the <code>RelativePathExpr</code> is
the <a title="posture" class="termref" href=
"#dt-posture">posture</a> of the right hand operand, namely
<a title="climbing" class="termref" href=
"#dt-climbing">climbing</a>. The <a title="sweep" class="termref"
href="#dt-sweep">sweep</a> of the <code>RelativePathExpr</code> is
the wider of the <a title="sweep" class="termref" href=
"#dt-sweep">sweeps</a> of its operands, which is <a title=
"consuming" class="termref" href="#dt-consuming">consuming</a></p>
</li>
<li>
<p>The type of the expression <code>current-group()/@value</code>
is determined using the rules in <a href=
"#determining-static-type"><i>19.2 Determining the Static Type of a
Construct</i></a> as <code>attribute()</code>.</p>
</li>
</ol>
</li>
<li>
<p>So the <code>sum</code> function has a single operand with
<var>U</var> = <a title="absorption" class="termref" href=
"#dt-absorption">absorption</a>, <var>P</var> = <a title="climbing"
class="termref" href="#dt-climbing">climbing</a>, <var>S</var> =
<a title="consuming" class="termref" href=
"#dt-consuming">consuming</a>, <var>T</var> =
<code>attribute()</code>.</p>
</li>
<li>
<p>In the <a title="general streamability rules" class="termref"
href="#dt-general-streamability-rules">general streamability
rules</a>, Rule 1(b)(iii)(A) gives the adjusted usage as
<var>U'</var> = <a title="inspection" class="termref" href=
"#dt-inspection">inspection</a>, and Rule 1(b)(iii)(B) gives the
adjusted sweep as <var>S'</var> = <var>S</var> = <a title=
"consuming" class="termref" href="#dt-consuming">consuming</a>.
Rule 2(d) gives the posture and sweep of the call to
<code>sum</code> as <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> and <a title="consuming" class=
"termref" href="#dt-consuming">consuming</a>.</p>
</li>
</ol>
</li>
<li>
<p>So the literal result element has two operands, one of which is
<a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> and <a title="motionless" class=
"termref" href="#dt-motionless">motionless</a>, the other <a title=
"grounded" class="termref" href="#dt-grounded">grounded</a> and
<a title="consuming" class="termref" href=
"#dt-consuming">consuming</a>. Rule 2(d) of the <a title=
"general streamability rules" class="termref" href=
"#dt-general-streamability-rules">general streamability rules</a>
determines that the literal result element is <a title="grounded"
class="termref" href="#dt-grounded">grounded</a> and <a title=
"consuming" class="termref" href="#dt-consuming">consuming</a>.</p>
</li>
<li>
<p>So the content of the <a href=
"#element-stream"><code>xsl:stream</code></a> instruction is
<a title="grounded" class="termref" href=
"#dt-grounded">grounded</a>, which means that the instruction is
<a title="guaranteed-streamable" class="termref" href=
"#dt-guaranteed-streamable">guaranteed-streamable</a>.</p>
</li>
</ol>
</div>
</div>
<div class="div2">
<h3><a name="streamability-guarantees" id=
"streamability-guarantees"></a>19.10 <a href=
"#streamability-guarantees" style=
"text-decoration: none">Streamability Guarantees</a></h3>
<p>Certain constructs allow a stylesheet author to declare that a
construct is streamable. Specifically:</p>
<ol class="enumar">
<li>
<p>Specifying <code>streamable="yes"</code> on <a href=
"#element-mode"><code>xsl:mode</code></a> declares that all
template rules in that mode <span>(and all template rules that
specify <code>mode="#all"</code>)</span> are streamable;</p>
</li>
<li>
<p>The <a href="#element-stream"><code>xsl:stream</code></a>
instruction implicitly declares that its contained sequence
constructor is streamable;</p>
</li>
<li>
<p>Specifying <code>streamable="yes"</code> on <a href=
"#element-function"><code>xsl:function</code></a> declares that the
<a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet function</a> in question is
streamable;</p>
</li>
<li>
<p>Specifying <code>streamable="yes"</code> on <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a>
declares that the attribute set in question is streamable;</p>
</li>
<li>
<p>Specifying <code>streamable="yes"</code> on <a href=
"#element-merge"><code>xsl:merge</code></a> declares that the
merging process is streamable.</p>
</li>
<li>
<p>Specifying <code>streamable="yes"</code> on <a href=
"#element-accumulator"><code>xsl:accumulator</code></a> declares
that the accumulator can be evaluated on a streamed document.</p>
</li>
<li>
<p>Specifying <code>streamable="yes"</code> on <a href=
"#element-global-context-item"><code>xsl:global-context-item</code></a>
declares that the global context item may be a node in a streamed
document.</p>
</li>
</ol>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-declared-streamable" id="dt-declared-streamable" title=
"declared-streamable"></a>The above constructs (template rules
belonging to a mode declared with <code>streamable="yes"</code>;
<a href="#element-stream"><code>xsl:stream</code></a>; and <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a>,
<a href="#element-function"><code>xsl:function</code></a>, <a href=
"#element-merge"><code>xsl:merge</code></a>, <a href=
"#element-accumulator"><code>xsl:accumulator</code></a>, <span>and
<a href=
"#element-global-context-item"><code>xsl:global-context-item</code></a></span>
elements specifying <code>streamable="yes"</code>) are said to be
<b>declared-streamable</b>.<span class="definition">]</span></p>
<p>In each case the construct in question is said to be
<b>guaranteed-streamable</b> if it satisfies two conditions:</p>
<ol class="enumar">
<li>
<p>The construct is <a title="declared-streamable" class="termref"
href="#dt-declared-streamable">declared-streamable</a>.</p>
</li>
<li>
<p>Streamability analysis following the rules defined in this
specification determines that streamed processing is possible (the
detailed conditions vary from one construct to another).</p>
</li>
</ol>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-guaranteed-streamable" id="dt-guaranteed-streamable" title=
"guaranteed-streamable"></a>A <b>guaranteed-streamable</b>
construct is a <a title="construct" class="termref" href=
"#dt-construct">construct</a> that is declared to be streamable and
that follows the particular rules for that construct to make
streaming possible, as defined by the analysis in this
specification.<span class="definition">]</span></p>
<p>For a streaming processor, that is, a processor that claims
conformance with the <a title="streaming feature" class="termref"
href="#dt-streaming-feature">streaming feature</a>:</p>
<ol class="enumar">
<li>
<p>If a construct is <a title="guaranteed-streamable" class=
"termref" href=
"#dt-guaranteed-streamable">guaranteed-streamable</a> then it
<span class="verb">must</span> be processed using streaming.</p>
</li>
<li>
<p>If a construct is declared as streamable but is not <a title=
"guaranteed-streamable" class="termref" href=
"#dt-guaranteed-streamable">guaranteed-streamable</a> (that is, if
it fails to satisfy the conditions for streamability defined in
this specification), then the processor <span class=
"verb">must</span> be prepared to do any one of the following at
user option:</p>
<ol class="enumla">
<li>
<p>Signal a static error <span class="error">[see <a href=
"#err-XTSE3430">ERR XTSE3430</a>]</span></p>
</li>
<li>
<p>Process the stylesheet as if it were a non-streaming processor
(see below)</p>
</li>
<li>
<p>Process the stylesheet with streaming if it is able to do so, or
signal a static error <span class="error">[see <a href=
"#err-XTSE3430">ERR XTSE3430</a>]</span> if it is not able to do
so.</p>
</li>
</ol>
</li>
</ol>
<p><a name="err-XTSE3430" id="err-XTSE3430"><span class=
"error">[ERR XTSE3430]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if a
<a title="package" class="termref" href="#dt-package">package</a>
contains a construct that is declared to be streamable but which is
not <a title="guaranteed-streamable" class="termref" href=
"#dt-guaranteed-streamable">guaranteed-streamable</a>, unless the
user has indicated that the processor is to handle this situation
by processing the stylesheet without streaming or by making use of
processor extensions to the streamability rules where
available.</p>
<p>For a non-streaming processor, the processor <span class=
"verb">must</span> evaluate the <span>construct</span> delivering
the same results as if execution used streaming, but with no
constraints on the evaluation strategy. (Processing <span class=
"verb">may</span>, of course, fail due to insufficient memory being
available, or for other reasons.)</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This specification does not attempt to legislate precisely what
constitutes evaluation "using streaming". The most important test
is that the amount of memory needed should be for practical
purposes independent of the size of the source document, and in
particular that the finite size of memory available should not
impose a limit on the size of source document that can be
processed.</p>
<p>The rules are designed to ensure that streaming processors can
analyze streamability using rules different from those in this
specification, provided that all constructs that are <a title=
"guaranteed-streamable" class="termref" href=
"#dt-guaranteed-streamable">guaranteed-streamable</a> according to
this specification are actually streamable by the implementation.
Furthermore, non-streaming processors are not required to analyze
streamability at all.</p>
</div>
</div>
</div>
<div class="div1">
<h2><a name="add-func" id="add-func"></a>20 <a href="#add-func"
style="text-decoration: none">Additional Functions</a></h2>
<p>This section describes XSLT-specific additions to the <a title=
"core function" class="termref" href="#dt-core-function">core
function</a> library. Some of these additional functions also make
use of information specified by <a title="declaration" class=
"termref" href="#dt-declaration">declarations</a> in the
stylesheet; this section also describes these declarations.</p>
<div class="div2">
<h3><a name="func-document" id="func-document"></a>20.1 <a href=
"#func-document" style="text-decoration: none">fn:document</a></h3>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Provides access to XML documents identified by a URI.</p>
</dd>
<dt class="label">Signatures</dt>
<dd>
<p><a name="function-document" id="function-document"></a></p>
<div class="proto"><code class=
"function">document</code>(<code class=
"arg">$uri-sequence</code><code class=
"as">&#160;as&#160;</code><code class=
"type">item()*</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">node()*</code></div>
<div class="proto">
<table border="0" cellpadding="0" cellspacing="0" summary=
"Function signature for :document function">
<tr>
<td valign="baseline" rowspan="2"><code class=
"function">document</code>(</td>
<td valign="baseline"><code class="arg">$uri-sequence</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class="type">item()*</code>,</td>
</tr>
<tr>
<td valign="baseline"><code class="arg">$base-node</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class=
"type">node()</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">node()*</code></td>
</tr>
</table>
</div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>The one-argument form of this function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>.
It depends on static base uri.</p>
<p>The two-argument form of this function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-independent">context-independent</a><sup><small>FO30</small></sup>.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>The <a href="#func-document"><code>document</code></a> function
allows access to XML documents identified by a URI.</p>
<p>The first argument contains a sequence of URI references. The
second argument, if present, is a node whose base URI is used to
resolve any relative URI references contained in the first
argument.</p>
<p>A sequence of absolute URI references is obtained as
follows.</p>
<ul>
<li>
<p>For an item in <code>$uri-sequence</code> that is an instance of
<code>xs:string</code>, <code>xs:anyURI</code>, or
<code>xs:untypedAtomic</code>, the value is cast to
<code>xs:anyURI</code>. If the resulting URI reference is an
absolute URI reference then it is used <em>as is</em>. If it is a
relative URI reference, then it is resolved against the base URI of
<code>$base-node</code> if supplied, or against the base URI from
the static context otherwise (this will usually be the base URI of
the stylesheet module). A relative URI <span>reference</span> is
resolved against a base URI using the rules defined in <a href=
"#RFC3986">[RFC3986]</a>.</p>
</li>
<li>
<p>For an item in <code>$uri-sequence</code> that is a node, the
node is <a title="atomize" class="termref" href=
"#dt-atomization">atomized</a>. The result <span class=
"verb">must</span> be a sequence whose items are all instances of
<code>xs:string</code>, <code>xs:anyURI</code>, or
<code>xs:untypedAtomic</code>. Each of these values is cast to
<code>xs:anyURI</code>, and if the resulting URI reference is an
absolute URI reference then it is used <em>as is</em>. If it is a
relative URI reference, then it is resolved against the base URI of
<code>$base-node</code> if supplied, or against the base URI of the
node that contained it otherwise.</p>
</li>
<li>
<p>If <code>$uri-sequence</code> (after atomizing any nodes)
contains an atomic value of a type other than
<code>xs:string</code>, <code>xs:anyURI</code>, or
<code>xs:untypedAtomic</code> then a type error is raised <a href=
"http://www.w3.org/TR/xpath-30/#ERRXPTY0004" title=
"XPTY0004"><span class="error">[ERR XPTY0004]</span></a>
<sup><small>XP30</small></sup>.</p>
</li>
</ul>
<p>Each of these absolute URI references is then processed as
follows. Any fragment identifier that is present in the URI
reference is removed, and the resulting absolute URI is cast to a
string and then passed to the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>
function defined in <a href="#xpath-functions-30">[Functions and
Operators]</a>. This returns a document node. If an error occurs
during evaluation of the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>
function, the processor <span class="verb">may</span> either signal
this error in the normal way, or <span class="verb">may</span>
recover by ignoring the failure, in which case the failing URI will
not contribute any nodes to the result of the <a href=
"#func-document"><code>document</code></a> function.</p>
<p>If the URI reference contained no fragment identifier, then this
document node is included in the sequence of nodes returned by the
<a href="#func-document"><code>document</code></a> function.</p>
<p>If the URI reference contained a fragment identifier, then the
fragment identifier is interpreted according to the rules for the
media type of the resource representation identified by the URI,
and is used to select zero or more nodes that are
descendant-or-self nodes of the returned document node. As
described in <a href="#initiating"><i>2.3 Initiating a
Transformation</i></a>, the media type is available as part of the
evaluation context for a transformation.</p>
<p>The sequence of nodes returned by the function is in document
order, with no duplicates. This order has no necessary relationship
to the order in which URIs were supplied in the
<code>$uri-sequence</code> argument.</p>
</dd>
<dt class="label">Error Conditions</dt>
<dd>
<p><a name="err-XTDE1160" id="err-XTDE1160"><span class=
"error">[ERR XTDE1160]</span></a> When a URI reference contains a
fragment identifier, it is a <a title="dynamic error" class=
"termref" href="#dt-dynamic-error">dynamic error</a> if the media
type is not one that is recognized by the processor, or if the
fragment identifier does not conform to the rules for fragment
identifiers for that media type, or if the fragment identifier
selects something other than a sequence of nodes (for example, if
it selects a range of characters within a text node).</p>
<p>A processor <span class="verb">may</span> provide an option
which, if selected, causes the processor instead of signaling this
error, to ignore the fragment identifier and return the document
node.</p>
<p>The set of media types recognized by a processor is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
<p><a name="err-XTDE1162" id="err-XTDE1162"><span class=
"error">[ERR XTDE1162]</span></a> When a URI reference is a
relative reference, it is a <a title="dynamic error" class=
"termref" href="#dt-dynamic-error">dynamic error</a> if no base URI
is available to resolve the relative reference. This can arise for
example when the URI is contained in a node that has no base URI
(for example a parentless text node), or when the second argument
to the function is a node that has no base URI, or when the base
URI from the static context is undefined.</p>
</dd>
<dt class="label">Notes</dt>
<dd>
<p>One effect of these rules is that unless XML entities or
<code>xml:base</code> are used, and provided that the base URI of
the stylesheet module is known, <code>document("")</code> refers to
the document node of the containing stylesheet module (the
definitive rules are in <a href="#RFC3986">[RFC3986]</a>). The XML
resource containing the stylesheet module is processed exactly as
if it were any other XML document, for example there is no special
recognition of <a href="#element-text"><code>xsl:text</code></a>
elements, and no special treatment of comments and processing
instructions.</p>
<p>The XPath rules for function calling ensure that it is a type
error if the supplied value of the second argument is anything
other than a single node. If <a title=
"XPath 1.0 compatibility mode" class="termref" href=
"#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is
enabled, then a sequence of nodes may be supplied, and the first
node in the sequence will be used.</p>
</dd>
</dl>
</div>
<div class="div2">
<h3><a name="key" id="key"></a>20.2 <a href="#key" style=
"text-decoration: none">Keys</a></h3>
<p>Keys provide a way to work with documents that contain an
implicit cross-reference structure. They make it easier to locate
the nodes within a document that have a given value for a given
attribute or child element, and they provide a hint to the
implementation that certain access paths in the document need to be
efficient.</p>
<div class="div3">
<h4><a name="xsl-key" id="xsl-key"></a>20.2.1 <a href="#xsl-key"
style="text-decoration: none">The</a> <a href=
"#element-key"><code>xsl:key</code></a> <a href="#xsl-key" style=
"text-decoration: none">Declaration</a></h4>
<p class="element-syntax"><a name="element-key" id=
"element-key"></a><code>&lt;!-- Category: declaration --&gt;<br />
&lt;xsl:key<br />
&#160;&#160;<b>name</b> = <var>eqname</var><br />
&#160;&#160;<b>match</b> = <var>pattern</var><br />
&#160;&#160;use? = <var>expression</var><br />
&#160;&#160;composite? = <var>boolean</var><br />
&#160;&#160;collation? = <var>uri</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:key&gt;</code></p>
<p>The <a href="#element-key"><code>xsl:key</code></a> <a title=
"declaration" class="termref" href=
"#dt-declaration">declaration</a> is used to declare <a title="key"
class="termref" href="#dt-key">keys</a>. The <code>name</code>
attribute specifies the name of the key. The value of the
<code>name</code> attribute is an <span><a title="EQName" class=
"termref" href="#dt-eqname">EQName</a></span>, which is expanded as
described in <a href="#qname"><i>5.1 Qualified Names</i></a>. The
<code>match</code> attribute is a <a href=
"#doc-xslt30-patterns-Pattern30">Pattern</a>; an <a href=
"#element-key"><code>xsl:key</code></a> element applies to all
nodes that match the pattern specified in the <code>match</code>
attribute.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-key" id="dt-key" title="key"></a>A <b>key</b> is defined as a
set of <a href="#element-key"><code>xsl:key</code></a> declarations
in the <span>same <a title="package" class="termref" href=
"#dt-package">package</a></span> that share the same
name.<span class="definition">]</span></p>
<p>The key name is scoped to the containing <a title="package"
class="termref" href="#dt-package">package</a>, and is available
for use in calls to the <a href="#func-key"><code>key</code></a>
function within that package.</p>
<p>The value of the key may be specified either using the
<code>use</code> attribute or by means of the contained <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>.</p>
<p><a name="err-XTSE1205" id="err-XTSE1205"><span class=
"error">[ERR XTSE1205]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if an
<a href="#element-key"><code>xsl:key</code></a> declaration has a
<code>use</code> attribute and has non-empty content, or if it has
empty content and no <code>use</code> attribute.</p>
<p>If the <code>use</code> attribute is present, its value is an
<a title="expression" class="termref" href=
"#dt-expression">expression</a> specifying the values of the key.
The expression will be evaluated with <span>a <a title=
"singleton focus" class="termref" href=
"#dt-singleton-focus">singleton focus</a> based on the node that
matches the pattern</span>. The result of evaluating the expression
is <a title="atomize" class="termref" href=
"#dt-atomization">atomized</a>.</p>
<p>Similarly, if a <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> is
present, it is used to determine the values of the key. The
sequence constructor will be evaluated with the node that matches
the pattern as the context node. The result of evaluating the
sequence constructor is <a title="atomize" class="termref" href=
"#dt-atomization">atomized</a>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-key-specifier" id="dt-key-specifier" title=
"key specifier"></a>The expression in the <code>use</code>
attribute and the <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> within an
<a href="#element-key"><code>xsl:key</code></a> declaration are
referred to collectively as the <b>key specifier</b>. The key
specifier determines the values that may be used to find a node
using this <a title="key" class="termref" href=
"#dt-key">key</a>.<span class="definition">]</span></p>
<p>When evaluation of the <a title="key specifier" class="termref"
href="#dt-key-specifier">key specifier</a> results in a sequence
(after atomization) containing more than one atomic value, the
effect depends on the value of the <code>composite</code>
attribute:</p>
<ul>
<li>
<p>When the attribute is absent or has the value <code>no</code>,
each atomic value in the sequence acts as an individual key. For
example, if <code>match="book" use="author" composite="no"</code>
is specified, then a <code>book</code> element may be located using
the value of any <code>author</code> element.</p>
</li>
<li>
<p>When the attribute is present and has the value
<code>yes</code>, the sequence of atomic values is treated as a
composite key that must be matched in its entirety. For example, if
<code>match="book" use="author" composite="yes"</code> is
specified, then a <code>book</code> element may be located using
the value of all its <code>author</code> elements, supplied in the
correct order.</p>
</li>
</ul>
<p>If there are several <a href=
"#element-key"><code>xsl:key</code></a> declarations in the
<span>same package</span> with the same key name, then they must
all have the same effective value for their <code>composite</code>
attribute. The effective value is the actual value of the attribute
if present, or "no" if the attribute is absent.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>There is no requirement that all the values of a key should have
the same type.</p>
</div>
<p>The presence of an <a href=
"#element-key"><code>xsl:key</code></a> declaration makes it easy
to find a node that matches the <code>match</code> pattern if the
values of the <a title="key specifier" class="termref" href=
"#dt-key-specifier">key specifier</a> (when applied to that node)
are known. It also provides a hint to the implementation that
access to the nodes by means of these values needs to be efficient
(many implementations are likely to construct an index or hash
table to achieve this).</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>An <a href="#element-key"><code>xsl:key</code></a> declaration
is not bound to a specific source document. The source document to
which it applies is determined only when the <a href=
"#func-key"><code>key</code></a> function is used to locate nodes
using the key. Keys can be used to locate nodes within any source
document (including temporary trees), but each use of the <a href=
"#func-key"><code>key</code></a> function searches one document
only.</p>
</div>
<p>The optional <code>collation</code> attribute is used only when
deciding whether two strings are equal for the purposes of key
matching. Specifically, two key values <code>$a</code> and
<code>$b</code> are considered equal if the result of the function
call <span><code>deep-equal($a, $b, $collation)</code> is
true</span>. The effective collation for an <a href=
"#element-key"><code>xsl:key</code></a> declaration is the
collation specified in its <code>collation</code> attribute if
present, resolved against the base URI of the <a href=
"#element-key"><code>xsl:key</code></a> element, or the <a title=
"default collation" class="termref" href=
"#dt-default-collation">default collation</a> that is in scope for
the <a href="#element-key"><code>xsl:key</code></a> declaration
otherwise; the effective collation must be the same for all the
<a href="#element-key"><code>xsl:key</code></a> declarations making
up a <a title="key" class="termref" href="#dt-key">key</a>.</p>
<p><a name="err-XTSE1210" id="err-XTSE1210"><span class=
"error">[ERR XTSE1210]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
<a href="#element-key"><code>xsl:key</code></a> declaration has a
<code>collation</code> attribute whose value (after resolving
against the base URI) is not a URI recognized by the implementation
as referring to a collation.</p>
<p><a name="err-XTSE1220" id="err-XTSE1220"><span class=
"error">[ERR XTSE1220]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if there
are several <a href="#element-key"><code>xsl:key</code></a>
declarations in the <span>same <a title="package" class="termref"
href="#dt-package">package</a></span> with the same key name and
different effective collations. Two collations are the same if
their URIs are equal under the rules for comparing
<code>xs:anyURI</code> values, or if the implementation can
determine that they are different URIs referring to the same
collation.</p>
<p><a name="err-XTSE1222" id="err-XTSE1222"><span class=
"error">[ERR XTSE1222]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if there
are several <a href="#element-key"><code>xsl:key</code></a>
declarations in a <a title="package" class="termref" href=
"#dt-package">package</a> with the same key name and different
effective values for the <code>composite</code> attribute.</p>
<p>It is possible to have:</p>
<ul>
<li>
<p>multiple <a href="#element-key"><code>xsl:key</code></a>
declarations with the same name;</p>
</li>
<li>
<p>a node that matches the <code>match</code> patterns of several
different <a href="#element-key"><code>xsl:key</code></a>
declarations, whether these have the same key name or different key
names;</p>
</li>
<li>
<p>a node that returns more than one value from its <a title=
"key specifier" class="termref" href="#dt-key-specifier">key
specifier</a> <span>(which can be treated either as separate
individual key values, or as a single composite key
value)</span>;</p>
</li>
<li>
<p>a key value that identifies more than one node (the key values
for different nodes do not need to be unique).</p>
</li>
</ul>
<p>An <a href="#element-key"><code>xsl:key</code></a> declaration
with higher <a title="import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a> does not override
another of lower import precedence; all the <a href=
"#element-key"><code>xsl:key</code></a> declarations in the
stylesheet are effective regardless of their import precedence.</p>
</div>
<div class="div3">
<h4><a name="func-key" id="func-key"></a>20.2.2 <a href="#func-key"
style="text-decoration: none">fn:key</a></h4>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Returns the nodes that match a supplied key value.</p>
</dd>
<dt class="label">Signatures</dt>
<dd>
<p><a name="function-key" id="function-key"></a></p>
<div class="proto">
<table border="0" cellpadding="0" cellspacing="0" summary=
"Function signature for :key function">
<tr>
<td valign="baseline" rowspan="2"><code class=
"function">key</code>(</td>
<td valign="baseline"><code class="arg">$key-name</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class="type">xs:string</code>,</td>
</tr>
<tr>
<td valign="baseline"><code class="arg">$key-value</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class=
"type">xs:anyAtomicType*</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">node()*</code></td>
</tr>
</table>
</div>
<div class="proto">
<table border="0" cellpadding="0" cellspacing="0" summary=
"Function signature for :key function">
<tr>
<td valign="baseline" rowspan="3"><code class=
"function">key</code>(</td>
<td valign="baseline"><code class="arg">$key-name</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class="type">xs:string</code>,</td>
</tr>
<tr>
<td valign="baseline"><code class="arg">$key-value</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class=
"type">xs:anyAtomicType*</code>,</td>
</tr>
<tr>
<td valign="baseline"><code class="arg">$top</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class=
"type">node()</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">node()*</code></td>
</tr>
</table>
</div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>The two-argument form of this function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-dependent">focus-dependent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>.</p>
<p>The three-argument form of this function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>The <a href="#func-key"><code>key</code></a> function does for
keys what the <span><a href=
"http://www.w3.org/TR/xpath-functions-30/#func-element-with-id"><code>
element-with-id</code></a><sup><small>FO30</small></sup></span>
function does for IDs.</p>
<p>The <code>$key-name</code> argument specifies the name of the
<a title="key" class="termref" href="#dt-key">key</a>. The value of
the argument <span class="verb">must</span> be a <span>string
containing an <a title="EQName" class="termref" href=
"#dt-eqname">EQName</a>.</span> If it is a <a title="lexical QName"
class="termref" href="#dt-lexical-qname">lexical QName</a>, then it
is expanded as described in <a href="#qname"><i>5.1 Qualified
Names</i></a> (no prefix means no namespace).</p>
<p>The <code>$key-value</code> argument to the <a href=
"#func-key"><code>key</code></a> function is considered as a
sequence. <span>The effect depends on the value of the
<code>composite</code> attribute of the corresponding
<code>xsl:key</code> declaration.</span></p>
<ul>
<li>
<p><span>If <code>composite</code> is <code>no</code> or
absent,</span> the set of requested key values is formed by
atomizing the supplied value of the argument, using the standard
<a title="function conversion rules" class="termref" href=
"#dt-function-conversion-rules">function conversion rules</a>. Each
of the resulting atomic values is considered as a requested key
value. The result of the function is a sequence of nodes, in
document order and with duplicates removed, comprising those nodes
in the selected subtree (see below) that are matched by an <a href=
"#element-key"><code>xsl:key</code></a> declaration whose name is
the same as the supplied key name, where the result of evaluating
the <a title="key specifier" class="termref" href=
"#dt-key-specifier">key specifier</a> contains a value that is
equal to one of these requested key values, under the rules
appropriate to the XPath <code>eq</code> operator for the two
values in question, using the <code>collation</code> attributes of
the <a href="#element-key"><code>xsl:key</code></a> declaration
when comparing strings. No error is reported if two values are
encountered that are not comparable; they are regarded for the
purposes of this function as being not equal.</p>
<p>If the second argument is an empty sequence, the result of the
function will be an empty sequence.</p>
</li>
<li>
<p>If <code>composite</code> is <code>yes</code>, the requested key
value is the sequence formed by atomizing the supplied value of the
argument, using the standard <a title="function conversion rules"
class="termref" href="#dt-function-conversion-rules">function
conversion rules</a>. The result of the function is a sequence of
nodes, in document order and with duplicates removed, comprising
those nodes in the selected subtree (see below) that are matched by
an <a href="#element-key"><code>xsl:key</code></a> declaration
whose name is the same as the supplied key name, where the result
of evaluating the <a title="key specifier" class="termref" href=
"#dt-key-specifier">key specifier</a> is deep-equal to the
requested key value, under the rules appropriate to the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-deep-equal"><code>deep-equal</code></a><sup><small>FO30</small></sup>
function applied to the two values in question, using the
<code>collation</code> attributes of the <a href=
"#element-key"><code>xsl:key</code></a> declaration when comparing
strings. Note that the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-deep-equal"><code>deep-equal</code></a><sup><small>FO30</small></sup>
function reports no error if two values are encountered that are
not comparable; they are regarded for the purposes of this function
as being not equal.</p>
<p>If the second argument is an empty sequence, the result of the
function will be the set of nodes having an empty sequence as the
value of the key specifier.</p>
</li>
</ul>
<p>Different rules apply when <span><a title="XSLT 1.0 behavior"
class="termref" href="#dt-xslt-10-behavior">XSLT 1.0 compatible
behavior</a> is enabled.</span></p>
<p>A key (that is, a set of <a href=
"#element-key"><code>xsl:key</code></a> declarations sharing the
same key name) is processed in backwards compatible mode if (a) at
least one of the xsl:key elements in the definition of the key
enables backwards compatible behavior, and (b) the effective value
of the <code>composite</code> attribute is <code>no</code>.</p>
<p>When a key is processed in backwards compatible mode, then:</p>
<div style="margin-left: 2em">
<p>The result of evaluating the key specifier in any <a href=
"#element-key"><code>xsl:key</code></a> declaration having this key
name is converted after atomization to a sequence of strings, by
applying a cast to each item in the sequence.</p>
<p>When the first argument to the <a href=
"#func-key"><code>key</code></a> function specifies this key name,
then the value of the second argument is converted after
atomization to a sequence of strings, by applying a cast to each
item in the sequence. The values are then compared as strings.</p>
</div>
<p>The third argument is used to identify the selected subtree. If
the argument is present, the selected subtree is the set of nodes
that have <var>$top</var> as an ancestor-or-self node. If the
argument is omitted, the selected subtree is the document
containing the context node. This means that the third argument
effectively defaults to <code>/</code>.</p>
<p>The result of the <a href="#func-key"><code>key</code></a>
function can be described more specifically as follows. The result
is a sequence containing every node <var>$N</var> that satisfies
the following conditions:</p>
<ul>
<li>
<p><code>$N/ancestor-or-self::node() intersect $top</code> is
non-empty. (If the third argument is omitted, <code>$top</code>
defaults to <code>/</code>)</p>
</li>
<li>
<p><var>$N</var> matches the pattern specified in the
<code>match</code> attribute of an <a href=
"#element-key"><code>xsl:key</code></a> declaration whose
<code>name</code> attribute matches the name specified in the
<code>$key-name</code> argument.</p>
</li>
<li>
<p><span>When <code>composite="no"</code>,</span> and the <a title=
"key specifier" class="termref" href="#dt-key-specifier">key
specifier</a> of that <a href=
"#element-key"><code>xsl:key</code></a> declaration is evaluated
with a <a title="singleton focus" class="termref" href=
"#dt-singleton-focus">singleton focus</a> based on <var>$N</var>,
the <a title="atomize" class="termref" href=
"#dt-atomization">atomized</a> value of the resulting sequence
includes a value that compares equal to at least one item in the
atomized value of the sequence supplied as <code>$key-value</code>,
under the rules of the <code>eq</code> operator with the collation
selected as described above.</p>
<p><span>When <code>composite="yes"</code>,</span> and the
<a title="key specifier" class="termref" href=
"#dt-key-specifier">key specifier</a> of that <a href=
"#element-key"><code>xsl:key</code></a> declaration is evaluated
with a <a title="singleton focus" class="termref" href=
"#dt-singleton-focus">singleton focus</a> based on <var>$N</var>,
the <a title="atomize" class="termref" href=
"#dt-atomization">atomized</a> value of the resulting sequence
compares equal to the atomized value of the sequence supplied as
<code>$key-value</code>, under the rules of the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-deep-equal"><code>deep-equal</code></a><sup><small>FO30</small></sup>
function with the collation selected as described above.</p>
</li>
</ul>
<p>The sequence returned by the <a href=
"#func-key"><code>key</code></a> function will be in document
order, with duplicates (that is, nodes having the same identity)
removed.</p>
</dd>
<dt class="label">Error Conditions</dt>
<dd>
<p><a name="err-XTDE1260" id="err-XTDE1260"><span class=
"error">[ERR XTDE1260]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
value is not a valid QName, or if there is no namespace declaration
in scope for the prefix of the QName, or if the name obtained by
expanding the QName is not the same as the expanded name of any
<a href="#element-key"><code>xsl:key</code></a> declaration in the
<span>containing <a title="package" class="termref" href=
"#dt-package">package</a></span>. If the processor is able to
detect the error statically (for example, when the argument is
supplied as a string literal), then the processor <span class=
"verb">may</span> optionally signal this as a <a title=
"static error" class="termref" href="#dt-static-error">static
error</a>.</p>
<p><a name="err-XTDE1270" id="err-XTDE1270"><span class=
"error">[ERR XTDE1270]</span></a> It is a <span><a title=
"dynamic error" class="termref" href="#dt-dynamic-error">dynamic
error</a></span> to call the <a href=
"#func-key"><code>key</code></a> function with two arguments if
there is no <a title="context node" class="termref" href=
"#dt-context-node">context node</a>, or if the root of the tree
containing the context node is not a document node; or to call the
function with three arguments if the root of the tree containing
the node supplied in the third argument is not a document node.</p>
</dd>
<dt class="label">Notes</dt>
<dd>
<p>Untyped atomic values are converted to strings, not to the type
of the other operand. This means, for example, that if the
expression in the <code>use</code> attribute returns a date,
supplying an untyped atomic value in the call to the <a href=
"#func-key"><code>key</code></a> function will return an empty
sequence.</p>
</dd>
<dt class="label">Examples</dt>
<dd>
<div class="example">
<div class="exampleHeader"><a name="d7e58050" id=
"d7e58050"></a>Example: Using a Key to Follow
Cross-References</div>
<p>Given a declaration</p>
<div class="exampleInner">
<pre>
&lt;xsl:key name="idkey" match="div" use="@id"/&gt;
</pre></div>
<p>an expression <code>key("idkey",@ref)</code> will return the
same nodes as <code>id(@ref)</code>, assuming that the only ID
attribute declared in the XML source document is:</p>
<div class="exampleInner">
<pre>
&lt;!ATTLIST div id ID #IMPLIED&gt;
</pre></div>
<p>and that the <code>ref</code> attribute of the context node
contains no whitespace.</p>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e58072" id=
"d7e58072"></a>Example: Using a Key to Generate Hyperlinks</div>
<p>Suppose a document describing a function library uses a
<code>prototype</code> element to define functions</p>
<div class="exampleInner">
<pre>
&lt;prototype name="sqrt" return-type="xs:double"&gt;
  &lt;arg type="xs:double"/&gt;
&lt;/prototype&gt;
</pre></div>
<p>and a <code>function</code> element to refer to function
names</p>
<div class="exampleInner">
<pre>
&lt;function&gt;sqrt&lt;/function&gt;
</pre></div>
<p>Then the stylesheet could generate hyperlinks between the
references and definitions as follows:</p>
<div class="exampleInner">
<pre>
&lt;xsl:key name="func" match="prototype" use="@name"/&gt;

&lt;xsl:template match="function"&gt;
&lt;b&gt;
  &lt;a href="#{generate-id(key('func',.))}"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/a&gt;
&lt;/b&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="prototype"&gt;
  &lt;p&gt;
    &lt;a name="{generate-id()}"&gt;
      &lt;b&gt;Function: &lt;/b&gt;
      ...
    &lt;/a&gt;
  &lt;/p&gt;
  &lt;/xsl:template&gt;
</pre></div>
</div>
<p>When called with two arguments, the <a href=
"#func-key"><code>key</code></a> function always returns nodes that
are in the same document as the context node. To retrieve a node
from any other document, it is necessary either to change the
context node, or to supply a third argument.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e58098" id=
"d7e58098"></a>Example: Using Keys to Reference other
Documents</div>
<p>For example, suppose a document contains bibliographic
references in the form
<code>&lt;bibref&gt;XSLT&lt;/bibref&gt;</code>, and there is a
separate XML document <code>bib.xml</code> containing a
bibliographic database with entries in the form:</p>
<div class="exampleInner">
<pre>
&lt;entry name="XSLT"&gt;...&lt;/entry&gt;
</pre></div>
<p>Then the stylesheet could use the following to transform the
<code>bibref</code> elements:</p>
<div class="exampleInner">
<pre>
&lt;xsl:key name="bib" match="entry" use="@name"/&gt;

&lt;xsl:template match="bibref"&gt;
  &lt;xsl:variable name="name" select="."/&gt;
  &lt;xsl:apply-templates select="document('bib.xml')/key('bib',$name)"/&gt;
&lt;/xsl:template&gt;
</pre></div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This relies on the ability in XPath 2.0 to have a function call
on the right-hand side of the <code>/</code> operator in a path
expression.</p>
</div>
<p>The following code would also work:</p>
<div class="exampleInner">
<pre>
&lt;xsl:key name="bib" match="entry" use="@name"/&gt;

&lt;xsl:template match="bibref"&gt;
  &lt;xsl:apply-templates select="key('bib', ., document('bib.xml'))"/&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e58128" id=
"d7e58128"></a>Example: Using a Composite Key</div>
<p>This example uses a composite key consisting of first name and
last name to locate employees in an employee file.</p>
<p>The key can be defined like this:</p>
<div class="exampleInner">
<pre>
&lt;xsl:key name="emp-name-key" 
         match="employee" 
         use="name/first, name/last" 
         composite="yes"/&gt;                     
         
</pre></div>
<p>A particular employee can then be located using the function
call:</p>
<div class="exampleInner">
<pre>
key('emp-name-key', ('Tim', 'Berners-Lee'), doc('employees.xml'))
</pre></div>
</div>
</dd>
</dl>
</div>
</div>
<div class="div2">
<h3><a name="misc-func" id="misc-func"></a>20.3 <a href=
"#misc-func" style="text-decoration: none">Miscellaneous Additional
Functions</a></h3>
<div class="div3">
<h4><a name="func-current" id="func-current"></a>20.3.1 <a href=
"#func-current" style="text-decoration: none">fn:current</a></h4>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Returns the item that is the context item for the evaluation of
the containing XPath expression</p>
</dd>
<dt class="label">Signature</dt>
<dd>
<p><a name="function-current" id="function-current"></a></p>
<div class="proto"><code class=
"function">current</code>()<code class=
"as">&#160;as&#160;</code><code class=
"return-type">item()</code></div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-dependent">focus-dependent</a><sup><small>FO30</small></sup>.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>The <a href="#func-current"><code>current</code></a> function,
used within an XPath <a title="expression" class="termref" href=
"#dt-expression">expression</a>, returns the item that was the
<a title="context item" class="termref" href=
"#dt-context-item">context item</a> at the point where the
expression was invoked from the XSLT <a title="stylesheet" class=
"termref" href="#dt-stylesheet">stylesheet</a>. This is referred to
as the current item. For an outermost expression (an expression not
occurring within another expression), the current item is always
the same as the context item. Thus,</p>
<div class="exampleInner">
<pre>
&lt;xsl:value-of select="current()"/&gt;
</pre></div>
<p>means the same as</p>
<div class="exampleInner">
<pre>
&lt;xsl:value-of select="."/&gt;
</pre></div>
<p>However, within square brackets, or on the right-hand side of
the <code>/</code> operator, the current item is generally
different from the context item.</p>
<p>If the <a href="#func-current"><code>current</code></a> function
is used within a <a title="pattern" class="termref" href=
"#dt-pattern">pattern</a>, its value is the <span>item</span> that
is being matched against the pattern.</p>
</dd>
<dt class="label">Error Conditions</dt>
<dd>
<p><a name="err-XTDE1360" id="err-XTDE1360"><span class=
"error">[ERR XTDE1360]</span></a> If the <a href=
"#func-current"><code>current</code></a> function is evaluated
within an expression that is evaluated when the context item is
absent, a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> occurs.</p>
<p>When the <a href="#func-current"><code>current</code></a> is
called by means of a dynamic function call (for example,
<code>current#0()</code>), it is evaluated as if the context item
is absent (<span class="error">[see <a href="#err-XTDE1360">ERR
XTDE1360</a>]</span>).</p>
</dd>
<dt class="label">Examples</dt>
<dd>
<p>The instruction:</p>
<div class="exampleInner">
<pre>
&lt;xsl:apply-templates select="//glossary/entry[@name=current()/@ref]"/&gt;
</pre></div>
<p>will process all <code>entry</code> elements that have a
<code>glossary</code> parent element and that have a
<code>name</code> attribute with value equal to the value of the
current item's <code>ref</code> attribute. This is different
from</p>
<div class="exampleInner">
<pre>
&lt;xsl:apply-templates select="//glossary/entry[@name=./@ref]"/&gt;
</pre></div>
<p>which means the same as</p>
<div class="exampleInner">
<pre>
&lt;xsl:apply-templates select="//glossary/entry[@name=@ref]"/&gt;
</pre></div>
<p>and so would process all <code>entry</code> elements that have a
<code>glossary</code> parent element and that have a
<code>name</code> attribute and a <code>ref</code> attribute with
the same value.</p>
</dd>
</dl>
</div>
<div class="div3">
<h4><a name="func-unparsed-entity-uri" id=
"func-unparsed-entity-uri"></a>20.3.2 <a href=
"#func-unparsed-entity-uri" style=
"text-decoration: none">fn:unparsed-entity-uri</a></h4>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Returns the URI (system identifier) of an unparsed entity</p>
</dd>
<dt class="label">Signature</dt>
<dd>
<p><a name="function-unparsed-entity-uri" id=
"function-unparsed-entity-uri"></a></p>
<div class="proto"><code class=
"function">unparsed-entity-uri</code>(<code class=
"arg">$entity-name</code><code class=
"as">&#160;as&#160;</code><code class=
"type">xs:string</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">xs:anyURI</code></div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-dependent">focus-dependent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>The <a href=
"#func-unparsed-entity-uri"><code>unparsed-entity-uri</code></a>
function returns the URI of the unparsed entity whose name is given
by the value of the <code>$entity-name</code> argument, in the
document containing the <a title="context node" class="termref"
href="#dt-context-node">context node</a>. It returns the
zero-length <code>xs:anyURI</code> if there is no such entity. This
function maps to the <code>dm:unparsed-entity-system-id</code>
accessor defined in <a href="#xpath-datamodel-30">[Data
Model]</a>.</p>
</dd>
<dt class="label">Error Conditions</dt>
<dd>
<p><a name="err-XTDE1370" id="err-XTDE1370"><span class=
"error">[ERR XTDE1370]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<a href=
"#func-unparsed-entity-uri"><code>unparsed-entity-uri</code></a>
function is called when there is no <a title="context node" class=
"termref" href="#dt-context-node">context node</a>, or when the
root of the tree containing the context node is not a document
node.</p>
</dd>
</dl>
</div>
<div class="div3">
<h4><a name="func-unparsed-entity-public-id" id=
"func-unparsed-entity-public-id"></a>20.3.3 <a href=
"#func-unparsed-entity-public-id" style=
"text-decoration: none">fn:unparsed-entity-public-id</a></h4>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Returns the public identifier of an unparsed entity</p>
</dd>
<dt class="label">Signature</dt>
<dd>
<p><a name="function-unparsed-entity-public-id" id=
"function-unparsed-entity-public-id"></a></p>
<div class="proto"><code class=
"function">unparsed-entity-public-id</code>(<code class=
"arg">$entity-name</code><code class=
"as">&#160;as&#160;</code><code class=
"type">xs:string</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">xs:anyURI</code></div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-dependent">focus-dependent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>The <a href=
"#func-unparsed-entity-public-id"><code>unparsed-entity-public-id</code></a>
function returns the public identifier of the unparsed entity whose
name is given by the value of the <code>$entity-name</code>
argument, in the document containing the <a title="context node"
class="termref" href="#dt-context-node">context node</a>. It
returns the zero-length string if there is no such entity, or if
the entity has no public identifier. This function maps to the
<code>dm:unparsed-entity-public-id</code> accessor defined in
<a href="#xpath-datamodel-30">[Data Model]</a>.</p>
</dd>
<dt class="label">Error Conditions</dt>
<dd>
<p><a name="err-XTDE1380" id="err-XTDE1380"><span class=
"error">[ERR XTDE1380]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<a href=
"#func-unparsed-entity-public-id"><code>unparsed-entity-public-id</code></a>
function is called when there is no <a title="context node" class=
"termref" href="#dt-context-node">context node</a>, or when the
root of the tree containing the context node is not a document
node.</p>
</dd>
</dl>
</div>
<div class="div3">
<h4><a name="func-system-property" id=
"func-system-property"></a>20.3.4 <a href="#func-system-property"
style="text-decoration: none">fn:system-property</a></h4>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Returns the value of a system property</p>
</dd>
<dt class="label">Signature</dt>
<dd>
<p><a name="function-system-property" id=
"function-system-property"></a></p>
<div class="proto"><code class=
"function">system-property</code>(<code class=
"arg">$property-name</code><code class=
"as">&#160;as&#160;</code><code class=
"type">xs:string</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">xs:string</code></div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>.
It depends on namespaces.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>The <code>$property-name</code> argument <span class=
"verb">must</span> evaluate to a <a title="lexical QName" class=
"termref" href="#dt-lexical-qname">lexical QName</a>. The <a title=
"lexical QName" class="termref" href="#dt-lexical-qname">lexical
QName</a> is expanded as described in <a href="#qname"><i>5.1
Qualified Names</i></a>.</p>
<p>The <a href=
"#func-system-property"><code>system-property</code></a> function
returns a string representing the value of the system property
identified by the name. If there is no such system property, the
zero-length string is returned.</p>
<p>Implementations <span class="verb">must</span> provide the
following system properties, which are all in the <a title=
"XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT
namespace</a>:</p>
<ul>
<li>
<p><code>xsl:version</code>, a number giving the version of XSLT
implemented by the <a title="processor" class="termref" href=
"#dt-processor">processor</a>; for implementations conforming to
the version of XSLT specified by this document, this is the string
<span><code>"3.0"</code></span>. The value will always be a string
in the lexical space of the decimal datatype defined in XML Schema
(see <a href="#xmlschema-2">[XML Schema Part 2]</a>). This allows
the value to be converted to a number for the purpose of magnitude
comparisons.</p>
</li>
<li>
<p><code>xsl:vendor</code>, a string identifying the implementer of
the <a title="processor" class="termref" href=
"#dt-processor">processor</a></p>
</li>
<li>
<p><code>xsl:vendor-url</code>, a string containing a URL
identifying the implementer of the <a title="processor" class=
"termref" href="#dt-processor">processor</a>; typically this is the
host page (home page) of the implementer's Web site.</p>
</li>
<li>
<p><code>xsl:product-name</code>, a string containing the name of
the implementation, as defined by the implementer. This
<span class="verb">should</span> normally remain constant from one
release of the product to the next. It <span class=
"verb">should</span> also be constant across platforms in cases
where the same source code is used to produce compatible products
for multiple execution platforms.</p>
</li>
<li>
<p><code>xsl:product-version</code>, a string identifying the
version of the implementation, as defined by the implementer. This
<span class="verb">should</span> normally vary from one release of
the product to the next, and at the discretion of the implementer
it <span class="verb">may</span> also vary across different
execution platforms.</p>
</li>
<li>
<p><code>xsl:is-schema-aware</code>, returns the string
<code>"yes"</code> in the case of a processor that claims
conformance as a <a title="schema-aware XSLT processor" class=
"termref" href="#dt-schema-aware-xslt-processor">schema-aware XSLT
processor</a>, or <code>"no"</code> in the case of a <a title=
"basic XSLT processor" class="termref" href=
"#dt-basic-xslt-processor">basic XSLT processor</a>.</p>
</li>
<li>
<p><code>xsl:supports-serialization</code>, returns the string
<code>"yes"</code> in the case of a processor that offers the
<a title="serialization feature" class="termref" href=
"#dt-serialization-feature">serialization feature</a>, or
<code>"no"</code> otherwise.</p>
</li>
<li>
<p><code>xsl:supports-backwards-compatibility</code>, returns the
string <code>"yes"</code> in the case of a processor that offers
the <span><a title="XSLT 1.0 compatibility feature" class="termref"
href="#dt-1.0-compatibility-feature">XSLT 1.0 compatibility
feature</a></span>, or <code>"no"</code> otherwise.</p>
</li>
<li>
<p><code>xsl:supports-namespace-axis</code>, returns the string
<code>"yes"</code> in the case of a processor that offers the XPath
namespace axis even when not in backwards compatible mode, or
<code>"no"</code> otherwise. Note that a processor that supports
backwards compatible mode must support the namespace axis when in
that mode, so this property is not relevant to that case.</p>
</li>
<li>
<p><code>xsl:supports-streaming</code>, returns the string
<code>"yes"</code> in the case of a processor that offers the
streaming feature (see <a href="#streaming-feature"><i>26.5
Streaming Feature</i></a>), or <code>"no"</code> otherwise.</p>
</li>
<li>
<p><code>xsl:supports-dynamic-evaluation</code>, returns the string
<code>"yes"</code> in the case of a processor that offers the
dynamic evaluation feature (see <a href=
"#dynamic-evaluation-feature"><i>26.6 Dynamic Evaluation
Feature</i></a>), or <code>"no"</code> otherwise.</p>
</li>
</ul>
<p>Some of these properties relate to the conformance levels and
features offered by the <a title="processor" class="termref" href=
"#dt-processor">processor</a>: these options are described in
<a href="#conformance"><i>26 Conformance</i></a>.</p>
<p>The actual values returned for the above properties are
<a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
<p>The set of system properties that are supported, in addition to
those listed above, is also <a title="implementation-defined"
class="termref" href=
"#dt-implementation-defined">implementation-defined</a>.
Implementations <span class="verb">must not</span> define
additional system properties in the XSLT namespace.</p>
</dd>
<dt class="label">Error Conditions</dt>
<dd>
<p><a name="err-XTDE1390" id="err-XTDE1390"><span class=
"error">[ERR XTDE1390]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
value supplied as the <code>$property-name</code> argument is not a
valid QName, or if there is no namespace declaration in scope for
the prefix of the QName. If the processor is able to detect the
error statically (for example, when the argument is supplied as a
string literal), then the processor <span class="verb">may</span>
optionally signal this as a <a title="static error" class="termref"
href="#dt-static-error">static error</a>.</p>
</dd>
<dt class="label">Notes</dt>
<dd>
<p>An implementation must not return the value
<code><span>3.0</span></code> as the value of the
<code>xsl:version</code> system property unless it is conformant to
XSLT <span>3.0</span>.</p>
<p>It is recognized that vendors who are enhancing XSLT 1.0
<span>or 2.0</span> processors may wish to release interim
implementations before all the mandatory features of this
specification are implemented. Since such products are not
conformant to XSLT 3.0, this specification cannot define their
behavior. However, implementers of such products are encouraged to
return a value for the <code>xsl:version</code> system property
that is intermediate between 1.0 and 3.0, and to provide the
<a href=
"#func-element-available"><code>element-available</code></a> and
<a href=
"#func-function-available"><code>function-available</code></a>
functions to allow users to test which features have been fully
implemented.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="div1">
<h2><a name="additional-types" id="additional-types"></a>21
<a href="#additional-types" style="text-decoration: none">XPath
Extensions</a></h2>
<p>XSLT 3.0 extends the type system and data model of XPath 3.0
with additional datatypes and associated functions and operators
defined in this section.</p>
<div class="div2">
<h3><a name="map" id="map"></a>21.1 <a href="#map" style=
"text-decoration: none">Maps</a></h3>
<p>A map is an additional kind of item.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-map" id="dt-map" title="map"></a>A map consists of a set of
entries. Each entry comprises a key which is an arbitrary atomic
value, and an arbitrary sequence called the associated
value.<span class="definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-same-key" id="dt-same-key" title="same key"></a>Within a map,
no two entries have the <b>same key</b>. <span>Two atomic values
<code>K1</code> and <code>K2</code> are the <b>same key</b> for
this purpose if the relation <code>deep-equal(K1, K2, $UCC)</code>
holds, where <code>$UCC</code> is the Unicode codepoint
collation.</span><span class="definition">]</span></p>
<p>To put it another way, the keys are the same if either <code>K1
eq K2</code> is true under the Unicode codepoint collation, or if
both <code>K1</code> and <code>K2</code> are <code>NaN</code>. It
is not necessary that all the keys should be mutually comparable
(for example, they can include a mixture of integers and
strings).</p>
<p>A map cannot contain among its keys both date/time values with a
timezone and date/time values with no timezone. The term "date/time
value" here means an instance of any of the types
<code>xs:dateTime</code>, <code>xs:date</code>,
<code>xs:time</code>, <code>xs:gYear</code>
<code>xs:gYearMonth</code>, <code>xs:gMonth</code>,
<code>xs:gMonthDay</code>, or <code>xs:gDay</code>. If a map
contains such a value with a timezone, then adding an entry with no
timezone results in a dynamic error; and conversely, if a map
contains such a value with no timezone, then adding an entry with a
timezone results in a dynamic error.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The reason for this rule is that comparison of a date/time value
with timezone to one without timezone depends on knowing the
implicit timezone. If values with timezones and values without
timezones could be mixed in the same map, such a map could become
invalid when the implicit timezone changes. The rule therefore
ensures that the constraint that no two entries have the <a title=
"same key" class="termref" href="#dt-same-key">same key</a> applies
regardless what timezone is used for the assessment. Without this
rule, for example, a map created in a <a title="static variable"
class="termref" href="#dt-static-variable">static variable</a>
could be invalid during stylesheet execution, since the implicit
timezone used during the analysis phase can differ from that used
during evaluation.</p>
</div>
<p><a name="err-XTDE3368" id="err-XTDE3368"><span class=
"error">[ERR XTDE3368]</span></a> A <a title="dynamic error" class=
"termref" href="#dt-dynamic-error">dynamic error</a> occurs if the
set of keys in a map produced by the evaluation of any expression
or instruction contains an instance of any of the types
<code>xs:dateTime</code>, <code>xs:date</code>,
<code>xs:time</code>, <code>xs:gYear</code>
<code>xs:gYearMonth</code>, <code>xs:gMonth</code>,
<code>xs:gMonthDay</code>, or <code>xs:gDay</code> having a
timezone and also contains an instance of any of these types having
no timezone.</p>
<p>The function call <code>map:get($map, $key)</code> can be used
to retrieve the value associated with a given key.</p>
<p>A <a title="map" class="termref" href="#dt-map">map</a> can also
be viewed as a function from keys to associated values. To achieve
this, a map is also a function item. The properties of this
function are as follows:</p>
<ul>
<li>
<p>The <b>name</b> of the function is absent.</p>
</li>
<li>
<p>The <b>arity</b> of the function is 1 (one).</p>
</li>
<li>
<p>The <b>parameter names</b> comprise a sequence of one QName,
conventionally <code>$key</code>, though the choice of name has no
observable consequences.</p>
</li>
<li>
<p>The <b>signature</b> is <code>function($key as
xs:anyAtomicValue) as item()*</code> (with no annotations).</p>
</li>
<li>
<p>The <b>implementation</b> is the expression <code>map:get($self,
$key)</code></p>
</li>
<li>
<p>The <b>non-local-variable-bindings</b> comprise a single
variable, <code>$self</code>, whose value is the map itself.</p>
</li>
</ul>
<p>Calling the function has the same effect as calling the
<code>get</code> function: the expression <code>$map($key)</code>
returns the same result as <code>get($map, $key)</code>. For
example, if <code>$books-by-isbn</code> is a map whose keys are
ISBNs and whose associated values are <code>book</code> elements,
then the expression <code>$books-by-isbn("0470192747")</code>
returns the <code>book</code> element with the given ISBN. The fact
that a map is a function item allows it to be passed as an argument
to higher-order functions that expect a function item as one of
their arguments.</p>
<p>Like all other values, <a title="map" class="termref" href=
"#dt-map">maps</a> are immutable. For example, the <a href=
"#func-map-remove"><code>map:remove</code></a> function creates a
new map by removing an entry from an existing map, but the existing
map is not changed by the operation.</p>
<p>Like sequences, <a title="map" class="termref" href=
"#dt-map">maps</a> have no identity. It is meaningful to compare
the contents of two maps, but there is no way of asking whether
they are "the same map": two maps with the same content are
indistinguishable.</p>
<div class="div3">
<h4><a name="map-type" id="map-type"></a>21.1.1 <a href="#map-type"
style="text-decoration: none">The Type of a Map</a></h4>
<p>The syntax of <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-ItemType">ItemType</a><sup><small>XP30</small></sup>
as defined in XPath is extended as follows:</p>
<h5><a name="d7e59003" id="d7e59003"></a>MapType</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="NT-ItemType-2" id=
"NT-ItemType-2"></a>[69]&#160;&#160;&#160;</td>
<td><code>ItemType</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>KindTest | ("item" "(" ")") | FunctionTest |
AtomicOrUnionType | ParenthesizedItemType<br />
| MapType</code></td>
</tr>
<tr valign="baseline">
<td><a name="NT-MapType" id=
"NT-MapType"></a>[201]&#160;&#160;&#160;</td>
<td><code>MapType</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>'map' '(' ( '*' | (<a href=
"http://www.w3.org/TR/xpath-30/#doc-xpath30-AtomicOrUnionType">AtomicOrUnionType</a><sup><small>XP30</small></sup>
',' <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-SequenceType">SequenceType</a><sup><small>XP30</small></sup>)
')'</code></td>
</tr>
</tbody>
</table>
<p>The following rules express the matching rules for a map item
type and a map, and extend the set of rules given in <a href=
"http://www.w3.org/TR/xpath-30/#id-matching-item">Section 2.5.5.2
Matching an ItemType and an Item</a>
<sup><small>XP30</small></sup>:</p>
<ul>
<li>
<p>The <code>ItemType</code> <code>map(K, V)</code> matches an item
<var>M</var> if (a) <var>M</var> is a <a title="map" class=
"termref" href="#dt-map">map</a>, and (b) every entry in
<var>M</var> has a key that matches <code>K</code> and an
associated value that matches <code>V</code>. For example,
<code>map(xs:integer, element(employee))</code> matches a map if
all the keys in the map are integers, and all the associated values
are <code>employee</code> elements. Note that a map (like a
sequence) carries no intrinsic type information separate from the
types of its entries, and the type of existing entries in a map
does not constrain the type of new entries that can be added to the
map.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In consequence, <code>map(K, V)</code> matches an empty map,
whatever the types <var>K</var> and <var>V</var> might be.</p>
</div>
</li>
<li>
<p>The <code>ItemType</code> <code>map(*)</code> matches any map
regardless of its contents. It is equivalent to
<code>map(xs:anyAtomicType, item()*)</code>.</p>
</li>
</ul>
<p>A map also acts as a function. This means that maps match
certain function item types. Specifically, the following rule
extends the list of rules in <a href=
"http://www.w3.org/TR/xpath-30/#id-function-test">Section 2.5.5.7
Function Test</a> <sup><small>XP30</small></sup>:</p>
<ul>
<li>
<p><code>function(*)</code> matches any map.</p>
</li>
<li>
<p><code>function(xs:anyAtomicType) as item()*</code> matches any
map.</p>
</li>
</ul>
<p>Because of the rules for subtyping of function types according
to their signature, it follows that the item type <code>function(A)
as item()*</code>, where A is an atomic type, also matches any map,
regardless of the type of the keys actually found in the map. For
example, a map whose keys are all strings can be supplied where the
required type is <code>function(xs:integer) as item()*</code>; a
call on the map that treats it as a function with an integer
argument will always succeed, and will always return an empty
sequence.</p>
<p>The function signature of the map, treated as a function, is
always <code>function(xs:anyAtomicType) as item()*</code>,
regardless of the actual types of the keys and values in the map.
This means that a function item type with a more specific return
type, such as <code>function(xs:anyAtomicType) as
xs:integer</code>, does not match a map in the sense required to
satisfy the <code>instance of</code> operator. However, the rules
for function coercion mean that any map can be supplied as a value
in a context where such a type is the required type, and a type
error will only occur if an actual call on the map (treated as a
function) returns a value that is not an instance of the required
return type.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>So, given a map <code>$M</code> whose keys are integers and
whose results are strings, such as <code>map{0:"no",
1:"yes"}</code>, the following relations hold, among others:</p>
<ul>
<li>
<p><code>$M instance of map(*)</code></p>
</li>
<li>
<p><code>$M instance of map(xs:integer, xs:string)</code></p>
</li>
<li>
<p><code>$M instance of map(xs:decimal,
xs:anyAtomicType)</code></p>
</li>
<li>
<p><code>not($M instance of map(xs:int, xs:string))</code></p>
</li>
<li>
<p><code>not($M instance of map(xs:integer, xs:token))</code></p>
</li>
<li>
<p><code>$M instance of function(*)</code></p>
</li>
<li>
<p><code>$M instance of function(xs:anyAtomicType) as
item()*</code></p>
</li>
<li>
<p><code>$M instance of function(xs:integer) as item()*</code></p>
</li>
<li>
<p><code>$M instance of function(xs:int) as item()*</code></p>
</li>
<li>
<p><code>$M instance of function(xs:string) as item()*</code></p>
</li>
<li>
<p><code>not($M instance of function(xs:integer) as
xs:string)</code></p>
</li>
</ul>
<p>The last case might seem surprising; however, function coercion
ensures that <code>$M</code> can be used successfully anywhere that
the required type is <code>function(xs:integer) as
xs:string</code>.</p>
</div>
<p>The rules for judging whether one item type is a subtype of
another, given in <a href=
"http://www.w3.org/TR/xpath-30/#id-itemtype-subtype">Section
2.5.6.2 The judgement subtype-itemtype(Ai, Bi)</a>
<sup><small>XP30</small></sup>, are extended with some additional
rules. The judgement <code>subtype-itemtype(Ai, Bi)</code> is true
if:</p>
<ul>
<li>
<p><code>Ai</code> is <code>map(K, V)</code> and <code>Bi</code> is
<code>map(*)</code>, for any <code>K</code> and <code>V</code>.</p>
</li>
<li>
<p><code>Ai</code> is <code>map(Ka, Va)</code> and <code>Bi</code>
is <code>map(Kb, Vb)</code>, where <code>subtype-itemtype(Ka,
Kb)</code> and <code>subtype(Va, Vb)</code>.</p>
</li>
<li>
<p><code>Ai</code> is <code>map(*)</code> (or, because of the
transitivity rules, any other map type) and <code>Bi</code> is
<code>function(*)</code>.</p>
</li>
<li>
<p><code>Ai</code> is <code>map(*)</code>, (or, because of the
transitivity rules, any other map type) and <code>Bi</code> is
<code>function(xs:anyAtomicType) as item()*</code>.</p>
</li>
</ul>
</div>
<div class="div3">
<h4><a name="map-functions" id="map-functions"></a>21.1.2 <a href=
"#map-functions" style="text-decoration: none">Functions that
Operate on Maps</a></h4>
<p>The functions defined in this section use a conventional
namespace prefix <code>map</code>, which is assumed to be bound to
the namespace URI
<code>http://www.w3.org/2005/xpath-functions/map</code>.</p>
<p>There is no operation to atomize a map or convert it to a
string.</p>
<div class="div4">
<h5><a name="func-map-merge" id="func-map-merge"></a>21.1.2.1
<a href="#func-map-merge" style=
"text-decoration: none">map:merge</a></h5>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Creates a new map that combines entries from a number of
existing maps.</p>
</dd>
<dt class="label">Signature</dt>
<dd>
<p><a name="function-merge" id="function-merge"></a></p>
<div class="proto"><code class="function">merge</code>(<code class=
"arg">$maps</code><code class=
"as">&#160;as&#160;</code><code class="type">map(*)*</code>)<code class="as">&#160;as&#160;</code><code class="return-type">map(*)</code></div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-independent">context-independent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>The function <a href=
"#func-map-merge"><code>map:merge</code></a> constructs and returns
a new map.</p>
<p>The function returns a <a title="map" class="termref" href=
"#dt-map">map</a> that is formed by combining the contents of the
maps supplied in the <code>$input</code> argument.</p>
<p>The supplied maps are combined as follows:</p>
<ol class="enumar">
<li>
<p>There is one entry in the new map for each distinct key present
in the union of the input maps, where two keys are distinct if they
are not the <span><a title="same key" class="termref" href=
"#dt-same-key">same key</a></span>.</p>
</li>
<li>
<p>The associated value for each such key is taken from the last
map in the input sequence <code>$input</code> that contains an
entry with this key.</p>
</li>
</ol>
<p>There is no requirement that the supplied input maps should have
the same or compatible types. The type of a map (for example
<code>map(xs:integer, xs:string)</code>) is descriptive of the
entries it currently contains, but is not a constraint on how the
map may be combined with other maps.</p>
</dd>
<dt class="label">Error Conditions</dt>
<dd>
<p>See <span class="error">[see <a href="#err-XTDE3368">ERR
XTDE3368</a>]</span>.</p>
</dd>
<dt class="label">Notes</dt>
<dd>
<p>If the input is an empty sequence, the result is an empty
map.</p>
<p>If the input is a sequence of length one, the result map is the
same as the supplied map. (Since maps are immutable and have no
discernible identity, it is meaningless to ask whether the result
is the same map as the original, or a different map with the same
content.)</p>
</dd>
<dt class="label">Examples</dt>
<dd>
<p>let <code>$week</code> := <code>map{0:"Sonntag", 1:"Montag",
2:"Dienstag", 3:"Mittwoch", 4:"Donnerstag", 5:"Freitag",
6:"Samstag"}</code></p>
<p>The expression <code>map:merge(())</code> returns
<code>map{}</code>. <em>(Returns an empty map).</em></p>
<p>The expression <code>map:merge((map:entry(0, "no"), map:entry(1,
"yes")))</code> returns <code>map{0:"no", 1:"yes"}</code>.
<em>(Returns a map with two entries).</em></p>
<p>The expression <code>map:merge(($week, {7:"Unbekannt"}))</code>
returns <code>map{0:"Sonntag", 1:"Montag", 2:"Dienstag",
3:"Mittwoch", 4:"Donnerstag", 5:"Freitag", 6:"Samstag",
7:"Unbekannt"}</code>. <em>(The value of the existing map is
unchanged; a new map is created containing all the entries from
<code>$week</code>, supplemented with a new entry.).</em></p>
<p>The expression <code>map:merge(($week, {6:"Sonnabend"}))</code>
returns <code>map{0:"Sonntag", 1:"Montag", 2:"Dienstag",
3:"Mittwoch", 4:"Donnerstag", 5:"Freitag", 6:"Sonnabend"}</code>.
<em>(The value of the existing map is unchanged; a new map is
created containing all the entries from <code>$week</code>, with
one entry replaced by a new entry. Both input maps contain an entry
with the key <code>6</code>; the one used in the result is the one
that comes last in the input sequence.).</em></p>
</dd>
</dl>
</div>
<div class="div4">
<h5><a name="func-map-size" id="func-map-size"></a>21.1.2.2
<a href="#func-map-size" style=
"text-decoration: none">map:size</a></h5>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Returns the number of entries in the supplied map.</p>
</dd>
<dt class="label">Signature</dt>
<dd>
<p><a name="function-size" id="function-size"></a></p>
<div class="proto"><code class="function">size</code>(<code class=
"arg">$input</code><code class=
"as">&#160;as&#160;</code><code class=
"type">map(*)</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">xs:integer</code></div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-independent">context-independent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>The function <a href="#func-map-size"><code>map:size</code></a>
takes any <a title="map" class="termref" href="#dt-map">map</a> as
its <code>$input</code> argument and returns the number of entries
that are present in the map.</p>
</dd>
<dt class="label">Examples</dt>
<dd>
<p>The expression <code>map:size(map{})</code> returns
<code>0</code>.</p>
<p>The expression <code>map:size(map{"true":1, "false":0})</code>
returns <code>2</code>.</p>
</dd>
</dl>
</div>
<div class="div4">
<h5><a name="func-map-keys" id="func-map-keys"></a>21.1.2.3
<a href="#func-map-keys" style=
"text-decoration: none">map:keys</a></h5>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Returns a sequence containing all the keys present in a map</p>
</dd>
<dt class="label">Signature</dt>
<dd>
<p><a name="function-keys" id="function-keys"></a></p>
<div class="proto"><code class="function">keys</code>(<code class=
"arg">$input</code><code class=
"as">&#160;as&#160;</code><code class=
"type">map(*)</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">xs:anyAtomicType*</code></div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-independent">context-independent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>The function <a href="#func-map-keys"><code>map:keys</code></a>
takes any <a title="map" class="termref" href="#dt-map">map</a> as
its <code>$input</code> argument and returns the keys that are
present in the map as a sequence of atomic values, in <a title=
"implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a>
order.</p>
</dd>
<dt class="label">Notes</dt>
<dd>
<p>The number of items in the result will be the same as the number
of entries in the map, and the result sequence will contain no
duplicate values.</p>
</dd>
<dt class="label">Examples</dt>
<dd>
<p>The expression <code>map:keys(map{1:"yes", 2:"no"})</code>
returns some permutation of <code>(1,2)</code>. <em>(The result is
in <a title="implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a>
order.).</em></p>
</dd>
</dl>
</div>
<div class="div4">
<h5><a name="func-map-contains" id="func-map-contains"></a>21.1.2.4
<a href="#func-map-contains" style=
"text-decoration: none">map:contains</a></h5>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Tests whether a supplied map contains an entry for a given
key</p>
</dd>
<dt class="label">Signature</dt>
<dd>
<p><a name="function-contains" id="function-contains"></a></p>
<div class="proto">
<table border="0" cellpadding="0" cellspacing="0" summary=
"Function signature for :contains function">
<tr>
<td valign="baseline" rowspan="2"><code class=
"function">contains</code>(</td>
<td valign="baseline"><code class="arg">$map</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class="type">map(*)</code>,</td>
</tr>
<tr>
<td valign="baseline"><code class="arg">$key</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class=
"type">xs:anyAtomicType</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">xs:boolean</code></td>
</tr>
</table>
</div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-independent">context-independent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>The function <a href=
"#func-map-contains"><code>map:contains</code></a> returns true if
the <a title="map" class="termref" href="#dt-map">map</a> supplied
as <code>$map</code> contains an entry with <span>the <a title=
"same key" class="termref" href="#dt-same-key">same key</a>
as</span> the supplied value of <code>$key</code>; otherwise it
returns false. The equality comparison uses the <span>Unicode
codepoint collation</span>; no error occurs if the map contains
keys that are not comparable with the supplied
<code>$key</code>.</p>
<p>If the supplied key is <code>xs:untypedAtomic</code>, it
<span>is compared as an instance of</span> <code>xs:string</code>.
If the supplied key is the <code>xs:float</code> or
<code>xs:double</code> value <code>NaN</code>, the function
<span>returns true if there is an entry whose key is
<code>NaN</code>, or false otherwise</span>.</p>
</dd>
<dt class="label">Examples</dt>
<dd>
<p>let <code>$week</code> := <code>map{0:"Sonntag", 1:"Montag",
2:"Dienstag", 3:"Mittwoch", 4:"Donnerstag", 5:"Freitag",
6:"Samstag"}</code></p>
<p>The expression <code>map:contains($week, 2)</code> returns
<code>true()</code>.</p>
<p>The expression <code>map:contains($week, 9)</code> returns
<code>false()</code>.</p>
<p>The expression <code>map:contains(map{}, "xyz")</code> returns
<code>false()</code>.</p>
<p>The expression <code>map:contains(map{"xyz":23}, "xyz")</code>
returns <code>true()</code>.</p>
<p>The expression <code>map:contains(map{"abc":23, "xyz":()},
"xyz")</code> returns <code>true()</code>.</p>
</dd>
</dl>
</div>
<div class="div4">
<h5><a name="func-map-get" id="func-map-get"></a>21.1.2.5 <a href=
"#func-map-get" style="text-decoration: none">map:get</a></h5>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Returns the value associated with a supplied key in a given
map.</p>
</dd>
<dt class="label">Signature</dt>
<dd>
<p><a name="function-get" id="function-get"></a></p>
<div class="proto">
<table border="0" cellpadding="0" cellspacing="0" summary=
"Function signature for :get function">
<tr>
<td valign="baseline" rowspan="2"><code class=
"function">get</code>(</td>
<td valign="baseline"><code class="arg">$map</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class="type">map(*)</code>,</td>
</tr>
<tr>
<td valign="baseline"><code class="arg">$key</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class=
"type">xs:anyAtomicType</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">item()*</code></td>
</tr>
</table>
</div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-independent">context-independent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>The function <a href="#func-map-get"><code>map:get</code></a>
attempts to find an entry within the <a title="map" class="termref"
href="#dt-map">map</a> supplied as <code>$map</code> that has
<span>the <a title="same key" class="termref" href=
"#dt-same-key">same key</a> as</span> the supplied value of
<code>$key</code>. If there is such an entry, it returns the
associated value; otherwise it returns an empty sequence. The
comparison uses the <span>Unicode codepoint collation</span>; no
error occurs if the map contains keys that are not comparable with
the supplied <code>$key</code>.</p>
<p>If the supplied key is <code>xs:untypedAtomic</code>, it is
<span>compared as an instance of</span> <code>xs:string</code>. If
the supplied key is the <code>xs:float</code> or
<code>xs:double</code> value <code>NaN</code>, the function returns
<span>the value in the entry whose key is <code>NaN</code>, if
there is such an entry, or the empty sequence otherwise</span>.</p>
<p>Where values of different numeric types are numerically very
close to each other, it can happen that the map contains two
entries whose keys both match the supplied key, but which are not
equal to each other. In this situation the entry that is returned
is <a title="implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a>.</p>
</dd>
<dt class="label">Notes</dt>
<dd>
<p>A return value of <code>()</code> from <a href=
"#func-map-get"><code>map:get</code></a> could indicate that the
key is present in the map with an associated value of
<code>()</code>, or it could indicate that the key is not present
in the map. The two cases can be distinguished by calling <a href=
"#func-map-contains"><code>map:contains</code></a>.</p>
<p>Invoking the <a title="map" class="termref" href=
"#dt-map">map</a> as a function item has the same effect as calling
<code>get</code>: that is, when <code>$map</code> is a map, the
expression <code>$map($K)</code> is equivalent to
<code>map:get($map, $K)</code>. Similarly, the expression
<code>map:get(map:get(map:get($map, 'employee'), 'name'),
'first')</code> can be written as
<code>$map('employee')('name')('first')</code>.</p>
</dd>
<dt class="label">Examples</dt>
<dd>
<p>let <code>$week</code> := <code>map{0:"Sonntag", 1:"Montag",
2:"Dienstag", 3:"Mittwoch", 4:"Donnerstag", 5:"Freitag",
6:"Samstag"}</code></p>
<p>The expression <code>map:get($week, 4)</code> returns
<code>"Donnerstag"</code>.</p>
<p>The expression <code>map:get($week, 9)</code> returns
<code>()</code>. <em>(When the key is not present, the function
returns an empty sequence.).</em></p>
<p>The expression <code>map:get(map:entry(7,()), 7)</code> returns
<code>()</code>. <em>(An empty sequence as the result can also
signify that the key is present and the associated value is an
empty sequence.).</em></p>
</dd>
</dl>
</div>
<div class="div4">
<h5><a name="func-map-put" id="func-map-put"></a>21.1.2.6 <a href=
"#func-map-put" style="text-decoration: none">map:put</a></h5>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Creates a map that adds a single entry to an existing map, or
replaces a single entry in an existing map.</p>
</dd>
<dt class="label">Signature</dt>
<dd>
<p><a name="function-put" id="function-put"></a></p>
<div class="proto">
<table border="0" cellpadding="0" cellspacing="0" summary=
"Function signature for :put function">
<tr>
<td valign="baseline" rowspan="3"><code class=
"function">put</code>(</td>
<td valign="baseline"><code class="arg">$map</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class="type">map(*)</code>,</td>
</tr>
<tr>
<td valign="baseline"><code class="arg">$key</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class=
"type">xs:anyAtomicType</code>,</td>
</tr>
<tr>
<td valign="baseline"><code class="arg">$value</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class=
"type">item()*</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">map(*)</code></td>
</tr>
</table>
</div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-independent">context-independent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>The function <a href="#func-map-put"><code>map:put</code></a>
returns a new <a title="map" class="termref" href="#dt-map">map</a>
The new map contains all entries from the supplied
<code>$map</code>, with the exception of any entry whose key is
<code>$key</code>, together with a new entry whose key is
<code>$key</code> and whose associated value is
<code>$value</code>.</p>
<p>The effect of the function call <code>map:put($map, $key,
$value)</code> is equivalent to the expression
<code>map:merge(($map, map:entry($key, $value)))</code>.</p>
</dd>
<dt class="label">Error Conditions</dt>
<dd>
<p>See <span class="error">[see <a href="#err-XTDE3368">ERR
XTDE3368</a>]</span>.</p>
</dd>
<dt class="label">Notes</dt>
<dd>
<p>There is no requirement that the type of <code>$key</code> and
<code>$value</code> be consistent with the types of any existing
keys and values in the supplied map.</p>
</dd>
<dt class="label">Examples</dt>
<dd>
<p>let <code>$week</code> := <code>map{0:"Sonntag", 1:"Montag",
2:"Dienstag", 3:"Mittwoch", 4:"Donnerstag", 5:"Freitag",
6:"Samstag"}</code></p>
<p>The expression <code>map:put($week, 6, "Sonnabend")</code>
returns <code>map{0:"Sonntag", 1:"Montag", 2:"Dienstag",
3:"Mittwoch", 4:"Donnerstag", 5:"Freitag",
6:"Sonnabend"}</code>.</p>
<p>The expression <code>map:put($week, -1, "Unbekannt")</code>
returns <code>map{0:"Sonntag", 1:"Montag", 2:"Dienstag",
3:"Mittwoch", 4:"Donnerstag", 5:"Freitag", 6:"Samstag",
-1:"Unbekannt"}</code>.</p>
</dd>
</dl>
</div>
<div class="div4">
<h5><a name="func-map-entry" id="func-map-entry"></a>21.1.2.7
<a href="#func-map-entry" style=
"text-decoration: none">map:entry</a></h5>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Creates a map that contains a single entry (a key-value
pair).</p>
</dd>
<dt class="label">Signature</dt>
<dd>
<p><a name="function-entry" id="function-entry"></a></p>
<div class="proto">
<table border="0" cellpadding="0" cellspacing="0" summary=
"Function signature for :entry function">
<tr>
<td valign="baseline" rowspan="2"><code class=
"function">entry</code>(</td>
<td valign="baseline"><code class="arg">$key</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class=
"type">xs:anyAtomicType</code>,</td>
</tr>
<tr>
<td valign="baseline"><code class="arg">$value</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class=
"type">item()*</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">map(*)</code></td>
</tr>
</table>
</div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-independent">context-independent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>The function <a href=
"#func-map-entry"><code>map:entry</code></a> returns a new
<a title="map" class="termref" href="#dt-map">map</a> which
contains a single entry. The key of the entry in the new map is
<code>$key</code>, and its associated value is
<code>$value</code>.</p>
</dd>
<dt class="label">Notes</dt>
<dd>
<p>The function <code>map:entry</code> is intended primarily for
use in conjunction with the function <code>map:merge</code>. For
example, a map containing seven entries may be constructed like
this:</p>
<div class="exampleInner">
<pre>
map:merge((
   map:entry("Su", "Sunday"),
   map:entry("Mo", "Monday"),
   map:entry("Tu", "Tuesday"),
   map:entry("We", "Wednesday"),
   map:entry("Th", "Thursday"),
   map:entry("Fr", "Friday"),
   map:entry("Sa", "Saturday")
   ))
</pre></div>
<p>Unlike the map expression (<code>{...}</code>), this technique
can be used to construct a map with a variable number of entries,
for example:</p>
<div class="exampleInner">
<pre>
map:merge(for $b in //book return map:entry($b/isbn, $b))
</pre></div>
</dd>
<dt class="label">Examples</dt>
<dd>
<p>The expression <code>map:entry("M", "Monday")</code> returns
<code>{"M":"Monday"}</code>.</p>
</dd>
</dl>
</div>
<div class="div4">
<h5><a name="func-map-remove" id="func-map-remove"></a>21.1.2.8
<a href="#func-map-remove" style=
"text-decoration: none">map:remove</a></h5>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Constructs a new map by removing an entry from an existing
map</p>
</dd>
<dt class="label">Signature</dt>
<dd>
<p><a name="function-remove" id="function-remove"></a></p>
<div class="proto">
<table border="0" cellpadding="0" cellspacing="0" summary=
"Function signature for :remove function">
<tr>
<td valign="baseline" rowspan="2"><code class=
"function">remove</code>(</td>
<td valign="baseline"><code class="arg">$map</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class="type">map(*)</code>,</td>
</tr>
<tr>
<td valign="baseline"><code class="arg">$key</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class=
"type">xs:anyAtomicType</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">map(*)</code></td>
</tr>
</table>
</div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-independent">context-independent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>The function <a href=
"#func-map-remove"><code>map:remove</code></a> returns a new
<a title="map" class="termref" href="#dt-map">map</a>. The entries
in the new map correspond to the entries of <code>$map</code>,
excluding any entry whose key is <span>the <a title="same key"
class="termref" href="#dt-same-key">same key</a> as</span>
<code>$key</code>.</p>
<p>No failure occurs if the input map contains no entry with the
supplied key; the input map is returned unchanged</p>
</dd>
<dt class="label">Examples</dt>
<dd>
<p>let <code>$week</code> := <code>map{0:"Sonntag", 1:"Montag",
2:"Dienstag", 3:"Mittwoch", 4:"Donnerstag", 5:"Freitag",
6:"Samstag"}</code></p>
<p>The expression <code>map:remove($week, 4)</code> returns
<code>map{0:"Sonntag", 1:"Montag", 2:"Dienstag", 3:"Mittwoch",
5:"Freitag", 6:"Samstag"}</code>.</p>
<p>The expression <code>map:remove($week, 23)</code> returns
<code>map{0:"Sonntag", 1:"Montag", 2:"Dienstag", 3:"Mittwoch",
4:"Donnerstag", 5:"Freitag", 6:"Samstag"}</code>.</p>
</dd>
</dl>
</div>
<div class="div4">
<h5><a name="func-map-for-each" id="func-map-for-each"></a>21.1.2.9
<a href="#func-map-for-each" style=
"text-decoration: none">map:for-each</a></h5>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Applies a supplied function to every entry in a map, returning
the concatenation of the results.</p>
</dd>
<dt class="label">Signature</dt>
<dd>
<p><a name="function-for-each" id="function-for-each"></a></p>
<div class="proto">
<table border="0" cellpadding="0" cellspacing="0" summary=
"Function signature for :for-each function">
<tr>
<td valign="baseline" rowspan="2"><code class=
"function">for-each</code>(</td>
<td valign="baseline"><code class="arg">$input</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class="type">map(*)</code>,</td>
</tr>
<tr>
<td valign="baseline"><code class="arg">$action</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class="type">function($key as
xs:anyAtomicType, $value as item()*)</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">item()*</code></td>
</tr>
</table>
</div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-independent">context-independent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>The function <a href=
"#func-map-for-each"><code>map:for-each</code></a> takes any
<a title="map" class="termref" href="#dt-map">map</a> as its
<code>$input</code> argument and applies the supplied function to
each entry in the map, in <a title="implementation-dependent"
class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a> order;
the result is the sequence obtained by concatenating the results of
these function calls.</p>
<p>The function supplied as <code>$action</code> takes two
arguments. It is called supplying the key of the map entry as the
first argument, and the associated value as the second
argument.</p>
</dd>
<dt class="label">Examples</dt>
<dd>
<p>The expression <code>map:for-each(map{1:"yes", 2:"no"},
function($k, $v){$k})</code> returns some permutation of
<code>(1,2)</code>. <em>(This function call is equivalent to
calling <code>map:keys</code>. The result is in
implementation-dependent order.).</em></p>
<p>The expression <code>distinct-values(map:for-each(map{1:"yes",
2:"no"}, function($k, $v){$v})</code> returns some permutation of
<code>("yes", "no")</code>. <em>(This function call returns the
distinct values present in the map, in implementation-dependent
order.).</em></p>
<p>The expression <code>map:merge(map:for-each(map{"a":1, "b":2},
function($k, $v){map:entry($k, $v+1)})</code> returns
<code>map{"a":2, "b":3}</code>. <em>(This function call returns a
map with the same keys as the input map, with the value of each
entry increased by one.).</em></p>
<div class="example">
<div class="exampleHeader"><a name="d7e60317" id=
"d7e60317"></a>Example: Converting a Map to an Element Node</div>
<p>This example converts the entries in a map to attributes on a
newly constructed element node.</p>
<div class="exampleInner">
<pre>
   &lt;xsl:variable name="dimensions" 
                 select="map{'height': 3, 'width': 4, 'depth': 5}"/&gt;
   
   &lt;xsl:function name="f:make-attribute" as="attribute()"&gt;
     &lt;xsl:param name="key" as="xs:string"/&gt;
     &lt;xsl:param name="value" as="xs:anyAtomicType"/&gt;
     &lt;xsl:attribute name="{$key}" select="string($value)"/&gt;
   &lt;/xsl:function&gt;
   
   &lt;xsl:template name="convert"&gt;
     &lt;box&gt;
       &lt;xsl:sequence select="map:for-each(
                               $dimensions, f:make-attribute#2)"/&gt;
     &lt;/box&gt;
   &lt;/xsl:template&gt;  
   
</pre></div>
<p>The result is the element <code>&lt;box height="3" width="4"
depth="5"/&gt;</code>.</p>
</div>
</dd>
</dl>
</div>
<div class="div4">
<h5><a name="func-collation-key" id=
"func-collation-key"></a>21.1.2.10 <a href="#func-collation-key"
style="text-decoration: none">fn:collation-key</a></h5>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Given a key and a collation, generates an internal value with
the property that the internal value is the same for any two keys
that compare equal under the given collation.</p>
</dd>
<dt class="label">Signatures</dt>
<dd>
<p><a name="function-collation-key" id=
"function-collation-key"></a></p>
<div class="proto"><code class=
"function">collation-key</code>(<code class=
"arg">$key</code><code class="as">&#160;as&#160;</code><code class=
"type">xs:string</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">xs:anyAtomicType</code></div>
<div class="proto">
<table border="0" cellpadding="0" cellspacing="0" summary=
"Function signature for :collation-key function">
<tr>
<td valign="baseline" rowspan="2"><code class=
"function">collation-key</code>(</td>
<td valign="baseline"><code class="arg">$key</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class="type">xs:string</code>,</td>
</tr>
<tr>
<td valign="baseline"><code class="arg">$collation</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class=
"type">xs:string</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">xs:anyAtomicType</code></td>
</tr>
</table>
</div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>The one-argument form of this function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>.
It depends on collations.</p>
<p>The two-argument form of this function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>.
It depends on collations, and static base uri.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>Calling the one-argument version of this function is equivalent
to calling the two-argument version supplying the default collation
as the second argument.</p>
<p>The function returns an <a title="implementation-defined" class=
"termref" href=
"#dt-implementation-defined">implementation-defined</a> value with
the property that <code>collation-key($K1, $C) eq
collation-key($K2, $C)</code> if and only if <code>compare($K1,
$K2, $C) = 0</code>.</p>
<p>If the collation URI is a relative reference, it is resolved
against the static base URI.</p>
<p>An implementation is free to generate a collation key in any
convenient way provided that it always generates the same collation
key for two strings that are equal under the collation, and
different collation keys for strings that are not equal. This holds
only within a single <a href=
"http://www.w3.org/TR/xpath-functions-30/#execution-scope">execution
scope</a><sup><small>FO30</small></sup>; an implementation is under
no obligation to generate the same collation keys during a
subsequent unrelated query or transformation.</p>
<p>It is possible to define collations that do not have the ability
to generate collation keys. Supplying such a collation will cause
the function to fail. The ability to generate collation keys is an
<a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> property of
the collation.</p>
</dd>
<dt class="label">Error Conditions</dt>
<dd>
<p>An error is raised <a href=
"http://www.w3.org/TR/xpath-functions-30/#ERRFOCH0004" title=
"FOCH0004"><span class="error">[ERR FOCH0004]</span></a>
<sup><small>FO30</small></sup> if the specified collation does not
support the generation of collation keys.</p>
</dd>
<dt class="label">Notes</dt>
<dd>
<p>The function is provided primarily for use with maps. If a map
is required where codepoint equality is inappropriate for comparing
keys, then a common technique is to normalize the key so that
equality matching becomes feasible. There are many ways keys can be
normalized, for example by use of functions such as <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-upper-case"><code>upper-case</code></a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#func-lower-case"><code>lower-case</code></a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#func-normalize-space"><code>
normalize-space</code></a><sup><small>FO30</small></sup>, or
<code>normalize-unicode</code>, but this function provides a way of
normalizing them according to the rules of a specified collation.
For example, if the collation ignores accents, then the function
will generate the same collation key for two input strings that
differ only in their use of accents.</p>
<p>The result of the function can be of any atomic type.</p>
<p>For collations based on the Unicode Collation Algorithm, an
algorithm for computing collation keys is provided in <a href=
"#UNICODE-TR10">[UNICODE TR10]</a>. This algorithm generates binary
collation keys, which might be materialized as a value of type
<code>xs:hexBinary</code> or <code>xs:base64Binary</code>.
Implementations are <span class="verb">not required</span> to use
this algorithm.</p>
<p>This specification does not mandate that collation keys should
retain ordering. This is partly because the primary use case is for
maps, where only equality comparisons are required, and partly to
allow the use of binary datatypes (which are currently unordered
types) for the result. The specification may be revised in a future
release to specify that ordering is preserved.</p>
</dd>
<dt class="label">Examples</dt>
<dd>
<p>let <code>$C</code> :=</p>
<div class="exampleInner">
<pre>
"http://www.w3.org/2005/xpath-functions/collations/UCA?strength=primary"
</pre></div>
<p>The expression <code>map:merge((map{collation-key("A", $C):1},
map{collation-key("a", $C):2}))(collation-key("A", $C))</code>
returns <code>2</code>. <em>(Given that the keys of the two entries
are equal under the rules of the chosen collation, only one of the
entries can appear in the result; the one that is chosen is the one
from the last map in the input sequence. ).</em></p>
<p>The expression <code>let $M : map{collation-key("A", $C):1,
collation-key("B", $C):2} return $M(collation-key("a", $C))</code>
returns <code>1</code>. <em>(The strings "A" and "a" have the same
collation key under this collation.).</em></p>
<p>As the above examples illustrate, it is important that when the
<code>collation-key</code> function is used to add entries to a
map, then it must also be used when retrieving entries from the
map. This process can be made less error-prone by encapsulating the
map within a function: <code>function($k) {$M(collation-key($k,
$collation)}</code>.</p>
</dd>
</dl>
</div>
<div class="div4">
<h5><a name="func-deep-equal" id="func-deep-equal"></a>21.1.2.12
<a href="#func-deep-equal" style=
"text-decoration: none">fn:deep-equal</a></h5>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>This function assesses whether two sequences are deep-equal to
each other. The function as described here extends the definition
of the XPath 3.0 <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-deep-equal"><code>deep-equal</code></a><sup><small>FO30</small></sup>
to explain how it should handle maps; it is intended to replace the
existing <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-deep-equal"><code>deep-equal</code></a><sup><small>FO30</small></sup>
function at some stage in the future.</p>
</dd>
<dt class="label">Signatures</dt>
<dd>
<p><a name="function-deep-equal" id="function-deep-equal"></a></p>
<div class="proto">
<table border="0" cellpadding="0" cellspacing="0" summary=
"Function signature for :deep-equal function">
<tr>
<td valign="baseline" rowspan="2"><code class=
"function">deep-equal</code>(</td>
<td valign="baseline"><code class="arg">$parameter1</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class="type">item()*</code>,</td>
</tr>
<tr>
<td valign="baseline"><code class="arg">$parameter2</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class=
"type">item()*</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">xs:boolean</code></td>
</tr>
</table>
</div>
<div class="proto">
<table border="0" cellpadding="0" cellspacing="0" summary=
"Function signature for :deep-equal function">
<tr>
<td valign="baseline" rowspan="3"><code class=
"function">deep-equal</code>(</td>
<td valign="baseline"><code class="arg">$parameter1</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class="type">item()*</code>,</td>
</tr>
<tr>
<td valign="baseline"><code class="arg">$parameter2</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class="type">item()*</code>,</td>
</tr>
<tr>
<td valign="baseline"><code class="arg">$collation</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class=
"type">xs:string</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">xs:boolean</code></td>
</tr>
</table>
</div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>The two-argument form of this function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>.
It depends on collations, and implicit timezone.</p>
<p>The three-argument form of this function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>.
It depends on collations, and static base uri, and implicit
timezone.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>The function delivers the same result as <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-deep-equal"><code>deep-equal</code></a><sup><small>FO30</small></sup>
except when (at some level of recursion) it is necessary to compare
two function items. In the case of <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-deep-equal"><code>deep-equal</code></a><sup><small>FO30</small></sup>,
comparing two function items raises a dynamic error. In the case of
this function, two function items that are both maps are compared
as follows.</p>
<p>If two items <code>$i1</code> and <code>$i2</code> to be
compared are both <a title="map" class="termref" href=
"#dt-map">maps</a>, the result is <code>true</code> if and only if
all the following conditions apply:</p>
<ol class="enumar">
<li>
<p>Both maps have the same number of entries.</p>
</li>
<li>
<p>For every entry in the first map, there is an entry in the
second map that:</p>
<ol class="enumla">
<li>
<p>has the <a title="same key" class="termref" href=
"#dt-same-key">same key</a> (note that the collation is not used
when comparing keys), and</p>
</li>
<li>
<p>has the same associated value (compared using the
<code>fn:deep-equal</code> function, under the collation supplied
in the original call to <code>fn:deep-equal</code>).</p>
</li>
</ol>
</li>
</ol>
</dd>
<dt class="label">Error Conditions</dt>
<dd>
<p>An error is raised <a href=
"http://www.w3.org/TR/xpath-functions-30/#ERRFOTY0015" title=
"FOTY0015"><span class="error">[ERR FOTY0015]</span></a>
<sup><small>FO30</small></sup> if either input sequence contains a
function item <span>that is not a map.</span></p>
</dd>
<dt class="label">Examples</dt>
<dd>
<p>The expression <code>fn:deep-equal(map{}, map{})</code> returns
<code>true()</code>.</p>
<p>The expression <code>fn:deep-equal(map{"a":1, "b":2}, map{"b":2,
"a":1.0})</code> returns <code>true()</code>.</p>
<p>The expression <code>fn:deep-equal(map{"a":xs:double('NaN')},
map{"a":xs:float('NaN')})</code> returns <code>true()</code>.</p>
<p>let <code>$at</code> :=</p>
<div class="exampleInner">
<pre>
&lt;attendees&gt;
  &lt;name last='Parker' first='Peter'/&gt;
  &lt;name last='Barker' first='Bob'/&gt;
  &lt;name first='Peter' last='Parker'/&gt;
&lt;/attendees&gt;
</pre></div>
<p>The expression <code>fn:deep-equal($at, $at/*)</code> returns
<code>false()</code>.</p>
<p>The expression <code>fn:deep-equal($at/name[1],
$at/name[2])</code> returns <code>false()</code>.</p>
<p>The expression <code>fn:deep-equal($at/name[1],
$at/name[3])</code> returns <code>true()</code>.</p>
<p>The expression <code>fn:deep-equal($at/name[1], 'Peter
Parker')</code> returns <code>false()</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="div3">
<h4><a name="map-instructions" id="map-instructions"></a>21.1.3
<a href="#map-instructions" style="text-decoration: none">Map
Instructions</a></h4>
<p>Two instructions are added to XSLT to facilitate the
construction of maps.</p>
<p class="element-syntax"><a name="element-map" id=
"element-map"></a><code>&lt;!-- Category: instruction --&gt;<br />
&lt;xsl:map&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:map&gt;</code></p>
<p>The instruction <a href="#element-map"><code>xsl:map</code></a>
constructs and returns a new map.</p>
<p>The contained sequence constructor <span class=
"verb">must</span> evaluate to a sequence of maps: call this
<code>$maps</code>.</p>
<p>The result of the instruction is then given by the XPath
expression:</p>
<div class="exampleInner">
<pre>
   
let $keys := $maps!map:keys(.)
return if (count($keys) = count(distinct-values($keys)))
       then map:merge($maps)                        
       else error()
</pre></div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Informally: if there are duplicate keys among the sequence of
maps, a dynamic error occurs. Otherwise, the resulting map contains
the union of the map entries from the supplied sequence of
maps.</p>
</div>
<p><a name="err-XTDE3365" id="err-XTDE3365"><span class=
"error">[ERR XTDE3365]</span></a> A <a title="dynamic error" class=
"termref" href="#dt-dynamic-error">dynamic error</a> occurs if the
set of keys in the maps resulting from evaluating the sequence
constructor contains duplicates.</p>
<p>There is no requirement that the supplied input maps should have
the same or compatible types. The type of a map (for example
<code>map(xs:integer, xs:string)</code>) is descriptive of the
entries it currently contains, but is not a constraint on how the
map may be combined with other maps.</p>
<p><a name="err-XTTE3375" id="err-XTTE3375"><span class=
"error">[ERR XTTE3375]</span></a> A type error occurs if the result
of evaluating the sequence constructor is not an instance of the
required type <code>map(*)*</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In practice, the effect of this rule is that the sequence
constructor contained in the <a href=
"#element-map"><code>xsl:map</code></a> instruction is severely
constrained: it doesn't make sense, for example, for it to contain
instructions such as <a href=
"#element-element"><code>xsl:element</code></a> that create new
nodes. As with other type errors, processors are free to signal the
error statically if they are able to determine that the sequence
constructor would always fail when evaluated.</p>
</div>
<p class="element-syntax"><a name="element-map-entry" id=
"element-map-entry"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:map-entry<br />
&#160;&#160;<b>key</b> = <var>expression</var><br />
&#160;&#160;select? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:map-entry&gt;</code></p>
<p>The instruction <a href=
"#element-map-entry"><code>xsl:map-entry</code></a> constructs and
returns a singleton map: that is, a map which contains one key and
one value. Such a map is primarily used as a building block when
constructing maps using the <a href=
"#element-map"><code>xsl:map</code></a> instruction.</p>
<p>The <code>select</code> attribute and the contained sequence
constructor are mutually exclusive: if a <code>select</code>
attribute is present, then the content <span class=
"verb">must</span> be empty except optionally for <a href=
"#element-fallback"><code>xsl:fallback</code></a> instructions.</p>
<p><a name="err-XTSE3280" id="err-XTSE3280"><span class=
"error">[ERR XTSE3280]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
<code>select</code> attribute of the <a href=
"#element-map-entry"><code>xsl:map-entry</code></a> element is
present unless the element has no children other than <a href=
"#element-fallback"><code>xsl:fallback</code></a> elements.</p>
<p>The key of the entry in the new map is the value obtained by
evaluating the expression in the <code>key</code> attribute,
converted to the required type <code>xs:anyAtomicType</code> by
applying the <a title="function conversion rules" class="termref"
href="#dt-function-conversion-rules">function conversion rules</a>.
If the supplied key (after conversion) is of type
<code>xs:untypedAtomic</code>, it is cast to
<code>xs:string</code>.</p>
<p>The associated value is the value obtained by evaluating the
expression in the <code>select</code> attribute, or the contained
sequence constructor, with no conversion. If there is no
<code>select</code> attribute and the sequence constructor is
empty, the associated value is the empty sequence.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e60848" id=
"d7e60848"></a>Example: Using XSLT instructions to create a fixed
map</div>
<p>The following example binds a variable to a map whose content is
statically known:</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="week" as="map(xs:string, xs:string)"&gt;
  &lt;xsl:map&gt;
    &lt;xsl:map-entry key="'Mo'" select="'Monday'"/&gt;
    &lt;xsl:map-entry key="'Tu'" select="'Tuesday'"/&gt;
    &lt;xsl:map-entry key="'We'" select="'Wednesday'"/&gt;
    &lt;xsl:map-entry key="'Th'" select="'Thursday'"/&gt;
    &lt;xsl:map-entry key="'Fr'" select="'Friday'"/&gt;
    &lt;xsl:map-entry key="'Sa'" select="'Saturday'"/&gt;
    &lt;xsl:map-entry key="'Su'" select="'Sunday'"/&gt;
  &lt;/xsl:map&gt;
&lt;/xsl:variable&gt;  
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e60856" id=
"d7e60856"></a>Example: Using XSLT instructions to create a
computed map</div>
<p>The following example binds a variable to a map acting as an
index into a source document:</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="index" as="map(xs:string, element(employee))"&gt;
  &lt;xsl:map&gt;
    &lt;xsl:for-each select="//employee"&gt;
      &lt;xsl:map-entry key="@empNr" select="."/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:map&gt;
&lt;/xsl:variable&gt;  
</pre></div>
</div>
</div>
<div class="div3">
<h4><a name="map-expressions" id="map-expressions"></a>21.1.4
<a href="#map-expressions" style="text-decoration: none">Map
Expressions</a></h4>
<p>A new kind of expression is added to the syntax of XPath.</p>
<p>The syntax of <a href=
"http://www.w3.org/TR/xpath-30/#doc-xpath30-PrimaryExpr">PrimaryExpr</a><sup><small>XP30</small></sup>
is extended to permit <code>MapExpr</code> as an additional
alternative.</p>
<h5><a name="d7e60876" id="d7e60876"></a>MapExpr</h5>
<table class="scrap" summary="Scrap">
<tbody>
<tr valign="baseline">
<td><a name="NT-PrimaryExpr" id=
"NT-PrimaryExpr"></a>[52]&#160;&#160;&#160;</td>
<td><code>PrimaryExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>Literal | VarRef | ParenthesizedExpr | ContextItemExpr |
FunctionCall | FunctionItemExpr<br />
| MapExpr</code></td>
</tr>
<tr valign="baseline">
<td><a name="NT-MapExpr" id=
"NT-MapExpr"></a>[202]&#160;&#160;&#160;</td>
<td><code>MapExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code>"map{" (KeyExpr ":" ValueExpr ("," KeyExpr ":" ValueExpr
)*)? "}"</code></td>
</tr>
<tr valign="baseline">
<td><a name="NT-KeyExpr" id=
"NT-KeyExpr"></a>[203]&#160;&#160;&#160;</td>
<td><code>KeyExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xpath-30/#doc-xpath30-ExprSingle">ExprSingle</a><sup><small>XP30</small></sup></code></td>
</tr>
<tr valign="baseline">
<td><a name="NT-ValueExpr" id=
"NT-ValueExpr"></a>[204]&#160;&#160;&#160;</td>
<td><code>ValueExpr</code></td>
<td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>
<td><code><a href=
"http://www.w3.org/TR/xpath-30/#doc-xpath30-ExprSingle">ExprSingle</a><sup><small>XP30</small></sup></code></td>
</tr>
</tbody>
</table>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In some circumstances, it is necessary to include whitespace
before or after the colon to ensure that this grammar is correctly
parsed; this arises for example when the <code>KeyExpr</code> ends
with a name and the <code>ValueExpr</code> starts with a name.</p>
</div>
<p>The value of the expression is a map whose entries correspond to
the key-value pairs obtained by evaluating the successive
<code>KeyExpr</code> and <code>ValueExpr</code> expressions.</p>
<p>Each <code>KeyExpr</code> expression is evaluated and atomized;
a <span>type error <a href=
"http://www.w3.org/TR/xpath-30/#ERRXPTY0004" title=
"XPTY0004"><span class="error">[ERR XPTY0004]</span></a>
<sup><small>XP30</small></sup></span> occurs if the result is not a
single atomic value. If the key is of type
<code>xs:untypedAtomic</code> it is converted to
<code>xs:string</code>. The associated value is the result of
evaluating the corresponding <code>ValueExpr</code>. If two or more
entries have the <span><a title="same key" class="termref" href=
"#dt-same-key">same key</a></span> then <span>a dynamic error
occurs <span class="error">[see <a href="#err-XTDE3365">ERR
XTDE3365</a>]</span></span>.</p>
<p>For example, the following expression constructs a map with
seven entries:</p>
<div class="exampleInner">
<pre>
map {
  "Su" : "Sunday",
  "Mo" : "Monday",
  "Tu" : "Tuesday",
  "We" : "Wednesday",
  "Th" : "Thursday",
  "Fr" : "Friday",
  "Sa" : "Saturday"
}
</pre></div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Unlike the <a href="#func-map-merge"><code>map:merge</code></a>
function, the number of entries in a map that is constructed using
a map expression is known statically.</p>
</div>
</div>
<div class="div3">
<h4><a name="maps-streaming" id="maps-streaming"></a>21.1.5
<a href="#maps-streaming" style="text-decoration: none">Maps and
Streaming</a></h4>
<p>Maps have many uses, but their introduction to XSLT 3.0 was
strongly motivated by streaming use cases. In essence, when a
source document is processed in streaming mode, data that is
encountered in the course of processing may need to be retained in
variables for subsequent use, because the nodes cannot be
revisited. This creates a need for a flexible data structure to
accommodate such temporary data, and maps were designed to fulfil
this need.</p>
<p>The <a href="#element-map"><code>xsl:map</code></a> instruction,
and the XPath <code>MapExpr</code> construct, are exceptions to the
general rule that during streaming, only one downward selection
(one consuming subexpression) is permitted. They share this
characteristic with <a href=
"#element-fork"><code>xsl:fork</code></a>. As with <a href=
"#element-fork"><code>xsl:fork</code></a>, a streaming processor is
expected to be able to construct the map during a single pass of
the streamed input document, which may require multiple expressions
to be evaluated in parallel.</p>
<p>In the case of the <a href=
"#element-map"><code>xsl:map</code></a> instruction, this applies
only in the case where the instruction consists exclusively of
<a href="#element-map-entry"><code>xsl:map-entry</code></a> (and
<a href="#element-fallback"><code>xsl:fallback</code></a>)
children, and not in more complex cases where the map entries are
constructed dynamically (for example using a control flow
implemented using <a href=
"#element-choose"><code>xsl:choose</code></a>, <a href=
"#element-for-each"><code>xsl:for-each</code></a>, or <a href=
"#element-call-template"><code>xsl:call-template</code></a>).</p>
<p>For example, the following XPath expression is streamable,
despite making two downward selections:</p>
<div class="exampleInner">
<pre>
let $m := map{'price':xs:decimal(price), 'discount':xs:decimal(discount)} 
return ($m('price') - $m('discount'))
</pre></div>
<p>Analysis:</p>
<ol class="enumar">
<li>
<p>Because the <code>return</code> clause is motionless, the
<a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the
<code>let</code> expression is the sweep of the map expression (the
expression in curly braces).</p>
</li>
<li>
<p>The sweep of a map expression is the maximum sweep of its
key/value pairs.</p>
</li>
<li>
<p>For both key/value pairs, the key is <a title="motionless"
class="termref" href="#dt-motionless">motionless</a> and the value
is <a title="consuming" class="termref" href=
"#dt-consuming">consuming</a>.</p>
</li>
<li>
<p>The expression carefully atomizes both values, because retaining
references to streamed nodes in a variable is not permitted.</p>
</li>
<li>
<p>Therefore the map expression, and hence the expression as a
whole, is <a title="grounded" class="termref" href=
"#dt-grounded">grounded</a> and <a title="consuming" class=
"termref" href="#dt-consuming">consuming</a>.</p>
</li>
</ol>
<p>See also: <a href=
"#streamability-of-map-expressions"><i>19.8.7.15 Streamability of
map expressions</i></a>, <a href=
"#streamability-xsl-map"><i>19.8.4.23 Streamability of
xsl:map</i></a>, <a href=
"#streamability-xsl-map-entry"><i>19.8.4.24 Streamability of
xsl:map-entry</i></a></p>
</div>
<div class="div3">
<h4><a name="map-examples" id="map-examples"></a>21.1.6 <a href=
"#map-examples" style="text-decoration: none">Examples using
Maps</a></h4>
<p>This section gives some examples of where maps can be
useful.</p>
<div class="example">
<div class="exampleHeader"><a name="maps-with-iterate" id=
"maps-with-iterate"></a>Example: Using Maps with xsl:iterate</div>
<p>This example uses maps in conjunction with the <a href=
"#element-iterate"><code>xsl:iterate</code></a> instruction to find
the highest-earning employee in each department, in a single
streaming pass of an input document containing employee
records.</p>
<div class="exampleInner">
<pre>
&lt;xsl:stream href="employees.xml"&gt;
  &lt;xsl:iterate select="*/employee"&gt;
    &lt;xsl:param name="highest-earners" 
               as="map(xs:string, element(employee))" 
               select="map{}"/&gt;
    &lt;xsl:on-completion&gt;
      &lt;xsl:for-each select="map:keys($highest-earners)"&gt;
        &lt;department name="{.}"&gt;
          &lt;xsl:copy-of select="$highest-earners(.)"/&gt;
        &lt;/department&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:on-completion&gt;           
    &lt;xsl:variable name="this" select="copy-of(.)" as="element(employee)"/&gt; 
    &lt;xsl:next-iteration&gt;
      &lt;xsl:with-param name="highest-earners"
          select="let $existing := $highest-earners($this/department)
                  return if ($existing/salary gt $this/salary)
                         then $highest-earners
                         else map:put($highest-earners, $this/department, $this})"/&gt;
    &lt;/xsl:next-iteration&gt;
  &lt;/xsl:iterate&gt;
&lt;/xsl:stream&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="example-complex-numbers" id=
"example-complex-numbers"></a>Example: Using Maps to Implement
Complex Numbers</div>
<p>A complex number might be represented as a map with two entries,
the keys being the <code>xs:boolean</code> value <code>true</code>
for the real part, and the <code>xs:boolean</code> value
<code>false</code> for the imaginary part. A library for
manipulation of complex numbers might include functions such as the
following:</p>
<div class="exampleInner">
<pre>

&lt;xsl:variable name="REAL" static="yes" as="xs:int" select="0"/&gt; 
&lt;xsl:variable name="IMAG" static="yes" as="xs:int" select="1"/&gt; 
                     
&lt;xsl:function name="i:complex" as="map(xs:int, xs:double)"&gt;
  &lt;xsl:param name="real" as="xs:double"/&gt;
  &lt;xsl:param name="imaginary" as="xs:double"/&gt;
  &lt;xsl:sequence select="map{ $REAL : $real, $IMAG : $imaginary }"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:function name="i:real" as="xs:double"&gt;
  &lt;xsl:param name="complex" as="map(xs:int, xs:double)"/&gt;
  &lt;xsl:sequence select="$complex($REAL)"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:function name="i:imaginary" as="xs:double"&gt;
  &lt;xsl:param name="complex" as="map(xs:int, xs:double)"/&gt;
  &lt;xsl:sequence select="$complex($IMAG)"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:function name="i:add" as="map(xs:int, xs:double)"&gt;
  &lt;xsl:param name="arg1" as="map(xs:int, xs:double)"/&gt;
  &lt;xsl:param name="arg2" as="map(xs:int, xs:double)"/&gt;
  &lt;xsl:sequence select="i:complex(i:real($arg1)+i:real($arg2), 
                                  i:imaginary($arg1)+i:imaginary($arg2)"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:function name="i:multiply" as="map(xs:boolean, xs:double)"&gt;
  &lt;xsl:param name="arg1" as="map(xs:boolean, xs:double)"/&gt;
  &lt;xsl:param name="arg2" as="map(xs:boolean, xs:double)"/&gt;
  &lt;xsl:sequence select="i:complex(
      i:real($arg1)*i:real($arg2) - i:imaginary($arg1)*i:imaginary($arg2),
      i:real($arg1)*i:imaginary($arg2) + i:imaginary($arg1)*i:real($arg2))"/&gt;
&lt;/xsl:function&gt;
</pre></div>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="map-as-index" id=
"map-as-index"></a>Example: Using a Map as an Index</div>
<p>Given a set of <code>book</code> elements, it is possible to
construct an index in the form of a map allowing the books to be
retrieved by ISBN number.</p>
<p>Assume the book elements have the form:</p>
<div class="exampleInner">
<pre>
&lt;book&gt;
  &lt;isbn&gt;0470192747&lt;/isbn&gt;
  &lt;author&gt;Michael H. Kay&lt;/author&gt;
  &lt;publisher&gt;Wiley&lt;/publisher&gt;
  &lt;title&gt;XSLT 2.0 and XPath 2.0 Programmer's Reference&lt;/title&gt;
&lt;/book&gt;
</pre></div>
<p>An index may be constructed as follows:</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="isbn-index" as="map(xs:string, element(book))"
    select="map:merge(for $b in //book return map{$b/isbn : $b})"/&gt;
</pre></div>
<p>This index may then be used to retrieve the book for a given
ISBN using either of the expressions <code>map:get($isbn-index,
"0470192747")</code> or <code>$isbn-index("0470192747")</code>.</p>
<p>In this simple form, this replicates the functionality available
using <a href="#element-key"><code>xsl:key</code></a> and the
<a href="#func-key"><code>key</code></a> function. However, it also
provides capabilities not directly available using the <a href=
"#func-key"><code>key</code></a> function: for example, the index
can include <code>book</code> elements in multiple source
documents. It also allows processing of all the books using a
construct such as <code>&lt;xsl:for-each
select="map:keys($isbn-index)"&gt;</code></p>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="map-as-class" id=
"map-as-class"></a>Example: A Map containing Named Functions</div>
<p>As in JavaScript, a map whose keys are strings and whose
associated values are function items can be used in a similar way
to a class in object-oriented programming languages.</p>
<p>Suppose an application needs to handle customer order
information that may arrive in three different formats, with
different hierarchic arrangements:</p>
<ol class="enumar">
<li>
<p>Flat structure:</p>
<div class="exampleInner">
<pre>
&lt;customer id="c123"&gt;...&lt;/customer&gt;
&lt;product id="p789"&gt;...&lt;/product&gt;
&lt;order customer="c123" product="p789"&gt;...&lt;/order&gt;
</pre></div>
</li>
<li>
<p>Orders within customer elements:</p>
<div class="exampleInner">
<pre>
&lt;customer id="c123"&gt;
   &lt;order product="p789"&gt;...&lt;/order&gt;
&lt;/customer&gt;
&lt;product id="p789"&gt;...&lt;/product&gt;
</pre></div>
</li>
<li>
<p>Orders within product elements:</p>
<div class="exampleInner">
<pre>
&lt;customer id="c123"&gt;...&lt;/customer&gt;
&lt;product id="p789"&gt;
  &lt;order customer="c123"&gt;...&lt;/order&gt;
&lt;/product&gt;
</pre></div>
</li>
</ol>
<p>An application can isolate itself from these differences by
defining a set of functions to navigate the relationships between
customers, orders, and products: <code>orders-for-customer</code>,
<code>orders-for-product</code>, <code>customer-for-order</code>,
<code>product-for-order</code>. These functions can be implemented
in different ways for the three different input formats. For
example, with the first format the implementation might be:</p>
<div class="exampleInner">
<pre>
&lt;xsl:variable name="flat-input-functions" as="map(xs:string, function(*))*"
  select="map{
            'orders-for-customer' : 
                 function($c as element(customer)) as element(order)* 
                    {$c/../order[@customer=$c/@id]},
            'orders-for-product' : 
                 function($p as element(product)) as element(order)* 
                    {$p/../order[@product=$p/@id]},
            'customer-for-order' : 
                 function($o as element(order)) as element(customer) 
                    {$o/../customer[@id=$o/@customer]},
            'product-for-order' : 
                 function($o as element(order)) as element(product) 
                    {$o/../product[@id=$o/@product]} }                    
         "/&gt;
</pre></div>
<p>Having established which input format is in use, the application
can bind the appropriate implementation of these functions to a
variable such as <code>$input-navigator</code>, and can then
process the input using XPath expressions such as the following,
which selects all products for which there is no order:
<code>//product[empty($input-navigator("orders-for-product")(.))]</code></p>
</div>
</div>
</div>
<div class="div2">
<h3><a name="json" id="json"></a>21.2 <a href="#json" style=
"text-decoration: none">Processing JSON Data</a></h3>
<p>JSON is a popular format for exchange of structured data on the
web: it is specified in <span><a href="#rfc7159">[RFC
7159]</a></span>. This section describes facilities allowing JSON
data to be processed using XSLT.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>RFC7159 is taken as the definitive specification of JSON for the
purposes of this document. The RFC explains its relationship with
other JSON specifications such as <a href=
"#ECMA-404">[ECMA-404]</a>.</p>
</div>
<div class="div3">
<h4><a name="json-to-xml-mapping" id=
"json-to-xml-mapping"></a>21.2.1 <a href="#json-to-xml-mapping"
style="text-decoration: none">XML Representation of JSON</a></h4>
<p>This specification defines a mapping from JSON data to XML
(specifically, to XDM instances). A function <a href=
"#func-json-to-xml"><code>json-to-xml</code></a> is provided to
take a JSON string as input and convert it to the XML
representation. Two stylesheet modules are provided to perform the
reverse transformation: one produces JSON in compact linear form,
the other in indented form suitable for display, editing, or
printing.</p>
<p>The XML representation is designed to be capable of representing
any valid JSON text other than one that uses characters which are
not valid in XML. The transformation is lossless: that is, distinct
JSON texts convert to distinct XML representations. When converting
JSON to XML, options are provided to reject unsupported characters,
to replace them with a substitute character, or to leave them in
backslash-escaped form.</p>
<p>The following example demonstrates the correspondence of a JSON
text and the corresponding XML representation.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e61203" id=
"d7e61203"></a>Example: A JSON Text and its XML
Representation</div>
<p>Consider the following JSON text:</p>
<div class="exampleInner">
<pre>
{
  "desc"    : "Distances between several cities, in kilometers.",
  "updated" : "2014-02-04T18:50:45",
  "uptodate": true
  "author"  : null
  "cities"  : {
    "Brussels": [
      {"to": "London",    "distance": 322},
      {"to": "Paris",     "distance": 265},
      {"to": "Amsterdam", "distance": 173}
    ],
    "London": [
      {"to": "Brussels",  "distance": 322},
      {"to": "Paris",     "distance": 344},
      {"to": "Amsterdam", "distance": 358}
    ],
    "Paris": [
      {"to": "Brussels",  "distance": 265},
      {"to": "London",    "distance": 344},
      {"to": "Amsterdam", "distance": 431}
    ],
    "Amsterdam": [
      {"to": "Brussels",  "distance": 173},
      {"to": "London",    "distance": 358},
      {"to": "Paris",     "distance": 431}
    ]
  }
}
               
</pre></div>
<p>The XML representation of this text is as follows. Whitespace is
included in the XML representation for purposes of illustration,
and is ignored by the stylesheets that convert XML to JSON, but it
will not be present in the output of the <a href=
"#func-json-to-xml"><code>json-to-xml</code></a> function.</p>
<div class="exampleInner">
<pre>
  &lt;map xmlns="http://www.w3.org/2013/XSL/json"&gt;
    &lt;string key='desc'&gt;Distances between several cities, in kilometers.&lt;/string&gt;
    &lt;string key='updated'&gt;2014-02-04T18:50:45&lt;/string&gt;
    &lt;boolean key="uptodate"&gt;true&lt;/boolean&gt;
    &lt;null key="author"/&gt;
    &lt;map key='cities'&gt;
      &lt;array key="Brussels"&gt;
        &lt;map&gt;
            &lt;string key="to"&gt;London&lt;/string&gt;
            &lt;number key="distance"&gt;322&lt;/number&gt;
        &lt;/map&gt; 
        &lt;map&gt;
            &lt;string key="to"&gt;Paris&lt;/string&gt;
            &lt;number key="distance"&gt;265&lt;/number&gt;
        &lt;/map&gt; 
        &lt;map&gt;
            &lt;string key="to"&gt;Amsterdam&lt;/string&gt;
            &lt;number key="distance"&gt;173&lt;/number&gt;
        &lt;/map&gt; 
      &lt;/array&gt;
      &lt;array key="London"&gt;
        &lt;map&gt;
            &lt;string key="to"&gt;Brussels&lt;/string&gt;
            &lt;number key="distance"&gt;322&lt;/number&gt;
        &lt;/map&gt; 
        &lt;map&gt;
            &lt;string key="to"&gt;Paris&lt;/string&gt;
            &lt;number key="distance"&gt;344&lt;/number&gt;
        &lt;/map&gt; 
        &lt;map&gt;
            &lt;string key="to"&gt;Amsterdam&lt;/string&gt;
            &lt;number key="distance"&gt;358&lt;/number&gt;
        &lt;/map&gt; 
      &lt;/array&gt;
      &lt;array key="Paris"&gt;
        &lt;map&gt;
            &lt;string key="to"&gt;Brussels&lt;/string&gt;
            &lt;number key="distance"&gt;265&lt;/number&gt;
        &lt;/map&gt; 
        &lt;map&gt;
            &lt;string key="to"&gt;London&lt;/string&gt;
            &lt;number key="distance"&gt;344&lt;/number&gt;
        &lt;/map&gt; 
        &lt;map&gt;
            &lt;string key="to"&gt;Amsterdam&lt;/string&gt;
            &lt;number key="distance"&gt;431&lt;/number&gt;
        &lt;/map&gt;  
      &lt;/array&gt;
      &lt;array key="Amsterdam"&gt;
        &lt;map&gt;
            &lt;string key="to"&gt;Brussels&lt;/string&gt;
            &lt;number key="distance"&gt;173&lt;/number&gt;
        &lt;/map&gt; 
        &lt;map&gt;
            &lt;string key="to"&gt;London&lt;/string&gt;
            &lt;number key="distance"&gt;358&lt;/number&gt;
        &lt;/map&gt; 
        &lt;map&gt;
            &lt;string key="to"&gt;Paris&lt;/string&gt;
            &lt;number key="distance"&gt;431&lt;/number&gt;
        &lt;/map&gt;
      &lt;/array&gt;
    &lt;/map&gt;  
  &lt;/map&gt;
</pre></div>
</div>
<p>An XSD 1.0 schema for the XML representation is provided in
<a href="#schema-for-json"><i>B.1 Schema for the XML Representation
of JSON</i></a>. It is not necessary to import this schema (using
<a href=
"#element-import-schema"><code>xsl:import-schema</code></a>) unless
the stylesheet makes explicit reference to the components defined
in the schema. If the stylesheet does import a schema for the
namespace <code>http://www.w3.org/2013/XSL/json</code>, then:</p>
<ol class="enumar">
<li>
<p>The processor (if it is schema-aware) <span class=
"verb">must</span> recognize an <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>
declaration for this namespace, whether or not the
<code>schema-location</code> is supplied.</p>
</li>
<li>
<p>If a <code>schema-location</code> is provided, then the schema
document at that location <span class="verb">must</span> be
equivalent to the schema document at <a href=
"#schema-for-json"><i>B.1 Schema for the XML Representation of
JSON</i></a>; the effect if it is not is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a></p>
</li>
</ol>
<p>The rules governing the mapping from JSON to XML are as follows.
In these rules, the phrase "an element named N" is to be
interpreted as meaning "an element node whose local name is N and
whose namespace URI is
<code>http://www.w3.org/2013/XSL/json</code>"</p>
<ol class="enumar">
<li>
<p>The JSON value <code>null</code> is represented by an element
named <code>null</code>, with empty content.</p>
</li>
<li>
<p>The JSON values <code>true</code> and <code>false</code> are
represented by an element named <code>boolean</code>, with content
conforming to the type <code>xs:boolean</code>.</p>
</li>
<li>
<p>A JSON number is represented by an element named
<code>number</code>, with content conforming to the type
<code>xs:double</code>, with the additional restriction that the
value must not be positive or negative infinity, nor
<code>NaN</code>.</p>
</li>
<li>
<p>A JSON string is represented by an element named
<code>string</code>, with content conforming to the type
<code>xs:string</code>.</p>
</li>
<li>
<p>A JSON array is represented by an element named
<code>array</code>. The content is a sequence of child elements
representing the members of the array in order, each such element
being the representation of the array member obtained by applying
these rules recursively.</p>
</li>
<li>
<p>A JSON object is represented by an element named
<code>map</code>. The content is a sequence of child elements each
of which represents one of the name/value pairs in the object. The
representation of the name/value pair <var>N:V</var> is obtained by
taking the element that represents the value <var>V</var> (by
applying these rules recursively) and adding an attribute with name
<code>key</code> (in no namespace), whose value is <var>N</var> as
an instance of <code>xs:string</code>.</p>
</li>
</ol>
<p>The attribute <code>escaped="true"</code> may be specified on a
<code>string</code> element to indicate that the string value
contains backslash-escaped characters that are to be interpreted
according to the JSON rules. The attribute
<code>escaped-key="true"</code> may be specified on any element
with a <code>key</code> attribute to indicate that the key contains
backslash-escaped characters that are to be interpreted according
to the JSON rules. Both attributes have the default value
<code>false</code>.</p>
<p>The JSON grammar for <code>number</code> is a subset of the
lexical space of the XSD type <code>xs:double</code>. The mapping
from JSON <code>number</code> values to <code>xs:double</code>
values is defined by the XPath rules for casting from
<code>xs:string</code> to <code>xs:double</code>. Note that these
rules will never generate an error for out-of-range values; instead
very large or very small values will be converted to
<code>+INF</code> or <code>-INF</code>. Since JSON does not impose
limits on the range or precision of numbers, the conversion is not
guaranteed to be lossless.</p>
<p>Although the order of entries in a JSON object is generally
considered to have no significance, the function
<code>json-to-xml</code> and the stylesheets that perform the
reverse transformation both retain order.</p>
<p>The XDM representation of a JSON value may either be untyped
(all elements annotated as <code>xs:untyped</code>, attributes as
<code>xs:untypedAtomic</code>), or it may be typed. If it is typed,
then it <span class="verb">must</span> have the type annotations
obtained by validating the untyped representation against the
schema given in <a href="#schema-for-json"><i>B.1 Schema for the
XML Representation of JSON</i></a>. If it is untyped, then it
<span class="verb">must</span> be an XDM instance such that
validation against this schema would succeed.</p>
</div>
<div class="div3">
<h4><a name="func-json-to-xml" id="func-json-to-xml"></a>21.2.2
<a href="#func-json-to-xml" style=
"text-decoration: none">fn:json-to-xml</a></h4>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Parses a string supplied in the form of a JSON text, returning
the results in the form of an XML <span>document node</span>.</p>
</dd>
<dt class="label">Signatures</dt>
<dd>
<p><a name="function-json-to-xml" id=
"function-json-to-xml"></a></p>
<div class="proto"><code class=
"function">json-to-xml</code>(<code class=
"arg">$json-text</code><code class=
"as">&#160;as&#160;</code><code class=
"type">xs:string</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">document-node()</code></div>
<div class="proto">
<table border="0" cellpadding="0" cellspacing="0" summary=
"Function signature for :json-to-xml function">
<tr>
<td valign="baseline" rowspan="2"><code class=
"function">json-to-xml</code>(</td>
<td valign="baseline"><code class="arg">$json-text</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class="type">xs:string</code>,</td>
</tr>
<tr>
<td valign="baseline"><code class="arg">$options</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class=
"type">map(*)</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">document-node()</code></td>
</tr>
</table>
</div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-nondeterministic">nondeterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>.
It depends on static base uri.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>The effect of the one-argument form of this function is the same
as calling the two-argument form with an empty map as the value of
the <code>$options</code> argument.</p>
<p>The first argument is a JSON-text (see below) in the form of a
string. The function parses this string to return an XDM node.</p>
<p>The <code>$options</code> argument can be used to control the
way in which the parsing takes place. The value of the argument is
a map. The options defined in this specification have keys that are
strings. The effect of any map entries whose keys are not defined
in this specification is implementation-defined;
implementation-defined options <span class="verb">should</span> use
QNames as keys. Implementations <span class="verb">must</span>
ignore any entries in the map whose keys are not defined in this
specification, unless the key has a specific <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>
meaning.</p>
<p>The entries that may appear in the <code>$options</code> map are
as follows. The keys are <code>xs:string</code> values:</p>
<table border="1" cellpadding="5" width="100%">
<thead>
<tr>
<th colspan="1" align="left" valign="top">Key</th>
<th colspan="1" align="left" valign="top">Value</th>
<th colspan="1" align="left" valign="top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td rowspan="3" align="left" valign="top"><code>liberal</code></td>
<td colspan="2" align="left" valign="top">Determines whether
deviations from the syntax of RFC7159 are permitted. The value
<span class="verb">must</span> be a boolean.</td>
</tr>
<tr>
<td align="left" valign="top"><code>false</code></td>
<td align="left" valign="top">The input <span class=
"verb">must</span> consist of an optional byte order mark (which is
ignored) followed by a string that conforms to the grammar of
<code>JSON-text</code> in <a href="#rfc7159">[RFC 7159]</a>. An
error <span class="verb">must</span> be raised (see below) if the
input does not conform to the grammar.</td>
</tr>
<tr>
<td align="left" valign="top"><code>true</code></td>
<td align="left" valign="top">The input <span class=
"verb">may</span> contain deviations from the grammar of <a href=
"#rfc7159">[RFC 7159]</a>, which are handled in an <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> way. (Note:
some popular extensions include allowing quotes on keys to be
omitted, allowing a comma to appear after the last item in an
array, allowing leading zeroes in numbers, and allowing control
characters such as tab and newline to be present in unescaped
form.) Since the extensions accepted are implementation-defined, an
error <span class="verb">may</span> be raised (see below) if the
input does not conform to the grammar.</td>
</tr>
<tr>
<td rowspan="3" align="left" valign="top">
<code>validate</code></td>
<td colspan="2" align="left" valign="top">If the
<code>$options</code> map contains an entry with the key
<code>"validate"</code>, then the value <span class=
"verb">must</span> be an <code>xs:boolean</code>. The default is
<code>true</code> for a schema-aware processor, <code>false</code>
for a non-schema-aware processor. If the value <code>true</code> is
supplied and the processor is not schema-aware, a dynamic error
results <span class="error">[see <a href="#err-XTDE3245">ERR
XTDE3245</a>]</span>. It is not necessary that the containing
stylesheet should import the relevant schema.</td>
</tr>
<tr>
<td align="left" valign="top"><code>true</code></td>
<td align="left" valign="top">Indicates that the resulting XDM
instance must be typed; that is, the element and attribute nodes
must carry the type annotations that result from validation against
the schema given at <a href="#schema-for-json"><i>B.1 Schema for
the XML Representation of JSON</i></a>, or against an <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> schema if
the <span><code>liberal</code> option has the value
<code>yes</code></span>.</td>
</tr>
<tr>
<td align="left" valign="top"><code>false</code></td>
<td align="left" valign="top">Indicates that the XDM instance must
be untyped.</td>
</tr>
<tr>
<td rowspan="3" align="left" valign="top">
<code>unescape</code></td>
<td colspan="2" align="left" valign="top">If the
<code>$options</code> map contains an entry with the key
<code>"unescape"</code>, then the value <span class=
"verb">must</span> be an <code>xs:boolean</code>. The value
determines whether escape sequences (marked by a backslash) in the
input are expanded. The default is <code>true</code>.</td>
</tr>
<tr>
<td align="left" valign="top"><code>false</code></td>
<td align="left" valign="top">In the result, any
<code>string</code> element whose string value contains a backslash
character must have the attribute value
<code>escaped="true"</code>, and any element that contains a
<code>key</code> attribute whose string value contains a backslash
character must have the attribute <code>escaped-key="true"</code>.
(The value of the <code>escaped</code> and <code>key-escaped</code>
attributes is immaterial when there is no backslash present, and it
is never necessary to include either attribute when the value is
<code>false</code>.) The escaped representation in this case
<span class="verb">may</span> be used for any character, whether or
not it was escaped in the original JSON input.</td>
</tr>
<tr>
<td align="left" valign="top"><code>true</code></td>
<td align="left" valign="top">The attributes <code>escaped</code>
and <code>escaped-key</code> will never be present with the value
<code>true</code>. If the input contains escape sequences
representing characters or codepoints that are not valid characters
in the version of XML supported by the implementation, <span>such
characters are replaced by the Unicode replacement character
(xFFFD), or as described in the next paragraph</span>.</td>
</tr>
<tr>
<td rowspan="2" align="left" valign="top">
<code>fallback</code></td>
<td colspan="2" align="left" valign="top">Provides a function which
is called when an invalid character is encountered.</td>
</tr>
<tr>
<td align="left" valign="top">Function with signature
<code>function(xs:string) as xs:string</code></td>
<td align="left" valign="top">When an invalid character is
encountered this function is called supplying the escaped form of
the character as the argument. The function returns a string which
is inserted into the result in place of the invalid character. The
function also has the option of raising a dynamic error.</td>
</tr>
</tbody>
</table>
<p>The various structures that can occur in JSON are transformed
recursively to XDM values according to the rules given in <a href=
"#json-to-xml-mapping"><i>21.2.1 XML Representation of
JSON</i></a>.</p>
<p>The function returns <span>a document node, whose only child
is</span> the element node representing the outermost construct in
the JSON text.</p>
<p>The function is not <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>:
that is, if the function is called twice with the same arguments,
it is <a title="implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a> whether
the same node is returned on both occasions.</p>
<p>The base URI of the returned document node is taken from the
static base URI of the function call.</p>
</dd>
<dt class="label">Error Conditions</dt>
<dd>
<p><a name="err-XTDE3240" id="err-XTDE3240"><span class=
"error">[ERR XTDE3240]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
value of <code>$input</code> does not conform to the JSON grammar
<span>as defined by <a href="#rfc7159">[RFC 7159]</a>, allowing
implementation-defined extensions if the <code>liberal</code>
option is set to <code>yes</code></span>.</p>
<p><a name="err-XTDE3245" id="err-XTDE3245"><span class=
"error">[ERR XTDE3245]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
value of the <code>validate</code> option is <code>true</code> and
the processor is not schema-aware.</p>
<p><a name="err-XTDE3250" id="err-XTDE3250"><span class=
"error">[ERR XTDE3250]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
value of <code>$input</code> contains an escaped representation of
a character (or codepoint) that is not a valid character in the
version of XML supported by the implementation, unless the
<code>unescape</code> option is set to false.</p>
<p><a name="err-XTDE3260" id="err-XTDE3260"><span class=
"error">[ERR XTDE3260]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
value of <code>$options</code> includes an entry whose key is
<span><code>liberal</code>, <code>validate</code>,
<code>unescape</code>, or <code>fallback</code>, and whose value is
not a permitted value for that key</span>.</p>
</dd>
<dt class="label">Notes</dt>
<dd>
<p>To read a JSON file, this function can be used in conjunction
with the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-unparsed-text"><code>
unparsed-text</code></a><sup><small>FO30</small></sup>
function.</p>
<p>Many JSON implementations allow commas to be used after the last
item in an object or array, although the specification does not
permit it. The option <code>spec="liberal"</code> is provided to
allow such deviations from the specification to be accepted. Some
JSON implementations also allow constructors such as <code>new
Date("2000-12-13")</code> to appear as values: specifying
<code>spec="liberal"</code> allows such extensions to be accepted,
but does not guarantee it. If such extensions are accepted, the
resulting value is implementation-defined, and will not necessarily
conform to the schema at <a href="#schema-for-json"><i>B.1 Schema
for the XML Representation of JSON</i></a>.</p>
</dd>
<dt class="label">Examples</dt>
<dd>
<p>The expression <code>json-to-xml('{"x": 1, "y":
[3,4,5]}')</code> returns <code>&lt;map
xmlns="http://www.w3.org/2013/XSL/json"&gt; &lt;number
key="x"&gt;1&lt;/number&gt; &lt;array key="y"&gt;
&lt;number&gt;3&lt;/number&gt; &lt;number&gt;4&lt;/number&gt;
&lt;number&gt;5&lt;/number&gt; &lt;/array&gt;
&lt;/map&gt;</code>.</p>
<p>The expression <code>json-to-xml('"abcd"', map{'liberal':
false()})</code> returns <code>&lt;string
xmlns="http://www.w3.org/2013/XSL/json"&gt;abcd&lt;/string&gt;</code>.</p>
<p>The expression <code>json-to-xml('{"x": "\\", "y":
"\u0025"}')</code> returns one of the following: <code>&lt;map
xmlns="http://www.w3.org/2013/XSL/json"&gt; &lt;string
key="x"&gt;\&lt;/string&gt; &lt;string key="y"&gt;%&lt;/string&gt;
&lt;/map&gt;</code> or <code>map{"x": "\","y": "%"}</code>.</p>
<p>The expression <code>json-to-xml('{"x": "\\", "y": "\u0025"}',
map{'unescape': false()})</code> returns <code>&lt;map
xmlns="http://www.w3.org/2013/XSL/json"&gt; &lt;string
escaped="true" key="x"&gt;\\&lt;/string&gt; &lt;string
escaped="true" key="y"&gt;\u0025&lt;/string&gt;
&lt;/map&gt;</code>.</p>
<p>The following example illustrates use of the fallback function
to handle characters that are invalid in XML.</p>
<div class="exampleInner">
<pre>
 &lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:err="http://example.com/ns/errors"
                xmlns:f="http://example.com/ns/functions"
                xmlns:xs="http://www.w3.org/2001/XMLSchema"
                exclude-result-prefixes="xs err f"
                version="3.0"&gt;

&lt;xsl:template match="someElement"&gt;
  &lt;xsl:variable name="jsonstr" 
                select="unparsed-text('http://example.com/endpoint')"/&gt;
  &lt;xsl:variable name="options" 
                select="map{'liberal':true(), 'fallback':f:convert#1}"/&gt;
  &lt;xsl:variable name="json" 
                select="json-to-xml($jsonstr, $options)"/&gt;

  &lt;!-- now do something with that json --&gt;
&lt;/xsl:template&gt;

&lt;xsl:function name="f:convert" as="xs:string"&gt;
  &lt;xsl:param name="char" as="xs:string"/&gt;
    &lt;xsl:variable name="c0chars" select="{
     '\u0000':'[NUL]',
     '\u0001':'[SOH]',
     '\u0002':'[STX]',
     ...
     '\u001E':'[RS]',
     '\u001F':'[US]'}"/&gt;
  &lt;xsl:variable name="replacement" select="$c0chars($char)"/&gt;
  &lt;xsl:sequence select="if (exists($replacement)) then $replacement
      else error(xs:QName('err:invalid-char'), 
           'Error: '||$char||' is not a terminal control char.'))"/&gt;
&lt;/xsl:function&gt;
&lt;/xsl:stylesheet&gt;
</pre></div>
</dd>
</dl>
</div>
<div class="div3">
<h4><a name="func-xml-to-json" id="func-xml-to-json"></a>21.2.3
<a href="#func-xml-to-json" style=
"text-decoration: none">fn:xml-to-json</a></h4>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Converts an XML tree, whose format corresponds to the XML
representation of JSON defined in this specification, into a string
conforming to the JSON grammar.</p>
</dd>
<dt class="label">Signatures</dt>
<dd>
<p><a name="function-xml-to-json" id=
"function-xml-to-json"></a></p>
<div class="proto"><code class=
"function">xml-to-json</code>(<code class=
"arg">$input</code><code class=
"as">&#160;as&#160;</code><code class=
"type">node()</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">xs:string</code></div>
<div class="proto">
<table border="0" cellpadding="0" cellspacing="0" summary=
"Function signature for :xml-to-json function">
<tr>
<td valign="baseline" rowspan="2"><code class=
"function">xml-to-json</code>(</td>
<td valign="baseline"><code class="arg">$input</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class="type">node()</code>,</td>
</tr>
<tr>
<td valign="baseline"><code class="arg">$options</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class=
"type">map(*)</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">xs:string</code></td>
</tr>
</table>
</div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-independent">context-independent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>The effect of the one-argument form of this function is the same
as calling the two-argument form with an empty map as the value of
the <code>$options</code> argument.</p>
<p>The first argument is a node; the subtree rooted at this node
will typically be the XML representation of a JSON document as
defined in <a href="#json-to-xml-mapping"><i>21.2.1 XML
Representation of JSON</i></a>.</p>
<p>The <code>$options</code> argument can be used to control the
way in which the conversion takes place. The value of the argument
is a map. The options defined in this specification have keys that
are strings. The effect of any map entries whose keys are not
defined in this specification is <a title="implementation-defined"
class="termref" href=
"#dt-implementation-defined">implementation-defined</a>;
implementation-defined options <span class="verb">should</span> use
QNames as keys. Implementations <span class="verb">must</span>
ignore any entries in the map whose keys are not defined in this
specification, unless the key has a specific <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>
meaning.</p>
<p>The entries that may appear in the <code>$options</code> map are
as follows. The keys are <code>xs:string</code> values:</p>
<table border="1" cellpadding="5" width="100%">
<thead>
<tr>
<th colspan="1" align="left" valign="top">Key</th>
<th colspan="1" align="left" valign="top">Value</th>
<th colspan="1" align="left" valign="top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td rowspan="3" align="left" valign="top"><code>indent</code></td>
<td colspan="2" align="left" valign="top">Determines whether
additional whitespace should be added to the output to improve
readability. The value <span class="verb">must</span> be a
boolean.</td>
</tr>
<tr>
<td align="left" valign="top"><code>false</code></td>
<td align="left" valign="top">The processor must not insert any
insignificant whitespace between JSON tokens.</td>
</tr>
<tr>
<td align="left" valign="top"><code>true</code></td>
<td align="left" valign="top">The processor <span class=
"verb">may</span> insert whitespace between JSON tokens in order to
improve readability. The specification imposes no constraints on
how this is done.</td>
</tr>
<tr>
<td rowspan="2" align="left" valign="top">
<code>fallback</code></td>
<td colspan="2" align="left" valign="top">Provides a function which
is called when an invalid element is encountered.</td>
</tr>
<tr>
<td align="left" valign="top">Function with signature
<code>function(node()) as xs:string</code></td>
<td align="left" valign="top">When a node is encountered that is
not valid against the schema for the XML representation of JSON,
this function is called, and the resulting string is added to the
output. If no fallback function is provided, a dynamic error occurs
in this situation.</td>
</tr>
</tbody>
</table>
<p>The node supplied as <code>$input</code> must be one of the
following:</p>
<ol class="enumar">
<li>An element node whose name matches the name of a global element
declaration in the schema given in <a href=
"#schema-for-json"><i>B.1 Schema for the XML Representation of
JSON</i></a> and whose type annotation matches the type of that
element declaration (indicating that the element has been validated
against this schema).</li>
<li>An element node whose name matches the name of a global element
declaration in the schema given in <a href=
"#schema-for-json"><i>B.1 Schema for the XML Representation of
JSON</i></a>, whose type annotation is <code>xs:untyped</code>, and
whose content is such that validation against the schema given in
<a href="#schema-for-json"><i>B.1 Schema for the XML Representation
of JSON</i></a> would succeed.</li>
<li>A document node having exactly one element child and no text
node children, where the element child satisfies one of the two
conditions above.</li>
</ol>
<p>Nodes in the input tree are handled by applying the following
rules, recursively. In these rules the term "an element named
<var>N</var>" means "an element node whose local name is
<var>N</var> and whose namespace URI is
<code>http://www.w3.org/2013/XSL/json</code>.</p>
<ol class="enumar">
<li>
<p>A document node having a single element node child is processed
by processing that child.</p>
</li>
<li>
<p>An element named <code>null</code> results in the output
<code>null</code>.</p>
</li>
<li>
<p>An element named <code>boolean</code> results in the output
<code>true</code> or <code>false</code> depending on the content of
the element.</p>
</li>
<li>
<p>An named <code>number</code> results in the output of the string
value of the element.</p>
</li>
<li>
<p>An element named <code>string</code> results in the output of
the string value of the element, enclosed in quotation marks, with
any special characters in the string escaped as described
below.</p>
</li>
<li>
<p>An element named <code>array</code> results in the output of the
children of the <code>array</code> element, each processed by
applying these rules recursively: the items in the resulting list
are enclosed between square brackets, and separated by commas.</p>
</li>
<li>
<p>An element named <code>map</code> results in the output of a
sequence of map entries corresponding to the children of the
<code>map</code> element, enclosed between curly braces and
separated by commas. Each entry comprises the value of the
<code>key</code> attribute of the child element, enclosed in
quotation marks and escaped as described below, followed by a
colon, followed by the result of processing the child element by
applying these rules recursively.</p>
</li>
<li>
<p>Comments, processing instructions, and whitespace text nodes are
ignored.</p>
</li>
<li>
<p>Any other node (including invalid elements and elements with
unrecognized names) is processed as follows:</p>
<ol class="enumla">
<li>
<p>If there is a fallback function, the fallback function is called
with a deep copy of that node as its argument, and the returned
string is output.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The node is copied to preserve streamability.</p>
</div>
</li>
<li>
<p>Otherwise, a dynamic error is reported (see below).</p>
</li>
</ol>
</li>
</ol>
<p>Strings are escaped as follows:</p>
<ul>
<li>
<p>If the attribute <code>escaped="true"</code> is present for a
string value, or <code>escaped-key="true"</code> for a key value,
then any valid JSON escape sequence present in the string is copied
unchanged to the output, and any invalid JSON escape sequence
results in a dynamic error.</p>
</li>
<li>
<p>In the absence of the attribute <code>escaped="true"</code> for
a string value, or <code>escaped-key="true"</code> for a key value,
any occurrence of backslash is replaced by <code>\\</code>.</p>
</li>
<li>
<p>Regardless of the value of the <code>escaped</code> or
<code>escaped-key</code> attributes, any occurrence of quotation
mark, backspace, form-feed, newline, carriage return, or tab is
replaced by <code>\"</code>, <code>\b</code>, <code>\f</code>,
<code>\n</code>, <code>\r</code>, or <code>\t</code> respectively,
and any other codepoint in the range 1-31 or 127-159 is replaced by
an escape in the form <code>\uHHHH</code> where <code>HHHH</code>
is the hexadecimal representation of the codepoint value.</p>
</li>
</ul>
</dd>
<dt class="label">Error Conditions</dt>
<dd>
<p><a name="err-XTDE3255" id="err-XTDE3255"><span class=
"error">[ERR XTDE3255]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
value of <code>$options</code> includes an entry whose key is
<code>indent</code>, <code>validate</code>, <code>unescape</code>,
or <code>fallback</code>, and whose value is not a permitted value
for that key.</p>
<p><a name="err-XTDE3265" id="err-XTDE3265"><span class=
"error">[ERR XTDE3265]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
value of <code>$input</code> is not valid according to the schema
for the XML representation of JSON.</p>
</dd>
</dl>
</div>
<div class="div3">
<h4><a name="xml-to-json-transformation" id=
"xml-to-json-transformation"></a>21.2.4 <a href=
"#xml-to-json-transformation" style=
"text-decoration: none">Transforming XML to JSON</a></h4>
<p>Given an XML structure that does not use the XML representation
of JSON defined in <a href="#json-to-xml-mapping"><i>21.2.1 XML
Representation of JSON</i></a>, there are two practical ways to
convert it to JSON: either perform a transformation to the XML
representation of JSON and then call the <a href=
"#func-xml-to-json"><code>xml-to-json</code></a> function; or
transform it to JSON directly by using custom template rules.</p>
<p>To assist with the second approach, a stylesheet is provided in
<a href="#xml-to-json-stylesheet"><i>B.2 Stylesheet for converting
XML to JSON (without indentation)</i></a>. This stylesheet includes
a function <code>j:xml-to-json</code> which, apart from being in a
different namespace, is functionally identical to the <a href=
"#func-xml-to-json"><code>xml-to-json</code></a> function described
in the previous section. The implementation of the function is
exposed, using template rules to perform a recursive descent of the
supplied input, and the behavior of the function can therefore be
customized (typically by importing the stylesheet and adding
additional template rules) to handle arbitrary XML input.</p>
<p>The stylesheet is provided under the W3C software license for
the convenience of users. There is no requirement for any
conformant XSLT processor to make this stylesheet available.
Processors <span class="verb">may</span> implement the <a href=
"#func-xml-to-json"><code>xml-to-json</code></a> function by
invoking this stylesheet or something similar, but there is no
requirement to do so.</p>
</div>
</div>
</div>
<div class="div1">
<h2><a name="diagnostics" id="diagnostics"></a>22 <a href=
"#diagnostics" style="text-decoration: none">Diagnostics</a></h2>
<div class="div2">
<h3><a name="message" id="message"></a>22.1 <a href="#message"
style="text-decoration: none">Messages</a></h3>
<p class="element-syntax"><a name="element-message" id=
"element-message"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:message<br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;terminate? = { <var>boolean</var> }<br />
&#160;&#160;error-code? = { <var>eqname</var> }&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:message&gt;</code></p>
<p>The <a href="#element-message"><code>xsl:message</code></a>
instruction sends a message in an <a title="implementation-defined"
class="termref" href=
"#dt-implementation-defined">implementation-defined</a> way. The
<a href="#element-message"><code>xsl:message</code></a> instruction
causes the creation of a new document, which is typically
serialized and output to an <a title="implementation-defined"
class="termref" href=
"#dt-implementation-defined">implementation-defined</a>
destination. The result of the <a href=
"#element-message"><code>xsl:message</code></a> instruction is an
empty sequence.</p>
<p>The content of the message may be specified by using either or
both of the optional <code>select</code> attribute and the
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> that forms the
content of the <a href=
"#element-message"><code>xsl:message</code></a> instruction.</p>
<p>If the <a href="#element-message"><code>xsl:message</code></a>
instruction contains a <a title="sequence constructor" class=
"termref" href="#dt-sequence-constructor">sequence constructor</a>,
then the sequence obtained by evaluating this sequence constructor
is used to construct the content of the new document node, as
described in <a href="#constructing-complex-content"><i>5.8.1
Constructing Complex Content</i></a>.</p>
<p>If the <a href="#element-message"><code>xsl:message</code></a>
instruction has a <code>select</code> attribute, then the value of
the attribute <span class="verb">must</span> be an XPath
expression. The effect of the <a href=
"#element-message"><code>xsl:message</code></a> instruction is then
the same as if a single <a href=
"#element-copy-of"><code>xsl:copy-of</code></a> instruction with
this <code>select</code> attribute were added to the start of the
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>.</p>
<p>If the <a href="#element-message"><code>xsl:message</code></a>
instruction has no content and no <code>select</code> attribute,
then an empty message is produced.</p>
<p>The tree produced by the <a href=
"#element-message"><code>xsl:message</code></a> instruction is not
technically a <a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a>. The tree has no URI
and processors are not <span class="verb">required</span> to make
the tree accessible to applications.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In many cases, the XML document produced using <a href=
"#element-message"><code>xsl:message</code></a> will consist of a
document node owning a single text node. However, it may contain a
more complex structure.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>An implementation might implement <a href=
"#element-message"><code>xsl:message</code></a> by popping up an
alert box or by writing to a log file. Because the order of
execution of instructions is implementation-defined, the order in
which such messages appear is not predictable.</p>
</div>
<p>The <code>terminate</code> attribute is interpreted as an
<a title="attribute value template" class="termref" href=
"#dt-attribute-value-template">attribute value template</a>.</p>
<p>If the <a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the
<code>terminate</code> attribute is <code>yes</code>, then the
<a title="processor" class="termref" href=
"#dt-processor">processor</a> <span class="verb">must</span>
<span>signal a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a></span> after sending the
message. <span>This error may be caught in the same way as any
other dynamic error using <a href=
"#element-catch"><code>xsl:catch</code></a>.</span> The default
value is <code>no</code>. Note that because the order of evaluation
of instructions is <a title="implementation-dependent" class=
"termref" href=
"#dt-implementation-dependent">implementation-dependent</a>, this
gives no guarantee that any particular instruction will or will not
be evaluated before processing terminates.</p>
<p>The optional <code>error-code</code> attribute may be used to
indicate the error code associated with the message. This may be
used irrespective of the value of <code>terminate</code>. The error
code is an <span><a title="EQName" class="termref" href=
"#dt-eqname">EQName</a></span>. If no error code is specified, or
if the value is not a valid EQName, the error code will have local
part <code>XTMM9000</code> and namespace URI
<code>http://www.w3.org/2005/xqt-errors</code>. User-defined error
codes <span class="verb">should</span> be in a namespace other than
<code>http://www.w3.org/2005/xqt-errors</code>. When the value of
<code>terminate</code> is <code>yes</code>, the error code may be
matched in an <a href="#element-catch"><code>xsl:catch</code></a>
element to catch the error and cause processing to continue
normally.</p>
<p><a name="err-XTMM9000" id="err-XTMM9000"><span class=
"error">[ERR XTMM9000]</span></a> When a transformation is
terminated by use of <code>xsl:message terminate="yes"</code>, the
effect is the same as when a <a title="dynamic error" class=
"termref" href="#dt-dynamic-error">dynamic error</a> occurs during
the transformation. <span>The default error code is
<code>XTMM9000</code>; this may be overridden using the
<code>error-code</code> attribute of the <a href=
"#element-message"><code>xsl:message</code></a>
instruction.</span></p>
<div class="example">
<div class="exampleHeader"><a name="d7e62429" id=
"d7e62429"></a>Example: Localizing Messages</div>
<p>One convenient way to do localization is to put the localized
information (message text, etc.) in an XML document, which becomes
an additional input file to the <a title="stylesheet" class=
"termref" href="#dt-stylesheet">stylesheet</a>. For example,
suppose messages for a language <code><var>L</var></code> are
stored in an XML file <code>resources/<var>L</var>.xml</code> in
the form:</p>
<div class="exampleInner">
<pre>
&lt;messages&gt;
  &lt;message name="problem"&gt;A problem was detected.&lt;/message&gt;
  &lt;message name="error"&gt;An error was detected.&lt;/message&gt;
&lt;/messages&gt;
</pre></div>
<p>Then a stylesheet could use the following approach to localize
messages:</p>
<div class="exampleInner">
<pre>
&lt;xsl:param name="lang" select="'en'"/&gt;
&lt;xsl:variable name="messages"
  select="document(concat('resources/', $lang, '.xml'))/messages"/&gt;

&lt;xsl:template name="localized-message"&gt;
  &lt;xsl:param name="name"/&gt;
  &lt;xsl:message select="string($messages/message[@name=$name])"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template name="problem"&gt;
  &lt;xsl:call-template name="localized-message"&gt;
    &lt;xsl:with-param name="name"&gt;problem&lt;/xsl:with-param&gt;
  &lt;/xsl:call-template&gt;
&lt;/xsl:template&gt;
</pre></div>
</div>
<p>Any <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> that occurs while evaluating
the <code>select</code> expression or the contained <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>, and any
<a title="serialization error" class="termref" href=
"#dt-serialization-error">serialization error</a> that occurs while
processing the result, <span>does not cause the transformation to
fail; at worst, it means that no message is output, or that the
only message that is output is one that relates to the error that
occurred.</span>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>An example of such an error is the serialization error that
occurs when processing the instruction <code>&lt;xsl:message
select="@code"/&gt;</code> (on the grounds that free-standing
attributes cannot be serialized). Making such errors recoverable
means that it is implementation-defined whether or not they are
signaled to the user and whether they cause termination of the
transformation. If the processor chooses to recover from the error,
the content of any resulting message is
implementation-dependent.</p>
<p>One possible recovery action is to include a description of the
error in the generated message text.</p>
</div>
</div>
<div class="div2">
<h3><a name="assertions" id="assertions"></a>22.2 <a href=
"#assertions" style="text-decoration: none">Assertions</a></h3>
<p>The <a href="#element-assert"><code>xsl:assert</code></a>
instruction is used to assert that the value of a particular
expression is true; if the value of the expression is false, and
assertions are enabled, then a dynamic error occurs.</p>
<p class="element-syntax"><a name="element-assert" id=
"element-assert"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:assert<br />
&#160;&#160;<b>test</b> = <var>expression</var><br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;error-code? = { <var>eqname</var> }&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:assert&gt;</code></p>
<p>By default, assertions are enabled. Checking of assertions may
be disabled in several ways:</p>
<ol class="enumar">
<li>
<p>As with any other instruction, assertions may be disabled by use
of the <code>use-when</code> attribute: see <a href=
"#conditional-inclusion"><i>3.14.1 Conditional Element
Inclusion</i></a>.</p>
</li>
<li>
<p>An implementation <span class="verb">should</span> provide an
external mechanism to disable assertion checking for the stylesheet
as a whole (either statically or dynamically). The detail of such
mechanisms is <a title="implementation-defined" class="termref"
href="#dt-implementation-defined">implementation-defined</a>.</p>
</li>
</ol>
<p>If assertion checking is enabled, the instruction is evaluated
as follows:</p>
<ol class="enumar">
<li>
<p>The expression in the <code>test</code> attribute is evaluated.
If the effective boolean value of the result is <code>true</code>,
the assertion succeeds, and no further action is taken. If the
effective boolean value is false, or if a dynamic error occurs
during evaluation of the expression, then the assertion fails.</p>
</li>
<li>
<p>If the assertion fails, then the effect of the instruction is
governed by the rules for evaluation of an <a href=
"#element-message"><code>xsl:message</code></a> instruction with
the same <code>select</code> attribute, <code>error-code</code>
attribute, and contained <a title="sequence constructor" class=
"termref" href="#dt-sequence-constructor">sequence constructor</a>,
and with the value <code>terminate="yes"</code>. However, the
default error code if the <code>error-code</code> attribute is
omitted is <code>XTMM9001</code> rather than
<code>XTMM9000</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>To the extent that the behavior of <a href=
"#element-message"><code>xsl:message</code></a> is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>, this rule
does not prevent an implementation treating <a href=
"#element-assert"><code>xsl:assert</code></a> and <a href=
"#element-message"><code>xsl:message</code></a> differently.</p>
</div>
</li>
</ol>
<p><a name="err-XTMM9001" id="err-XTMM9001"><span class=
"error">[ERR XTMM9001]</span></a> When a transformation is
terminated by use of <code>xsl:assert</code>, the effect is the
same as when a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> occurs during the
transformation. The default error code is <code>XTMM9001</code>;
this may be overridden using the <code>error-code</code> attribute
of the <a href="#element-assert"><code>xsl:assert</code></a>
instruction.</p>
<p>As with any other dynamic error, an error caused by an assertion
failing may be trapped using <a href=
"#element-try"><code>xsl:try</code></a>: see <a href=
"#try-catch"><i>8.3 Try/Catch</i></a>.</p>
<p>The result of the <a href=
"#element-assert"><code>xsl:assert</code></a> instruction is an
empty sequence.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e62618" id=
"d7e62618"></a>Example: Using Assertions with Static
Parameters</div>
<p>The following example shows a stylesheet function that checks
that the value of its supplied argument is in range. The check is
performed only if the <a title="static parameter" class="termref"
href="#dt-static-parameter">static parameter</a>
<code>$DEBUG</code> is set to true.</p>
<div class="exampleInner">
<pre>
&lt;xsl:param name="DEBUG" as="xs:boolean" select="false()" 
           static="yes" required="no"/&gt;
&lt;xsl:function name="f:days-elapsed" as="xs:integer"&gt;
  &lt;xsl:param name="date" as="xs:date"/&gt;
  &lt;xsl:assert use-when="$DEBUG" test="$date lt current-date()"/&gt;
  &lt;xsl:sequence select="(current-date() - $since) 
                            div xs:dayTimeDuration('PT1D')"/&gt;
&lt;/xsl:function&gt;
</pre></div>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Implementations should avoid optimizing <a href=
"#element-assert"><code>xsl:assert</code></a> instructions away. As
a guideline, if the result of a sequence constructor is required by
the transformation, the implementation should ensure that all
<a href="#element-assert"><code>xsl:assert</code></a> instructions
in that sequence constructor are evaluated. Conversely, if the
result of a sequence constructor is not required by the
transformation, its <a href=
"#element-assert"><code>xsl:assert</code></a> instructions should
not be evaluated.</p>
<p>This recommendation is not intended to prevent optimizations
such as lazy evaluation, where evaluation of a sequence constructor
may finish early, as soon as enough information is available to
evaluate the containing instruction.</p>
</div>
<p>An implementation <span class="verb">may</span> provide a user
option allowing a processor to treat assertions as being true
without explicit checking. This option <span class="verb">must
not</span> be enabled by default. If such an option is in force,
the effect of any assertion not being true is <a title=
"implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>For example, given the assertion <code>&lt;xsl:assert
test="count(//title)=1"/&gt;</code>, a processor might generate
code for the expression <code>&lt;xsl:value-of
select="//title"/&gt;</code> that stops searching for
<code>title</code> elements after finding the first one. In the
event that the source document contains more than one
<code>title</code>, execution of the stylesheet may fail in
arbitrary ways, or it may produce incorrect output.</p>
</div>
</div>
</div>
<div class="div1">
<h2><a name="extension" id="extension"></a>23 <a href="#extension"
style="text-decoration: none">Extensibility and Fallback</a></h2>
<p>XSLT allows two kinds of extension, extension instructions and
extension functions.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-extension-instruction" id="dt-extension-instruction" title=
"extension instruction"></a>An <b>extension instruction</b> is an
element within a <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> that is in
a namespace (not the <a title="XSLT namespace" class="termref"
href="#dt-xslt-namespace">XSLT namespace</a>) designated as an
extension namespace.<span class="definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-extension-function" id="dt-extension-function" title=
"extension function"></a>An <b>extension function</b> is a function
that is available for use within an XPath <a title="expression"
class="termref" href="#dt-expression">expression</a>, other than a
<a title="core function" class="termref" href=
"#dt-core-function">core function</a> defined in <a href=
"#xpath-functions-30">[Functions and Operators]</a>, an additional
function defined in this XSLT specification, a constructor function
named after an atomic type, or a <a title="stylesheet function"
class="termref" href="#dt-stylesheet-function">stylesheet
function</a> defined using an <a href=
"#element-function"><code>xsl:function</code></a>
declaration.<span class="definition">]</span>.</p>
<p>This specification does not define any mechanism for creating or
binding implementations of <a title="extension instruction" class=
"termref" href="#dt-extension-instruction">extension
instructions</a> or <a title="extension function" class="termref"
href="#dt-extension-function">extension functions</a>, and it is
not <span class="verb">required</span> that implementations support
any such mechanism. Such mechanisms, if they exist, are <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. Therefore,
an XSLT stylesheet that <span class="verb">must</span> be portable
between XSLT implementations cannot rely on particular extensions
being available. XSLT provides mechanisms that allow an XSLT
stylesheet to determine whether the implementation makes particular
extensions available, and to specify what happens if those
extensions are not available. If an XSLT stylesheet is careful to
make use of these mechanisms, it is possible for it to take
advantage of extensions and still retain portability.</p>
<div class="div2">
<h3><a name="extension-functions" id="extension-functions"></a>23.1
<a href="#extension-functions" style=
"text-decoration: none">Extension Functions</a></h3>
<p>The set of functions that can be called from a <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-FunctionCall">FunctionCall</a><sup><small>XP30</small></sup>
within an XPath <a title="expression" class="termref" href=
"#dt-expression">expression</a> may include one or more <a title=
"extension function" class="termref" href=
"#dt-extension-function">extension functions</a>. The <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a> of an extension function always has a non-null namespace
URI.</p>
<div class="div3">
<h4><a name="func-function-available" id=
"func-function-available"></a>23.1.1 <a href=
"#func-function-available" style=
"text-decoration: none">fn:function-available</a></h4>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Determines whether a particular function is or is not available
for use. The function is particularly useful for calling within an
<code>[xsl:]use-when</code> attribute (see <a href=
"#conditional-inclusion"><i>3.14.1 Conditional Element
Inclusion</i></a>) to test whether a particular <a title=
"extension function" class="termref" href=
"#dt-extension-function">extension function</a> is available.</p>
</dd>
<dt class="label">Signatures</dt>
<dd>
<p><a name="function-function-available" id=
"function-function-available"></a></p>
<div class="proto"><code class=
"function">function-available</code>(<code class=
"arg">$function-name</code><code class=
"as">&#160;as&#160;</code><code class=
"type">xs:string</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">xs:boolean</code></div>
<div class="proto">
<table border="0" cellpadding="0" cellspacing="0" summary=
"Function signature for :function-available function">
<tr>
<td valign="baseline" rowspan="2"><code class=
"function">function-available</code>(</td>
<td valign="baseline"><code class="arg">$function-name</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class="type">xs:string</code>,</td>
</tr>
<tr>
<td valign="baseline"><code class="arg">$arity</code></td>
<td valign="baseline"><code class=
"as">&#160;as&#160;</code><code class=
"type">xs:integer</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">xs:boolean</code></td>
</tr>
</table>
</div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>.
It depends on namespaces, and known function signatures.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>A function is said to be available within an XPath expression if
it is present in the <a href=
"http://www.w3.org/TR/xpath-30/#dt-known-func-signatures">statically
known function signatures</a><sup><small>XP30</small></sup> for
that expression (see <a href="#static-context"><i>5.4.1
Initializing the Static Context</i></a>). Functions in the static
context are uniquely identified by the name of the function (a
QName) in combination with its <a title="arity" class="termref"
href="#dt-arity">arity</a>.</p>
<p>The value of the <code>$function-name</code> argument
<span class="verb">must</span> be a string containing an <a title=
"EQName" class="termref" href="#dt-eqname">EQName</a>. The lexical
QName is expanded into an <a title="expanded QName" class="termref"
href="#dt-expanded-qname">expanded QName</a> using the namespace
declarations in scope for the <a title="expression" class="termref"
href="#dt-expression">expression</a>. If the value is an unprefixed
lexical QName, then the <a title="standard function namespace"
class="termref" href="#dt-standard-function-namespace">standard
function namespace</a> is used in the expanded QName.</p>
<p>The two-argument version of the <a href=
"#func-function-available"><code>function-available</code></a>
function returns true if and only if there is an available function
whose name matches the value of the <code>$function-name</code>
argument and whose <a title="arity" class="termref" href=
"#dt-arity">arity</a> matches the value of the <code>$arity</code>
argument.</p>
<p>The single-argument version of the <a href=
"#func-function-available"><code>function-available</code></a>
function returns true if and only if there is at least one
available function (with some arity) whose name matches the value
of the <code>$function-name</code> argument.</p>
<p><span>When the containing expression is evaluated with <a title=
"XPath 1.0 compatibility mode" class="termref" href=
"#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> set to
true</span>, the <a href=
"#func-function-available"><code>function-available</code></a>
function returns false in respect of a function name and arity for
which no implementation is available (other than the fallback error
function that raises a dynamic error whenever it is called). This
means that it is possible (as in XSLT 1.0) to use logic such as the
following to test whether a function is available before calling
it:</p>
<div class="example">
<div class="exampleHeader"><a name="d7e62871" id=
"d7e62871"></a>Example: Calling an extension function with
backwards compatibility enabled</div>
<div class="exampleInner">
<pre>
&lt;summary xsl:version="1.0"&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="function-available('my:summary')"&gt;
      &lt;xsl:value-of select="my:summary()"/&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:text&gt;Summary not available&lt;/xsl:text&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/summary&gt;
</pre></div>
</div>
</dd>
<dt class="label">Error Conditions</dt>
<dd>
<p><a name="err-XTDE1400" id="err-XTDE1400"><span class=
"error">[ERR XTDE1400]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
argument does not evaluate to a string that is a valid <a title=
"EQName" class="termref" href="#dt-eqname">EQName</a>, or if the
value is a <a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a> with a prefix for which no
namespace declaration is present in the static context. If the
processor is able to detect the error statically (for example, when
the argument is supplied as a string literal), then the processor
<span class="verb">may</span> optionally signal this as a <a title=
"static error" class="termref" href="#dt-static-error">static
error</a>.</p>
</dd>
<dt class="label">Notes</dt>
<dd>
<p>The fact that a function with a given name is available gives no
guarantee that any particular call on the function will be
successful. For example, it is not possible to determine the types
of the arguments expected.</p>
<p>The introduction of the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>
function-lookup</code></a><sup><small>FO30</small></sup> function
in XPath 3.0 reduces the need for <a href=
"#func-function-available"><code>function-available</code></a>,
since <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>
function-lookup</code></a><sup><small>FO30</small></sup> not only
tests whether a function is available, but also returns a function
item that enables it to be dynamically called.</p>
<p>If a function is present in the static context but with no
useful functionality (for example, if the system has been
configured for security reasons so that <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-available-environment-variables">
<code>available-environment-variables</code></a><sup><small>FO30</small></sup>
returns no information), then <a href=
"#func-function-available"><code>function-available</code></a> when
applied to that function should return false.</p>
<p>It is not necessary that there be a direct equivalence between
the results of <a href=
"#func-function-available"><code>function-available</code></a> and
<a href=
"http://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>
function-lookup</code></a><sup><small>FO30</small></sup> in all
cases. For example, there may be <a title="extension function"
class="termref" href="#dt-extension-function">extension
functions</a> whose side-effects are such that for security
reasons, dynamic calls to the function are disallowed; <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>
function-lookup</code></a><sup><small>FO30</small></sup> might then
not provide access to the function. The main use-case for <a href=
"#func-function-available"><code>function-available</code></a>, by
contrast, is for use in <code>[xsl:]use-when</code> conditions to
test whether static calls on the function are possible.</p>
</dd>
<dt class="label">Examples</dt>
<dd>
<div class="example">
<div class="exampleHeader"><a name="d7e62960" id=
"d7e62960"></a>Example: Stylesheet portable between XSLT 1.0, XSLT
2.0, and XSLT 3.0</div>
<p>A stylesheet that is designed to use XSLT 2.0 facilities when
running under an <span>XSLT 2.0 or XSLT 3.0 processor</span>, but
to fall back to XSLT 1.0 capabilities when not, might be written
using the code:</p>
<div class="exampleInner">
<pre>
&lt;out xsl:version="2.0"&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="function-available('matches')"&gt;
      &lt;xsl:value-of select="matches(/doc/title, '[a-z]*')"/&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:value-of select="string-length(
                translate(/doc/title, 'abcdefghijklmnopqrstuvwxyz', '')) = 0"/&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/out&gt;
</pre></div>
<p>Here an <span>XSLT 2.0 or XSLT 3.0</span> processor will always
take the <a href="#element-when"><code>xsl:when</code></a> branch,
while a 1.0 processor will follow the <a href=
"#element-otherwise"><code>xsl:otherwise</code></a> branch. The
single-argument version of the <a href=
"#func-function-available"><code>function-available</code></a>
function is used here, because that is the only version available
in XSLT 1.0. Under the rules of XSLT 1.0, the call on the
<code>matches</code> function is not an error, because it is never
evaluated.</p>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e62987" id=
"d7e62987"></a>Example: Stylesheet portable between XSLT 3.0 and a
future version of XSLT</div>
<p>A stylesheet that is designed to use facilities in some future
XSLT version when they are available, but to fall back to
<span>XSLT 2.0 or XSLT 3.0</span> capabilities when not, might be
written using code such as the following. This hypothesizes the
availability in some future version of a function <code>pad</code>
which pads a string to a fixed length with spaces:</p>
<div class="exampleInner">
<pre>
 &lt;xsl:value-of select="pad(/doc/title, 10)" 
               use-when="function-available('pad', 2)"/&gt;
 &lt;xsl:value-of select="concat(/doc/title, string-join(
                          for $i in 1 to 10 - string-length(/doc/title) 
                                                  return ' ', ''))"
               use-when="not(function-available('pad', 2))"/&gt;
 
</pre></div>
<p>In this case the two-argument version of <a href=
"#func-function-available"><code>function-available</code></a> is
used, because there is no requirement for this code to run under
XSLT 1.0.</p>
</div>
</dd>
</dl>
</div>
<div class="div3">
<h4><a name="calling-extension-functions" id=
"calling-extension-functions"></a>23.1.2 <a href=
"#calling-extension-functions" style=
"text-decoration: none">Calling Extension Functions</a></h4>
<p>If the function name used in a <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-FunctionCall">FunctionCall</a><sup><small>XP30</small></sup>
within an XPath <a title="expression" class="termref" href=
"#dt-expression">expression</a> identifies an extension function,
then to evaluate the <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-FunctionCall">FunctionCall</a><sup><small>XP30</small></sup>,
the processor will first evaluate each of the arguments in the
<a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-FunctionCall">FunctionCall</a><sup><small>XP30</small></sup>.
If the processor has information about the datatypes expected by
the extension function, then it <span class="verb">may</span>
perform any necessary type conversions between the XPath datatypes
and those defined by the implementation language. If multiple
extension functions are available with the same name, the processor
<span class="verb">may</span> decide which one to invoke based on
the number of arguments, the types of the arguments, or any other
criteria. The result returned by the implementation is returned as
the result of the function call, again after any necessary
conversions between the datatypes of the implementation language
and those of XPath. The details of such type conversions are
outside the scope of this specification.</p>
<p><a name="err-XTDE1420" id="err-XTDE1420"><span class=
"error">[ERR XTDE1420]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
arguments supplied to a call on an extension function do not
satisfy the rules defined for that particular extension function,
or if the extension function reports an error, or if the result of
the extension function cannot be converted to an XPath value.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Implementations may also provide mechanisms allowing extension
functions to report recoverable dynamic errors, or to execute
within an environment that treats some or all of the errors listed
above as recoverable.</p>
</div>
<p><a name="err-XTDE1425" id="err-XTDE1425"><span class=
"error">[ERR XTDE1425]</span></a> <span>When the containing element
is processed with <a title="XSLT 1.0 behavior" class="termref"
href="#dt-xslt-10-behavior">XSLT 1.0 behavior</a>,</span> it is a
<a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> to evaluate an extension
function call if no implementation of the extension function is
available.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>When <span>XSLT 1.0 behavior</span> is not enabled, this is a
static error <a href="http://www.w3.org/TR/xpath-30/#ERRXPST0017"
title="XPST0017"><span class="error">[ERR XPST0017]</span></a>
<sup><small>XP30</small></sup>.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>There is no prohibition on calling extension functions that have
side-effects (for example, an extension function that writes data
to a file). However, the order of execution of XSLT instructions is
not defined in this specification, so the effects of such functions
are unpredictable.</p>
</div>
<p>Implementations are not <span class="verb">required</span> to
perform full validation of values returned by extension functions.
It is an error for an extension function to return a string
containing characters that are not permitted in XML, but the
consequences of this error are <a title="implementation-defined"
class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. The
implementation <span class="verb">may</span> raise an error,
<span class="verb">may</span> convert the string to a string
containing valid characters only, or <span class="verb">may</span>
treat the invalid characters as if they were permitted
characters.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The ability to execute extension functions represents a
potential security weakness, since untrusted stylesheets may invoke
code that has privileged access to resources on the machine where
the <a title="processor" class="termref" href=
"#dt-processor">processor</a> executes. Implementations may
therefore provide mechanisms that restrict the use of extension
functions by untrusted stylesheets.</p>
</div>
<p>All observations in this section regarding the errors that can
occur when invoking extension functions apply equally when invoking
<a title="extension instruction" class="termref" href=
"#dt-extension-instruction">extension instructions</a>.</p>
</div>
<div class="div3">
<h4><a name="external-objects" id="external-objects"></a>23.1.3
<a href="#external-objects" style="text-decoration: none">External
Objects</a></h4>
<p>An implementation <span class="verb">may</span> allow an
extension function to return an object that does not have any
natural representation in the XDM data model, whether as an atomic
value, a node, <span>or a function item</span>. For example, an
extension function <code>sql:connect</code> might return an object
that represents a connection to a relational database; the
resulting connection object might be passed as an argument to calls
on other extension functions such as <code>sql:insert</code> and
<code>sql:select</code>.</p>
<p>The way in which such objects are represented in the type system
is <a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. They might
be represented by a completely new datatype, or they might be
mapped to existing datatypes such as <code>integer</code>,
<code>string</code>, or <code>anyURI</code>.</p>
</div>
<div class="div3">
<h4><a name="func-type-available" id=
"func-type-available"></a>23.1.4 <a href="#func-type-available"
style="text-decoration: none">fn:type-available</a></h4>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Used to control how a stylesheet behaves if a particular schema
type is or is not available in the static context.</p>
</dd>
<dt class="label">Signature</dt>
<dd>
<p><a name="function-type-available" id=
"function-type-available"></a></p>
<div class="proto"><code class=
"function">type-available</code>(<code class=
"arg">$type-name</code><code class=
"as">&#160;as&#160;</code><code class=
"type">xs:string</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">xs:boolean</code></div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>.
It depends on namespaces, and schema definitions.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>A schema type (that is, a simple type or a complex type) is said
to be available within an XPath expression if it is a type
definition that is present in the <a href=
"http://www.w3.org/TR/xpath-30/#dt-is-types">in-scope schema
types</a><sup><small>XP30</small></sup> for that expression (see
<a href="#static-context"><i>5.4.1 Initializing the Static
Context</i></a>). This includes built-in types, types imported
using <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>, and
extension types defined by the implementation.</p>
<p>The value of the <code>$type-name</code> argument <span class=
"verb">must</span> be a string containing an <span><a title=
"EQName" class="termref" href="#dt-eqname">EQName</a></span>. The
EQName is expanded into an <a title="expanded QName" class=
"termref" href="#dt-expanded-qname">expanded QName</a> using the
namespace declarations in scope for the <a title="expression"
class="termref" href="#dt-expression">expression</a>. If the value
is an unprefixed lexical QName, then the default namespace is used
in the expanded QName.</p>
<p>The function returns true if and only if there is an available
type whose name matches the value of the <code>$type-name</code>
argument.</p>
</dd>
<dt class="label">Error Conditions</dt>
<dd>
<p><a name="err-XTDE1428" id="err-XTDE1428"><span class=
"error">[ERR XTDE1428]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
argument does not evaluate to a string that is a valid <a title=
"EQName" class="termref" href="#dt-eqname">EQName</a>, or if the
value is a <a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a> with a prefix for which no
namespace declaration is present in the static context. If the
processor is able to detect the error statically (for example, when
the argument is supplied as a string literal), then the processor
<span class="verb">may</span> optionally signal this as a <a title=
"static error" class="termref" href="#dt-static-error">static
error</a>.</p>
</dd>
<dt class="label">Notes</dt>
<dd>
<p>The <a href=
"#func-type-available"><code>type-available</code></a> function is
of limited use within an <code>[xsl:]use-when</code> expression,
because the static context for the expression does not include any
user-defined types.</p>
</dd>
</dl>
</div>
</div>
<div class="div2">
<h3><a name="extension-instruction" id=
"extension-instruction"></a>23.2 <a href="#extension-instruction"
style="text-decoration: none">Extension Instructions</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-extension-namespace" id="dt-extension-namespace" title=
"extension namespace"></a>The <a title="extension instruction"
class="termref" href="#dt-extension-instruction">extension
instruction</a> mechanism allows namespaces to be designated as
<b>extension namespaces</b>. When a namespace is designated as an
extension namespace and an element with a name from that namespace
occurs in a <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>, then the
element is treated as an <a title="instruction" class="termref"
href="#dt-instruction">instruction</a> rather than as a <a title=
"literal result element" class="termref" href=
"#dt-literal-result-element">literal result
element</a>.<span class="definition">]</span> The namespace
determines the semantics of the instruction.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Since an element that is a child of an <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> element is
not occurring <em>in a <a title="sequence constructor" class=
"termref" href="#dt-sequence-constructor">sequence
constructor</a></em> , <a title="user-defined data element" class=
"termref" href="#dt-data-element">user-defined data elements</a>
(see <a href="#user-defined-top-level"><i>3.8.3 User-defined Data
Elements</i></a>) are not extension elements as defined here, and
nothing in this section applies to them.</p>
</div>
<div class="div3">
<h4><a name="designating-extension-namespace" id=
"designating-extension-namespace"></a>23.2.1 <a href=
"#designating-extension-namespace" style=
"text-decoration: none">Designating an Extension Namespace</a></h4>
<p>A namespace is designated as an extension namespace by using an
<code>[xsl:]extension-element-prefixes</code> attribute on an
element in the stylesheet (see <a href=
"#standard-attributes"><i>3.5 Standard Attributes</i></a>). The
attribute <span class="verb">must</span> be in the XSLT namespace
only if its parent element is <em>not</em> in the XSLT namespace.
The value of the attribute is a whitespace-separated list of
namespace prefixes. The namespace bound to each of the prefixes is
designated as an extension namespace.</p>
<p>The default namespace (as declared by <code>xmlns</code>) may be
designated as an extension namespace by including
<code>#default</code> in the list of namespace prefixes.</p>
<p><a name="err-XTSE1430" id="err-XTSE1430"><span class=
"error">[ERR XTSE1430]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if there
is no namespace bound to the prefix on the element bearing the
<code>[xsl:]extension-element-prefixes</code> attribute or, when
<code>#default</code> is specified, if there is no default
namespace.</p>
<p>The designation of a namespace as an extension namespace is
effective for the element bearing the
<code>[xsl:]extension-element-prefixes</code> attribute and for all
descendants of that element within the same stylesheet module.</p>
</div>
<div class="div3">
<h4><a name="func-element-available" id=
"func-element-available"></a>23.2.2 <a href=
"#func-element-available" style=
"text-decoration: none">fn:element-available</a></h4>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Determines whether a particular instruction is or is not
available for use. The function is particularly useful for calling
within an <code>[xsl:]use-when</code> attribute (see <a href=
"#conditional-inclusion"><i>3.14.1 Conditional Element
Inclusion</i></a>) to test whether a particular <a title=
"extension instruction" class="termref" href=
"#dt-extension-instruction">extension instruction</a> is
available.</p>
</dd>
<dt class="label">Signature</dt>
<dd>
<p><a name="function-element-available" id=
"function-element-available"></a></p>
<div class="proto"><code class=
"function">element-available</code>(<code class=
"arg">$element-name</code><code class=
"as">&#160;as&#160;</code><code class=
"type">xs:string</code>)<code class=
"as">&#160;as&#160;</code><code class=
"return-type">xs:boolean</code></div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>.
It depends on namespaces.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>The value of the <code>$element-name</code> argument
<span class="verb">must</span> be a string containing an <a title=
"EQName" class="termref" href="#dt-eqname">EQName</a>. If it is a
<a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a> with a prefix, then it is
expanded into an <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> using the namespace
declarations in the static context of the <a title="expression"
class="termref" href="#dt-expression">expression</a>. If there is a
default namespace in scope, then it is used to expand an unprefixed
<a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a>.</p>
<p>If the resulting <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> is in the <a title=
"XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT
namespace</a>, the function returns true if and only if the local
name matches the name of an XSLT element that is defined in this
specification and implemented by the XSLT processor.</p>
<p>If the <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> has a null namespace URI,
the <a href=
"#func-element-available"><code>element-available</code></a>
function will return false.</p>
<p>If the <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> is not in the <a title=
"XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT
namespace</a>, the function returns true if and only if the
processor has an implementation available of an <a title=
"extension instruction" class="termref" href=
"#dt-extension-instruction">extension instruction</a> with the
given expanded QName. This applies whether or not the namespace has
been designated as an <a title="extension namespace" class=
"termref" href="#dt-extension-namespace">extension
namespace</a>.</p>
<p>If the processor does not have an implementation of a particular
extension instruction available, and such an extension instruction
is evaluated, then the processor <span class="verb">must</span>
perform fallback for the element as specified in <a href=
"#fallback"><i>23.2.3 Fallback</i></a>. An implementation
<span class="verb">must not</span> signal an error merely because
the stylesheet contains an extension instruction for which no
implementation is available.</p>
</dd>
<dt class="label">Error Conditions</dt>
<dd>
<p><a name="err-XTDE1440" id="err-XTDE1440"><span class=
"error">[ERR XTDE1440]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
argument does not evaluate to a string that is a valid <a title=
"EQName" class="termref" href="#dt-eqname">EQName</a>, or if the
value is a <a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a> with a prefix for which no
namespace declaration is present in the static context. If the
processor is able to detect the error statically (for example, when
the argument is supplied as a string literal), then the processor
<span class="verb">may</span> optionally signal this as a <a title=
"static error" class="termref" href="#dt-static-error">static
error</a>.</p>
</dd>
<dt class="label">Notes</dt>
<dd>
<p>For element names in the XSLT namespace:</p>
<ul>
<li>
<p>Where conformance rules make some features of the specification
optional, for example the <a href=
"#element-stream"><code>xsl:stream</code></a> element, this
function can be used (typically in a <code>use-when</code>
expression) to determine whether the feature is available in a
particular processor. It can also be useful to distinguish
processors that implement XSLT 3.0 from processors that implement
other (older or newer) versions of the specification, and to
distinguish full implementations from incomplete
implementations.</p>
</li>
<li>
<p>In earlier versions of this specification, <a href=
"#func-element-available"><code>element-available</code></a> was
defined to return true only for elements classified as
instructions. The distinction between instructions and other
elements, however, is sometimes rather technical, and in XSLT 3.0
the effect of the function has therefore been aligned to do what
its name might suggest.</p>
</li>
<li>
<p>If an instruction is recognized but offers no useful
functionality (for example, if the system has been configured for
security reasons so that <a href=
"#element-evaluate"><code>xsl:evaluate</code></a> always raises an
error), then <a href=
"#func-element-available"><code>element-available</code></a> when
applied to that instruction <span class="verb">should</span> return
false.</p>
</li>
</ul>
<p>For element names in other namespaces:</p>
<ul>
<li>
<p>The result of the <a href=
"#func-element-available"><code>element-available</code></a> does
not depend on whether or not the namespace of the supplied
instruction name has been designated as an extension element
namespace; it tests whether the instruction would be available if
the namespace were designated as such.</p>
</li>
</ul>
</dd>
</dl>
</div>
<div class="div3">
<h4><a name="fallback" id="fallback"></a>23.2.3 <a href="#fallback"
style="text-decoration: none">Fallback</a></h4>
<p class="element-syntax"><a name="element-fallback" id=
"element-fallback"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:fallback&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:fallback&gt;</code></p>
<p>The content of an <a href=
"#element-fallback"><code>xsl:fallback</code></a> element is a
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>, and when
performing fallback, the value returned by the <a href=
"#element-fallback"><code>xsl:fallback</code></a> element is the
result of evaluating this sequence constructor.</p>
<p>When not performing fallback, evaluating an <a href=
"#element-fallback"><code>xsl:fallback</code></a> element returns
an empty sequence: the content of the <a href=
"#element-fallback"><code>xsl:fallback</code></a> element is
ignored.</p>
<p>There are two situations where a <a title="processor" class=
"termref" href="#dt-processor">processor</a> performs fallback:
when an extension instruction that is not available is evaluated,
and when an instruction in the XSLT namespace, that is not defined
in XSLT <span>3.0</span>, is evaluated within a region of the
stylesheet for which <a title="forwards compatible behavior" class=
"termref" href="#dt-forwards-compatible-behavior">forwards
compatible behavior</a> is enabled.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Fallback processing is not invoked in other situations, for
example it is not invoked when an XPath expression uses
unrecognized syntax or contains a call to an unknown function. To
handle such situations dynamically, the stylesheet should call
functions such as <a href=
"#func-system-property"><code>system-property</code></a> and
<a href=
"#func-function-available"><code>function-available</code></a> to
decide what capabilities are available.</p>
</div>
<p><a name="err-XTDE1450" id="err-XTDE1450"><span class=
"error">[ERR XTDE1450]</span></a> When a <a title="processor"
class="termref" href="#dt-processor">processor</a> performs
fallback for an <a title="extension instruction" class="termref"
href="#dt-extension-instruction">extension instruction</a> that is
not recognized, if the instruction element has one or more <a href=
"#element-fallback"><code>xsl:fallback</code></a> children, then
the content of each of the <a href=
"#element-fallback"><code>xsl:fallback</code></a> children
<span class="verb">must</span> be evaluated; it is a <a title=
"dynamic error" class="termref" href="#dt-dynamic-error">dynamic
error</a> if it has no <a href=
"#element-fallback"><code>xsl:fallback</code></a> children.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This is different from the situation with unrecognized <a title=
"XSLT element" class="termref" href="#dt-xslt-element">XSLT
elements</a>. As explained in <a href="#forwards"><i>3.11 Forwards
Compatible Processing</i></a>, an unrecognized XSLT element
appearing within a <a title="sequence constructor" class="termref"
href="#dt-sequence-constructor">sequence constructor</a> is a
static error unless (a) <a title="forwards compatible behavior"
class="termref" href="#dt-forwards-compatible-behavior">forwards
compatible behavior</a> is enabled, and (b) the instruction has an
<a href="#element-fallback"><code>xsl:fallback</code></a>
child.</p>
</div>
</div>
</div>
</div>
<div class="div1">
<h2><a name="result-trees" id="result-trees"></a>24 <a href=
"#result-trees" style="text-decoration: none">Final Result
Trees</a></h2>
<p>The output of a transformation <span>(after the optional
post-processing step described in <a href=
"#post-processing"><i>2.3.6 Post-processing the Raw
Result</i></a>)</span> is a set of one or more <a title=
"final result tree" class="termref" href=
"#dt-final-result-tree">final result trees</a>.</p>
<p>A <a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a> can be created
explicitly, by evaluating an <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction. As explained in <a href=
"#executing-a-transformation"><i>2.4 Executing a
Transformation</i></a> <span>and <a href=
"#post-processing"><i>2.3.6 Post-processing the Raw
Result</i></a></span>, a final result tree <span class=
"verb">may</span> also be created implicitly if no <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction is evaluated, or if the result of evaluating the
<a title="initial named template" class="termref" href=
"#dt-initial-named-template">initial named template</a> is a
non-empty sequence.</p>
<p>The way in which a <a title="final result tree" class="termref"
href="#dt-final-result-tree">final result tree</a> is delivered to
an application is <a title="implementation-defined" class="termref"
href="#dt-implementation-defined">implementation-defined</a>.</p>
<p>Serialization of <a title="final result tree" class="termref"
href="#dt-final-result-tree">final result trees</a> is described
further in <a href="#serialization"><i>25 Serialization</i></a></p>
<div class="div2">
<h3><a name="creating-result-trees" id=
"creating-result-trees"></a>24.1 <a href="#creating-result-trees"
style="text-decoration: none">Creating Final Result Trees</a></h3>
<p class="element-syntax"><a name="element-result-document" id=
"element-result-document"></a><code>&lt;!-- Category: instruction
--&gt;<br />
&lt;xsl:result-document<br />
&#160;&#160;format? = { <var>eqname</var> }<br />
&#160;&#160;href? = { <var>uri</var> }<br />
&#160;&#160;validation? = "strict" | "lax" | "preserve" |
"strip"<br />
&#160;&#160;type? = <var>eqname</var><br />
&#160;&#160;method? = { "xml" | "html" | "xhtml" | "text" |
<var>eqname</var> }<br />
&#160;&#160;byte-order-mark? = { <var>boolean</var> }<br />
&#160;&#160;cdata-section-elements? = { <var>eqnames</var> }<br />
&#160;&#160;doctype-public? = { <var>string</var> }<br />
&#160;&#160;doctype-system? = { <var>string</var> }<br />
&#160;&#160;encoding? = { <var>string</var> }<br />
&#160;&#160;escape-uri-attributes? = { <var>boolean</var> }<br />
&#160;&#160;html-version? = { <var>decimal</var> }<br />
&#160;&#160;include-content-type? = { <var>boolean</var> }<br />
&#160;&#160;indent? = { <var>boolean</var> }<br />
&#160;&#160;item-separator? = { <var>string</var> }<br />
&#160;&#160;media-type? = { <var>string</var> }<br />
&#160;&#160;normalization-form? = { "NFC" | "NFD" | "NFKC" | "NFKD"
| "fully-normalized" | "none" | <var>nmtoken</var> }<br />
&#160;&#160;omit-xml-declaration? = { <var>boolean</var> }<br />
&#160;&#160;parameter-document? = { <var>uri</var> }<br />
&#160;&#160;standalone? = { <var>boolean</var> | "omit" }<br />
&#160;&#160;suppress-indentation? = { <var>eqnames</var> }<br />
&#160;&#160;undeclare-prefixes? = { <var>boolean</var> }<br />
&#160;&#160;use-character-maps? = <var>eqnames</var><br />
&#160;&#160;output-version? = { <var>nmtoken</var>
}&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:result-document&gt;</code></p>
<p>The <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction is used to create a <a title="final result tree" class=
"termref" href="#dt-final-result-tree">final result tree</a>. The
content of the <a href=
"#element-result-document"><code>xsl:result-document</code></a>
element is a <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> for the
children of the document node of the tree. A document node is
created, and the sequence obtained by evaluating the sequence
constructor is used to construct the content of the document, as
described in <a href="#constructing-complex-content"><i>5.8.1
Constructing Complex Content</i></a>. The tree rooted at this
document node forms the final result tree.</p>
<p>The <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction defines the URI of the result tree, and may optionally
specify the output format to be used for serializing this tree.</p>
<p>Technically, the result of evaluating the <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction is an empty sequence. This means it does not contribute
anything to the result of the sequence constructor it is part
of.</p>
<p>The <a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the
<code>format</code> attribute, if specified, <span class=
"verb">must</span> be an <span><a title="EQName" class="termref"
href="#dt-eqname">EQName</a></span>. The value is expanded using
the namespace declarations in scope for the <a href=
"#element-result-document"><code>xsl:result-document</code></a>
element. The resulting <a title="expanded QName" class="termref"
href="#dt-expanded-qname">expanded QName</a> <span class=
"verb">must</span> match the expanded QName of a named <a title=
"output definition" class="termref" href=
"#dt-output-definition">output definition</a> in the <a title=
"stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>.
This identifies the <a href=
"#element-output"><code>xsl:output</code></a> declaration that will
control the serialization of the <a title="final result tree"
class="termref" href="#dt-final-result-tree">final result tree</a>
(see <a href="#serialization"><i>25 Serialization</i></a>), if the
result tree is serialized. If the <code>format</code> attribute is
omitted, the unnamed <a title="output definition" class="termref"
href="#dt-output-definition">output definition</a> is used to
control serialization of the result tree.</p>
<p><a name="err-XTDE1460" id="err-XTDE1460"><span class=
"error">[ERR XTDE1460]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the
<code>format</code> attribute is not a valid <a title="EQName"
class="termref" href="#dt-eqname">EQName</a>, or if it does not
match the <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> of an <a title=
"output definition" class="termref" href=
"#dt-output-definition">output definition</a> in the <a title=
"stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>.
If the processor is able to detect the error statically (for
example, when the <code>format</code> attribute contains no curly
brackets), then the processor <span class="verb">may</span>
optionally signal this as a <a title="static error" class="termref"
href="#dt-static-error">static error</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The only way to select the unnamed <a title="output definition"
class="termref" href="#dt-output-definition">output definition</a>
is to omit the <code>format</code> attribute.</p>
</div>
<p>The <code>parameter-document</code> attribute allows
serialization parameters to be supplied in an external document.
The external document must contain an
<code>output:serialization-parameters</code> element with the
format described in <a href=
"http://www.w3.org/TR/xslt-xquery-serialization-30/#serparams-in-xdm-instance">
Section 3.1 Setting Serialization Parameters by Means of a Data
Model Instance</a> <sup><small>SER30</small></sup>, and the
parameters are interpreted as described in that specification.</p>
<p>If present, the effective value of the URI supplied in the
<code>parameter-document</code> attribute is dereferenced, after
resolution against the base URI of the
<code>xsl:result-document</code> element if it is a relative
reference. If the location of the stylesheet at development time is
different from the deployed location, any relative reference should
be resolved against the deployed location. A serialization error
occurs if the result of dereferencing the URI is ill-formed or
invalid; but if no document can be found at the specified location,
the attribute <code>may</code> be ignored.</p>
<p>A serialization parameter specified in the
<code>parameter-document</code> takes precedence over a value
supplied directly as an attribute of <a href=
"#element-result-document"><code>xsl:result-document</code></a>,
which in turn takes precedence over a value supplied in the
selected output definition, except that the values of the
<code>cdata-section-elements</code> and
<code>suppress-indentation</code> attributes are merged in the same
way as when multiple <code>xsl:output</code> declarations are
merged.</p>
<p>The attributes <code>method</code>, <code>byte-order-mark</code>
<code>cdata-section-elements</code>, <code>doctype-public</code>,
<code>doctype-system</code>, <code>encoding</code>,
<code>escape-uri-attributes</code>,
<span><code>html-version</code></span>, <code>indent</code>,
<span><code>item-separator</code>,</span> <code>media-type</code>,
<code>normalization-form</code>, <code>omit-xml-declaration</code>,
<code>standalone</code>,
<span><code>suppress-indentation</code>,</span>
<code>undeclare-prefixes</code>, <code>use-character-maps</code>,
and <code>output-version</code> may be used to override attributes
defined in the selected <a title="output definition" class=
"termref" href="#dt-output-definition">output definition</a>.</p>
<p>With the exception of <code>use-character-maps</code>, these
attributes are all defined as <a title="attribute value template"
class="termref" href="#dt-attribute-value-template">attribute value
templates</a>, so their values may be set dynamically. For any of
these attributes that is present on the <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction, the <a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the attribute
overrides or supplements the corresponding value from the output
definition. This works in the same way as when one <a href=
"#element-output"><code>xsl:output</code></a> declaration overrides
another:</p>
<ul>
<li>
<p>In the case of <code>cdata-section-elements</code> <span>and
<code>suppress-indentation</code></span>, the value of the
serialization parameter is the union of the expanded names of the
elements named in this instruction and the elements named in the
selected output definition;</p>
</li>
<li>
<p>In the case of <code>use-character-maps</code>, the character
maps referenced in this instruction supplement and take precedence
over those defined in the selected output definition;</p>
</li>
<li>
<p>In the case of <code>doctype-public</code> and
<code>doctype-system</code>, setting the effective value of the
attribute to a zero-length string has the effect of overriding any
value for these attributes obtained from the output definition. The
corresponding serialization parameter is not set (is "absent").</p>
</li>
<li>
<p>In the case of <code>item-separator</code>, setting the
effective value of the attribute to the special value
<code>"#absent"</code> has the effect of overriding any value for
this attribute obtained from the output definition. The
corresponding serialization parameter is not set (is "absent"). it
is not possible to set the value of the serialization parameter to
the literal 7-character string "#absent".</p>
</li>
<li>
<p>In all other cases, the effective value of an attribute actually
present on this instruction takes precedence over the value defined
in the selected output definition.</p>
</li>
</ul>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>In the case of the attributes <code>method</code>,
<code>cdata-section-elements</code>,
<span><code>suppress-indentation</code></span>, and
<code>use-character-maps</code>, the <a title="effective value"
class="termref" href="#dt-effective-value">effective value</a> of
the attribute contains a space-separated list of <a title="EQName"
class="termref" href="#dt-eqname">EQNames</a>. If any of these is a
<a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a> with a prefix, the prefix is
expanded using the in-scope namespaces for the
<code>xsl:result-document</code> element. In the case of
<code>cdata-section-elements</code> <span>and
<code>suppress-indentation</code></span>, an unprefixed element
name is expanded using the default namespace. In the case of the
<code>method</code> attribute, if the method is not one of the
system-defined methods (xml, html, xhtml, text) then the expanded
name must have a non-absent namespace.</p>
</div>
<p>The <code>output-version</code> attribute on the <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction overrides the <code>version</code> attribute on
<a href="#element-output"><code>xsl:output</code></a> (it has been
renamed because <code>version</code> is available with a different
meaning as a standard attribute: see <a href=
"#standard-attributes"><i>3.5 Standard Attributes</i></a>). In all
other cases, attributes correspond if they have the same name.</p>
<p>There are some serialization parameters that apply to some
output methods but not to others. For example, the
<code>indent</code> attribute has no effect on the
<code>text</code> output method. If a value is supplied for an
attribute that is inapplicable to the output method, its value is
not passed to the serializer. The processor <span class=
"verb">may</span> validate the value of such an attribute, but is
not <span class="verb">required</span> to do so.</p>
<p>The <code>item-separator</code> serialization parameter defined
in <a href="#xslt-xquery-serialization-30">[XSLT and XQuery
Serialization]</a> is not available in <a href=
"#element-result-document"><code>xsl:result-document</code></a>; it
is not applicable, because the sequence that is serialized by XSLT
is always a singleton document node. Formally therefore, the
serializer is invoked passing an empty string as the value of this
parameter.</p>
<p>The <code>href</code> attribute is optional. The default value
is the zero-length string. The <a title="effective value" class=
"termref" href="#dt-effective-value">effective value</a> of the
attribute <span class="verb">must</span> be a <a title=
"URI Reference" class="termref" href="#dt-uri-reference">URI
Reference</a>, which may be absolute or relative. There
<span class="verb">may</span> be <a title="implementation-defined"
class="termref" href=
"#dt-implementation-defined">implementation-defined</a>
restrictions on the form of absolute URI that may be used, but the
implementation is not <span class="verb">required</span> to enforce
any restrictions. Any valid relative URI <span>reference</span>
<span class="verb">must</span> be accepted. Note that the
zero-length string is a valid relative URI
<span>reference</span>.</p>
<p>The base URI of the document node at the root of the <a title=
"final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a> is based on the
<a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the <code>href</code>
attribute. If the <a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> is a relative URI
<span>reference</span>, then it is resolved relative to the
<a title="base output URI" class="termref" href=
"#dt-base-output-uri">base output URI</a>. If the implementation
provides an API to access final result trees, then it <span class=
"verb">must</span> allow a final result tree to be identified by
means of this base URI.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The base URI of the <a title="final result tree" class="termref"
href="#dt-final-result-tree">final result tree</a> is not
necessarily the same thing as the URI of its serialized
representation on disk, if any. For example, a server (or browser
client) might store final result trees only in memory, or in an
internal disk cache. As long as the processor satisfies requests
for those URIs, it is irrelevant where they are actually written on
disk, if at all.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>It will often be the case that one <a title="final result tree"
class="termref" href="#dt-final-result-tree">final result tree</a>
contains links to another final result tree produced during the
same transformation, in the form of a relative URI
<span>reference</span>. The mechanism of associating a URI with a
final result tree has been chosen to allow the integrity of such
links to be preserved when the trees are serialized.</p>
<p>As well as being potentially significant in any API that
provides access to final result trees, the base URI of the new
document node is relevant if the final result tree, rather than
being serialized, is supplied as input to a further
transformation.</p>
</div>
<p>The optional attributes <code>type</code> and
<code>validation</code> may be used on the <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction to validate the contents of the new document, and to
determine the <a title="type annotation" class="termref" href=
"#dt-type-annotation">type annotation</a> that elements and
attributes within the <a title="final result tree" class="termref"
href="#dt-final-result-tree">final result tree</a> will carry. The
permitted values and their semantics are described in <a href=
"#validating-document-nodes"><i>24.4.2 Validating Document
Nodes</i></a>.</p>
<p>A <a title="processor" class="termref" href=
"#dt-processor">processor</a> <span class="verb">may</span> allow a
<a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a> to be serialized.
Serialization is described in <a href="#serialization"><i>25
Serialization</i></a>. However, an implementation (for example, a
<a title="processor" class="termref" href=
"#dt-processor">processor</a> running in an environment with no
access to writable filestore) is not <span class=
"verb">required</span> to support the serialization of <a title=
"final result tree" class="termref" href=
"#dt-final-result-tree">final result trees</a>. An implementation
that does not support the serialization of final result trees
<span class="verb">may</span> ignore the <code>format</code>
attribute and the serialization attributes. Such an implementation
<span class="verb">must</span> provide the application with some
means of access to the (un-serialized) result tree, using its URI
to identify it.</p>
<p>Implementations may provide additional mechanisms, outside the
scope of this specification, for defining the way in which
<a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result trees</a> are processed. Such
mechanisms <span class="verb">may</span> make use of the
XSLT-defined attributes on the <a href=
"#element-result-document"><code>xsl:result-document</code></a>
and/or <a href="#element-output"><code>xsl:output</code></a>
elements, or they <span class="verb">may</span> use additional
elements or attributes in an <a title="implementation-defined"
class="termref" href=
"#dt-implementation-defined">implementation-defined</a>
namespace.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e64306" id=
"d7e64306"></a>Example: Multiple Result Documents</div>
<p>The following example takes an XHTML document as input, and
breaks it up so that the text following each &lt;h1&gt; element is
included in a separate document. A new document
<code>toc.html</code> is constructed to act as an index:</p>
<div class="exampleInner">
<pre>
&lt;xsl:stylesheet
        version="3.0"
        xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
        xmlns:xhtml="http://www.w3.org/1999/xhtml"&gt;
        
&lt;xsl:output name="toc-format" method="xhtml" indent="yes"
     doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
     doctype-public="-//W3C//DTD XHTML 1.0 Strict//EN"/&gt;
            
&lt;xsl:output name="section-format" method="xhtml" indent="no"
     doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"
     doctype-public="-//W3C//DTD XHTML 1.0 Transitional//EN"/&gt;       
         
&lt;xsl:template match="/"&gt;
  &lt;xsl:result-document href="toc.html" 
                       format="toc-format" 
                       validation="strict"&gt;
    &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
      &lt;head&gt;&lt;title&gt;Table of Contents&lt;/title&gt;&lt;/head&gt;
      &lt;body&gt;
        &lt;h1&gt;Table of Contents&lt;/h1&gt;
        &lt;xsl:for-each select="/*/xhtml:body/(*[1] | xhtml:h1)"&gt;
          &lt;p&gt;
            &lt;a href="section{position()}.html"&gt;
              &lt;xsl:value-of select="."/&gt;
            &lt;/a&gt;
          &lt;/p&gt;
        &lt;/xsl:for-each&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:result-document&gt;
  &lt;xsl:for-each-group select="/*/xhtml:body/*" group-starting-with="xhtml:h1"&gt;
    &lt;xsl:result-document href="section{position()}.html" 
                         format="section-format" validation="strip"&gt;         
      &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
        &lt;head&gt;&lt;title&gt;&lt;xsl:value-of select="."/&gt;&lt;/title&gt;&lt;/head&gt;
        &lt;body&gt;
          &lt;xsl:copy-of select="current-group()"/&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    &lt;/xsl:result-document&gt;
  &lt;/xsl:for-each-group&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</pre></div>
</div>
</div>
<div class="div2">
<h3><a name="result-document-restrictions" id=
"result-document-restrictions"></a>24.2 <a href=
"#result-document-restrictions" style=
"text-decoration: none">Restrictions on the use of</a>
<code>xsl:result-document</code></h3>
<p>There are restrictions on the use of the <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction, designed to ensure that the results are fully
interoperable even when processors optimize the sequence in which
instructions are evaluated. Informally, the restriction is that the
<a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction can only be used while writing a final result tree, not
while writing to a temporary tree or a sequence. This restriction
is defined formally as follows.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-output-state" id="dt-output-state" title=
"output state"></a>Each instruction in the <a title="stylesheet"
class="termref" href="#dt-stylesheet">stylesheet</a> is evaluated
in one of two possible <b>output states</b>: <a title=
"final output state" class="termref" href=
"#dt-final-output-state">final output state</a> or <a title=
"temporary output state" class="termref" href=
"#dt-temporary-output-state">temporary output state</a>
<span class="definition">]</span>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-final-output-state" id="dt-final-output-state" title=
"final output state"></a>The first of the two <a title=
"output state" class="termref" href="#dt-output-state">output
states</a> is called <b>final output</b> state. This state applies
when instructions are writing to a <a title="final result tree"
class="termref" href="#dt-final-result-tree">final result
tree</a>.<span class="definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-temporary-output-state" id="dt-temporary-output-state" title=
"temporary output state"></a>The second of the two <a title=
"output state" class="termref" href="#dt-output-state">output
states</a> is called <b>temporary output</b> state. This state
applies when instructions are writing to a <a title=
"temporary tree" class="termref" href=
"#dt-temporary-tree">temporary tree</a> or any other non-final
destination.<span class="definition">]</span></p>
<p>The instructions in the <a title="initial named template" class=
"termref" href="#dt-initial-named-template">initial named
template</a> are evaluated in <a title="final output state" class=
"termref" href="#dt-final-output-state">final output state</a>. An
instruction is evaluated in the same <a title="output state" class=
"termref" href="#dt-output-state">output state</a> as its calling
instruction, except that <a href=
"#element-variable"><code>xsl:variable</code></a>, <a href=
"#element-param"><code>xsl:param</code></a>, <a href=
"#element-with-param"><code>xsl:with-param</code></a>, <a href=
"#element-function"><code>xsl:function</code></a>, <a href=
"#element-key"><code>xsl:key</code></a>, <a href=
"#element-sort"><code>xsl:sort</code></a>, <span><a href=
"#element-accumulator-rule"><code>xsl:accumulator-rule</code></a>,
and <a href=
"#element-merge-key"><code>xsl:merge-key</code></a></span> always
evaluate the instructions in their contained <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> in <a title=
"temporary output state" class="termref" href=
"#dt-temporary-output-state">temporary output state</a>.</p>
<p><a name="err-XTDE1480" id="err-XTDE1480"><span class=
"error">[ERR XTDE1480]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> to
evaluate the <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction in <a title="temporary output state" class="termref"
href="#dt-temporary-output-state">temporary output state</a>.</p>
<p><a name="err-XTDE1490" id="err-XTDE1490"><span class=
"error">[ERR XTDE1490]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> for a
transformation to generate two or more <a title="final result tree"
class="termref" href="#dt-final-result-tree">final result trees</a>
with the same URI.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Note, this means that it is an error to evaluate more than one
<a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction that omits the <code>href</code> attribute, or to
evaluate any <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction that omits the <code>href</code> attribute if an
initial <a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a> is created
implicitly.</p>
</div>
<p>In addition, an implementation <span class="verb">may</span>
report this error if it is able to detect that two or more final
result trees are generated with different URIs that refer to the
same physical resource.</p>
<p><a name="err-XTDE1500" id="err-XTDE1500"><span class=
"error">[ERR XTDE1500]</span></a> It is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> for a
<a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> to write to an external resource
and read from the same resource during a single transformation,
<span>if the same absolute URI is used to access the resource in
both cases</span>.</p>
<p>In addition, an implementation <span class="verb">may</span>
report this error if it is able to detect that a transformation
writes to a resource and reads from the same resource using
different URIs that refer to the same physical resource. Note that
if the error is not detected, it is <a title=
"implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a> whether
the document that is read from the resource reflects its state
before or after the result tree is written.</p>
</div>
<div class="div2">
<h3><a name="current-output-uri" id="current-output-uri"></a>24.3
<a href="#current-output-uri" style="text-decoration: none">The
Current Output URI</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-current-output-uri" id="dt-current-output-uri" title=
"current output URI"></a>The <b>current output URI</b> is the URI
associated with the final result tree that is currently being
written.<span class="definition">]</span></p>
<div class="div3">
<h4><a name="func-current-output-uri" id=
"func-current-output-uri"></a>24.3.1 <a href=
"#func-current-output-uri" style=
"text-decoration: none">fn:current-output-uri</a></h4>
<dl>
<dt class="label">Summary</dt>
<dd>
<p>Returns the value of the <a title="current output URI" class=
"termref" href="#dt-current-output-uri">current output URI</a>.</p>
</dd>
<dt class="label">Signature</dt>
<dd>
<p><a name="function-current-output-uri" id=
"function-current-output-uri"></a></p>
<div class="proto"><code class=
"function">current-output-uri</code>()<code class=
"as">&#160;as&#160;</code><code class=
"return-type">xs:anyURI?</code></div>
</dd>
<dt class="label">Properties</dt>
<dd>
<p>This function is <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>.</p>
</dd>
<dt class="label">Rules</dt>
<dd>
<p>On initial invocation of a stylesheet component, the current
output uri is set to the <a title="base output URI" class="termref"
href="#dt-base-output-uri">base output URI</a>.</p>
<p>During execution of an <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction with an <code>href</code> attribute, the current output
URI changes to the absolute URI obtained by resolving the <a title=
"effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the <code>href</code>
attribute against the base output URI.</p>
<p>The current output URI is cleared (set to <a title="absent"
class="termref" href="#dt-absent">absent</a>) while evaluating
stylesheet functions, dynamic function calls, evaluation of global
variables, stylesheet parameters, and patterns. If the function is
called when the current output URI is absent, the function returns
the empty sequence.</p>
<p>The current output URI may also be <a title="absent" class=
"termref" href="#dt-absent">absent</a> in the event that a
stylesheet is invoked without supplying a <a title=
"base output URI" class="termref" href="#dt-base-output-uri">base
output URI</a>.</p>
</dd>
<dt class="label">Notes</dt>
<dd>
<p>The current output URI is not cleared when evaluating a local
variable, even though <a href=
"#element-result-document"><code>xsl:result-document</code></a>
cannot be used while evaluating a local variable. The reason for
this is to allow the value of <code>current-output-uri</code> to be
set as the value of a tunnel parameter, so that the original base
output URI is accessible even when writing nested result
documents.</p>
</dd>
</dl>
</div>
</div>
<div class="div2">
<h3><a name="validation" id="validation"></a>24.4 <a href=
"#validation" style="text-decoration: none">Validation</a></h3>
<p>It is possible to control the <a title="type annotation" class=
"termref" href="#dt-type-annotation">type annotation</a> applied to
individual element and attribute nodes as they are constructed.
This is done using the <code>type</code> and
<code>validation</code> attributes of the <a href=
"#element-element"><code>xsl:element</code></a>, <a href=
"#element-attribute"><code>xsl:attribute</code></a>, <a href=
"#element-copy"><code>xsl:copy</code></a>, <a href=
"#element-copy-of"><code>xsl:copy-of</code></a>, <a href=
"#element-document"><code>xsl:document</code></a>, and <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instructions, or the <code>xsl:type</code> and
<code>xsl:validation</code> attributes of a <a title=
"literal result element" class="termref" href=
"#dt-literal-result-element">literal result element</a>. <span>The
same attributes are used on <a href=
"#element-stream"><code>xsl:stream</code></a> and <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> to
control validation of input documents.</span></p>
<p>The <code>[xsl:]type</code> attribute is used to request
validation of an element or attribute against a specific simple or
complex type defined in a schema. The <code>[xsl:]validation</code>
attribute is used to request validation against the global element
or attribute declaration whose name matches the name of the element
or attribute being validated.</p>
<p>The <code>[xsl:]type</code> and <code>[xsl:]validation</code>
attributes are mutually exclusive. Both are optional, but if one is
present then the other <span class="verb">must</span> be omitted.
If both attributes are omitted, the effect is the same as
specifying the <code>validation</code> attribute with the value
specified in the <span><code>[xsl:]default-validation</code>
attribute of the innermost containing element having such an
attribute</span>; if this is not specified, the effect is the same
as specifying <code>validation="strip"</code>.</p>
<p>The <code>[xsl:]default-validation</code> attribute defines the
default value of the <code>validation</code> attribute of all
<a href="#element-element"><code>xsl:element</code></a>, <a href=
"#element-attribute"><code>xsl:attribute</code></a>, <a href=
"#element-copy"><code>xsl:copy</code></a>, <a href=
"#element-copy-of"><code>xsl:copy-of</code></a>, <a href=
"#element-document"><code>xsl:document</code></a>, and <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instructions, and of the <code>xsl:validation</code> attribute of
all <a title="literal result element" class="termref" href=
"#dt-literal-result-element">literal result elements</a> <span>,
appearing within its scope</span>. It also determines the
validation applied to the implicit <a title="final result tree"
class="termref" href="#dt-final-result-tree">final result tree</a>
created in the absence of an <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction. This default applies within the containing <a title=
"stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet module</a> or <a title="package"
class="termref" href="#dt-package">package</a>: it does not extend
to included or imported stylesheet modules or used packages. If the
attribute is omitted, the default is <code>strip</code>. The
permitted values are <code>preserve</code> and
<code>strip</code>.</p>
<p>The <code>[xsl:]default-validation</code> attribute has no
effect on the <a href="#element-stream"><code>xsl:stream</code></a>
and <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> elements,
which perform no validation unless explicitly requested.</p>
<p><a name="err-XTSE1505" id="err-XTSE1505"><span class=
"error">[ERR XTSE1505]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if both
the <code>[xsl:]type</code> and <code>[xsl:]validation</code>
attributes are present on the <a href=
"#element-element"><code>xsl:element</code></a>, <a href=
"#element-attribute"><code>xsl:attribute</code></a>, <a href=
"#element-copy"><code>xsl:copy</code></a>, <a href=
"#element-copy-of"><code>xsl:copy-of</code></a>, <a href=
"#element-document"><code>xsl:document</code></a>, <a href=
"#element-result-document"><code>xsl:result-document</code></a>,
<span><a href="#element-stream"><code>xsl:stream</code></a>, or
<a href=
"#element-merge-source"><code>xsl:merge-source</code></a></span>
elements, or on a <a title="literal result element" class="termref"
href="#dt-literal-result-element">literal result element</a>.</p>
<p>The detailed rules for validation vary depending on the kind of
node being validated. The rules for element and attribute nodes are
given in <a href="#validating-constructed-nodes"><i>24.4.1
Validating Constructed Elements and Attributes</i></a>, while those
for document nodes are given in <a href=
"#validating-document-nodes"><i>24.4.2 Validating Document
Nodes</i></a>.</p>
<div class="div3">
<h4><a name="validating-constructed-nodes" id=
"validating-constructed-nodes"></a>24.4.1 <a href=
"#validating-constructed-nodes" style=
"text-decoration: none">Validating Constructed Elements and
Attributes</a></h4>
<div class="div4">
<h5><a name="validating-using-validation-attribute" id=
"validating-using-validation-attribute"></a>24.4.1.1 <a href=
"#validating-using-validation-attribute" style=
"text-decoration: none">Validation using the</a>
<code>[xsl:]validation</code> <a href=
"#validating-using-validation-attribute" style=
"text-decoration: none">Attribute</a></h5>
<p>The <code>[xsl:]validation</code> attribute defines the
validation action to be taken. It determines not only the <a title=
"type annotation" class="termref" href="#dt-type-annotation">type
annotation</a> of the node that is constructed by the relevant
instruction itself, but also the type annotations of all element
and attribute nodes that have the constructed node as an ancestor.
Conceptually, the validation requested for a child element or
attribute node is applied before the validation requested for its
parent element. For example, if the instruction that constructs a
child element specifies <code>validation="strict"</code>, this will
cause the child element to be checked against an element
declaration, but if the instruction that constructs its parent
element specifies <code>validation="strip"</code>, then the final
effect will be that the child node is annotated as
<code>xs:untyped</code>.</p>
<p>In the paragraphs below, the term <em>contained nodes</em> means
the elements and attributes that have the newly constructed node as
an ancestor.</p>
<ul>
<li>
<p>The value <code>strip</code> indicates that the new node and
each of the contained nodes will have the <a title=
"type annotation" class="termref" href="#dt-type-annotation">type
annotation</a> <code>xs:untyped</code> if it is an element, or
<code>xs:untypedAtomic</code> if it is an attribute. Any previous
type annotation present on a contained element or attribute node
(for example, a type annotation that is present on an element
copied from a source document) is also replaced by
<code>xs:untyped</code> or <code>xs:untypedAtomic</code> as
appropriate. The typed value of the node is changed to be the same
as its string value, as an instance of
<code>xs:untypedAtomic</code>. In the case of elements the
<code>nilled</code> property is set to <code>false</code>. The
values of the <code>is-id</code> and <code>is-idrefs</code>
properties are unchanged. Schema validation is not invoked.</p>
</li>
<li>
<p>The value <code>preserve</code> indicates that nodes that are
copied will retain their <a title="type annotation" class="termref"
href="#dt-type-annotation">type annotations</a>, but nodes whose
content is newly constructed will be annotated as
<code>xs:anyType</code> in the case of elements, or
<code>xs:untypedAtomic</code> in the case of attributes. Schema
validation is not invoked. The detailed effect depends on the
instruction:</p>
<ul>
<li>
<p>In the case of <a href=
"#element-element"><code>xsl:element</code></a> and literal result
elements, the new element has a <a title="type annotation" class=
"termref" href="#dt-type-annotation">type annotation</a> of
<code>xs:anyType</code>, and the type annotations of contained
nodes are retained unchanged.</p>
</li>
<li>
<p>In the case of <a href=
"#element-attribute"><code>xsl:attribute</code></a>, the effect is
exactly the same as specifying <code>validation="strip"</code>:
that is, the new attribute will have the type annotation
<code>xs:untypedAtomic</code>.</p>
</li>
<li>
<p>In the case of <a href=
"#element-copy-of"><code>xsl:copy-of</code></a>, all the nodes that
are copied will retain their type annotations unchanged.</p>
</li>
<li>
<p>In the case of <a href=
"#element-copy"><code>xsl:copy</code></a>, the effect depends on
the kind of node being copied.</p>
<ol class="enumar">
<li>
<p>Where the node being copied is an attribute, the copied
attribute will retain its <a title="type annotation" class=
"termref" href="#dt-type-annotation">type annotation</a>.</p>
</li>
<li>
<p>Where the node being copied is an element, the copied element
will have a <a title="type annotation" class="termref" href=
"#dt-type-annotation">type annotation</a> of
<code>xs:anyType</code> (because this instruction does not copy the
content of the element, it would be wrong to assume that the type
is unchanged); but any contained nodes will have their type
annotations retained in the same way as with <a href=
"#element-element"><code>xsl:element</code></a>.</p>
</li>
</ol>
</li>
</ul>
</li>
<li>
<p>The value <code>strict</code> indicates that <a title=
"type annotation" class="termref" href="#dt-type-annotation">type
annotations</a> are established by performing strict schema
validity assessment on the element or attribute node created by
this instruction as follows:</p>
<ul>
<li>
<p>In the case of an element, a top-level element declaration is
identified whose local name and namespace (if any) match the name
of the element, and schema-validity assessment is carried out
according to the rules defined in <a href="#xmlschema-1">[XML
Schema Part 1]</a> (section 3.3.4 "Element Declaration Validation
Rules", validation rule "Schema-Validity Assessment (Element)",
clauses 1.1 and 2, using the top-level element declaration as the
"declaration stipulated by the processor", which is mentioned in
clause 1.1.1.1). The element is considered valid if the result of
the schema validity assessment is a PSVI in which the relevant
element node has a <code>validity</code> property whose value is
<code>valid</code>. If there is no matching element declaration, or
if the element is not considered valid, the transformation fails
<span class="error">[see <a href="#err-XTTE1510">ERR
XTTE1510</a>]</span>, <span class="error">[see <a href=
"#err-XTTE1512">ERR XTTE1512</a>]</span>. In effect this means that
the element being validated <span class="verb">must</span> be
declared using a top-level declaration in the schema, and
<span class="verb">must</span> conform to its declaration. The
process of validation applies recursively to contained elements and
attributes to the extent required by the schema definition.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>It is not an error if the identified type definition is a simple
type, although <a href="#xmlschema-1">[XML Schema Part 1]</a> does
not define explicitly that this case is permitted.</p>
</div>
</li>
<li>
<p>In the case of an attribute, a top-level attribute declaration
is identified whose local name and namespace (if any) match the
name of the attribute, and schema-validity assessment is carried
out according to the rules defined in <a href="#xmlschema-1">[XML
Schema Part 1]</a> (section 3.2.4 "Attribute Declaration Validation
Rules", validation rule "Schema-Validity Assessment (Attribute)").
The attribute is considered valid if the result of the schema
validity assessment is a PSVI in which the relevant attribute node
has a <code>validity</code> property whose value is
<code>valid</code>. If the attribute is not considered valid, the
transformation fails <span class="error">[see <a href=
"#err-XTTE1510">ERR XTTE1510</a>]</span>. In effect this means that
the attribute being validated <span class="verb">must</span> be
declared using a top-level declaration in the schema, and
<span class="verb">must</span> conform to its declaration.</p>
</li>
<li>
<p>The schema components used to validate an element or attribute
may be located in any way described by <a href="#xmlschema-1">[XML
Schema Part 1]</a> (see section 4.3.2, <em>How schema documents are
located on the Web</em>). The components in the schema constructed
from the synthetic schema document (see <a href=
"#import-schema"><i>3.16 Importing Schema Components</i></a>) will
always be available for validating constructed nodes; if additional
schema components are needed, they <span class="verb">may</span> be
located in other ways, for example implicitly from knowledge of the
namespace in which the elements and attributes appear, or using the
<code>xsi:schemaLocation</code> attribute of elements within the
tree being validated.</p>
</li>
<li>
<p>If no validation is performed for a node, which can happen when
the schema specifies <code>lax</code> or <code>skip</code>
validation for that node or for a subtree, then the node is
annotated as <code>xs:anyType</code> in the case of an element, and
<code>xs:untypedAtomic</code> in the case of an attribute.</p>
</li>
</ul>
</li>
<li>
<p>The value <code>lax</code> has the same effect as the value
<code>strict</code>, except that whereas <code>strict</code>
validation fails if there is no matching top-level element
declaration or if the outcome of validity assessment is a
<code>validity</code> property of <code>invalid</code> or
<code>notKnown</code>, <code>lax</code> validation fails only if
the outcome of validity assessment is a <code>validity</code>
property of <code>invalid</code>. That is, <code>lax</code>
validation does not cause a <a title="type error" class="termref"
href="#dt-type-error">type error</a> when the outcome is
<code>notKnown</code>.</p>
<p>In practice this means that the element or attribute being
validated <span class="verb">must</span> conform to its declaration
if a top-level declaration is available. If no such declaration is
available, then the element or attribute is not validated, but its
attributes and children are validated, again with lax validation.
Any nodes whose validation outcome is a <code>validity</code>
property of <code>notKnown</code> are annotated as
<code>xs:anyType</code> in the case of an element, and
<code>xs:untypedAtomic</code> in the case of an attribute.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>When the parent element lacks a declaration, the XML Schema
specification defines the recursive checking of children and
attributes as optional. For this specification, this recursive
checking is required.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>If an element that is being validated has an
<code>xsi:type</code> attribute, then the value of the
<code>xsi:type</code> attribute will be taken into account when
performing the validation. However, the presence of an
<code>xsi:type</code> attribute will not of itself cause an element
to be validated: if validation against a named type is required, as
distinct from validation against a top-level element declaration,
then it must be requested using the XSLT <code>[xsl:]type</code>
attribute on the instruction that invokes the validation, as
described in section <a href="#validation-xsl-type"><i>24.4.1.2
Validation using the [xsl:]type Attribute</i></a></p>
</div>
</li>
</ul>
<p><a name="err-XTTE1510" id="err-XTTE1510"><span class=
"error">[ERR XTTE1510]</span></a> If the <code>validation</code>
attribute of an <a href=
"#element-element"><code>xsl:element</code></a>, <a href=
"#element-attribute"><code>xsl:attribute</code></a>, <a href=
"#element-copy"><code>xsl:copy</code></a>, <a href=
"#element-copy-of"><code>xsl:copy-of</code></a>, or <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction, or the <code>xsl:validation</code> attribute of a
literal result element, has the effective value
<code>strict</code>, and schema validity assessment concludes that
the validity of the element or attribute is invalid or unknown, a
<a title="type error" class="termref" href="#dt-type-error">type
error</a> occurs. As with other type errors, the error <span class=
"verb">may</span> be signaled statically if it can be detected
statically.</p>
<p><a name="err-XTTE1512" id="err-XTTE1512"><span class=
"error">[ERR XTTE1512]</span></a> If the <code>validation</code>
attribute of an <a href=
"#element-element"><code>xsl:element</code></a>, <a href=
"#element-attribute"><code>xsl:attribute</code></a>, <a href=
"#element-copy"><code>xsl:copy</code></a>, <a href=
"#element-copy-of"><code>xsl:copy-of</code></a>, or <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction, or the <code>xsl:validation</code> attribute of a
literal result element, has the effective value
<code>strict</code>, and there is no matching top-level declaration
in the schema, then a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> occurs. As with other type errors,
the error <span class="verb">may</span> be signaled statically if
it can be detected statically.</p>
<p><a name="err-XTTE1515" id="err-XTTE1515"><span class=
"error">[ERR XTTE1515]</span></a> If the <code>validation</code>
attribute of an <a href=
"#element-element"><code>xsl:element</code></a>, <a href=
"#element-attribute"><code>xsl:attribute</code></a>, <a href=
"#element-copy"><code>xsl:copy</code></a>, <a href=
"#element-copy-of"><code>xsl:copy-of</code></a>, or <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction, or the <code>xsl:validation</code> attribute of a
literal result element, has the effective value <code>lax</code>,
and schema validity assessment concludes that the element or
attribute is invalid, a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> occurs. As with other type errors,
the error <span class="verb">may</span> be signaled statically if
it can be detected statically.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>No mechanism is provided to validate an element or attribute
against a local declaration in a schema. Such validation can
usually be achieved by applying validation to a containing element
for which a top-level element declaration exists.</p>
</div>
</div>
<div class="div4">
<h5><a name="validation-xsl-type" id=
"validation-xsl-type"></a>24.4.1.2 <a href="#validation-xsl-type"
style="text-decoration: none">Validation using the</a>
<code>[xsl:]type</code> <a href="#validation-xsl-type" style=
"text-decoration: none">Attribute</a></h5>
<p>The <code>[xsl:]type</code> attribute takes as its value a
<code>QName</code>. This <span class="verb">must</span> be the name
of a type definition included in the <a title=
"in-scope schema component" class="termref" href=
"#dt-in-scope-schema-component">in-scope schema components</a> for
the stylesheet. If the QName has no prefix, it is expanded using
the default namespace established using the effective
<code>[xsl:]xpath-default-namespace</code> attribute if there is
one; otherwise, it is taken as being a name in no namespace.</p>
<p>If the <code>[xsl:]type</code> attribute is present, then the
newly constructed element or attribute is validated against the
type definition identified by this attribute.</p>
<ul>
<li>
<p>In the case of an element, schema-validity assessment is carried
out according to the rules defined in <a href="#xmlschema-1">[XML
Schema Part 1]</a> (section 3.3.4 "Element Declaration Validation
Rules", validation rule "Schema-Validity Assessment (Element)",
clauses 1.2 and 2), using this type definition as the
"processor-stipulated type definition". The element is considered
valid if the result of the schema validity assessment is a PSVI in
which the relevant element node has a <code>validity</code>
property whose value is <code>valid</code>.</p>
</li>
<li>
<p>In the case of an attribute, the attribute is considered valid
if (in the terminology of XML Schema) the attribute's normalized
value is locally valid with respect to that type definition
according to the rules for "String Valid" (<a href=
"#xmlschema-1">[XML Schema Part 1]</a>, section 3.14.4).
(Normalization here refers to the process of normalizing whitespace
according to the rules of the <code>whiteSpace</code> facet for the
datatype).</p>
</li>
<li>
<p>If the element or attribute is not considered valid, as defined
above, the transformation fails <span class="error">[see <a href=
"#err-XTTE1540">ERR XTTE1540</a>]</span>.</p>
</li>
</ul>
<p>If an element node is validated against the type
<code>xs:untyped</code>, the effect is the same as specifying
<code>validation="strip"</code>: that is, the elements and
attributes in the subtree rooted at the target element are copied
with a type annotation of <code>xs:untyped</code> or
<code>xs:untypedAtomic</code> respectively.</p>
<p>If an element or attribute node is validated against the type
<code>xs:untypedAtomic</code>, the effect is the same as specifying
<code>[xsl:]type="xs:string"</code> except that when validation
succeeds, the returned element or attribute has a type annotation
of <code>xs:untypedAtomic</code>. Validation fails in the case of
an element with element children.</p>
<p><a name="err-XTSE1520" id="err-XTSE1520"><span class=
"error">[ERR XTSE1520]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
value of the <code>type</code> attribute of an <a href=
"#element-element"><code>xsl:element</code></a>, <a href=
"#element-attribute"><code>xsl:attribute</code></a>, <a href=
"#element-copy"><code>xsl:copy</code></a>, <a href=
"#element-copy-of"><code>xsl:copy-of</code></a>, <a href=
"#element-document"><code>xsl:document</code></a>, or <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction, or the <code>xsl:type</code> attribute of a literal
result element, is not a valid <code>QName</code>, or if it uses a
prefix that is not defined in an in-scope namespace declaration, or
if the QName is not the name of a type definition included in the
<a title="in-scope schema component" class="termref" href=
"#dt-in-scope-schema-component">in-scope schema components</a> for
the <a title="package" class="termref" href=
"#dt-package">package</a>.</p>
<p><a name="err-XTSE1530" id="err-XTSE1530"><span class=
"error">[ERR XTSE1530]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if the
value of the <code>type</code> attribute of an <a href=
"#element-attribute"><code>xsl:attribute</code></a> instruction
refers to a complex type definition.</p>
<p><a name="err-XTTE1535" id="err-XTTE1535"><span class=
"error">[ERR XTTE1535]</span></a> It is a <a title="type error"
class="termref" href="#dt-type-error">type error</a> if the value
of the <code>type</code> attribute of an <a href=
"#element-copy"><code>xsl:copy</code></a> or <a href=
"#element-copy-of"><code>xsl:copy-of</code></a> instruction refers
to a complex type definition and one or more of the items being
copied is an attribute node.</p>
<p><a name="err-XTTE1540" id="err-XTTE1540"><span class=
"error">[ERR XTTE1540]</span></a> It is a <a title="type error"
class="termref" href="#dt-type-error">type error</a> if an
<code>[xsl:]type</code> attribute is defined for a constructed
element or attribute, and the outcome of schema validity assessment
against that type is that the <code>validity</code> property of
that element or attribute information item is other than
<code>valid</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Like other type errors, this error may be signaled statically if
it can be detected statically. For example, the instruction
<code>&lt;xsl:attribute name="dob"
type="xs:date"&gt;1999-02-29&lt;/xsl:attribute&gt;</code> may
result in a static error being signaled. If the error is not
signaled statically, it will be signaled when the instruction is
evaluated.</p>
</div>
</div>
<div class="div4">
<h5><a name="validation-process" id=
"validation-process"></a>24.4.1.3 <a href="#validation-process"
style="text-decoration: none">The Validation Process</a></h5>
<p>As well as checking for validity against the schema, the
validity assessment process causes <a title="type annotation"
class="termref" href="#dt-type-annotation">type annotations</a> to
be associated with element and attribute nodes. If default values
for elements or attributes are defined in the schema, the
validation process will where necessary create new nodes containing
these default values.</p>
<p>Validation of an element or attribute node only takes into
account constraints on the content of the element or attribute.
Validation rules affecting the document as a whole are not applied.
Specifically, this means:</p>
<ul>
<li>
<p>The validation rule "Validation Root Valid (ID/IDREF)" is not
applied. This means that validation will not fail if there are
non-unique ID values or dangling IDREF values in the subtree being
validated.</p>
</li>
<li>
<p>The validation rule "Validation Rule: Identity-constraint
Satisfied" <span class="verb">should</span> be applied.</p>
</li>
<li>
<p>There is no check that the document contains unparsed entities
whose names match the values of nodes of type
<code>xs:ENTITY</code> or <code>xs:ENTITIES</code>. (XSLT
<span>3.0</span> provides no facility to construct unparsed
entities within a tree.)</p>
</li>
</ul>
<p>With these caveats, validating a newly constructed element,
using strict or lax validation, is equivalent to the following
steps:</p>
<ol class="enumar">
<li>
<p>The element is serialized to textual XML form, according to the
rules defined in <a href="#xslt-xquery-serialization-30">[XSLT and
XQuery Serialization]</a> using the XML output method, with all
parameters defaulted. Note that this process discards any existing
<a title="type annotation" class="termref" href=
"#dt-type-annotation">type annotations</a>.</p>
</li>
<li>
<p>The resulting XML document is parsed to create an XML
Information Set (see <a href="#xml-infoset">[XML Information
Set]</a>.)</p>
</li>
<li>
<p>The Information Set produced in the previous step is validated
according to the rules in <a href="#xmlschema-1">[XML Schema Part
1]</a>. The result of this step is a Post-Schema Validation Infoset
(PSVI). If the validation process is not successful (as defined
above), a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> is raised.</p>
</li>
<li>
<p>The PSVI produced in the previous step is converted back into
the XDM data model by the mapping described in <a href=
"#xpath-datamodel-30">[Data Model]</a> (<a href=
"http://www.w3.org/TR/xpath-datamodel-30/#PSVI2Types">Section 3.3.1
Mapping PSVI Additions to Node Properties</a>
<sup><small>DM30</small></sup>). This process creates nodes with
simple or complex <a title="type annotation" class="termref" href=
"#dt-type-annotation">type annotations</a> based on the types
established during schema validation.</p>
</li>
</ol>
<p>The above process must be done in such a way that the base URI
property of every node in the resulting XDM tree is the same as the
base URI property of the corresponding node in the input tree.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>As an alternative to steps 1 and 2, the XDM tree may be
converted to an Infoset directly, using the mapping rules given for
each kind of node in <a href="#xpath-datamodel-30">[Data Model]</a>
(Section 6).</p>
</div>
<p>Validating an attribute using strict or lax validation requires
a modified version of this procedure. A copy of the attribute is
first added to an element node that is created for the purpose, and
namespace fixup (see <a href="#namespace-fixup"><i>5.8.3 Namespace
Fixup</i></a>) is performed on this element node. The name of this
element is of no consequence, but it must be the same as the name
of a synthesized element declaration of the form:</p>
<div class="exampleInner">
<pre>
&lt;xs:element name="E"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:sequence/&gt;
    &lt;xs:attribute ref="A"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</pre></div>
<p>where A is the name of the attribute being validated.</p>
<p>This synthetic element is then validated using the procedure
given above for validating elements, and if it is found to be
valid, a copy of the validated attribute is made, retaining its
<a title="type annotation" class="termref" href=
"#dt-type-annotation">type annotation</a>, but detaching it from
the containing element (and thus, from any namespace nodes).</p>
<p>The XDM data model does not permit an attribute node with no
parent to have a typed value that includes a namespace-qualified
name, that is, a value whose type is derived from
<code>xs:QName</code> or <code>xs:NOTATION</code>. This restriction
is imposed because these types rely on the namespace nodes of a
containing element to resolve namespace prefixes. Therefore, it is
an error to validate a parentless attribute against such a type.
This affects the instructions <a href=
"#element-attribute"><code>xsl:attribute</code></a>, <a href=
"#element-copy"><code>xsl:copy</code></a>, and <a href=
"#element-copy-of"><code>xsl:copy-of</code></a>.</p>
<p><a name="err-XTTE1545" id="err-XTTE1545"><span class=
"error">[ERR XTTE1545]</span></a> A <a title="type error" class=
"termref" href="#dt-type-error">type error</a> occurs if a
<code>type</code> or <code>validation</code> attribute is defined
(explicitly or implicitly) for an instruction that constructs a new
attribute node, if the effect of this is to cause the attribute
value to be validated against a type that is derived from, or
constructed by list or union from, the primitive types
<code>xs:QName</code> or <code>xs:NOTATION</code>.</p>
</div>
</div>
<div class="div3">
<h4><a name="validating-document-nodes" id=
"validating-document-nodes"></a>24.4.2 <a href=
"#validating-document-nodes" style=
"text-decoration: none">Validating Document Nodes</a></h4>
<p>It is possible to apply validation to a document node. This
happens when a new document node is constructed by one of the XSLT
elements <span><a href=
"#element-stream"><code>xsl:stream</code></a></span>,
<span><a href="#element-merge-source"><code>xsl:merge-source</code></a></span>,
<a href="#element-document"><code>xsl:document</code></a>, <a href=
"#element-result-document"><code>xsl:result-document</code></a>,
<a href="#element-copy"><code>xsl:copy</code></a>, or <a href=
"#element-copy-of"><code>xsl:copy-of</code></a>, and this element
has a <code>type</code> attribute, or a <code>validation</code>
attribute with the value <code>strict</code> or
<code>lax</code>.</p>
<p>Document-level validation is not applied to the document node
that is created implicitly when a variable-binding element has no
<code>select</code> attribute and no <code>as</code> attribute (see
<a href="#temporary-trees"><i>9.4 Creating Implicit Document
Nodes</i></a>). This is equivalent to using
<code>validation="preserve"</code> on <a href=
"#element-document"><code>xsl:document</code></a>: nodes within
such trees retain their <a title="type annotation" class="termref"
href="#dt-type-annotation">type annotation</a>. Similarly,
validation is not applied to document nodes created using <a href=
"#element-message"><code>xsl:message</code></a> <span>or <a href=
"#element-assert"><code>xsl:assert</code></a></span>.</p>
<p>The values <code>validation="preserve"</code> and
<code>validation="strip"</code> do not request validation. In the
first case, all element and attribute nodes within the tree rooted
at the new document node retain their <a title="type annotation"
class="termref" href="#dt-type-annotation">type annotations</a>. In
the second case, elements within the tree have their type
annotation set to <code>xs:untyped</code>, while attributes have
their type annotation set to <code>xs:untypedAtomic</code>.</p>
<p>When validation is requested for a document node (that is, when
<code>validation</code> is set to <code>strict</code> or
<code>lax</code>, or when a <code>type</code> attribute is
present), the following processing takes place:</p>
<ul>
<li>
<p><a name="err-XTTE1550" id="err-XTTE1550"><span class=
"error">[ERR XTTE1550]</span></a> A <a title="type error" class=
"termref" href="#dt-type-error">type error</a> occurs unless the
children of the document node comprise exactly one element node, no
text nodes, and zero or more comment and processing instruction
nodes, in any order.</p>
</li>
<li>
<p>The single element node child is validated, using the supplied
values of the <code>validation</code> and <code>type</code>
attributes, as described in <a href=
"#validating-constructed-nodes"><i>24.4.1 Validating Constructed
Elements and Attributes</i></a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The <code>type</code> attribute on <span><a href=
"#element-stream"><code>xsl:stream</code></a></span>, <a href=
"#element-document"><code>xsl:document</code></a> and <a href=
"#element-result-document"><code>xsl:result-document</code></a>,
and on <a href="#element-copy"><code>xsl:copy</code></a> and
<a href="#element-copy-of"><code>xsl:copy-of</code></a> when
copying a document node, thus refers to the required type of the
element node that is the only element child of the document node.
It does not refer to the type of the document node itself.</p>
</div>
</li>
<li>
<p>The validation rule "Validation Root Valid (ID/IDREF)" is
applied to the single element node child of the document node. This
means that validation will fail if there are non-unique ID values
or dangling IDREF values in the document tree.</p>
</li>
<li>
<p>Identity constraints, as defined in section 3.11 of <a href=
"#xmlschema-1">[XML Schema Part 1]</a>, are checked. (This refers
to constraints defined using <code>xs:unique</code>,
<code>xs:key</code>, and <code>xs:keyref</code>.)</p>
</li>
<li>
<p>There is no check that the tree contains unparsed entities whose
names match the values of nodes of type <code>xs:ENTITY</code> or
<code>xs:ENTITIES</code>. This is because there is no facility in
XSLT <span>3.0</span> to create unparsed entities in a <a title=
"result tree" class="termref" href="#dt-result-tree">result
tree</a>. It is possible to add unparsed entity declarations to the
result document by referencing a suitable DOCTYPE during
serialization.</p>
</li>
<li>
<p>All other children of the document node (comments and processing
instructions) are copied unchanged.</p>
</li>
</ul>
<p><a name="err-XTTE1555" id="err-XTTE1555"><span class=
"error">[ERR XTTE1555]</span></a> It is a <a title="type error"
class="termref" href="#dt-type-error">type error</a> if, when
validating a document node, document-level constraints (such as
ID/IDREF constraints) are not satisfied.</p>
</div>
</div>
</div>
<div class="div1">
<h2><a name="serialization" id="serialization"></a>25 <a href=
"#serialization" style=
"text-decoration: none">Serialization</a></h2>
<p>A <a title="processor" class="termref" href=
"#dt-processor">processor</a> <span class="verb">may</span> output
a <a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a> as a sequence of
octets, although it is not <span class="verb">required</span> to be
able to do so (see <a href="#conformance"><i>26
Conformance</i></a>). Stylesheet authors can use <a href=
"#element-output"><code>xsl:output</code></a> declarations to
specify how they wish result trees to be serialized. If a processor
serializes a final result tree, it <span class="verb">must</span>
do so as specified by these declarations.</p>
<p>The rules governing the output of the serializer are defined in
<a href="#xslt-xquery-serialization-30">[XSLT and XQuery
Serialization]</a>. The serialization is controlled using a number
of serialization parameters. The values of these serialization
parameters may be set within the <a title="stylesheet" class=
"termref" href="#dt-stylesheet">stylesheet</a>, using the <a href=
"#element-output"><code>xsl:output</code></a>, <a href=
"#element-result-document"><code>xsl:result-document</code></a>,
and <a href=
"#element-character-map"><code>xsl:character-map</code></a>
declarations.</p>
<p class="element-syntax"><a name="element-output" id=
"element-output"></a><code>&lt;!-- Category: declaration
--&gt;<br />
&lt;xsl:output<br />
&#160;&#160;name? = <var>eqname</var><br />
&#160;&#160;method? = "xml" | "html" | "xhtml" | "text" |
<var>eqname</var><br />
&#160;&#160;byte-order-mark? = <var>boolean</var><br />
&#160;&#160;cdata-section-elements? = <var>eqnames</var><br />
&#160;&#160;doctype-public? = <var>string</var><br />
&#160;&#160;doctype-system? = <var>string</var><br />
&#160;&#160;encoding? = <var>string</var><br />
&#160;&#160;escape-uri-attributes? = <var>boolean</var><br />
&#160;&#160;html-version? = <var>decimal</var><br />
&#160;&#160;include-content-type? = <var>boolean</var><br />
&#160;&#160;indent? = <var>boolean</var><br />
&#160;&#160;item-separator? = <var>string</var><br />
&#160;&#160;media-type? = <var>string</var><br />
&#160;&#160;normalization-form? = "NFC" | "NFD" | "NFKC" | "NFKD" |
"fully-normalized" | "none" | <var>nmtoken</var><br />
&#160;&#160;omit-xml-declaration? = <var>boolean</var><br />
&#160;&#160;parameter-document? = <var>uri</var><br />
&#160;&#160;standalone? = <var>boolean</var> | "omit"<br />
&#160;&#160;suppress-indentation? = <var>eqnames</var><br />
&#160;&#160;undeclare-prefixes? = <var>boolean</var><br />
&#160;&#160;use-character-maps? = <var>eqnames</var><br />
&#160;&#160;version? = <var>nmtoken</var>&#160;/&gt;</code></p>
<p>The <a href="#element-output"><code>xsl:output</code></a>
declaration is optional; if used, it <span class="verb">must</span>
always appear as a <a title="top-level" class="termref" href=
"#dt-top-level">top-level</a> element within a stylesheet
module.</p>
<p>A <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> may contain multiple <a href=
"#element-output"><code>xsl:output</code></a> declarations and may
include or import stylesheet modules that also contain <a href=
"#element-output"><code>xsl:output</code></a> declarations. The
name of an <a href="#element-output"><code>xsl:output</code></a>
declaration is the value of its <code>name</code> attribute, if
any.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-output-definition" id="dt-output-definition" title=
"output definition"></a>All the <a href=
"#element-output"><code>xsl:output</code></a> declarations
<span>within a <a title="package" class="termref" href=
"#dt-package">package</a></span> that share the same name are
grouped into a named <b>output definition</b>; those that have no
name are grouped into a single unnamed output
definition.<span class="definition">]</span></p>
<p>An output definition is scoped to a package. If this is a
<a title="library package" class="termref" href=
"#dt-library-package">library package</a> the output definition
applies only to <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instructions within the same package. If it is the <a title=
"top-level package" class="termref" href=
"#dt-top-level-package">top-level package</a>, the output
definition applies to <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instructions within the same package and also to the implicit
<a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a>.</p>
<p>A stylesheet always includes an unnamed <a title=
"output definition" class="termref" href=
"#dt-output-definition">output definition</a>; in the absence of an
unnamed <a href="#element-output"><code>xsl:output</code></a>
declaration, the unnamed output definition is equivalent to the one
that would be used if the stylesheet contained an <a href=
"#element-output"><code>xsl:output</code></a> declaration having no
attributes.</p>
<p>A named <a title="output definition" class="termref" href=
"#dt-output-definition">output definition</a> is used when its name
matches the <code>format</code> attribute used in an <a href=
"#element-result-document"><code>xsl:result-document</code></a>
element. The unnamed output definition is used when an <a href=
"#element-result-document"><code>xsl:result-document</code></a>
element omits the <code>format</code> attribute. It is also used
when serializing the <a title="final result tree" class="termref"
href="#dt-final-result-tree">final result tree</a> that is created
implicitly in the absence of an <a href=
"#element-result-document"><code>xsl:result-document</code></a>
element.</p>
<p>All the <a href="#element-output"><code>xsl:output</code></a>
elements making up an <a title="output definition" class="termref"
href="#dt-output-definition">output definition</a> are effectively
merged. For those attributes whose values are namespace-sensitive,
the merging is done after <a title="lexical QName" class="termref"
href="#dt-lexical-qname">lexical QNames</a> have been converted
into <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QNames</a>. For the
<code>cdata-section-elements</code> <span>and
<code>suppress-indentation</code></span> attributes, the output
definition uses the union of the values from all the constituent
<a href="#element-output"><code>xsl:output</code></a> declarations.
For the <code>use-character-maps</code> attribute, the output
definition uses the concatenation of the sequences of <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QNames</a> values from all the constituent <a href=
"#element-output"><code>xsl:output</code></a> declarations, taking
them in order of increasing <a title="import precedence" class=
"termref" href="#dt-import-precedence">import precedence</a>, or
where several have the same import precedence, in <a title=
"declaration order" class="termref" href=
"#dt-declaration-order">declaration order</a>. For other
attributes, the <a title="output definition" class="termref" href=
"#dt-output-definition">output definition</a> uses the value of
that attribute from the <a href=
"#element-output"><code>xsl:output</code></a> declaration with the
highest <a title="import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a>.</p>
<p>The <code>parameter-document</code> attribute allows
serialization parameters to be supplied in an external document.
The external document must contain an
<code>output:serialization-parameters</code> element with the
format described in <a href=
"http://www.w3.org/TR/xslt-xquery-serialization-30/#serparams-in-xdm-instance">
Section 3.1 Setting Serialization Parameters by Means of a Data
Model Instance</a> <sup><small>SER30</small></sup>, and the
parameters are interpreted as described in that specification.</p>
<p>If present, the URI supplied in the
<code>parameter-document</code> attribute is dereferenced, after
resolution against the base URI of the <code>xsl:output</code>
element if it is a relative reference. If the location of the
stylesheet at development time is different from the deployed
location, any relative reference should be resolved against the
deployed location. A serialization error occurs if the result of
dereferencing the URI is ill-formed or invalid; but if no document
can be found at the specified location, the attribute
<code>may</code> be ignored.</p>
<p>A serialization parameter specified in the
<code>parameter-document</code> takes precedence over a value
supplied directly in the output declaration, except that the values
of the <code>cdata-section-elements</code> and
<code>suppress-indentation</code> attributes are merged in the same
way as when multiple <code>xsl:output</code> declarations are
merged.</p>
<p><a name="err-XTSE1560" id="err-XTSE1560"><span class=
"error">[ERR XTSE1560]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if two
<a href="#element-output"><code>xsl:output</code></a> declarations
within an <a title="output definition" class="termref" href=
"#dt-output-definition">output definition</a> specify explicit
values for the same attribute (other than
<code>cdata-section-elements</code>,
<span><code>suppress-indentation</code>,</span> and
<code>use-character-maps</code>), with the values of the attributes
being not equal, unless there is another <a href=
"#element-output"><code>xsl:output</code></a> declaration within
the same <a title="output definition" class="termref" href=
"#dt-output-definition">output definition</a> that has higher
import precedence and that specifies an explicit value for the same
attribute.</p>
<p>If none of the <a href=
"#element-output"><code>xsl:output</code></a> declarations within
an <a title="output definition" class="termref" href=
"#dt-output-definition">output definition</a> specifies a value for
a particular attribute, then the corresponding serialization
parameter takes a default value. The default value depends on the
chosen output method.</p>
<p>There are some serialization parameters that apply to some
output methods but not to others. For example, the
<code>indent</code> attribute has no effect on the
<code>text</code> output method. If a value is supplied for an
attribute that is inapplicable to the output method, its value is
not passed to the serializer. The processor <span class=
"verb">may</span> validate the value of such an attribute, but is
not <span class="verb">required</span> to do so.</p>
<p>An implementation <span class="verb">may</span> allow the
attributes of the <a href=
"#element-output"><code>xsl:output</code></a> declaration to be
overridden, or the default values to be changed, using the API that
controls the transformation.</p>
<p>The location to which <a title="final result tree" class=
"termref" href="#dt-final-result-tree">final result trees</a> are
serialized (whether in filestore or elsewhere) is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> (which in
practice <span class="verb">may</span> mean that it is controlled
using an implementation-defined API). However, these locations
<span class="verb">must</span> satisfy the constraint that when two
<a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result trees</a> are both created
(implicitly or explicitly) using relative URI
<span>references</span> in the <code>href</code> attribute of the
<a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction, then these relative URI <span>references</span> may be
used to construct references from one tree to the other, and such
references <span class="verb">must</span> remain valid when both
result trees are serialized.</p>
<p>The <code>method</code> attribute on the <a href=
"#element-output"><code>xsl:output</code></a> element identifies
the overall method that is to be used for outputting the <a title=
"final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a>.</p>
<p><a name="err-XTSE1570" id="err-XTSE1570"><span class=
"error">[ERR XTSE1570]</span></a> The value <span class=
"verb">must</span> (if present) be a valid <a title="EQName" class=
"termref" href="#dt-eqname">EQName</a>. If it is a <a title=
"lexical QName" class="termref" href="#dt-lexical-qname">lexical
QName</a> with no a prefix, then it identifies a method specified
in <a href="#xslt-xquery-serialization-30">[XSLT and XQuery
Serialization]</a> and <span class="verb">must</span> be one of
<code>xml</code>, <code>html</code>, <code>xhtml</code>, or
<code>text</code>. If it is a <a title="lexical QName" class=
"termref" href="#dt-lexical-qname">lexical QName</a> with a prefix,
then the <a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a> is expanded into an <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a> as described in <a href="#qname"><i>5.1 Qualified
Names</i></a>; the <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> identifies the output
method; the behavior in this case is not specified by this
document.</p>
<p>The default for the <code>method</code> attribute depends on the
contents of the tree being serialized, and is chosen as follows. If
the document node of the <a title="final result tree" class=
"termref" href="#dt-final-result-tree">final result tree</a> has an
element child, and any text nodes preceding the first element child
of the document node of the result tree contain only whitespace
characters, then:</p>
<ul>
<li>
<p>If the <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> of this first element child
has local part <code>html</code> (in lower case), and namespace URI
<code>http://www.w3.org/1999/xhtml</code>, then the default output
method is normally <code>xhtml</code>. However, <span>if the
<a title="effective version" class="termref" href=
"#dt-effective-version">effective version</a> of the outermost
element of the <a title="principal stylesheet module" class=
"termref" href="#dt-principal-stylesheet-module">principal
stylesheet module</a> in the <a title="top-level package" class=
"termref" href="#dt-top-level-package">top-level package</a> has
the value <code>1.0</code>,</span> and if the result tree is
generated implicitly (rather than by an explicit <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction), then the default output method in this situation is
<code>xml</code>.</p>
</li>
<li>
<p>If the <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> of this first element child
has local part <code>html</code> (in any combination of upper and
lower case) and a null namespace URI, then the default output
method is <code>html</code>.</p>
</li>
</ul>
<p>In all other cases, the default output method is
<code>xml</code>.</p>
<p>The default output method is used if the selected <a title=
"output definition" class="termref" href=
"#dt-output-definition">output definition</a> does not include a
<code>method</code> attribute.</p>
<p>The other attributes on <a href=
"#element-output"><code>xsl:output</code></a> provide parameters
for the output method. The following attributes are allowed:</p>
<ul>
<li>
<p>The value of the <code>encoding</code> attribute provides the
value of the <code>encoding</code> parameter to the serialization
method. The default value is <a title="implementation-defined"
class="termref" href=
"#dt-implementation-defined">implementation-defined</a>, but in the
case of the <code>xml</code> and <code>xhtml</code> methods it
<span class="verb">must</span> be either <code>UTF-8</code> or
<code>UTF-16</code>.</p>
</li>
<li>
<p>The <code>byte-order-mark</code> attribute defines whether a
byte order mark is written at the start of the file. If the value
<code>yes</code> is specified, a byte order mark is written; if
<code>no</code> is specified, no byte order mark is written. The
default value depends on the encoding used. If the encoding is
<code>UTF-16</code>, the default is <code>yes</code>; for
<code>UTF-8</code> it is <a title="implementation-defined" class=
"termref" href=
"#dt-implementation-defined">implementation-defined</a>, and for
all other encodings it is <code>no</code>. The value of the byte
order mark indicates whether high order bytes are written before or
after low order bytes; the actual byte order used is <a title=
"implementation-dependent" class="termref" href=
"#dt-implementation-dependent">implementation-dependent</a>, unless
it is defined by the selected encoding.</p>
</li>
<li>
<p>The <code>cdata-section-elements</code> attribute is a
whitespace-separated list of QNames. The default value is an empty
list. After expansion of these names using the in-scope namespace
declarations for the <a href=
"#element-output"><code>xsl:output</code></a> declaration in which
they appear, this list of names provides the value of the
<code>cdata-section-elements</code> parameter to the serialization
method. In the case of an unprefixed name, the default namespace
(that is, the namespace declared using <code>xmlns="uri"</code>) is
used.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This differs from the rule for most other QNames used in a
stylesheet. The reason is that these names refer to elements in the
result document, and therefore follow the same convention as the
name of a literal result element or the <code>name</code> attribute
of <a href="#element-element"><code>xsl:element</code></a>.</p>
</div>
</li>
<li>
<p>The value of the <code>doctype-system</code> attribute provides
the value of the <code>doctype-system</code> parameter to the
serialization method. <span>If the attribute is absent or has a
zero-length string as its value, then the serialization parameter
is not set (is "absent").</span></p>
</li>
<li>
<p>The value of the <code>doctype-public</code> attribute provides
the value of the <code>doctype-public</code> parameter to the
serialization method. <span>If the attribute is absent or has a
zero-length string as its value, then the serialization parameter
is not set (is "absent").</span></p>
<p>The value of <code>doctype-public</code> must conform to the
rules for a <a href=
"http://www.w3.org/TR/REC-xml/#NT-PubidLiteral">PubidLiteral</a><sup><small>XML</small></sup>
(see <a href="#REC-xml">[XML 1.0]</a>).</p>
</li>
<li>
<p>The value of the <code>escape-uri-attributes</code> attribute
provides the value of the <code>escape-uri-attributes</code>
parameter to the serialization method. The default value is
<code>yes</code>.</p>
</li>
<li>
<p>The value of the <code>html-version</code> attribute provides
the value of the <code>html-version</code> parameter to the
serialization method. The set of permitted values, and the default
value, are <a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. A
<a title="serialization error" class="termref" href=
"#dt-serialization-error">serialization error</a> will be reported
if the requested version is not supported by the
implementation.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This serialization parameter is new in version 3.0. If it is
absent, the html output method uses the value of the
<code>version</code> parameter in its place. For XHTML
serialization, the <code>html-version</code> parameter indicates
the version of XHTML to be used, while the <code>version</code>
parameter indicates the version of XML.</p>
</div>
</li>
<li>
<p>The value of the <code>include-content-type</code> attribute
provides the value of the <code>include-content-type</code>
parameter to the serialization method. The default value is
<code>yes</code>.</p>
</li>
<li>
<p>The value of the <code>indent</code> attribute provides the
value of the <code>indent</code> parameter to the serialization
method. The default value is <code>yes</code> in the case of the
<code>html</code> and <code>xhtml</code> output methods,
<code>no</code> in the case of the <code>xml</code> output
method.</p>
</li>
<li>
<p>The value of the <code>item-separator</code> attribute provides
the value of the <code>item-separator</code> parameter to the
serialization method. The value of the serialization parameter can
be any string (including a zero-length string), or absent. To set
the parameter to absent, the <code>item-separator</code> attribute
can either be omitted, or set to the special value
<code>item-separator="#absent"</code>; it is not possible to set
the value of the serialization parameter to the literal 7-character
string "#absent".</p>
</li>
<li>
<p>The value of the <code>media-type</code> attribute provides the
value of the <code>media-type</code> parameter to the serialization
method. The default value is <code>text/xml</code> in the case of
the <code>xml</code> output method, <code>text/html</code> in the
case of the <code>html</code> and <code>xhtml</code> output
methods, and <code>text/plain</code> in the case of the
<code>text</code> output method.</p>
</li>
<li>
<p>The value of the <code>normalization-form</code> attribute
provides the value of the <code>normalization-form</code> parameter
to the serialization method. A value that is an
<code>NMTOKEN</code> other than one of those enumerated for the
<code>normalization-form</code> attribute specifies an
implementation-defined normalization form; the behavior in this
case is not specified by this document. The default value is
<code>none</code>.</p>
</li>
<li>
<p>The value of the <code>omit-xml-declaration</code> attribute
provides the value of the <code>omit-xml-declaration</code>
parameter to the serialization method. The default value is
<code>no</code>.</p>
</li>
<li>
<p>The value of the <code>standalone</code> attribute provides the
value of the <code>standalone</code> parameter to the serialization
method. The default value is <code>omit</code>; this means that no
<code>standalone</code> attribute is to be included in the XML
declaration.</p>
</li>
<li>
<p>The <code>suppress-indentation</code> attribute is a
whitespace-separated list of QNames. The default value is an empty
list. After expansion of these names using the in-scope namespace
declarations for the <a href=
"#element-output"><code>xsl:output</code></a> declaration in which
they appear, this list of names provides the value of the
<code>suppress-indentation</code> parameter to the serialization
method. In the case of an unprefixed name, the default namespace
(that is, the namespace declared using <code>xmlns="uri"</code>) is
used.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>This differs from the rule for most other QNames used in a
stylesheet. The reason is that these names refer to elements in the
result document, and therefore follow the same convention as the
name of a literal result element or the <code>name</code> attribute
of <a href="#element-element"><code>xsl:element</code></a>.</p>
</div>
</li>
<li>
<p>The <code>undeclare-prefixes</code> attribute is relevant only
when producing output with <code>method="xml"</code> and
<code>version="1.1"</code> (or later). It defines whether namespace
undeclarations (of the form <code>xmlns:foo=""</code>) <span class=
"verb">should</span> be output when a child element has no
namespace node with the same name (that is, namespace prefix) as a
namespace node of its parent element. The default value is
<code>no</code>: this means that namespace undeclarations are not
output, which has the effect that when the resulting XML is
reparsed, the new tree may contain namespace nodes on the child
element that were not there in the original tree before
serialization.</p>
</li>
<li>
<p>The <code>use-character-maps</code> attribute provides a list of
named character maps that are used in conjunction with this
<a title="output definition" class="termref" href=
"#dt-output-definition">output definition</a>. The way this
attribute is used is described in <a href="#character-maps"><i>25.1
Character Maps</i></a>. The default value is an empty list.</p>
</li>
<li>
<p>The value of the <code>version</code> attribute provides the
value of the <code>version</code> parameter to the serialization
method. The set of permitted values, and the default value, are
<a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. A
<a title="serialization error" class="termref" href=
"#dt-serialization-error">serialization error</a> will be reported
if the requested version is not supported by the
implementation.</p>
</li>
</ul>
<p>The <code>item-separator</code> serialization parameter defined
in <a href="#xslt-xquery-serialization-30">[XSLT and XQuery
Serialization]</a> is not available in <a href=
"#element-output"><code>xsl:output</code></a>; it is not
applicable, because the sequence that is serialized by XSLT is
always a singleton document node. Formally therefore, the
serializer is always invoked passing an empty string as the value
of this parameter.</p>
<p>If the processor performs serialization, then it must signal any
serialization errors that occur. These have the same effect as
<a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic errors</a>: that is, the processor must
signal the error and must not finish as if the transformation had
been successful.</p>
<div class="div2">
<h3><a name="character-maps" id="character-maps"></a>25.1 <a href=
"#character-maps" style="text-decoration: none">Character
Maps</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-character-map" id="dt-character-map" title=
"character map"></a>A <b>character map</b> allows a specific
character appearing in a text or attribute node in the <a title=
"final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a> to be substituted by
a specified string of characters during serialization.<span class=
"definition">]</span> The effect of character maps is defined in
<a href="#xslt-xquery-serialization-30">[XSLT and XQuery
Serialization]</a>.</p>
<p>The character map that is supplied as a parameter to the
serializer is determined from the <a href=
"#element-character-map"><code>xsl:character-map</code></a>
elements referenced from the <a href=
"#element-output"><code>xsl:output</code></a> declaration for the
selected <a title="output definition" class="termref" href=
"#dt-output-definition">output definition</a>.</p>
<p>The <a href=
"#element-character-map"><code>xsl:character-map</code></a> element
is a declaration that may appear as a child of the <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> element.</p>
<p class="element-syntax"><a name="element-character-map" id=
"element-character-map"></a><code>&lt;!-- Category: declaration
--&gt;<br />
&lt;xsl:character-map<br />
&#160;&#160;<b>name</b> = <var>eqname</var><br />
&#160;&#160;use-character-maps? =
<var>eqnames</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-output-character">xsl:output-character</a>*) --&gt;<br />
&lt;/xsl:character-map&gt;</code></p>
<p>The <a href=
"#element-character-map"><code>xsl:character-map</code></a>
declaration declares a character map with a name and a set of
character mappings. The character mappings are specified by means
of <a href=
"#element-output-character"><code>xsl:output-character</code></a>
elements contained either directly within the <a href=
"#element-character-map"><code>xsl:character-map</code></a>
element, or in further character maps referenced in the
<code>use-character-maps</code> attribute.</p>
<p>The <span class="verb">required</span> <code>name</code>
attribute provides a name for the character map. When a character
map is used by an <a title="output definition" class="termref"
href="#dt-output-definition">output definition</a> or another
character map, the character map with the highest <a title=
"import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a> is used.</p>
<p>The name of a character map is local to the <a title="package"
class="termref" href="#dt-package">package</a> in which its
declaration appears; it may be referenced only from within the same
package.</p>
<p><a name="err-XTSE1580" id="err-XTSE1580"><span class=
"error">[ERR XTSE1580]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if a
<a title="package" class="termref" href="#dt-package">package</a>
contains two or more character maps with the same name and the same
<a title="import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a>, unless it also
contains another character map with the same name and higher import
precedence.</p>
<p>The optional <code>use-character-maps</code> attribute lists the
names of further character maps that are included into this
character map.</p>
<p><a name="err-XTSE1590" id="err-XTSE1590"><span class=
"error">[ERR XTSE1590]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if a name
in the <code>use-character-maps</code> attribute of the <a href=
"#element-output"><code>xsl:output</code></a> or <a href=
"#element-character-map"><code>xsl:character-map</code></a>
elements does not match the <code>name</code> attribute of any
<a href="#element-character-map"><code>xsl:character-map</code></a>
in the <span>containing <a title="package" class="termref" href=
"#dt-package">package</a></span>.</p>
<p><a name="err-XTSE1600" id="err-XTSE1600"><span class=
"error">[ERR XTSE1600]</span></a> It is a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if a
character map references itself, directly or indirectly, via a name
in the <code>use-character-maps</code> attribute.</p>
<p>It is not an error if the same character map is referenced more
than once, directly or indirectly.</p>
<p>An <a title="output definition" class="termref" href=
"#dt-output-definition">output definition</a>, after recursive
expansion of character maps referenced via its
<code>use-character-maps</code> attribute, may contain several
mappings for the same character. In this situation, the last
character mapping takes precedence. To establish the ordering, the
following rules are used:</p>
<ul>
<li>
<p>Within a single <a href=
"#element-character-map"><code>xsl:character-map</code></a>
element, the characters defined in character maps referenced in the
<code>use-character-maps</code> attribute are considered before the
characters defined in the child <a href=
"#element-output-character"><code>xsl:output-character</code></a>
elements.</p>
</li>
<li>
<p>The character maps referenced in a single
<code>use-character-maps</code> attribute are considered in the
order in which they are listed in that attribute. The expansion is
depth-first: each referenced character map is fully expanded before
the next one is considered.</p>
</li>
<li>
<p>Two <a href=
"#element-output-character"><code>xsl:output-character</code></a>
elements appearing as children of the same <a href=
"#element-character-map"><code>xsl:character-map</code></a> element
are considered in document order.</p>
</li>
</ul>
<p>The <a href=
"#element-output-character"><code>xsl:output-character</code></a>
element is defined as follows:</p>
<p class="element-syntax"><a name="element-output-character" id=
"element-output-character"></a><code>&lt;xsl:output-character<br />
&#160;&#160;<b>character</b> = <var>char</var><br />
&#160;&#160;<b>string</b> = <var>string</var>&#160;/&gt;</code></p>
<p>The character map that is passed as a parameter to the
serializer contains a mapping for the character specified in the
<code>character</code> attribute to the string specified in the
<code>string</code> attribute.</p>
<p>Character mapping is not applied to characters for which output
escaping has been disabled as described in <a href=
"#disable-output-escaping"><i>25.2 Disabling Output
Escaping</i></a>.</p>
<p>If a character is mapped, then it is not subjected to XML or
HTML escaping.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e66932" id=
"d7e66932"></a>Example: Using Character Maps to Generate Non-XML
Output</div>
<p>Character maps can be useful when producing serialized output in
a format that resembles, but is not strictly conformant to, HTML or
XML. For example, when the output is a JSP page, there might be a
need to generate the output:</p>
<div class="exampleInner">
<pre>
&lt;jsp:setProperty name="user" property="id" value='&lt;%= "id" + idValue %&gt;'/&gt;
</pre></div>
<p>Although this output is not well-formed XML or HTML, it is valid
in Java Server Pages. This can be achieved by allocating three
Unicode characters (which are not needed for any other purpose) to
represent the strings <code>&lt;%</code>, <code>%&gt;</code>, and
<code>"</code>, for example:</p>
<div class="exampleInner">
<pre>
&lt;xsl:character-map name="jsp"&gt;
  &lt;xsl:output-character character="«" string="&amp;lt;%"/&gt;   
  &lt;xsl:output-character character="»" string="%&amp;gt;"/&gt;
  &lt;xsl:output-character character="§" string='"'/&gt;
&lt;/xsl:character-map&gt;
</pre></div>
<p>When this character map is referenced in the <a href=
"#element-output"><code>xsl:output</code></a> declaration, the
required output can be produced by writing the following in the
stylesheet:</p>
<div class="exampleInner">
<pre>
&lt;jsp:setProperty name="user" property="id" value='«= §id§ + idValue »'/&gt;
</pre></div>
<p>This works on the assumption that when an apostrophe or
quotation mark is generated as part of an attribute value by the
use of character maps, the serializer will (where possible) use the
other choice of delimiter around the attribute value.</p>
</div>
<p>&#160;</p>
<div class="example">
<div class="exampleHeader"><a name="d7e66961" id=
"d7e66961"></a>Example: Constructing a Composite Character
Map</div>
<p>The following example illustrates a composite character map
constructed in a modular fashion:</p>
<div class="exampleInner">
<pre>
&lt;xsl:output name="htmlDoc" use-character-maps="htmlDoc" /&gt;

&lt;xsl:character-map name="htmlDoc"
  use-character-maps="html-chars doc-entities windows-format" /&gt;
  
&lt;xsl:character-map name="html-chars"
  use-character-maps="latin1 ..." /&gt;

&lt;xsl:character-map name="latin1"&gt;
  &lt;xsl:output-character character="&amp;#160;" string="&amp;amp;nbsp;" /&gt;
  &lt;xsl:output-character character="&amp;#161;" string="&amp;amp;iexcl;" /&gt;
  ...
&lt;/xsl:character-map&gt;

&lt;xsl:character-map name="doc-entities"&gt;
  &lt;xsl:output-character character="&amp;#xE400;" string="&amp;amp;t-and-c;" /&gt;
  &lt;xsl:output-character character="&amp;#xE401;" string="&amp;amp;chap1;" /&gt;
  &lt;xsl:output-character character="&amp;#xE402;" string="&amp;amp;chap2;" /&gt;
  ...
&lt;/xsl:character-map&gt;

&lt;xsl:character-map name="windows-format"&gt;
  &lt;!-- newlines as CRLF --&gt;
  &lt;xsl:output-character character="&amp;#xA;" string="&amp;#xD;&amp;#xA;" /&gt;

  &lt;!-- tabs as three spaces --&gt;
  &lt;xsl:output-character character="&amp;#x9;" string="   " /&gt;

  &lt;!-- images for special characters --&gt;
  &lt;xsl:output-character character="&amp;#xF001;"
    string="&amp;lt;img src='special1.gif' /&amp;gt;" /&gt;
  &lt;xsl:output-character character="&amp;#xF002;"
    string="&amp;lt;img src='special2.gif' /&amp;gt;" /&gt;
  ...
&lt;/xsl:character-map&gt;
</pre></div>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>When character maps are used, there is no guarantee that the
serialized output will be well-formed XML (or HTML). Furthermore,
the fact that the result tree was validated against a schema gives
no guarantee that the serialized output will still be valid against
the same schema. Conversely, it is possible to use character maps
to produce schema-valid output from a result tree that would fail
validation.</p>
</div>
</div>
<div class="div2">
<h3><a name="disable-output-escaping" id=
"disable-output-escaping"></a>25.2 <a href=
"#disable-output-escaping" style="text-decoration: none">Disabling
Output Escaping</a></h3>
<p>Normally, when using the XML, HTML, or XHTML output method, the
serializer will escape special characters such as
<code>&amp;</code> and <code>&lt;</code> when outputting text
nodes. This ensures that the output is well-formed. However, it is
sometimes convenient to be able to produce output that is almost,
but not quite well-formed XML; for example, the output may include
ill-formed sections which are intended to be transformed into
well-formed XML by a subsequent non-XML-aware process. For this
reason, XSLT defines a mechanism for disabling output escaping.</p>
<p>This feature is <a title="deprecated" class="termref" href=
"#dt-deprecated">deprecated</a>.</p>
<p>This is an optional feature: it is not <span class=
"verb">required</span> that an XSLT processor that implements the
serialization option <span class="verb">should</span> offer the
ability to disable output escaping, and there is no conformance
level that requires this feature.</p>
<p>This feature requires an extension to the serializer described
in <a href="#xslt-xquery-serialization-30">[XSLT and XQuery
Serialization]</a>. Conceptually, the <a title="final result tree"
class="termref" href="#dt-final-result-tree">final result tree</a>
provides an additional boolean property
<code>disable-escaping</code> associated with every character in a
text node. When this property is set, the normal action of the
serializer to escape special characters such as <code>&amp;</code>
and <code>&lt;</code> is suppressed.</p>
<p>An <a href="#element-value-of"><code>xsl:value-of</code></a> or
<a href="#element-text"><code>xsl:text</code></a> element may have
a <code>disable-output-escaping</code> attribute; the allowed
values are <code>yes</code> or <code>no</code>. The default is
<code>no</code>; if the value is <code>yes</code>, then every
character in the text node generated by evaluating the <a href=
"#element-value-of"><code>xsl:value-of</code></a> or <a href=
"#element-text"><code>xsl:text</code></a> element <span class=
"verb">should</span> have the <code>disable-escaping</code>
property set.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e67049" id=
"d7e67049"></a>Example: Disable Output Escaping</div>
<p>For example,</p>
<div class="exampleInner">
<pre>
&lt;xsl:text disable-output-escaping="yes"&gt;&amp;lt;&lt;/xsl:text&gt;
</pre></div>
<p>should generate the single character <code>&lt;</code>.</p>
</div>
<p>If output escaping is disabled for an <a href=
"#element-value-of"><code>xsl:value-of</code></a> or <a href=
"#element-text"><code>xsl:text</code></a> instruction evaluated
when <a title="temporary output state" class="termref" href=
"#dt-temporary-output-state">temporary output state</a> is in
effect, the request to disable output escaping is ignored.</p>
<p>Similarly, if an <a href=
"#element-value-of"><code>xsl:value-of</code></a> or <a href=
"#element-text"><code>xsl:text</code></a> instruction specifies
that output escaping is to be disabled when writing to a <a title=
"final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a> that is not being
serialized, the request to disable output escaping is ignored.</p>
<p>If output escaping is disabled for text within an element that
would normally be output using a CDATA section, because the element
is listed in the <code>cdata-section-elements</code>, then the
relevant text will not be included in a CDATA section. In effect,
CDATA is treated as an alternative escaping mechanism, which is
disabled by the <code>disable-output-escaping</code> option.</p>
<div class="example">
<div class="exampleHeader"><a name="d7e67091" id=
"d7e67091"></a>Example: Interaction of Output Escaping and
CDATA</div>
<p>For example, if <code>&lt;xsl:output
cdata-section-elements="title"/&gt;</code> is specified, then the
following instructions:</p>
<div class="exampleInner">
<pre>
&lt;title&gt;
  &lt;xsl:text disable-output-escaping="yes"&gt;This is not &amp;lt;hr/&amp;gt; 
                                          good coding practice&lt;/xsl:text&gt;
&lt;/title&gt;
</pre></div>
<p>should generate the output:</p>
<div class="exampleInner">
<pre>
&lt;title&gt;&lt;![CDATA[This is not ]]&gt;&lt;hr/&gt;&lt;![CDATA[ good coding practice]]&gt;&lt;/title&gt;
</pre></div>
</div>
<p>The <code>disable-output-escaping</code> attribute may be used
with the <code>html</code> output method as well as with the
<code>xml</code> output method. The <code>text</code> output method
ignores the <code>disable-output-escaping</code> attribute, since
this method does not perform any output escaping.</p>
<p>A <a title="processor" class="termref" href=
"#dt-processor">processor</a> will only be able to disable output
escaping if it controls how the <a title="final result tree" class=
"termref" href="#dt-final-result-tree">final result tree</a> is
output. This might not always be the case. For example, the result
tree might be used as a <a title="source tree" class="termref"
href="#dt-source-tree">source tree</a> for another XSLT
transformation instead of being output. It is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> whether
(and under what circumstances) disabling output escaping is
supported. <span>If disabling output escaping is not supported, any
request to disable output escaping is ignored.</span></p>
<p>If output escaping is disabled for a character that is not
representable in the encoding that the <a title="processor" class=
"termref" href="#dt-processor">processor</a> is using for output,
the request to disable output escaping is ignored in respect of
that character.</p>
<p>Since disabling output escaping might not work with all
implementations and can result in XML that is not well-formed, it
<span class="verb">should</span> be used only when there is no
alternative.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>When disable-output-escaping is used, there is no guarantee that
the serialized output will be well-formed XML (or HTML).
Furthermore, the fact that the result tree was validated against a
schema gives no guarantee that the serialized output will still be
valid against the same schema. Conversely, it is possible to use
disable-output-escaping to produce schema-valid output from a
result tree that would fail validation.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The facility to define character maps for use during
serialization, as described in <a href="#character-maps"><i>25.1
Character Maps</i></a>, has been produced as an alternative
mechanism that can be used in many situations where disabling of
output escaping was previously necessary, without the same
difficulties.</p>
</div>
</div>
</div>
<div class="div1">
<h2><a name="conformance" id="conformance"></a>26 <a href=
"#conformance" style="text-decoration: none">Conformance</a></h2>
<p>A <a title="processor" class="termref" href=
"#dt-processor">processor</a> that claims conformance with this
specification <span class="verb">must</span> satisfy the
conformance requirements for a <a title="basic XSLT processor"
class="termref" href="#dt-basic-xslt-processor">basic XSLT
processor</a> and for each of the optional features with which it
claims conformance.</p>
<p>The following optional features are defined:</p>
<ol class="enumar">
<li>
<p>The schema-awareness feature, defined in <a href=
"#schema-aware-conformance"><i>26.2 Schema-Awareness Conformance
Feature</i></a></p>
</li>
<li>
<p>The serialization feature, defined in <a href=
"#serialization-feature"><i>26.3 Serialization Feature</i></a></p>
</li>
<li>
<p>The backwards compatibility feature, defined in <a href=
"#backwards-compatibility-feature"><i>26.4 Compatibility
Features</i></a></p>
</li>
<li>
<p>The streaming feature, defined in <a href=
"#streaming-feature"><i>26.5 Streaming Feature</i></a>.</p>
</li>
<li>
<p>The dynamic evaluation feature, defined in <a href=
"#dynamic-evaluation-feature"><i>26.6 Dynamic Evaluation
Feature</i></a>.</p>
</li>
<li>
<p>The XQuery invocation feature, defined in <a href=
"#xquery-invocation-feature"><i>26.7 XQuery Invocation
Feature</i></a>.</p>
</li>
</ol>
<p>A processor that does not claim conformance with an optional
feature <span class="verb">must</span> satisfy the requirements for
processors that do not implement that feature.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>There is no conformance level or feature defined in this
specification that requires implementation of the static typing
features described in <a href="#xpath-30">[XPath 3.0]</a>. An XSLT
processor may provide a user option to invoke static typing, but to
be conformant with this specification it must allow a stylesheet to
be processed with static typing disabled. The interaction of XSLT
stylesheets with the static typing feature of <span>XPath
3.0</span> has not been specified, so the results of using static
typing, if available, are implementation-defined.</p>
</div>
<p>An XSLT processor takes as its inputs a stylesheet and
<span>zero</span> or more XDM trees conforming to the data model
defined in <a href="#xpath-datamodel-30">[Data Model]</a>. It is
not <span class="verb">required</span> that the processor supports
any particular method of constructing XDM trees, but conformance
can only be tested if it provides a mechanism that enables XDM
trees representing the stylesheet and primary source document to be
constructed and supplied as input to the processor.</p>
<p>The output of the XSLT processor consists of zero or more
<a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result trees</a>. It is not
<span class="verb">required</span> that the processor supports any
particular method of accessing a final result tree, but if it does
not support the serialization <span>feature</span>, conformance can
only be tested if it provides some alternative mechanism that
enables access to the results of the transformation.</p>
<p>Certain facilities in this specification are described as
producing <a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> results. A
claim that asserts conformance with this specification <span class=
"verb">must</span> be accompanied by documentation stating the
effect of each implementation-defined feature. For convenience, a
non-normative checklist of implementation-defined features is
provided at <a href="#implementation-defined-features"><i>F
Checklist of Implementation-Defined Features</i></a>.</p>
<p>A conforming <a title="processor" class="termref" href=
"#dt-processor">processor</a> <span class="verb">must</span> signal
any <a title="static error" class="termref" href=
"#dt-static-error">static error</a> occurring in the stylesheet, or
in any XPath <a title="expression" class="termref" href=
"#dt-expression">expression</a>, except where specified otherwise
either for individual error conditions or under the general
provisions for <a title="forwards compatible behavior" class=
"termref" href="#dt-forwards-compatible-behavior">forwards
compatible behavior</a> (see <a href="#forwards"><i>3.11 Forwards
Compatible Processing</i></a>). After signaling such an error, the
processor <span class="verb">may</span> continue for the purpose of
signaling additional errors, but <span class="verb">must</span>
terminate abnormally without performing any transformation.</p>
<p>When a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> occurs during the course of a
transformation, <span>and is not caught using <a href=
"#element-catch"><code>xsl:catch</code></a>,</span> the processor
<span class="verb">must</span> signal it and <span class=
"verb">must</span> eventually terminate abnormally. If a
recoverable error occurs, the processor <span class=
"verb">must</span> either signal it and terminate abnormally, or it
<span class="verb">must</span> take the defined recovery action and
continue processing.</p>
<p>Some errors, notably <a title="type error" class="termref" href=
"#dt-type-error">type errors</a>, <span class="verb">may</span> be
treated as <a title="static error" class="termref" href=
"#dt-static-error">static errors</a> or <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic errors</a> at the
discretion of the processor.</p>
<p>A conforming processor <span class="verb">may</span> impose
limits on the processing resources consumed by the processing of a
stylesheet.</p>
<p>The mandatory requirements of this specification are taken to
include the mandatory requirements of <a href="#xpath-30">[XPath
3.0]</a>, <a href="#xpath-datamodel-30">[Data Model]</a>, and
<a href="#xpath-functions-30">[Functions and Operators]</a>. An
XSLT 3.0 processor <span class="verb">must</span> provide a mode of
operation which conforms to the 3.0 versions of those
specifications as extended by <a href="#additional-types"><i>21
XPath Extensions</i></a>. It <span class="verb">may</span> also
provide a mode of operation which conforms to later versions of
those specifications; in such cases the detail of how XSLT 3.0
interacts with new features introduced by such later versions (for
example, extensions to the data model) is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The above paragraph anticipates the possibility that an XPath
3.1 specification may be finalized during the lifetime of XSLT 3.0,
and allows implementations in that event to offer the combination
of XSLT 3.0 with XPath 3.1.</p>
</div>
<p>A requirement is mandatory unless the specification includes
wording (such as the use of the words <span class=
"verb">should</span> or <span class="verb">may</span>) that clearly
indicates that it is optional.</p>
<div class="div2">
<h3><a name="basic-conformance" id="basic-conformance"></a>26.1
<a href="#basic-conformance" style="text-decoration: none">Basic
XSLT Processor</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-basic-xslt-processor" id="dt-basic-xslt-processor" title=
"basic XSLT processor"></a>A <b>basic XSLT processor</b> is an XSLT
processor that implements all the mandatory requirements of this
specification with the exception of constructs explicitly
associated with an optional feature.<span class=
"definition">]</span> These constructs are listed below.</p>
</div>
<div class="div2">
<h3><a name="schema-aware-conformance" id=
"schema-aware-conformance"></a>26.2 <a href=
"#schema-aware-conformance" style=
"text-decoration: none">Schema-Awareness Conformance
Feature</a></h3>
<p>A conformant processor <span class="verb">must</span> either be
a conformant <a title="schema-aware XSLT processor" class="termref"
href="#dt-schema-aware-xslt-processor">schema-aware XSLT
processor</a> or a conformant <a title="non-schema-aware processor"
class="termref" href=
"#dt-non-schema-aware-processor">non-schema-aware
processor</a>.</p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-schema-aware-xslt-processor" id=
"dt-schema-aware-xslt-processor" title=
"schema-aware XSLT processor"></a>A <b>schema-aware XSLT
processor</b> is an XSLT processor that implements the mandatory
requirements of this specification connected with the <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>
declaration, the <code>[xsl:]validation</code> and <code>[xsl:]type
attributes</code>, and the ability to handle input documents whose
nodes have type annotations other than <code>xs:untyped</code> and
<code>xs:untypedAtomic</code>. The mandatory requirements of this
specification are taken to include the mandatory requirements of
<span>XPath 3.0</span>, as described in <a href="#xpath-30">[XPath
3.0]</a>. A requirement is mandatory unless the specification
includes wording (such as the use of the words <span class=
"verb">should</span> or <span class="verb">may</span>) that clearly
indicates that it is optional.<span class="definition">]</span></p>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-non-schema-aware-processor" id="dt-non-schema-aware-processor"
title="non-schema-aware processor"></a>A <b>non-schema-aware
processor</b> is a processor that does not claim conformance with
the schema-aware conformance feature. Such a processor <span class=
"verb">must</span> handle constructs associated with schema-aware
processing as described in this section.<span class=
"definition">]</span></p>
<p><a name="err-XTSE1650" id="err-XTSE1650"><span class=
"error">[ERR XTSE1650]</span></a> A <a title=
"non-schema-aware processor" class="termref" href=
"#dt-non-schema-aware-processor">non-schema-aware processor</a>
<span class="verb">must</span> signal a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if <span>a
<a title="package" class="termref" href=
"#dt-package">package</a></span> includes an <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>
declaration.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>A processor that rejects an <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>
declaration will also reject any reference to a user-defined type
defined in a schema, or to a user-defined element or attribute
declaration; it will not, however, reject references to the
built-in types listed in <a href="#built-in-types"><i>3.15 Built-in
Types</i></a>.</p>
</div>
<p>A <a title="non-schema-aware processor" class="termref" href=
"#dt-non-schema-aware-processor">non-schema-aware processor</a> is
not able to validate input documents, and is not able to handle
input documents containing type annotations other than
<code>xs:untyped</code> or <code>xs:untypedAtomic</code>.
Therefore, such a processor <span class="verb">must</span> treat
<span>any <code>[xsl:]validation</code> attribute with a value of
<code>preserve</code> or <code>lax</code>, or a
<code>[xsl:]default-validation</code> attribute with a value of
<code>preserve</code></span> as if the value were
<code>strip</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The values <code>lax</code> and <code>preserve</code> indicate
that the validation to be applied depends on the calling
application, so it is appropriate for the request to be treated
differently by different kinds of processor. By contrast,
requesting <code>strict</code> validation, either through the
<code>[xsl:]validation</code> attribute or the <code>type</code>
attribute, indicates that the stylesheet is expecting to deal with
typed data, and therefore cannot be processed without performing
the validation.</p>
</div>
<p><a name="err-XTSE1660" id="err-XTSE1660"><span class=
"error">[ERR XTSE1660]</span></a> A <a title=
"non-schema-aware processor" class="termref" href=
"#dt-non-schema-aware-processor">non-schema-aware processor</a>
<span class="verb">must</span> signal a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if <span>a
<a title="package" class="termref" href=
"#dt-package">package</a></span> includes an
<code>[xsl:]type</code> attribute, or an
<code>[xsl:]validation</code> or
<code>[xsl:]default-validation</code> attribute with a value other
than <code>strip</code><span>, <code>preserve</code>, or
<code>lax</code></span>.</p>
<p>A <a title="non-schema-aware processor" class="termref" href=
"#dt-non-schema-aware-processor">non-schema-aware processor</a>
constrains the data model as follows:</p>
<ul>
<li>
<p>Atomic values <span class="verb">must</span> belong to one of
the atomic types listed in <a href="#built-in-types"><i>3.15
Built-in Types</i></a> (except as noted below).</p>
<p>An atomic value may also belong to an implementation-defined
type that has been added to the context for use with <a title=
"extension function" class="termref" href=
"#dt-extension-function">extension functions</a> or <a title=
"extension instruction" class="termref" href=
"#dt-extension-instruction">extension instructions</a>.</p>
<p>The set of constructor functions available are limited to those
that construct values of the above atomic types.</p>
<p>The static context, which defines the full set of type names
recognized by an XSLT processor and also by the XPath processor,
includes these atomic types, plus <code>xs:anyType</code>,
<code>xs:anySimpleType</code>, <code>xs:untyped</code>, and
<code>xs:anyAtomicType</code>.</p>
</li>
<li>
<p>Element nodes <span class="verb">must</span> be annotated with
the <a title="type annotation" class="termref" href=
"#dt-type-annotation">type annotation</a> <code>xs:untyped</code>,
and attribute nodes with the type annotation
<code>xs:untypedAtomic</code>.</p>
</li>
</ul>
<p><a name="err-XTDE1665" id="err-XTDE1665"><span class=
"error">[ERR XTDE1665]</span></a> A <a title=
"non-schema-aware processor" class="termref" href=
"#dt-non-schema-aware-processor">non-schema-aware processor</a>
<span class="verb">must</span> raise a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
input to the processor includes a node with a <a title=
"type annotation" class="termref" href="#dt-type-annotation">type
annotation</a> other than <code>xs:untyped</code> or
<code>xs:untypedAtomic</code>, or an atomic value of a type other
than those which a basic XSLT processor supports. This error will
not arise if the <code>input-type-annotations</code> attribute is
set to <code>strip</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>Although this is expressed in terms of a requirement to detect
invalid input, an alternative approach is for a non-schema-aware
processor to prevent this error condition occurring, by not
providing any interfaces that would allow the situation to arise. A
processor might, for example, implement a mapping from the PSVI to
the data model that loses all non-trivial <a title=
"type annotation" class="termref" href="#dt-type-annotation">type
annotations</a>; or it might not accept input from a PSVI at
all.</p>
<p>The phrase <em>input to the processor</em> is deliberately wide:
it includes the tree containing the <span><a title=
"global context item" class="termref" href=
"#dt-global-context-item">global context item</a></span>,
<span>trees containing nodes present in the <a title=
"initial match selection" class="termref" href=
"#dt-initial-match-selection">initial match selection</a></span>,
trees passed as <a title="stylesheet parameter" class="termref"
href="#dt-stylesheet-parameter">stylesheet parameters</a>, trees
accessed using the <a href=
"#func-document"><code>document</code></a>, <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-collection"><code>collection</code></a><sup><small>FO30</small></sup>
functions, and trees returned by <a title="extension function"
class="termref" href="#dt-extension-function">extension
functions</a> and <a title="extension instruction" class="termref"
href="#dt-extension-instruction">extension instructions</a>.</p>
</div>
</div>
<div class="div2">
<h3><a name="serialization-feature" id=
"serialization-feature"></a>26.3 <a href="#serialization-feature"
style="text-decoration: none">Serialization Feature</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-serialization-feature" id="dt-serialization-feature" title=
"serialization feature"></a>A processor that claims conformance
with the <b>serialization feature</b> <span class=
"verb">must</span> support the conversion of a <a title=
"final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a> to a sequence of
octets following the rules defined in <a href=
"#serialization"><i>25 Serialization</i></a>.<span class=
"definition">]</span> It <span class="verb">must</span> respect all
the attributes of the <a href=
"#element-output"><code>xsl:output</code></a> and <a href=
"#element-character-map"><code>xsl:character-map</code></a>
declarations, and <span class="verb">must</span> provide all four
output methods, <code>xml</code>, <code>xhtml</code>,
<code>html</code>, and <code>text</code>. Where the specification
uses words such as <span class="verb">must</span> and <span class=
"verb">required</span>, then it <span class="verb">must</span>
serialize the result tree in precisely the way described; in other
cases it <span class="verb">may</span> use an alternative,
equivalent representation.</p>
<p>A processor may claim conformance with the serialization feature
whether or not it supports the setting
<code>disable-output-escaping="yes"</code> on <a href=
"#element-text"><code>xsl:text</code></a>, or <a href=
"#element-value-of"><code>xsl:value-of</code></a>.</p>
<p>A processor that does not claim conformance with the
serialization feature <span class="verb">must not</span> signal an
error merely because the <a title="stylesheet" class="termref"
href="#dt-stylesheet">stylesheet</a> contains <a href=
"#element-output"><code>xsl:output</code></a> or <a href=
"#element-character-map"><code>xsl:character-map</code></a>
declarations, or serialization attributes on the <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction. Such a processor <span class="verb">may</span> check
that these declarations and attributes have valid values, but is
not <span class="verb">required</span> to do so. Apart from
optional validation, these declarations <span class=
"verb">should</span> be ignored.</p>
<p>A processor that claims conformance with the Serialization
Feature must satisfy the mandatory requirements of <a href=
"#xslt-xquery-serialization-30">[XSLT and XQuery
Serialization]</a>. It <span class="verb">must</span> provide a
mode of operation which conforms to the 3.0 version of that
specification. It <span class="verb">may</span> also provide a mode
of operation which conforms to a later version of that
specification; in such cases the detail of how XSLT 3.0 interacts
with new features introduced by such a version (for example,
support for new serialization properties) is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>.</p>
</div>
<div class="div2">
<h3><a name="backwards-compatibility-feature" id=
"backwards-compatibility-feature"></a>26.4 <a href=
"#backwards-compatibility-feature" style=
"text-decoration: none">Compatibility Features</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-1.0-compatibility-feature" id="dt-1.0-compatibility-feature"
title="XSLT 1.0 compatibility feature"></a>A processor that claims
conformance with the <b>XSLT 1.0 compatibility feature</b>
<span class="verb">must</span> support the processing of stylesheet
instructions and XPath expressions with <a title=
"XSLT 1.0 behavior" class="termref" href=
"#dt-xslt-10-behavior">XSLT 1.0 behavior</a>, as defined in
<a href="#backwards"><i>3.10 Backwards Compatible
Processing</i></a>.<span class="definition">]</span></p>
<p>Note that a processor that does not claim conformance with the
<a title="XSLT 1.0 compatibility feature" class="termref" href=
"#dt-1.0-compatibility-feature">XSLT 1.0 compatibility feature</a>
<span class="verb">must</span> raise a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if an
instruction is evaluated whose <a title="effective version" class=
"termref" href="#dt-effective-version">effective version</a> is
1.0. <span class="error">[see <a href="#err-XTDE0160">ERR
XTDE0160</a>]</span>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The reason this is a dynamic error rather than a static error is
to allow stylesheets to contain conditional logic, following
different paths depending on whether the XSLT processor implements
<span>XSLT 1.0, 2.0, or 3.0</span>. The selection of which path to
use can be controlled by using the <a href=
"#func-system-property"><code>system-property</code></a> function
to test the <code>xsl:version</code> system property.</p>
</div>
<p>A processor that claims conformance with the <a title=
"XSLT 1.0 compatibility feature" class="termref" href=
"#dt-1.0-compatibility-feature">XSLT 1.0 compatibility feature</a>
<span class="verb">must</span> permit the use of the namespace axis
in XPath expressions when backwards compatible behavior is enabled.
In all other circumstances, support for the namespace axis is
optional.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>There are no incompatibilities between 3.0 and 2.0 that would
justify a 2.0-compatibility mode. When a 3.0 processor encounters a
stylesheet that specifies <code>version="2.0"</code>, evaluation
therefore proceeds exactly as if it specified
<code>version="3.0"</code>. However, a software product may invoke
an XSLT 2.0 processor in preference to an XSLT 3.0 processor when
the stylesheet specifies <code>version="3.0"</code>, in which case
any use of new 3.0 constructs will be rejected.</p>
</div>
</div>
<div class="div2">
<h3><a name="streaming-feature" id="streaming-feature"></a>26.5
<a href="#streaming-feature" style=
"text-decoration: none">Streaming Feature</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-streaming-feature" id="dt-streaming-feature" title=
"streaming feature"></a>A processor that claims conformance with
the <b>streaming feature</b> <span class="verb">must</span> use
streamed processing in cases where (a) streaming is requested (for
example by using the attribute <code>streamable="yes"</code> on
<a href="#element-mode"><code>xsl:mode</code></a>, or the <a href=
"#element-stream"><code>xsl:stream</code></a> instruction) and (b)
the constructs in question are <a title="guaranteed-streamable"
class="termref" href=
"#dt-guaranteed-streamable">guaranteed-streamable</a> according to
this specification.<span class="definition">]</span></p>
<p>A processor that does not claim conformance with the streaming
feature is not required to use streamed processing and is not
required to determine whether any construct is guaranteed
streamable. Such a processor must, however, implement the semantics
of all constructs in the language provided that enough memory is
available to perform the processing without streaming.</p>
<p>A processor that conforms with the feature <span class=
"verb">must</span> return the value <code>"yes"</code> in response
to the function call
<code>system-property('xsl:supports-streaming')</code>; a processor
that does not conform with the feature <span class=
"verb">must</span> return the value <code>"no"</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The term <em>streamed processing</em> as used here means the
ability to process arbitrarily large input documents without
ever-increasing memory requirements.</p>
</div>
</div>
<div class="div2">
<h3><a name="dynamic-evaluation-feature" id=
"dynamic-evaluation-feature"></a>26.6 <a href=
"#dynamic-evaluation-feature" style="text-decoration: none">Dynamic
Evaluation Feature</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-dynamic-evaluation-feature" id="dt-dynamic-evaluation-feature"
title="dynamic evaluation feature"></a>A processor that claims
conformance with the <b>dynamic evaluation feature</b> <span class=
"verb">must</span> evaluate the <a href=
"#element-evaluate"><code>xsl:evaluate</code></a> function as
described in this specification.<span class=
"definition">]</span></p>
<p>A processor that does not claim conformance with the dynamic
evaluation feature <span class="verb">must</span> report a dynamic
error if an <a href=
"#element-evaluate"><code>xsl:evaluate</code></a> instruction is
evaluated. It <span class="verb">must not</span> report a static
error merely because of the presence of an <a href=
"#element-evaluate"><code>xsl:evaluate</code></a> instruction in
the stylesheet, unless a processor that conforms with the feature
would report the same static error.</p>
<p>A processor that conforms with the feature <span class=
"verb">must</span> return the value <code>"yes"</code> in response
to the function call
<code>system-property('xsl:supports-dynamic-evaluation')</code>; a
processor that does not conform with the feature <span class=
"verb">must</span> return the value <code>"no"</code>.</p>
<p>A processor that conforms with the feature <span class=
"verb">must</span> return the value <code>true</code> in response
to the function call
<code>element-available('xsl:evaluate')</code>; a processor that
does not conform with the feature <span class="verb">must</span>
return the value <code>false</code>.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>A processor may allow dynamic evaluation to be enabled and
disabled by means of configuration settings, perhaps for security
reasons. In consequence, it may be impossible to tell during static
analysis of the stylesheet whether or not the feature will be
available during execution. A stylesheet author wanting to check
whether the feature is available should therefore make the test
using a run-time call on <code>system-property</code>, rather than
relying on tests in an <code>[xsl:]use-when</code> attribute.</p>
</div>
</div>
<div class="div2">
<h3><a name="xquery-invocation-feature" id=
"xquery-invocation-feature"></a>26.7 <a href=
"#xquery-invocation-feature" style="text-decoration: none">XQuery
Invocation Feature</a></h3>
<p><span class="definition">[Definition:&#160;</span><a name=
"dt-xquery-invocation-feature" id="dt-xquery-invocation-feature"
title="XQuery Invocation Feature"></a>A processor that claims
conformance with the <b>XQuery invocation feature</b> <span class=
"verb">must</span> allow XQuery library modules to be referenced in
<a href="#element-use-package"><code>xsl:use-package</code></a>,
and must allow the using package to reference the public functions
and variables declared in the referenced library
module.<span class="definition">]</span></p>
</div>
</div>
</div>
<div class="back">
<div class="div1">
<h2><a name="references" id="references"></a>A <a href=
"#references" style="text-decoration: none">References</a></h2>
<div class="div2">
<h3><a name="normative-references" id=
"normative-references"></a>A.1 <a href="#normative-references"
style="text-decoration: none">Normative References</a></h3>
<dl>
<dt class="label"><span><a name="xpath-datamodel-30" id=
"xpath-datamodel-30"></a>Data Model</span></dt>
<dd>
<div><a href=
"http://www.w3.org/TR/xpath-datamodel-30/"><cite>XQuery and XPath
Data Model (XDM) 3.0</cite></a>, Norman Walsh, Anders Berglund,
John Snelson, Editors. World Wide Web Consortium, 08 April 2014.
This version is
http://www.w3.org/TR/2014/REC-xpath-datamodel-30-20140408/. The
<a href="http://www.w3.org/TR/xpath-datamodel-30/">latest
version</a> is available at
http://www.w3.org/TR/xpath-datamodel-30/.</div>
</dd>
<dt class="label"><span><a name="xpath-functions-30" id=
"xpath-functions-30"></a>Functions and Operators</span></dt>
<dd>
<div><a href=
"http://www.w3.org/TR/xpath-functions-30/"><cite>XQuery and XPath
Functions and Operators 3.0</cite></a>, Michael Kay, Editor. World
Wide Web Consortium, 08 April 2014. This version is
http://www.w3.org/TR/2014/REC-xpath-functions-30-20140408/. The
<a href="http://www.w3.org/TR/xpath-functions-30/">latest
version</a> is available at
http://www.w3.org/TR/xpath-functions-30/.</div>
</dd>
<dt class="label"><span><a name="xml-infoset" id=
"xml-infoset"></a>XML Information Set</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xml-infoset/"><cite>XML
Information Set (Second Edition)</cite></a>, John Cowan and Richard
Tobin, Editors. World Wide Web Consortium, 04&#160;Feb&#160;2004.
This version is http://www.w3.org/TR/2004/REC-xml-infoset-20040204.
The <a href="http://www.w3.org/TR/xml-infoset">latest version</a>
is available at http://www.w3.org/TR/xml-infoset.</div>
</dd>
<dt class="label"><span><a name="ISO15924" id="ISO15924"></a>ISO
15924</span></dt>
<dd>
<div>ISO (International Organization for Standardization)
<em>Information and documentation — Codes for the representation of
names of scripts</em> ISO 15924:2004, January 2004. <span>See
<a href=
"https://www.iso.org/obp/ui/#iso:std:iso:15924:ed-1:v1:en">https://www.iso.org/obp/ui/#iso:std:iso:15924:ed-1:v1:en</a></span>.</div>
</dd>
<dt class="label"><span><a name="ISO15924_register" id=
"ISO15924_register"></a>ISO 15924 Register</span></dt>
<dd>
<div>Unicode Consortium. <em>Codes for the representation of names
of scripts — Alphabetical list of four-letter script codes.</em>
See <a href=
"http://www.unicode.org/iso15924/iso15924-codes.html">http://www.unicode.org/iso15924/iso15924-codes.html</a>.
Retrieved February 2013; continually updated.</div>
</dd>
<dt class="label"><span><a name="xslt-xquery-serialization-30" id=
"xslt-xquery-serialization-30"></a>XSLT and XQuery
Serialization</span></dt>
<dd>
<div><a href=
"http://www.w3.org/TR/xslt-xquery-serialization-30/"><cite>XSLT and
XQuery Serialization 3.0</cite></a>, Henry Zongaro, Andrew Coleman,
Michael Sperberg-McQueen, Editors. World Wide Web Consortium, 08
April 2014. This version is
http://www.w3.org/TR/2014/REC-xslt-xquery-serialization-30-20140408/.
The <a href=
"http://www.w3.org/TR/xslt-xquery-serialization-30/">latest
version</a> is available at
http://www.w3.org/TR/xslt-xquery-serialization-30/.</div>
</dd>
<dt class="label"><span><a name="rfc7159" id="rfc7159"></a>RFC
7159</span></dt>
<dd>
<div>IETF. <em>The JavaScript Object Notation (JSON) Data
Interchange Format.</em> <span>March 2014</span>. See <a href=
"http://www.ietf.org/rfc/rfc7159.txt">http://www.ietf.org/rfc/rfc7159.txt</a></div>
</dd>
<dt class="label"><span><a name="UNICODE" id=
"UNICODE"></a>UNICODE</span></dt>
<dd>
<div>Unicode Consortium. <em>The Unicode Standard</em> as updated
from time to time by the publication of new versions. See <a href=
"http://www.unicode.org/standard/versions/">http://www.unicode.org/standard/versions/</a>
for the latest version and additional information on versions of
the standard and of the Unicode Character Database. The version of
Unicode to be used is <a title="implementation-defined" class=
"termref" href=
"#dt-implementation-defined">implementation-defined</a>, but
implementations are recommended to use the latest Unicode
version.</div>
</dd>
<dt class="label"><span><a name="UNICODE-TR10" id=
"UNICODE-TR10"></a>UNICODE TR10</span></dt>
<dd>
<div>Unicode Consortium. <em>Unicode Technical Standard #10.
Unicode Collation Algorithm</em>. Unicode Technical Report. See
<a href=
"http://www.unicode.org/reports/tr10/">http://www.unicode.org/reports/tr10/</a>.</div>
</dd>
<dt class="label"><span><a name="UNICODE-TR35" id=
"UNICODE-TR35"></a>UNICODE TR35</span></dt>
<dd>
<div>Unicode Consortium. <em>Unicode Technical Standard #35.
Unicode Locale Data Markup Language</em>. Unicode Technical Report.
See <a href=
"http://www.unicode.org/reports/tr35/">http://www.unicode.org/reports/tr35/</a>.</div>
</dd>
<dt class="label"><span><a name="REC-xml" id="REC-xml"></a>XML
1.0</span></dt>
<dd>
<div>World Wide Web Consortium. <em>Extensible Markup Language
(XML) 1.0. W3C Recommendation.</em> See <a href=
"http://www.w3.org/TR/REC-xml">http://www.w3.org/TR/REC-xml/</a>.
The edition of XML 1.0 must be no earlier than the Third Edition;
the edition used is <a title="implementation-defined" class=
"termref" href=
"#dt-implementation-defined">implementation-defined</a>, but we
recommend that implementations use the latest version.</div>
</dd>
<dt class="label"><span><a name="xml11" id="xml11"></a>XML
1.1</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xml11/"><cite>Extensible Markup
Language (XML) 1.1 (Second Edition)</cite></a>, Tim Bray, Jean
Paoli, Michael Sperberg-McQueen, <em>et. al.</em>, Editors. World
Wide Web Consortium, 16&#160;Aug&#160;2006. This version is
http://www.w3.org/TR/2006/REC-xml11-20060816. The <a href=
"http://www.w3.org/TR/xml11/">latest version</a> is available at
http://www.w3.org/TR/xml11/.</div>
</dd>
<dt class="label"><span><a name="xmlbase" id="xmlbase"></a>XML
Base</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xmlbase/"><cite>XML Base (Second
Edition)</cite></a>, Jonathan Marsh and Richard Tobin, Editors.
World Wide Web Consortium, 28&#160;Jan&#160;2009. This version is
http://www.w3.org/TR/2009/REC-xmlbase-20090128/. The <a href=
"http://www.w3.org/TR/xmlbase/">latest version</a> is available at
http://www.w3.org/TR/xmlbase/.</div>
</dd>
<dt class="label"><span><a name="xml-id" id=
"xml-id"></a>xml:id</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xml-id/"><cite>xml:id Version
1.0</cite></a>, Jonathan Marsh, Daniel Veillard, and Norman Walsh,
Editors. World Wide Web Consortium, 09&#160;Sep&#160;2005. This
version is http://www.w3.org/TR/2005/REC-xml-id-20050909/. The
<a href="http://www.w3.org/TR/xml-id/">latest version</a> is
available at http://www.w3.org/TR/xml-id/.</div>
</dd>
<dt class="label"><span><a name="xml-names" id=
"xml-names"></a>Namespaces in XML</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xml-names/"><cite>Namespaces in
XML 1.0 (Third Edition)</cite></a>, Tim Bray, Dave Hollander,
Andrew Layman, <em>et. al.</em>, Editors. World Wide Web
Consortium, 08&#160;Dec&#160;2009. This version is
http://www.w3.org/TR/2009/REC-xml-names-20091208/. The <a href=
"http://www.w3.org/TR/xml-names">latest version</a> is available at
http://www.w3.org/TR/xml-names.</div>
</dd>
<dt class="label"><span><a name="xml-names11" id=
"xml-names11"></a>Namespaces in XML 1.1</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xml-names11/"><cite>Namespaces
in XML 1.1 (Second Edition)</cite></a>, Tim Bray, Dave Hollander,
Andrew Layman, and Richard Tobin, Editors. World Wide Web
Consortium, 16&#160;Aug&#160;2006. This version is
http://www.w3.org/TR/2006/REC-xml-names11-20060816. The <a href=
"http://www.w3.org/TR/xml-names11/">latest version</a> is available
at http://www.w3.org/TR/xml-names11/.</div>
</dd>
<dt class="label"><span><a name="xmlschema-1" id=
"xmlschema-1"></a>XML Schema Part 1</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xmlschema-1/"><cite>XML Schema
Part 1: Structures Second Edition</cite></a>, Henry Thompson, David
Beech, Murray Maloney, and Noah Mendelsohn, Editors. World Wide Web
Consortium, 28&#160;Oct&#160;2004. This version is
http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/. The <a href=
"http://www.w3.org/TR/xmlschema-1/">latest version</a> is available
at http://www.w3.org/TR/xmlschema-1/.</div>
</dd>
<dt class="label"><span><a name="xmlschema-2" id=
"xmlschema-2"></a>XML Schema Part 2</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xmlschema-2/"><cite>XML Schema
Part 2: Datatypes Second Edition</cite></a>, Paul V. Biron and
Ashok Malhotra, Editors. World Wide Web Consortium,
28&#160;Oct&#160;2004. This version is
http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/. The <a href=
"http://www.w3.org/TR/xmlschema-2/">latest version</a> is available
at http://www.w3.org/TR/xmlschema-2/.</div>
</dd>
<dt class="label"><span><a name="xmlschema11-1" id=
"xmlschema11-1"></a>XML Schema 1.1 Part 1</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xmlschema11-1/"><cite>W3C XML
Schema Definition Language (XSD) 1.1 Part 1: Structures</cite></a>,
Sandy Gao, Michael Sperberg-McQueen, Henry Thompson, <em>et.
al.</em>, Editors. World Wide Web Consortium,
05&#160;Apr&#160;2012. This version is
http://www.w3.org/TR/2012/REC-xmlschema11-1-20120405/. The <a href=
"http://www.w3.org/TR/xmlschema11-1/">latest version</a> is
available at http://www.w3.org/TR/xmlschema11-1/.</div>
</dd>
<dt class="label"><span><a name="xmlschema11-2" id=
"xmlschema11-2"></a>XML Schema 1.1 Part 2</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xmlschema11-2/"><cite>W3C XML
Schema Definition Language (XSD) 1.1 Part 2: Datatypes</cite></a>,
David Peterson, Sandy Gao, Ashok Malhotra, <em>et. al.</em>,
Editors. World Wide Web Consortium, 05&#160;Apr&#160;2012. This
version is http://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/.
The <a href="http://www.w3.org/TR/xmlschema11-2/">latest
version</a> is available at
http://www.w3.org/TR/xmlschema11-2/.</div>
</dd>
<dt class="label"><span><a name="xpath-30" id="xpath-30"></a>XPath
3.0</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xpath-30/"><cite>XML Path
Language (XPath) 3.0</cite></a>, Jonathan Robie, Don Chamberlin,
Michael Dyck, John Snelson, Editors. World Wide Web Consortium, 08
April 2014. This version is
http://www.w3.org/TR/2014/REC-xpath-30-20140408/. The <a href=
"http://www.w3.org/TR/xpath-30/">latest version</a> is available at
http://www.w3.org/TR/xpath-30/.</div>
</dd>
<dt class="label"><span><a name="XSLT-Mime-Type" id=
"XSLT-Mime-Type"></a>XSLT Media Type</span></dt>
<dd>
<div>World Wide Web Consortium. <em>Registration of MIME Media Type
application/xslt+xml</em>. In <a href=
"http://www.w3.org/TR/2007/REC-xslt20-20070123/#media-type-registration">
Appendix B.1 of the XSLT 2.0 specification.</a></div>
</dd>
</dl>
</div>
<div class="div2">
<h3><a name="other-references" id="other-references"></a>A.2
<a href="#other-references" style="text-decoration: none">Other
References</a></h3>
<dl>
<dt class="label"><span><a name="DOM-Level-2-Core" id=
"DOM-Level-2-Core"></a>DOM Level 2</span></dt>
<dd>
<div><a href=
"http://www.w3.org/TR/DOM-Level-2-Core/"><cite>Document Object
Model (DOM) Level 2 Core Specification</cite></a>, Arnaud Le Hors,
Philippe Le Hégaret, Lauren Wood, <em>et. al.</em>, Editors. World
Wide Web Consortium, 13&#160;Nov&#160;2000. This version is
http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113. The
<a href="http://www.w3.org/TR/DOM-Level-2-Core/">latest version</a>
is available at http://www.w3.org/TR/DOM-Level-2-Core/.</div>
</dd>
<dt class="label"><span><a name="ECMA-404" id=
"ECMA-404"></a>ECMA-404</span></dt>
<dd>
<div>ECMA International. <em>The JSON Data Interchange Format</em>
October 2013. See <a href=
"http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf">
http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf</a>.</div>
</dd>
<dt class="label"><span><a name="rfc2119" id=
"rfc2119"></a>RFC2119</span></dt>
<dd>
<div>S. Bradner. <em>Key words for use in RFCs to Indicate
Requirement Levels</em>. IETF RFC 2119. See <a href=
"http://www.ietf.org/rfc/rfc2119.txt">http://www.ietf.org/rfc/rfc2119.txt</a>.</div>
</dd>
<dt class="label"><span><a name="RFC3986" id=
"RFC3986"></a>RFC3986</span></dt>
<dd>
<div>T. Berners-Lee, R. Fielding, and L. Masinter. <em>Uniform
Resource Identifiers (URI): Generic Syntax</em>. IETF RFC 3986. See
<a href=
"http://www.ietf.org/rfc/rfc3986.txt">http://www.ietf.org/rfc/rfc3986.txt</a>.</div>
</dd>
<dt class="label"><span><a name="RFC3987" id=
"RFC3987"></a>RFC3987</span></dt>
<dd>
<div>M. Duerst, M. Suignard. <em>Internationalized Resource
Identifiers (IRIs)</em>. IETF RFC 3987. See <a href=
"http://www.ietf.org/rfc/rfc3987.txt">http://www.ietf.org/rfc/rfc3987.txt</a>.</div>
</dd>
<dt class="label"><span><a name="rfc7303" id=
"rfc7303"></a>RFC7303</span></dt>
<dd>
<div>H. Thompson and C. Lilley. <em>XML Media Types</em>. IETF RFC
7303. See <a href=
"http://www.ietf.org/rfc/rfc7303.txt">http://www.ietf.org/rfc/rfc7303.txt</a></div>
</dd>
<dt class="label"><span><a name="SemVer" id=
"SemVer"></a>SemVer</span></dt>
<dd>
<div>Tom Preston-Werner, <em>Semantic Versioning 2.0.0</em>. See
<a href="http://semver.org/">http://semver.org/</a>. Undated
(retrieved 1 August 2014).</div>
</dd>
<dt class="label"><span><a name="STX" id="STX"></a>STX</span></dt>
<dd>
<div>Petr Cimprich <em>et al</em>, <em>Streaming Transformations
for XML (STX) Version 1.0</em>. Working Draft 27 April 2007. See
<a href=
"http://stx.sourceforge.net/documents/spec-stx-20070427.html">http://stx.sourceforge.net/documents/spec-stx-20070427.html</a></div>
</dd>
<dt class="label"><span><a name="xlink" id=
"xlink"></a>XLink</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xlink/"><cite>XML Linking
Language (XLink) Version 1.0</cite></a>, Steven DeRose, Eve Maler,
and David Orchard, Editors. World Wide Web Consortium,
27&#160;Jun&#160;2001. This version is
http://www.w3.org/TR/2001/REC-xlink-20010627/. The <a href=
"http://www.w3.org/TR/xlink/">latest version</a> is available at
http://www.w3.org/TR/xlink/.</div>
</dd>
<dt class="label"><span><a name="SCHEMA-AND-XML-1.1" id=
"SCHEMA-AND-XML-1.1"></a>XML Schema 1.0 and XML 1.1</span></dt>
<dd>
<div>World Wide Web Consortium. <em>Processing XML 1.1 documents
with XML Schema 1.0 processors</em>. W3C Working Group Note 11 May
2005. See <a href=
"http://www.w3.org/TR/2005/NOTE-xml11schema10-20050511/">http://www.w3.org/TR/2005/NOTE-xml11schema10-20050511/</a></div>
</dd>
<dt class="label"><span><a name="xml-stylesheet" id=
"xml-stylesheet"></a>XML Stylesheet</span></dt>
<dd>
<div><a href=
"http://www.w3.org/TR/xml-stylesheet"><cite>Associating Style
Sheets with XML documents 1.0 (Second Edition)</cite></a>, James
Clark, Simon Pieters, and Henry Thompson, Editors. World Wide Web
Consortium, 28&#160;Oct&#160;2010. This version is
http://www.w3.org/TR/2010/REC-xml-stylesheet-20101028. The <a href=
"http://www.w3.org/TR/xml-stylesheet">latest version</a> is
available at http://www.w3.org/TR/xml-stylesheet.</div>
</dd>
<dt class="label"><span><a name="xptr-framework" id=
"xptr-framework"></a>XPointer Framework</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xptr-framework/"><cite>XPointer
Framework</cite></a>, Paul Grosso, Eve Maler, Jonathan Marsh, and
Norman Walsh, Editors. World Wide Web Consortium,
25&#160;Mar&#160;2003. This version is
http://www.w3.org/TR/2003/REC-xptr-framework-20030325/. The
<a href="http://www.w3.org/TR/xptr-framework/">latest version</a>
is available at http://www.w3.org/TR/xptr-framework/.</div>
</dd>
<dt class="label"><span><a name="xsl11" id=
"xsl11"></a>XSL-FO</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xsl11/"><cite>Extensible
Stylesheet Language (XSL) Version 1.1</cite></a>, Anders Berglund,
Editor. World Wide Web Consortium, 05&#160;Dec&#160;2006. This
version is http://www.w3.org/TR/2006/REC-xsl11-20061205/. The
<a href="http://www.w3.org/TR/xsl11/">latest version</a> is
available at http://www.w3.org/TR/xsl11/.</div>
</dd>
<dt class="label"><span><a name="xslt" id="xslt"></a>XSLT
1.0</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xslt"><cite>XSL Transformations
(XSLT) Version 1.0</cite></a>, James Clark, Editor. World Wide Web
Consortium, 16&#160;Nov&#160;1999. This version is
http://www.w3.org/TR/1999/REC-xslt-19991116. The <a href=
"http://www.w3.org/TR/xslt">latest version</a> is available at
http://www.w3.org/TR/xslt.</div>
</dd>
<dt class="label"><span><a name="xslt20" id="xslt20"></a>XSLT
2.0</span></dt>
<dd>
<div><a href="http://www.w3.org/TR/xslt20/"><cite>XSL
Transformations (XSLT) Version 2.0 (Second Edition)</cite></a>,
Michael Kay, Editor. World Wide Web Consortium, 23 January 2007.
This version is http://www.w3.org/TR/2007/REC-xslt20-20070123/. The
<a href="http://www.w3.org/TR/xslt20/">latest version</a> is
available at http://www.w3.org/TR/xslt20/.</div>
</dd>
</dl>
</div>
</div>
<div class="div1">
<h2><a name="json-in-xml" id="json-in-xml"></a>B <a href=
"#json-in-xml" style="text-decoration: none">XML Representation of
JSON</a></h2>
<p>This appendix contains the schema for the XML representation of
JSON described in <a href="#json-to-xml-mapping"><i>21.2.1 XML
Representation of JSON</i></a>, together with the stylesheets used
for converting from this XML representation to strings matching the
JSON grammar.</p>
<p>These schema documents and stylesheets are also available as
separate resources (links are listed at the top of this
document).</p>
<div class="div2">
<h3><a name="schema-for-json" id="schema-for-json"></a>B.1 <a href=
"#schema-for-json" style="text-decoration: none">Schema for the XML
Representation of JSON</a></h3>
<p>The schema is reproduced below:</p>
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
    elementFormDefault="qualified"
    targetNamespace="http://www.w3.org/2013/XSL/json"
    xmlns:j="http://www.w3.org/2013/XSL/json"&gt;
    
    &lt;!-- 
     * This is a schema for the XML representation of JSON used as the target for the
     * XSLT 3.0 function fn:json-to-xml()
     *
     * The schema is made available under the terms of the W3C software notice and license
     * at http://www.w3.org/Consortium/Legal/copyright-software-19980720
     *
    --&gt;
    
    &lt;xs:element name="map" type="j:mapType"&gt;
        &lt;xs:unique name="unique-key"&gt;
            &lt;xs:selector xpath="*"/&gt;
            &lt;xs:field xpath="@key"/&gt;
        &lt;/xs:unique&gt;
    &lt;/xs:element&gt;
    
    &lt;xs:element name="array" type="j:arrayType"/&gt;
    
    &lt;xs:element name="string" type="j:stringType"/&gt;
    
    &lt;xs:element name="number" type="j:numberType"/&gt;
    
    &lt;xs:element name="boolean" type="xs:boolean"/&gt;
    
    &lt;xs:element name="null" type="j:nullType"/&gt;
    
    &lt;xs:complexType name="nullType"&gt;
        &lt;xs:sequence/&gt;
    &lt;/xs:complexType&gt;
    
    &lt;xs:complexType name="stringType"&gt;
        &lt;xs:simpleContent&gt;
            &lt;xs:extension base="xs:string"&gt;
                &lt;xs:attribute name="escaped" type="xs:boolean" use="optional" default="false"/&gt;
            &lt;/xs:extension&gt;
        &lt;/xs:simpleContent&gt;
    &lt;/xs:complexType&gt;
    
    &lt;xs:simpleType name="numberType"&gt;
        &lt;xs:restriction base="xs:double"&gt;
            &lt;!-- exclude positive and negative infinity, and NaN --&gt;
            &lt;xs:minExclusive value="-INF"/&gt;
            &lt;xs:maxExclusive value="INF"/&gt;
        &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;
    
    &lt;xs:complexType name="arrayType"&gt;
        &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xs:element ref="j:map"/&gt;
            &lt;xs:element ref="j:array"/&gt;
            &lt;xs:element ref="j:string"/&gt;
            &lt;xs:element ref="j:number"/&gt;
            &lt;xs:element ref="j:boolean"/&gt;
            &lt;xs:element ref="j:null"/&gt;
        &lt;/xs:choice&gt;       
    &lt;/xs:complexType&gt;
    
    &lt;xs:complexType name="mapType"&gt;
        &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xs:element name="map"&gt;
                &lt;xs:complexType&gt;
                    &lt;xs:complexContent&gt;
                        &lt;xs:extension base="j:mapType"&gt;
                            &lt;xs:attribute name="key" type="xs:string"/&gt;
                        &lt;/xs:extension&gt;
                    &lt;/xs:complexContent&gt;
                &lt;/xs:complexType&gt;
                &lt;xs:unique name="unique-key-2"&gt;
                    &lt;xs:selector xpath="*"/&gt;
                    &lt;xs:field xpath="@key"/&gt;
                &lt;/xs:unique&gt;
            &lt;/xs:element&gt;
            &lt;xs:element name="array"&gt;
                &lt;xs:complexType&gt;
                    &lt;xs:complexContent&gt;
                        &lt;xs:extension base="j:arrayType"&gt;
                            &lt;xs:attributeGroup ref="j:key-group"/&gt;
                        &lt;/xs:extension&gt;
                    &lt;/xs:complexContent&gt;
                &lt;/xs:complexType&gt;
            &lt;/xs:element&gt;
            &lt;xs:element name="string"&gt;
                &lt;xs:complexType&gt;
                    &lt;xs:simpleContent&gt;
                        &lt;xs:extension base="j:stringType"&gt;
                            &lt;xs:attributeGroup ref="j:key-group"/&gt;
                        &lt;/xs:extension&gt;
                    &lt;/xs:simpleContent&gt;
                &lt;/xs:complexType&gt;
            &lt;/xs:element&gt;
            &lt;xs:element name="number"&gt;
                &lt;xs:complexType&gt;
                    &lt;xs:simpleContent&gt;
                        &lt;xs:extension base="j:numberType"&gt;
                            &lt;xs:attributeGroup ref="j:key-group"/&gt;
                        &lt;/xs:extension&gt;
                    &lt;/xs:simpleContent&gt;
                &lt;/xs:complexType&gt;
            &lt;/xs:element&gt;
            &lt;xs:element name="boolean"&gt;
                &lt;xs:complexType&gt;
                    &lt;xs:simpleContent&gt;
                        &lt;xs:extension base="xs:boolean"&gt;
                            &lt;xs:attributeGroup ref="j:key-group"/&gt;
                        &lt;/xs:extension&gt;
                    &lt;/xs:simpleContent&gt;
                &lt;/xs:complexType&gt;
            &lt;/xs:element&gt;
            &lt;xs:element name="null"&gt;
                &lt;xs:complexType&gt;
                    &lt;xs:attributeGroup ref="j:key-group"/&gt;
                &lt;/xs:complexType&gt;
            &lt;/xs:element&gt;
        &lt;/xs:choice&gt;
    &lt;/xs:complexType&gt;
    
    &lt;xs:attributeGroup name="key-group"&gt;
        &lt;xs:attribute name="key" type="xs:string"/&gt;
        &lt;xs:attribute name="escaped-key" type="xs:boolean" use="optional" default="false"/&gt;
    &lt;/xs:attributeGroup&gt;
    
&lt;/xs:schema&gt;
</pre></div>
<div class="div2">
<h3><a name="xml-to-json-stylesheet" id=
"xml-to-json-stylesheet"></a>B.2 <a href="#xml-to-json-stylesheet"
style="text-decoration: none">Stylesheet for converting XML to JSON
(without indentation)</a></h3>
<p>This stylesheet contains the implementation of a function very
similar to <a href=
"#func-xml-to-json"><code>xml-to-json</code></a>, but implemented
in XSLT so that it can be customized and extended. This stylesheet
is provided for the benefit of users and there are no conformance
requirements associated with it; there is no requirement that
processors should make this stylesheet available. The stylesheet is
reproduced below:</p>
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;


    &lt;!-- 
        * This is a stylesheet for converting XML to JSON. 
        * It expects the XML to be in the format produced by the XSLT 3.0 function
        * fn:json-to-xml(), but is designed to be highly customizable.
        *
        * The stylesheet is made available under the terms of the W3C software notice and license
        * at http://www.w3.org/Consortium/Legal/copyright-software-19980720
        *
    --&gt;    

&lt;xsl:package
    name="http://www.w3.org/2013/XSLT/xml-to-json.xsl"
    package-version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:j="http://www.w3.org/2013/XSL/json"
    exclude-result-prefixes="xs j" default-mode="j:xml-to-json" version="3.0"&gt;

    &lt;xsl:variable name="quot" visibility="private"&gt;"&lt;/xsl:variable&gt;
    &lt;xsl:param name="indent-spaces" select="2"/&gt;
    
    &lt;!-- The static parameter STREAMABLE controls whether the stylesheet is declared as streamable --&gt;
    
    &lt;xsl:param name="STREAMABLE" static="yes" as="xs:boolean" select="true()"/&gt;
    
    &lt;xsl:mode name="indent" _streamable="{$STREAMABLE}" visibility="public"/&gt;
    &lt;xsl:mode name="no-indent" _streamable="{$STREAMABLE}" visibility="public"/&gt;
    &lt;xsl:mode name="key-attribute" streamable="false" on-no-match="fail" visibility="public"/&gt;
    
    &lt;!-- The static parameter VALIDATE controls whether the input, if untyped, should be validated --&gt;
    
    &lt;xsl:param name="VALIDATE" static="yes" as="xs:boolean" select="false()"/&gt;
    &lt;xsl:import-schema namespace="http://www.w3.org/2013/XSL/json" use-when="$VALIDATE"/&gt;

    &lt;!-- Entry point: function to convert a supplied XML node to a JSON string --&gt;
    &lt;xsl:function name="j:xml-to-json" as="xs:string" visibility="public"&gt;
        &lt;xsl:param name="input" as="node()"/&gt;
        &lt;xsl:sequence select="j:xml-to-json($input, map{})"/&gt;
    &lt;/xsl:function&gt;

    &lt;!-- Entry point: function to convert a supplied XML node to a JSON string, supplying options --&gt;
    &lt;xsl:function name="j:xml-to-json" as="xs:string" visibility="public"&gt;
        &lt;xsl:param name="input" as="node()"/&gt;
        &lt;xsl:param name="options" as="map(*)"/&gt;
        &lt;xsl:variable name="input" as="node()" use-when="$VALIDATE"&gt;
            &lt;xsl:copy-of select="$input" validation="strict"/&gt;
        &lt;/xsl:variable&gt;
        &lt;xsl:choose&gt;
            &lt;xsl:when test="$options('indent') eq true()"&gt;
                &lt;xsl:apply-templates select="$input" mode="indent"&gt;
                    &lt;xsl:with-param name="fallback" as="(function(element()) as xs:string)?"
                        select="$options('fallback')" tunnel="yes"/&gt;
                &lt;/xsl:apply-templates&gt;
            &lt;/xsl:when&gt;
            &lt;xsl:otherwise&gt;
                &lt;xsl:apply-templates select="$input" mode="no-indent"&gt;
                    &lt;xsl:with-param name="fallback" as="(function(element()) as xs:string)?"
                        select="$options('fallback')" tunnel="yes"/&gt;
                &lt;/xsl:apply-templates&gt;
            &lt;/xsl:otherwise&gt;
        &lt;/xsl:choose&gt;
    &lt;/xsl:function&gt;
    
    &lt;!-- A document node is ignored --&gt;
    
    &lt;xsl:template match="/" mode="indent no-indent"&gt;
        &lt;xsl:apply-templates mode="#current"/&gt;
    &lt;/xsl:template&gt;

    &lt;!-- Template rule for j:map elements, representing JSON objects --&gt;

    &lt;xsl:template match="j:map" mode="indent"&gt;
        &lt;xsl:value-of&gt;
            &lt;xsl:variable name="depth" select="count(ancestor::*) + 1"/&gt;
            &lt;xsl:text&gt;{&lt;/xsl:text&gt;
            &lt;xsl:for-each select="*"&gt;
                &lt;xsl:if test="position() gt 1"&gt;
                    &lt;xsl:text&gt;, &lt;/xsl:text&gt;
                    &lt;xsl:value-of select="j:indent($depth)"/&gt;
                &lt;/xsl:if&gt;
                &lt;xsl:apply-templates select="snapshot(@key)" mode="key-attribute"/&gt;
                &lt;xsl:text&gt; : &lt;/xsl:text&gt;
                &lt;xsl:apply-templates select="." mode="#current"/&gt;
            &lt;/xsl:for-each&gt;
            &lt;xsl:text&gt;}&lt;/xsl:text&gt;
        &lt;/xsl:value-of&gt;
    &lt;/xsl:template&gt;

    &lt;xsl:template match="j:map" mode="no-indent"&gt;
        &lt;xsl:value-of&gt;
            &lt;xsl:text&gt;{&lt;/xsl:text&gt;
            &lt;xsl:for-each select="*"&gt;
                &lt;xsl:if test="position() gt 1"&gt;
                    &lt;xsl:text&gt;,&lt;/xsl:text&gt;
                &lt;/xsl:if&gt;
                &lt;xsl:apply-templates select="snapshot(@key)" mode="key-attribute"/&gt;
                &lt;xsl:text&gt;:&lt;/xsl:text&gt;
                &lt;xsl:apply-templates select="." mode="#current"/&gt;
            &lt;/xsl:for-each&gt;
            &lt;xsl:text&gt;}&lt;/xsl:text&gt;
        &lt;/xsl:value-of&gt;
    &lt;/xsl:template&gt;

    &lt;!-- Template rule for j:array elements, representing JSON arrays --&gt;
    &lt;xsl:template match="j:array" mode="indent"&gt;
        &lt;xsl:value-of&gt;
            &lt;xsl:variable name="depth" select="count(ancestor::*) + 1"/&gt;
            &lt;xsl:text&gt;[&lt;/xsl:text&gt;
            &lt;xsl:for-each select="*"&gt;
                &lt;xsl:if test="position() gt 1"&gt;
                    &lt;xsl:text&gt;, &lt;/xsl:text&gt;
                    &lt;xsl:value-of select="j:indent($depth)"/&gt;
                &lt;/xsl:if&gt;
                &lt;xsl:apply-templates select="." mode="#current"/&gt;
            &lt;/xsl:for-each&gt;
            &lt;xsl:text&gt;]&lt;/xsl:text&gt;
        &lt;/xsl:value-of&gt;
    &lt;/xsl:template&gt;

    &lt;xsl:template match="j:array" mode="no-indent"&gt;
        &lt;xsl:value-of&gt;
            &lt;xsl:text&gt;[&lt;/xsl:text&gt;
            &lt;xsl:for-each select="*"&gt;
                &lt;xsl:if test="position() gt 1"&gt;
                    &lt;xsl:text&gt;,&lt;/xsl:text&gt;
                &lt;/xsl:if&gt;
                &lt;xsl:apply-templates select="." mode="#current"/&gt;
            &lt;/xsl:for-each&gt;
            &lt;xsl:text&gt;]&lt;/xsl:text&gt;
        &lt;/xsl:value-of&gt;
    &lt;/xsl:template&gt;

    &lt;!-- Template rule for j:string elements in which special characters are already escaped --&gt;
    &lt;xsl:template match="j:string[@escaped='true']" mode="indent no-indent"&gt;
        &lt;xsl:sequence select="concat($quot, ., $quot)"/&gt;
    &lt;/xsl:template&gt;

    &lt;!-- Template rule for j:string elements in which special characters need to be escaped --&gt;
    &lt;xsl:template match="j:string[not(@escaped='true')]" mode="indent no-indent"&gt;
        &lt;xsl:sequence select="concat($quot, j:escape(.), $quot)"/&gt;
    &lt;/xsl:template&gt;

    &lt;!-- Template rule for j:boolean elements --&gt;
    &lt;xsl:template match="j:boolean" mode="indent no-indent"&gt;
        &lt;xsl:sequence select="xs:string(xs:boolean(.))"/&gt;
    &lt;/xsl:template&gt;

    &lt;!-- Template rule for j:number elements --&gt;
    &lt;xsl:template match="j:number" mode="indent no-indent"&gt;
        &lt;xsl:value-of select="xs:string(xs:double(.))"/&gt;
    &lt;/xsl:template&gt;

    &lt;!-- Template rule for JSON null elements --&gt;
    &lt;xsl:template match="j:null" mode="indent no-indent"&gt;
        &lt;xsl:text&gt;null&lt;/xsl:text&gt;
    &lt;/xsl:template&gt;

    &lt;!-- Template rule matching a key within a map where special characters in the key are already escaped --&gt;
    &lt;xsl:template match="j:*[@key-escaped='true']/@key" mode="key-attribute"&gt;
        &lt;xsl:value-of select="concat($quot, ., $quot)"/&gt;
    &lt;/xsl:template&gt;

    &lt;!-- Template rule matching a key within a map where special characters in the key need to be escaped --&gt;
    &lt;xsl:template match="j:*[not(@key-escaped='true')]/@key" mode="key-attribute"&gt;
        &lt;xsl:value-of select="concat($quot, j:escape(.), $quot)"/&gt;
    &lt;/xsl:template&gt;
    
    &lt;!-- Template matching "invalid" elements --&gt;
    &lt;xsl:template match="*" mode="indent no-indent"&gt;
        &lt;xsl:param name="fallback" as="(function(element()) as xs:string)?"
            tunnel="yes" required="yes"/&gt;
        &lt;xsl:choose&gt;
            &lt;xsl:when test="exists($fallback)"&gt;
                &lt;xsl:value-of select="$fallback(snapshot(.))"/&gt;
            &lt;/xsl:when&gt;
            &lt;xsl:otherwise&gt;
                &lt;xsl:message terminate="yes"&gt;&gt;Inc&lt;/xsl:message&gt;
            &lt;/xsl:otherwise&gt;
        &lt;/xsl:choose&gt;
    &lt;/xsl:template&gt;

    &lt;!-- Template rule matching (and discarding) whitespace text nodes in the XML --&gt;
    &lt;xsl:template match="text()[not(normalize-space())]" mode="indent no-indent"/&gt;

    &lt;!-- Function to escape special characters --&gt;
    &lt;xsl:function name="j:escape" as="xs:string" visibility="final"&gt;
        &lt;xsl:param name="in" as="xs:string"/&gt;
        &lt;xsl:value-of&gt;
            &lt;xsl:for-each select="string-to-codepoints($in)"&gt;
                &lt;xsl:choose&gt;
                    &lt;xsl:when test=". gt 65535"&gt;
                        &lt;xsl:value-of select="concat('\u', j:hex4((. - 65536) idiv 1024 + 55296))"/&gt;
                        &lt;xsl:value-of select="concat('\u', j:hex4((. - 65536) mod 1024 + 56320))"/&gt;
                    &lt;/xsl:when&gt;
                    &lt;xsl:when test=". = 34"&gt;\"&lt;/xsl:when&gt;
                    &lt;xsl:when test=". = 92"&gt;\\&lt;/xsl:when&gt;
                    &lt;xsl:when test=". = 08"&gt;\b&lt;/xsl:when&gt;
                    &lt;xsl:when test=". = 09"&gt;\t&lt;/xsl:when&gt;
                    &lt;xsl:when test=". = 10"&gt;\n&lt;/xsl:when&gt;
                    &lt;xsl:when test=". = 12"&gt;\f&lt;/xsl:when&gt;
                    &lt;xsl:when test=". = 13"&gt;\r&lt;/xsl:when&gt;
                    &lt;xsl:when test=". lt 32 or (. ge 127 and . le 160)"&gt;
                        &lt;xsl:value-of select="concat('\u', j:hex4(.))"/&gt;
                    &lt;/xsl:when&gt;
                    &lt;xsl:otherwise&gt;
                        &lt;xsl:value-of select="codepoints-to-string(.)"/&gt;
                    &lt;/xsl:otherwise&gt;
                &lt;/xsl:choose&gt;
            &lt;/xsl:for-each&gt;
        &lt;/xsl:value-of&gt;
    &lt;/xsl:function&gt;

    &lt;!-- Function to convert a UTF16 codepoint into a string of four hex digits --&gt;
    &lt;xsl:function name="j:hex4" as="xs:string" visibility="final"&gt;
        &lt;xsl:param name="ch" as="xs:integer"/&gt;
        &lt;xsl:variable name="hex" select="'0123456789abcdef'"/&gt;
        &lt;xsl:value-of&gt;
            &lt;xsl:value-of select="substring($hex, $ch idiv 4096 + 1, 1)"/&gt;
            &lt;xsl:value-of select="substring($hex, $ch idiv 256 mod 16 + 1, 1)"/&gt;
            &lt;xsl:value-of select="substring($hex, $ch idiv 16 mod 16 + 1, 1)"/&gt;
            &lt;xsl:value-of select="substring($hex, $ch mod 16 + 1, 1)"/&gt;
        &lt;/xsl:value-of&gt;
    &lt;/xsl:function&gt;

    &lt;!-- Function to output whitespace indentation based on the depth of the node supplied as a parameter --&gt;

    &lt;xsl:function name="j:indent" as="text()" visibility="public"&gt;
        &lt;xsl:param name="depth" as="xs:integer"/&gt;
        &lt;xsl:value-of select="'&amp;#xa;', string-join((1 to ($depth + 1) * $indent-spaces) ! ' ', '')"/&gt;
    &lt;/xsl:function&gt;

&lt;/xsl:package&gt;
</pre></div>
</div>
<div class="div1">
<h2><a name="glossary" id="glossary"></a>C Glossary
(Non-Normative)</h2>
<dl>
<dt><a href="#dt-absent">absent</a></dt>
<dd>
<p>A component of the context that has no value is said to be
<b>absent</b>.</p>
</dd>
<dt><a href="#dt-absorption">absorption</a></dt>
<dd>
<p>An operand usage of <b>absorption</b> indicates that the
construct reads the subtree(s) rooted at a supplied node(s).</p>
</dd>
<dt><a href="#dt-accumulator">accumulator</a></dt>
<dd>
<p>An <b>accumulator</b> defines a value that is computed
progressively while processing the nodes of a <span>tree</span> in
document order. The value for a given node is available via a pair
of functions, one giving the value for a node before processing its
descendants, and one giving the value for the same node after
processing its descendants.</p>
</dd>
<dt><a href="#dt-accumulator-function">accumulator
function</a></dt>
<dd>
<p>The functions <a href=
"#func-accumulator-before"><code>accumulator-before</code></a> and
<a href=
"#func-accumulator-after"><code>accumulator-after</code></a> are
referred to as the <b>accumulator functions</b>.</p>
</dd>
<dt><a href="#dt-alias">alias</a></dt>
<dd>
<p>A stylesheet can use the <a href=
"#element-namespace-alias"><code>xsl:namespace-alias</code></a>
element to declare that a <a title="literal namespace URI" class=
"termref" href="#dt-literal-namespace-uri">literal namespace
URI</a> is being used as an <b>alias</b> for a <a title=
"target namespace URI" class="termref" href=
"#dt-target-namespace-uri">target namespace URI</a>.</p>
</dd>
<dt><a href="#dt-applicable">applicable</a></dt>
<dd>
<p>A <a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a> is <b>applicable</b> to one
or more modes. The modes to which it is applicable are defined by
the <code>mode</code> attribute of the <a href=
"#element-template"><code>xsl:template</code></a> element. If the
attribute is omitted, then the template rule is applicable to the
<span>default mode specified in the
<span><code>[xsl:]default-mode</code> attribute of the innermost
containing element that has such an attribute</span>, which in turn
defaults to the <a title="unnamed mode" class="termref" href=
"#dt-unnamed-mode">unnamed mode</a>.</span> If the
<code>mode</code> attribute is present, then its value <span class=
"verb">must</span> be a non-empty whitespace-separated list of
tokens, each of which defines a mode to which the template rule is
applicable.</p>
</dd>
<dt><a href="#dt-arity">arity</a></dt>
<dd>
<p>The <b>arity</b> of a stylesheet function is the number of
<a href="#element-param"><code>xsl:param</code></a> elements in the
function definition.</p>
</dd>
<dt><a href="#dt-atomization">atomize</a></dt>
<dd>
<p>The term <b>atomization</b> is defined in <a href=
"http://www.w3.org/TR/xpath-30/#id-atomization">Section 2.4.2
Atomization</a> <sup><small>XP30</small></sup>. It is a process
that takes as input a sequence of <span>items</span>, and returns a
sequence of atomic values, in which the nodes are replaced by their
typed values as defined in <a href="#xpath-datamodel-30">[Data
Model]</a>.</p>
</dd>
<dt><a href="#dt-attribute-set">attribute set</a></dt>
<dd>
<p>An <b>attribute set</b> is defined as a set of <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a>
declarations in the same <a title="package" class="termref" href=
"#dt-package">package</a> that share the same <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a>.</p>
</dd>
<dt><a href="#dt-attribute-value-template">attribute value
template</a></dt>
<dd>
<p>In an attribute that is designated as an <b>attribute value
template</b>, such as an attribute of a <a title=
"literal result element" class="termref" href=
"#dt-literal-result-element">literal result element</a>, an
<a title="expression" class="termref" href=
"#dt-expression">expression</a> can be used by surrounding the
expression with curly brackets (<code>{}</code>), following the
general rules for <a title="value template" class="termref" href=
"#dt-value-template">value templates</a></p>
</dd>
<dt><a href="#dt-backwards-compatible-behavior">backwards
compatible behavior</a></dt>
<dd>
<p>An element is processed with <b>backwards compatible
behavior</b> if its <a title="effective version" class="termref"
href="#dt-effective-version">effective version</a> is less than
<code>3.0</code>.</p>
</dd>
<dt><a href="#dt-base-output-uri">base output URI</a></dt>
<dd>
<p>The <b>base output URI</b> is a URI to be used as the base URI
when resolving a relative URI <span>reference</span> allocated to a
<a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a>. If the
transformation generates more than one final result tree, then
typically each one will be allocated a URI relative to this base
URI.</p>
</dd>
<dt><a href="#dt-basic-xslt-processor">basic XSLT
processor</a></dt>
<dd>
<p>A <b>basic XSLT processor</b> is an XSLT processor that
implements all the mandatory requirements of this specification
with the exception of constructs explicitly associated with an
optional feature.</p>
</dd>
<dt><a href="#dt-character-map">character map</a></dt>
<dd>
<p>A <b>character map</b> allows a specific character appearing in
a text or attribute node in the <a title="final result tree" class=
"termref" href="#dt-final-result-tree">final result tree</a> to be
substituted by a specified string of characters during
serialization.</p>
</dd>
<dt><a href="#dt-choice-operand-group">choice operand
group</a></dt>
<dd>
<p>For some construct kinds, one or more operand roles may be
defined to form a <b>choice operand group</b>. This concept is used
where it is known that <a title="operand" class="termref" href=
"#dt-operand">operands</a> are mutually exclusive (for example the
<code>then</code> and <code>else</code> clauses in a conditional
expression).</p>
</dd>
<dt><a href="#dt-circularity">circularity</a></dt>
<dd>
<p>A <b>circularity</b> is said to exist if a construct such as a
<a title="global variable" class="termref" href=
"#dt-global-variable">global variable</a>, an <a title=
"attribute set" class="termref" href="#dt-attribute-set">attribute
set</a>, or a <a title="key" class="termref" href=
"#dt-key">key</a>, is defined in terms of itself. For example, if
the <a title="expression" class="termref" href=
"#dt-expression">expression</a> or <a title="sequence constructor"
class="termref" href="#dt-sequence-constructor">sequence
constructor</a> specifying the value of a <a title=
"global variable" class="termref" href="#dt-global-variable">global
variable</a> <var>X</var> references a global variable
<var>Y</var>, then the value for <var>Y</var> <span class=
"verb">must</span> be computed before the value of <var>X</var>. A
circularity exists if it is impossible to do this for all global
variable definitions.</p>
</dd>
<dt><a href="#dt-climbing">climbing</a></dt>
<dd>
<p><b>Climbing</b>: indicates that nodes returned by the construct
are reached by navigating the parent, ancestor[-or-self],
attribute, and/or namespace axes from the node at the current
streaming position.</p>
</dd>
<dt><a href="#dt-collation">collation</a></dt>
<dd>
<p>Facilities in XSLT <span>3.0</span> and XPath <span>3.0</span>
that require strings to be ordered rely on the concept of a named
<b>collation</b>. A collation is a set of rules that determine
whether two strings are equal, and if not, which of them is to be
sorted before the other.</p>
</dd>
<dt><a href="#dt-combined-posture">combined posture</a></dt>
<dd>
<p>The <b>combined posture</b> of a <a title="choice operand group"
class="termref" href="#dt-choice-operand-group">choice operand
group</a> is determined by the <a title="posture" class="termref"
href="#dt-posture">postures</a> of the <a title="operand" class=
"termref" href="#dt-operand">operands</a> in the group <span>(the
<b>operand postures</b>)</span>, and is the first of the following
that applies:</p>
</dd>
<dt><a href="#dt-compatible">compatible</a></dt>
<dd>
<p>The signatures of two <a title="component" class="termref" href=
"#dt-component">components</a> are <b>compatible</b> if they
present the same interface to the user of the component. The
additional rules depend on the kind of component.</p>
</dd>
<dt><a href="#dt-component">component</a></dt>
<dd>
<p>The term <b>component</b> is used to refer to any of the
following: a <a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet function</a>, a <a title=
"named template" class="termref" href="#dt-named-template">named
template</a>, a <a title="mode" class="termref" href=
"#dt-mode">mode</a>, <span>an <a title="accumulator function"
class="termref" href=
"#dt-accumulator-function">accumulator</a></span> an <a title=
"attribute set" class="termref" href="#dt-attribute-set">attribute
set</a>, a <span><a title="key" class="termref" href=
"#dt-key">key</a></span>, <a title="global variable" class=
"termref" href="#dt-global-variable">global variable</a>, or a
<a title="mode" class="termref" href="#dt-mode">mode</a>.</p>
</dd>
<dt><a href="#dt-composite-merge-key-value">composite merge key
value</a></dt>
<dd>
<p>The ordered collection of <a title="merge key value" class=
"termref" href="#dt-merge-key-value">merge key values</a> computed
for one item in a <a title="merge input sequence" class="termref"
href="#dt-merge-input-sequence">merge input sequence</a> (one for
each <a title="merge key component" class="termref" href=
"#dt-merge-key-component">merge key component</a> within the
<a title="merge key specification" class="termref" href=
"#dt-merge-key-specification">merge key specification</a>) is
referred to as a <b>composite merge key value</b>.</p>
</dd>
<dt><a href="#dt-construct">construct</a></dt>
<dd>
<p>The term <b>construct</b> refers to the union of the following:
a <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>, an <a title=
"instruction" class="termref" href=
"#dt-instruction">instruction</a>, an <a title="attribute set"
class="termref" href="#dt-attribute-set">attribute set</a>, a
<a title="value template" class="termref" href=
"#dt-value-template">value template</a>, an <a title="expression"
class="termref" href="#dt-expression">expression</a>, or a
<a title="pattern" class="termref" href=
"#dt-pattern">pattern</a>.</p>
</dd>
<dt><a href="#dt-consuming">consuming</a></dt>
<dd>
<p>A <b>consuming</b> construct is any <a title="construct" class=
"termref" href="#dt-construct">construct</a> deemed consuming by
the rules in this section (<a href="#streamability"><i>19
Streamability</i></a>).</p>
</dd>
<dt><a href="#dt-containing-package">containing package</a></dt>
<dd>
<p>A component declaration results in multiple components, one in
the package in which the declaration appears, and potentially one
in each package that uses the declaring package, directly or
indirectly, subject to the visibility of the component. Each of
these multiple components has the same <a title="declaring package"
class="termref" href="#dt-declaring-package">declaring package</a>,
but each has a different <b>containing package</b>. For the
original component, the declaring package and the containing
package are the same; for a copy of a component made as a result of
an <a href="#element-use-package"><code>xsl:use-package</code></a>
declaration, the declaring package will be the original package,
and the containing package will be the package in which the
<a href="#element-use-package"><code>xsl:use-package</code></a>
declaration appears.</p>
</dd>
<dt><a href="#dt-context-item">context item</a></dt>
<dd>
<p>The <b>context item</b> is the item currently being processed.
An item (see <a href="#xpath-datamodel-30">[Data Model]</a>) is
either an atomic value (such as an integer, date, or string), a
node, <span>or a function item</span>. It changes whenever
instructions such as <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a> and
<a href="#element-for-each"><code>xsl:for-each</code></a> are used
to process a sequence of items; each item in such a sequence
becomes the context item while that item is being processed.</p>
</dd>
<dt><a href="#dt-context-item-type">context item type</a></dt>
<dd>
<p>For every expression, it is possible to establish by static
analysis, information about the item type of the context item for
evaluation of that expression. This is called the <b>context item
type</b> of the expression.</p>
</dd>
<dt><a href="#dt-context-node">context node</a></dt>
<dd>
<p>If the <a title="context item" class="termref" href=
"#dt-context-item">context item</a> is a node (as distinct from an
atomic value such as an integer), then it is also referred to as
the <b>context node</b>. The context node is not an independent
variable, it changes whenever the context item changes. When the
context item is an atomic value <span>or a function item</span>,
there is no context node.</p>
</dd>
<dt><a href="#dt-context-position">context position</a></dt>
<dd>
<p>The <b>context position</b> is the position of the context item
within the sequence of items currently being processed. It changes
whenever the context item changes. When an instruction such as
<a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a> or
<a href="#element-for-each"><code>xsl:for-each</code></a> is used
to process a sequence of items, the first item in the sequence is
processed with a context position of 1, the second item with a
context position of 2, and so on.</p>
</dd>
<dt><a href="#dt-context-posture">context posture</a></dt>
<dd>
<p>The <b>context posture</b>. This captures information about how
the <a title="context item" class="termref" href=
"#dt-context-item">context item</a> used as input to the construct
is positioned relative to the streamed input. The <b>context
posture</b> of a construct C is the posture of the expression whose
value sets the focus for the evaluation of C.</p>
</dd>
<dt><a href="#dt-context-size">context size</a></dt>
<dd>
<p>The <b>context size</b> is the number of items in the sequence
of items currently being processed. It changes whenever
instructions such as <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a> and
<a href="#element-for-each"><code>xsl:for-each</code></a> are used
to process a sequence of items; during the processing of each one
of those items, the context size is set to the count of the number
of items in the sequence (or equivalently, the position of the last
item in the sequence).</p>
</dd>
<dt><a href="#dt-controlled-operand">controlled operand</a></dt>
<dd>
<p>Within a <a title="focus-changing construct" class="termref"
href="#dt-focus-changing-construct">focus-changing construct</a>
there are one or more <a title="operand" class="termref" href=
"#dt-operand">operands</a> that are evaluated with a <a title=
"focus" class="termref" href="#dt-focus">focus</a> determined by
the <a title="controlling operand" class="termref" href=
"#dt-controlling-operand">controlling operand</a> <span>(or in some
cases such as <a href=
"#element-on-completion"><code>xsl:on-completion</code></a>, with
an <a title="absent" class="termref" href="#dt-absent">absent</a>
<a title="focus" class="termref" href=
"#dt-focus">focus</a>)</span>; these are referred to as
<b>controlled operands</b>.</p>
</dd>
<dt><a href="#dt-controlling-operand">controlling operand</a></dt>
<dd>
<p>Within a <a title="focus-changing construct" class="termref"
href="#dt-focus-changing-construct">focus-changing construct</a>
there is in many cases one <a title="operand" class="termref" href=
"#dt-operand">operand</a> whose value determines the <a title=
"focus" class="termref" href="#dt-focus">focus</a> for evaluating
other operands; this is referred to as the <b>controlling
operand</b>.</p>
</dd>
<dt><a href="#dt-core-function">core function</a></dt>
<dd>
<p>The <b>core functions</b> are: functions specified in <a href=
"#xpath-functions-30">[Functions and Operators]</a> in either the
<a title="standard function namespace" class="termref" href=
"#dt-standard-function-namespace">standard function namespace</a>
<span>or the namespace
<code>http://www.w3.org/2005/xpath-functions/math</code>; plus
functions defined in this specification in namespace
<code>http://www.w3.org/2005/xpath-functions/map</code></span>.</p>
</dd>
<dt><a href="#dt-crawling">crawling</a></dt>
<dd>
<p><b>Crawling</b>: typically indicates that nodes returned by a
construct are reached by navigating the descendant[-or-self]
axis.</p>
</dd>
<dt><a href="#dt-current-captured-substrings">current captured
substrings</a></dt>
<dd>
<p>While the <a href=
"#element-matching-substring"><code>xsl:matching-substring</code></a>
instruction is active, a set of <b>current captured substrings</b>
is available, corresponding to the parenthesized subexpressions of
the regular expression.</p>
</dd>
<dt><a href="#dt-current-group">current group</a></dt>
<dd>
<p>The <b>current group</b> is the <a title="group" class="termref"
href="#dt-group">group</a> itself, as a sequence of items</p>
</dd>
<dt><a href="#dt-current-grouping-key">current grouping
key</a></dt>
<dd>
<p>The <b>current grouping key</b> is a single atomic value, or in
the case of a composite key, a sequence of atomic values,
containing the <a title="grouping key" class="termref" href=
"#dt-grouping-key">grouping key</a> of the items in the <a title=
"current group" class="termref" href="#dt-current-group">current
group</a>.</p>
</dd>
<dt><a href="#dt-current-merge-group">current merge group</a></dt>
<dd>
<p>The <b>current merge group</b> is a <a title="map" class=
"termref" href="#dt-map">map</a>. During evaluation of an <a href=
"#element-merge"><code>xsl:merge</code></a> instruction, as each
group of items with equal <a title="composite merge key value"
class="termref" href="#dt-composite-merge-key-value">composite
merge key values</a> is processed, the current merge group is set
to a map whose keys are the names of the various merge sources, and
whose associated values are the items from each merge source having
the relevant composite merge key value.</p>
</dd>
<dt><a href="#dt-current-merge-key">current merge key</a></dt>
<dd>
<p>The <b>current merge key</b> is a sequence of atomic values.
During evaluation of an <a href=
"#element-merge"><code>xsl:merge</code></a> instruction, as each
group of items with equal <a title="composite merge key value"
class="termref" href="#dt-composite-merge-key-value">composite
merge key values</a> is processed, the current merge key is set to
the composite merge key value that these items have in common.</p>
</dd>
<dt><a href="#dt-current-mode">current mode</a></dt>
<dd>
<p>At any point in the processing of a stylesheet, there is a
<b>current mode</b>. When the transformation is initiated, the
current mode is the <span><a title="initial mode" class="termref"
href="#dt-initial-mode">initial mode</a></span>, as described in
<a href="#initiating"><i>2.3 Initiating a Transformation</i></a>.
Whenever an <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction is evaluated, the current mode becomes the mode
selected by this instruction.</p>
</dd>
<dt><a href="#dt-current-output-uri">current output URI</a></dt>
<dd>
<p>The <b>current output URI</b> is the URI associated with the
final result tree that is currently being written.</p>
</dd>
<dt><a href="#dt-current-template-rule">current template
rule</a></dt>
<dd>
<p>At any point in the processing of a <a title="stylesheet" class=
"termref" href="#dt-stylesheet">stylesheet</a>, there may be a
<b>current template rule</b>. Whenever a <a title="template rule"
class="termref" href="#dt-template-rule">template rule</a> is
chosen as a result of evaluating <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a>, or
<a href="#element-next-match"><code>xsl:next-match</code></a>, the
template rule becomes the current template rule for the evaluation
of the rule's sequence constructor. When an <a href=
"#element-for-each"><code>xsl:for-each</code></a>, <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>,
<a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a>,
<span><a href="#element-iterate"><code>xsl:iterate</code></a>,
<a href="#element-stream"><code>xsl:stream</code></a>, <a href=
"#element-merge"><code>xsl:merge</code></a>, or <a href=
"#element-evaluate"><code>xsl:evaluate</code></a></span>
instruction is evaluated, or when evaluating a sequence constructor
contained in an <a href="#element-sort"><code>xsl:sort</code></a>
or <a href="#element-key"><code>xsl:key</code></a> element, or when
a <span><a title="non-contextual function call" class="termref"
href="#dt-non-contextual-function-call">non-contextual function
call</a> is made,</span> the current template rule becomes
<span><a title="absent" class="termref" href=
"#dt-absent">absent</a></span> for the evaluation of that
instruction or function.</p>
</dd>
<dt><a href="#dt-decimal-format">decimal format</a></dt>
<dd>
<p>All the <a href=
"#element-decimal-format"><code>xsl:decimal-format</code></a>
declarations in a <span>package</span> that share the same name are
grouped into a named <b>decimal format</b>; those that have no name
are grouped into a single unnamed decimal format.</p>
</dd>
<dt><a href="#dt-declaration">declaration</a></dt>
<dd>
<p>Top-level elements fall into two categories: declarations, and
user-defined data elements. Top-level elements whose names are in
the <a title="XSLT namespace" class="termref" href=
"#dt-xslt-namespace">XSLT namespace</a> are <b>declarations</b>.
Top-level elements in any other namespace are <a title=
"user-defined data element" class="termref" href=
"#dt-data-element">user-defined data elements</a> (see <a href=
"#user-defined-top-level"><i>3.8.3 User-defined Data
Elements</i></a>)</p>
</dd>
<dt><a href="#dt-declaration-order">declaration order</a></dt>
<dd>
<p>The <a title="declaration" class="termref" href=
"#dt-declaration">declarations</a> within a <a title=
"stylesheet level" class="termref" href=
"#dt-stylesheet-level">stylesheet level</a> have a total ordering
known as <b>declaration order</b>. The order of declarations within
a stylesheet level is the same as the document order that would
result if each stylesheet module were inserted textually in place
of the <a href="#element-include"><code>xsl:include</code></a>
element that references it.</p>
</dd>
<dt><a href="#dt-declared-streamable">declared-streamable</a></dt>
<dd>
<p>The above constructs (template rules belonging to a mode
declared with <code>streamable="yes"</code>; <a href=
"#element-stream"><code>xsl:stream</code></a>; and <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a>,
<a href="#element-function"><code>xsl:function</code></a>, <a href=
"#element-merge"><code>xsl:merge</code></a>, <a href=
"#element-accumulator"><code>xsl:accumulator</code></a>, <span>and
<a href=
"#element-global-context-item"><code>xsl:global-context-item</code></a></span>
elements specifying <code>streamable="yes"</code>) are said to be
<b>declared-streamable</b>.</p>
</dd>
<dt><a href="#dt-declaring-package">declaring package</a></dt>
<dd>
<p>The <b>declaring package</b> of a <a title="component" class=
"termref" href="#dt-component">component</a> is the package that
contains the declaration <span>(or, in the case of <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a> and
<a href="#element-key"><code>xsl:key</code></a>, multiple
declarations)</span> of the component.</p>
</dd>
<dt><a href="#dt-default-collation">default collation</a></dt>
<dd>
<p>In this specification the term <b>default collation</b> means
the collation that is used by XPath operators such as
<code>eq</code> and <code>lt</code> appearing in XPath expressions
within the stylesheet.</p>
</dd>
<dt><a href="#dt-default-priority">default priority</a></dt>
<dd>
<p>If no <code>priority</code> attribute is specified on an
<a href="#element-template"><code>xsl:template</code></a> element,
a <b>default priority</b> is computed, based on the syntax of the
<a title="pattern" class="termref" href="#dt-pattern">pattern</a>
supplied in the <code>match</code> attribute.</p>
</dd>
<dt><a href="#dt-defining-element">defining element</a></dt>
<dd>
<p>A string in the form of a lexical QName may occur as the value
of an attribute node in a stylesheet module, or within an XPath
<a title="expression" class="termref" href=
"#dt-expression">expression</a> contained in an attribute <span>or
text node within a stylesheet module</span>, or as the result of
evaluating an XPath expression contained in such a node. The
element containing this attribute <span>or text</span> node is
referred to as the <b>defining element</b> of the lexical
QName.</p>
</dd>
<dt><a href="#dt-deprecated">deprecated</a></dt>
<dd>
<p>Some constructs defined in this specification are described as
being <b>deprecated</b>. The use of this term implies that
stylesheet authors <span class="verb">should not</span> use the
construct, and that the construct may be removed in a later version
of this specification.</p>
</dd>
<dt><a href="#dt-dynamic-error">dynamic error</a></dt>
<dd>
<p>An error that is not detected until a source document is being
transformed is referred to as a <b>dynamic error</b>.</p>
</dd>
<dt><a href="#dt-dynamic-evaluation-feature">dynamic evaluation
feature</a></dt>
<dd>
<p>A processor that claims conformance with the <b>dynamic
evaluation feature</b> <span class="verb">must</span> evaluate the
<a href="#element-evaluate"><code>xsl:evaluate</code></a> function
as described in this specification.</p>
</dd>
<dt><a href="#dt-effective-value">effective value</a></dt>
<dd>
<p>The result of evaluating a value template is referred to as its
<b>effective value</b>.</p>
</dd>
<dt><a href="#dt-effective-version">effective version</a></dt>
<dd>
<p>The <b>effective version</b> of an element in a <span><a title=
"stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet module</a> or <a title=
"package manifest" class="termref" href=
"#dt-package-manifest">package manifest</a></span> is the decimal
value of the <code>[xsl:]version</code> attribute (see <a href=
"#standard-attributes"><i>3.5 Standard Attributes</i></a>) on that
element or on the innermost ancestor element that has such an
attribute, excluding the <code>version</code> attribute on an
<a href="#element-output"><code>xsl:output</code></a> element.</p>
</dd>
<dt><a href="#dt-embedded-stylesheet-module">embedded stylesheet
module</a></dt>
<dd>
<p>A stylesheet module whose outermost element is the child of a
non-XSLT element in a host document is referred to as an
<b>embedded stylesheet module</b>. See <a href="#embedded"><i>3.13
Embedded Stylesheet Modules</i></a>.</p>
</dd>
<dt><a href="#dt-eqname">EQName</a></dt>
<dd>
<p>An <b>EQName</b> is a string representing an <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a> where the string, after removing leading and trailing
whitespace, is in the form defined by the <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-EQName">EQName</a><sup><small>XP30</small></sup>
production in the XPath specification.</p>
</dd>
<dt><a href="#dt-expanded-qname">expanded QName</a></dt>
<dd>
<p>An <b>expanded QName</b> is a value in the value space of the
<code>xs:QName</code> datatype as defined in the XDM data model
(see <a href="#xpath-datamodel-30">[Data Model]</a>): that is, a
triple containing namespace prefix (optional), namespace URI
(optional), and local name. Two expanded QNames are equal if the
namespace URIs are the same (or both absent) and the local names
are the same. The prefix plays no part in the comparison, but is
used only if the expanded QName needs to be converted back to a
string.</p>
</dd>
<dt><a href="#dt-explicit-default">explicit default</a></dt>
<dd>
<p>An <b>explicit default</b> for a parameter is indicated by the
presence of either a <code>select</code> attribute or a non-empty
sequence constructor.</p>
</dd>
<dt><a href="#dt-explicitly-mandatory">explicitly
mandatory</a></dt>
<dd>
<p>A parameter is <b>explicitly mandatory</b> if it is a <a title=
"function parameter" class="termref" href=
"#dt-function-parameter">function parameter</a>, or if the
<code>required</code> attribute is present and has the value
<code>yes</code>.</p>
</dd>
<dt><a href="#dt-expression">expression</a></dt>
<dd>
<p>Within this specification, the term <b>XPath expression</b>, or
simply <b>expression</b>, means a string that matches the
production <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-Expr">Expr</a><sup><small>XP30</small></sup>
defined in <a href="#xpath-30">[XPath 3.0]</a>.</p>
</dd>
<dt><a href="#dt-extension-attribute">extension attribute</a></dt>
<dd>
<p>An element from the XSLT namespace may have any attribute not
from the XSLT namespace, provided that the <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a> (see <a href="#xpath-30">[XPath 3.0]</a>) of the
attribute has a non-null namespace URI. These attributes are
referred to as <b>extension attributes</b>.</p>
</dd>
<dt><a href="#dt-extension-function">extension function</a></dt>
<dd>
<p>An <b>extension function</b> is a function that is available for
use within an XPath <a title="expression" class="termref" href=
"#dt-expression">expression</a>, other than a <a title=
"core function" class="termref" href="#dt-core-function">core
function</a> defined in <a href="#xpath-functions-30">[Functions
and Operators]</a>, an additional function defined in this XSLT
specification, a constructor function named after an atomic type,
or a <a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet function</a> defined using an
<a href="#element-function"><code>xsl:function</code></a>
declaration.</p>
</dd>
<dt><a href="#dt-extension-instruction">extension
instruction</a></dt>
<dd>
<p>An <b>extension instruction</b> is an element within a <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> that is in a
namespace (not the <a title="XSLT namespace" class="termref" href=
"#dt-xslt-namespace">XSLT namespace</a>) designated as an extension
namespace.</p>
</dd>
<dt><a href="#dt-extension-namespace">extension namespace</a></dt>
<dd>
<p>The <a title="extension instruction" class="termref" href=
"#dt-extension-instruction">extension instruction</a> mechanism
allows namespaces to be designated as <b>extension namespaces</b>.
When a namespace is designated as an extension namespace and an
element with a name from that namespace occurs in a <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>, then the
element is treated as an <a title="instruction" class="termref"
href="#dt-instruction">instruction</a> rather than as a <a title=
"literal result element" class="termref" href=
"#dt-literal-result-element">literal result element</a>.</p>
</dd>
<dt><a href="#dt-final-output-state">final output state</a></dt>
<dd>
<p>The first of the two <a title="output state" class="termref"
href="#dt-output-state">output states</a> is called <b>final
output</b> state. This state applies when instructions are writing
to a <a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a>.</p>
</dd>
<dt><a href="#dt-final-result-tree">final result tree</a></dt>
<dd>
<p>A <b>final result tree</b> is a <a title="result tree" class=
"termref" href="#dt-result-tree">result tree</a> that forms part of
the final output of a transformation. Once created, the contents of
a final result tree are not accessible within the stylesheet
itself.</p>
</dd>
<dt><a href="#dt-focus">focus</a></dt>
<dd>
<p>When a <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> is evaluated,
the <a title="processor" class="termref" href=
"#dt-processor">processor</a> keeps track of which items are being
processed by means of a set of implicit variables referred to
collectively as the <b>focus</b>.</p>
</dd>
<dt><a href="#dt-focus-changing-construct">focus-changing
construct</a></dt>
<dd>
<p>A <b>focus-changing construct</b> is a <a title="construct"
class="termref" href="#dt-construct">construct</a> that has one or
more <a title="operand" class="termref" href=
"#dt-operand">operands</a> that are evaluated with a different
<a title="focus" class="termref" href="#dt-focus">focus</a> from
the parent construct.</p>
</dd>
<dt><a href="#dt-focus-setting-container">focus-setting
container</a></dt>
<dd>
<p>The <b>focus-setting container</b> of a construct <var>C</var>
is the innermost <a title="focus-changing construct" class=
"termref" href="#dt-focus-changing-construct">focus-changing
construct</a> <var>F</var> (if one exists) such that <var>C</var>
is directly or indirectly contained in a <a title=
"controlled operand" class="termref" href=
"#dt-controlled-operand">controlled operand</a> of <var>F</var>.
<span>If there is no such construct <var>F</var>, then the
focus-setting container is the containing <a title="declaration"
class="termref" href="#dt-declaration">declaration</a>, for example
an <a href="#element-function"><code>xsl:function</code></a> or
<a href="#element-template"><code>xsl:template</code></a>
element.</span></p>
</dd>
<dt><a href="#dt-forwards-compatible-behavior">forwards compatible
behavior</a></dt>
<dd>
<p>An element is processed with <b>forwards compatible behavior</b>
if its <a title="effective version" class="termref" href=
"#dt-effective-version">effective version</a> is greater than
<code>3.0</code>.</p>
</dd>
<dt><a href="#dt-free-ranging">free-ranging</a></dt>
<dd>
<p>A <b>free-ranging</b> construct is any <a title="construct"
class="termref" href="#dt-construct">construct</a> deemed
free-ranging by the rules in this section (<a href=
"#streamability"><i>19 Streamability</i></a>).</p>
</dd>
<dt><a href="#dt-function-conversion-rules">function conversion
rules</a></dt>
<dd>
<p>When used in this specification without further qualification,
the term <b>function conversion rules</b> means the function
conversion rules defined in <a href="#xpath-30">[XPath 3.0]</a>,
applied with XPath 1.0 compatibility mode set to false.</p>
</dd>
<dt><a href="#dt-function-parameter">function parameter</a></dt>
<dd>
<p>An <a href="#element-param"><code>xsl:param</code></a> element
may appear as a child of an <a href=
"#element-function"><code>xsl:function</code></a> element, before
any non-<a href="#element-param"><code>xsl:param</code></a>
children of that element. Such a parameter is known as a
<b>function parameter</b>. A function parameter is a <a title=
"local variable" class="termref" href="#dt-local-variable">local
variable</a> with the additional property that its value can be set
when the function is called, using a function call in an XPath
<a title="expression" class="termref" href=
"#dt-expression">expression</a>.</p>
</dd>
<dt><a href="#dt-fundamental-item-type">fundamental item
type</a></dt>
<dd>
<p>There are 28 <b>fundamental item types</b>: the 7 node kinds
defined in <a href="#xpath-datamodel-30">[Data Model]</a> (element,
attribute, etc.), the 19 primitive atomic types defined in <a href=
"#xmlschema-2">[XML Schema Part 2]</a>, plus the types
<code>function(*)</code> and <code>xs:untypedAtomic</code>. The
fundamental item types are disjoint, and every item is an instance
of exactly one of them.</p>
</dd>
<dt><a href="#dt-general-streamability-rules">general streamability
rules</a></dt>
<dd>
<p>Many <a title="construct" class="termref" href=
"#dt-construct">constructs</a> share the same streamability rules.
These rules, referred to as the <b>general streamability rules</b>,
are defined here.</p>
</dd>
<dt><a href="#dt-global-context-item">global context item</a></dt>
<dd>
<p><span>An item that acts as the <b>global context item</b> for
the transformation.</span> This item is accessible as the initial
value of the XPath <a title="expression" class="termref" href=
"#dt-expression">expressions</a> <code>.</code> (dot) and
<code>self::node()</code> <span>appearing within the
<code>select</code> expression or sequence constructor of a
<a title="global variable" class="termref" href=
"#dt-global-variable">global variable</a> declaration</span>
<span>within the <a title="top-level package" class="termref" href=
"#dt-top-level-package">top-level package</a></span>, as described
in <a href="#focus"><i>5.4.3.1 Maintaining Position: the
Focus</i></a>.</p>
</dd>
<dt><a href="#dt-global-variable">global variable</a></dt>
<dd>
<p>A top-level <a title="variable-binding element" class="termref"
href="#dt-variable-binding-element">variable-binding element</a>
declares a <b>global variable</b> that is visible everywhere
(except <span>within its own declaration, and</span> where it is
<a title="shadows" class="termref" href="#dt-shadows">shadowed</a>
by another binding).</p>
</dd>
<dt><a href="#dt-grounded">grounded</a></dt>
<dd>
<p><b>Grounded</b>: indicates that the value returned by the
construct does not contain nodes from the streamed input
document</p>
</dd>
<dt><a href="#dt-group">group</a></dt>
<dd>
<p>The <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction allocates the items in an input sequence into
<b>groups</b> of items (that is, it establishes a collection of
sequences) based either on common values of a grouping key, or on a
<a title="pattern" class="termref" href="#dt-pattern">pattern</a>
that the initial or final <span>item</span> in a group must
match.</p>
</dd>
<dt><a href="#dt-grouping-key">grouping key</a></dt>
<dd>
<p>If either of the <code>group-by</code> or
<code>group-adjacent</code> attributes is present, then for each
item in the <a title="population" class="termref" href=
"#dt-population">population</a> a set of <b>grouping keys</b> is
calculated, as follows: the expression contained in the
<code>group-by</code> or <code>group-adjacent</code> attribute is
evaluated; the result is atomized; and any
<code>xs:untypedAtomic</code> values are cast to
<code>xs:string</code>. <span>If <code>composite="yes"</code> is
specified, there is a single grouping key whose value is the
resulting sequence; otherwise, there is a set of grouping keys,
consisting of the distinct atomic values present in the result
sequence.</span></p>
</dd>
<dt><a href=
"#dt-guaranteed-streamable">guaranteed-streamable</a></dt>
<dd>
<p>A <b>guaranteed-streamable</b> construct is a <a title=
"construct" class="termref" href="#dt-construct">construct</a> that
is declared to be streamable and that follows the particular rules
for that construct to make streaming possible, as defined by the
analysis in this specification.</p>
</dd>
<dt><a href="#dt-higher-order-operand">higher-order
operand</a></dt>
<dd>
<p>Whether or not the <a title="operand" class="termref" href=
"#dt-operand">operand</a> is <b>higher-order</b>. For this purpose
an operand <var>O</var> of a construct <var>C</var> is higher-order
if the semantics of <var>C</var> potentially require <var>O</var>
to be evaluated more than once during a single evaluation of
<var>C</var>.</p>
</dd>
<dt><a href="#dt-homonymous">homonymous</a></dt>
<dd>
<p>Two <a title="component" class="termref" href=
"#dt-component">components</a> are said to be <b>homonymous</b> if
they have the same <a title="symbolic identifier" class="termref"
href="#dt-symbolic-identifier">symbolic identifier</a>.</p>
</dd>
<dt><a href="#dt-identical-types">identical (types)</a></dt>
<dd>
<p>Types S and T are considered <b>identical</b> for the purpose of
these rules if and only if <code>subtype(S, T)</code> and
<code>subtype(T, S)</code> both hold, where the subtype relation is
defined in <a href=
"http://www.w3.org/TR/xpath-30/#id-seqtype-subtype">Section 2.5.6.1
The judgement subtype(A, B)</a> <sup><small>XP30</small></sup>.</p>
</dd>
<dt><a href="#dt-implementation">implementation</a></dt>
<dd>
<p>A specific product that performs the functions of an <a title=
"processor" class="termref" href="#dt-processor">XSLT processor</a>
is referred to as an <b>implementation</b>.</p>
</dd>
<dt><a href=
"#dt-implementation-defined">implementation-defined</a></dt>
<dd>
<p>In this specification, the term <b>implementation-defined</b>
refers to a feature where the implementation is allowed some
flexibility, and where the choices made by the implementation
<span class="verb">must</span> be described in documentation that
accompanies any conformance claim.</p>
</dd>
<dt><a href=
"#dt-implementation-dependent">implementation-dependent</a></dt>
<dd>
<p>The term <b>implementation-dependent</b> refers to a feature
where the behavior <span class="verb">may</span> vary from one
implementation to another, and where the vendor is not expected to
provide a full specification of the behavior.</p>
</dd>
<dt><a href="#dt-implicit-default">implicit default</a></dt>
<dd>
<p>If a parameter that is not <a title="explicitly mandatory"
class="termref" href="#dt-explicitly-mandatory">explicitly
mandatory</a> has no <a title="explicit default" class="termref"
href="#dt-explicit-default">explicit default</a> value, then it has
an <b>implicit default</b> value, which is the empty sequence if
there is an <code>as</code> attribute, or a zero-length string if
not.</p>
</dd>
<dt><a href="#dt-implicitly-mandatory">implicitly
mandatory</a></dt>
<dd>
<p>If a parameter has an <a title="implicit default" class=
"termref" href="#dt-implicit-default">implicit default</a> value
which cannot be converted to the <a title="required type" class=
"termref" href="#dt-required-type">required type</a> (that is, if
it has an <code>as</code> attribute which does not permit the empty
sequence), then the parameter is <b>implicitly mandatory</b>.</p>
</dd>
<dt><a href="#dt-import-precedence">import precedence</a></dt>
<dd>
<p>A <a title="declaration" class="termref" href=
"#dt-declaration">declaration</a> <var>D</var> in the stylesheet is
defined to have lower <b>import precedence</b> than another
declaration <var>E</var> if the stylesheet level containing
<var>D</var> would be visited before the stylesheet level
containing <var>E</var> in a post-order traversal of the import
tree (that is, a traversal of the import tree in which a stylesheet
level is visited after its children). Two declarations within the
same stylesheet level have the same import precedence.</p>
</dd>
<dt><a href="#dt-import-tree">import tree</a></dt>
<dd>
<p>The <a title="stylesheet level" class="termref" href=
"#dt-stylesheet-level">stylesheet levels</a> making up a <a title=
"stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>
are treated as forming an <b>import tree</b>. In the import tree,
each stylesheet level has one child for each <a href=
"#element-import"><code>xsl:import</code></a> declaration that it
contains.</p>
</dd>
<dt><a href="#dt-in-scope-schema-component">in-scope schema
component</a></dt>
<dd>
<p>The <a title="schema component" class="termref" href=
"#dt-schema-component">schema components</a> that may be referenced
by name in a <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> are referred to as the <b>in-scope
schema components</b>. This set is the same throughout all the
modules of a stylesheet.</p>
</dd>
<dt><a href="#dt-initial-function">initial function</a></dt>
<dd>
<p>A stylesheet may be evaluated by calling a named <a title=
"stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet function</a>, referred to as
the <b>initial function</b>.</p>
</dd>
<dt><a href="#dt-initial-item">initial item</a></dt>
<dd>
<p>For each <a title="group" class="termref" href=
"#dt-group">group</a>, the item within the group that is first in
<a title="population order" class="termref" href=
"#dt-population-order">population order</a> is known as the
<b>initial item</b> of the group.</p>
</dd>
<dt><a href="#dt-initial-match-selection">initial match
selection</a></dt>
<dd>
<p>A stylesheet may be evaluated by supplying a value to be
processed, together with an <a title="initial mode" class="termref"
href="#dt-initial-mode">initial mode</a>. The value (which can be
any sequence of items) is referred to as the <b>initial match
selection</b>. The processing then corresponds to the effect of the
<a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction.</p>
</dd>
<dt><a href="#dt-initial-mode">initial mode</a></dt>
<dd>
<p>The initial mode, if specified, <span class="verb">must</span>
either be the <span>unnamed</span> mode, or a mode that is
explicitly named <span>either in an <a href=
"#element-mode"><code>xsl:mode</code></a> declaration, or</span> in
the <code>mode</code> attribute of an <a href=
"#element-template"><code>xsl:template</code></a> declaration
within the stylesheet. If an initial mode is supplied, then in
searching for the <a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a> that best matches the
<span>items in the <a title="initial match selection" class=
"termref" href="#dt-initial-match-selection">initial match
selection</a></span>, the processor considers only those rules that
apply to the initial mode. If no initial mode is supplied, then the
mode used is that named in the <code>default-mode</code> attribute
of the <span>(explicit or implicit) <a href=
"#element-package"><code>xsl:package</code></a> element of the
<a title="top-level package" class="termref" href=
"#dt-top-level-package">top-level package</a></span> or in the
absence of such an attribute, the <a title="unnamed mode" class=
"termref" href="#dt-unnamed-mode">unnamed mode</a>.</p>
</dd>
<dt><a href="#dt-initial-named-template">initial named
template</a></dt>
<dd>
<p>A stylesheet may be evaluated by selecting a named template to
be evaluated; this is referred to as the <b>initial named
template</b>.</p>
</dd>
<dt><a href="#dt-initial-sequence">initial sequence</a></dt>
<dd>
<p>The sequence to be sorted is referred to as the <b>initial
sequence</b>.</p>
</dd>
<dt><a href="#dt-initial-setting">initial setting</a></dt>
<dd>
<p>The <b>initial setting</b> of a component of the dynamic context
is used when evaluating <a title="global variable" class="termref"
href="#dt-global-variable">global variables</a> and <a title=
"stylesheet parameter" class="termref" href=
"#dt-stylesheet-parameter">stylesheet parameters</a>, when
evaluating the <code>use</code> and <code>match</code> attributes
of <a href="#element-key"><code>xsl:key</code></a>, when evaluating
the <code>initial-value</code> of <a href=
"#element-accumulator"><code>xsl:accumulator</code></a> and the
<code>select</code> expressions or contained sequence constructors
of <a href=
"#element-accumulator-rule"><code>xsl:accumulator-rule</code></a></p>
</dd>
<dt><a href="#dt-inspection">inspection</a></dt>
<dd>
<p>An operand usage of <b>inspection</b> indicates that the
construct accesses properties of a supplied node that are available
without reading its subtree.</p>
</dd>
<dt><a href="#dt-instruction">instruction</a></dt>
<dd>
<p>An <b>instruction</b> is either an <a title="XSLT instruction"
class="termref" href="#dt-xslt-instruction">XSLT instruction</a> or
an <a title="extension instruction" class="termref" href=
"#dt-extension-instruction">extension instruction</a>.</p>
</dd>
<dt><a href="#dt-invocation-construct">invocation
construct</a></dt>
<dd>
<p>The following <a title="construct" class="termref" href=
"#dt-construct">constructs</a> are classified as <b>invocation
constructs</b>: the instructions <a href=
"#element-call-template"><code>xsl:call-template</code></a>,
<a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a>, and
<a href="#element-next-match"><code>xsl:next-match</code></a>;
XPath function calls that bind to <a title="stylesheet function"
class="termref" href="#dt-stylesheet-function">stylesheet
functions</a>; XPath dynamic function calls; the functions <a href=
"#func-accumulator-before"><code>accumulator-before</code></a> and
<a href=
"#func-accumulator-after"><code>accumulator-after</code></a>; the
<code>[xsl:]use-attribute-sets</code> attribute. These all have the
characteristic that they can cause evaluation of constructs that
are not lexically contained within the calling construct.</p>
</dd>
<dt><a href="#dt-key">key</a></dt>
<dd>
<p>A <b>key</b> is defined as a set of <a href=
"#element-key"><code>xsl:key</code></a> declarations in the
<span>same <a title="package" class="termref" href=
"#dt-package">package</a></span> that share the same name.</p>
</dd>
<dt><a href="#dt-key-specifier">key specifier</a></dt>
<dd>
<p>The expression in the <code>use</code> attribute and the
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> within an
<a href="#element-key"><code>xsl:key</code></a> declaration are
referred to collectively as the <b>key specifier</b>. The key
specifier determines the values that may be used to find a node
using this <a title="key" class="termref" href=
"#dt-key">key</a>.</p>
</dd>
<dt><a href="#dt-lexical-qname">lexical QName</a></dt>
<dd>
<p>A <b>lexical QName</b> is a string representing an <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a> where the string, after removing leading and trailing
whitespace, is within the lexical space of the
<code>xs:QName</code> datatype as defined in XML Schema (see
<a href="#xmlschema-2">[XML Schema Part 2]</a>): that is, a local
name optionally preceded by a namespace prefix and a colon.</p>
</dd>
<dt><a href="#dt-library-package">library package</a></dt>
<dd>
<p>Every <a title="package" class="termref" href=
"#dt-package">package</a> within a <a title="stylesheet" class=
"termref" href="#dt-stylesheet">stylesheet</a>, other than the
<a title="top-level package" class="termref" href=
"#dt-top-level-package">top-level package</a>, is referred to as a
<b>library package</b>.</p>
</dd>
<dt><a href="#dt-literal-namespace-uri">literal namespace
URI</a></dt>
<dd>
<p>A namespace URI in the stylesheet tree that is being used to
specify a namespace URI in the <a title="result tree" class=
"termref" href="#dt-result-tree">result tree</a> is called a
<b>literal namespace URI</b>.</p>
</dd>
<dt><a href="#dt-literal-result-element">literal result
element</a></dt>
<dd>
<p>In a <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>, an element in
the <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> that does not belong to the
<a title="XSLT namespace" class="termref" href=
"#dt-xslt-namespace">XSLT namespace</a> and that is not an
<a title="extension instruction" class="termref" href=
"#dt-extension-instruction">extension instruction</a> (see <a href=
"#extension-instruction"><i>23.2 Extension Instructions</i></a>) is
classified as a <b>literal result element</b>.</p>
</dd>
<dt><a href="#dt-local-variable">local variable</a></dt>
<dd>
<p>As well as being allowed as a <a title="declaration" class=
"termref" href="#dt-declaration">declaration</a>, the <a href=
"#element-variable"><code>xsl:variable</code></a> element is also
allowed in <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructors</a>. Such a
variable is known as a <b>local variable</b>.</p>
</dd>
<dt><a href="#dt-map">map</a></dt>
<dd>
<p>A map consists of a set of entries. Each entry comprises a key
which is an arbitrary atomic value, and an arbitrary sequence
called the associated value.</p>
</dd>
<dt><a href="#dt-match-type">match type</a></dt>
<dd>
<p>The <b>match type</b> of a <a title="pattern" class="termref"
href="#dt-pattern">pattern</a> is the most specific <a title=
"U-type" class="termref" href="#dt-utype">U-type</a> that is known
to match all items that the pattern can match.</p>
</dd>
<dt><a href="#dt-merge-activation">merge activation</a></dt>
<dd>
<p>A <b>merge activation</b> is a single evaluation of the sequence
constructor contained within the <a href=
"#element-merge-action"><code>xsl:merge-action</code></a> element,
which occurs once for each distinct <a title=
"composite merge key value" class="termref" href=
"#dt-composite-merge-key-value">composite merge key value</a>.</p>
</dd>
<dt><a href="#dt-merge-input-sequence">merge input
sequence</a></dt>
<dd>
<p>A <b>merge input sequence</b> is an arbitrary <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dt-sequence">sequence</a><sup><small>DM30</small></sup>
of items which is already sorted according to the <a title=
"merge key specification" class="termref" href=
"#dt-merge-key-specification">merge key specification</a> for the
corresponding <a title="merge source definition" class="termref"
href="#dt-merge-source-definition">merge source definition</a>.</p>
</dd>
<dt><a href="#dt-merge-key-component">merge key component</a></dt>
<dd>
<p>A <b>merge key component</b> specifies one component of a
<a title="merge key specification" class="termref" href=
"#dt-merge-key-specification">merge key specification</a>; it
corresponds to a single <a href=
"#element-merge-key"><code>xsl:merge-key</code></a> element in the
stylesheet.</p>
</dd>
<dt><a href="#dt-merge-key-specification">merge key
specification</a></dt>
<dd>
<p>A <b>merge key specification</b> consists of one or more
adjacent <a href=
"#element-merge-key"><code>xsl:merge-key</code></a> elements which
together define how the <a title="merge input sequence" class=
"termref" href="#dt-merge-input-sequence">merge input sequences</a>
selected by a <a title="merge source definition" class="termref"
href="#dt-merge-source-definition">merge source definition</a> are
sorted. Each <a href=
"#element-merge-key"><code>xsl:merge-key</code></a> element defines
one <a title="merge key component" class="termref" href=
"#dt-merge-key-component">merge key component</a>.</p>
</dd>
<dt><a href="#dt-merge-key-value">merge key value</a></dt>
<dd>
<p>For each item in a <a title="merge input sequence" class=
"termref" href="#dt-merge-input-sequence">merge input sequence</a>,
a value is computed for each <a title="merge key component" class=
"termref" href="#dt-merge-key-component">merge key component</a>
within the <a title="merge key specification" class="termref" href=
"#dt-merge-key-specification">merge key specification</a>. The
value computed for an item by using the <var>N</var>th <a title=
"merge key component" class="termref" href=
"#dt-merge-key-component">merge key component</a> is referred to as
the <var>N</var>th <b>merge key value</b> of that item.</p>
</dd>
<dt><a href="#dt-merge-source-definition">merge source
definition</a></dt>
<dd>
<p>A <b>merge source definition</b> is the definition of one kind
of input to the merge operation. It selects zero or more <a title=
"merge input sequence" class="termref" href=
"#dt-merge-input-sequence">merge input sequences</a>, and it
includes a <a title="merge key specification" class="termref" href=
"#dt-merge-key-specification">merge key specification</a> to define
how the <span><a title="merge key value" class="termref" href=
"#dt-merge-key-value">merge key values</a></span> are computed for
each such merge input sequence.</p>
</dd>
<dt><a href="#dt-mode">mode</a></dt>
<dd>
<p><b>Modes</b> allow a node in a <a title="source tree" class=
"termref" href="#dt-source-tree">source tree</a> to be processed
multiple times, each time producing a different result. They also
allow different sets of <a title="template rule" class="termref"
href="#dt-template-rule">template rules</a> to be active when
processing different trees, for example when processing documents
loaded using the <a href="#func-document"><code>document</code></a>
function (see <a href="#func-document"><i>20.1 fn:document</i></a>)
or when processing <a title="temporary tree" class="termref" href=
"#dt-temporary-tree">temporary trees</a>.</p>
</dd>
<dt><a href="#dt-mode-definition">mode definition</a></dt>
<dd>
<p>All the <a href="#element-mode"><code>xsl:mode</code></a>
declarations in a <span><a title="package" class="termref" href=
"#dt-package">package</a></span> that share the same name are
grouped into a named <b>mode definition</b>; those that have no
name are grouped into a single unnamed mode definition.</p>
</dd>
<dt><a href="#dt-motionless">motionless</a></dt>
<dd>
<p>A <b>motionless</b> construct is any <a title="construct" class=
"termref" href="#dt-construct">construct</a> deemed motionless by
the rules in this section (<a href="#streamability"><i>19
Streamability</i></a>).</p>
</dd>
<dt><a href="#dt-named-template">named template</a></dt>
<dd>
<p>Templates can be invoked by name. An <a href=
"#element-template"><code>xsl:template</code></a> element with a
<code>name</code> attribute defines a <b>named template</b>.</p>
</dd>
<dt><a href="#dt-namespace-fixup">namespace fixup</a></dt>
<dd>
<p>The rules for the individual XSLT instructions that construct a
<a title="result tree" class="termref" href=
"#dt-result-tree">result tree</a> (see <a href=
"#creating-new-nodes"><i>11 Creating Nodes and Sequences</i></a>)
prescribe some of the situations in which namespace nodes are
written to the tree. These rules, however, are not sufficient to
ensure that the prescribed constraints are always satisfied. The
XSLT processor <span class="verb">must</span> therefore add
additional namespace nodes to satisfy these constraints. This
process is referred to as <b>namespace fixup</b>.</p>
</dd>
<dt><a href="#dt-navigation">navigation</a></dt>
<dd>
<p>An operand usage of <b>navigation</b> indicates that the
construct may navigate freely from the supplied node to other nodes
in the same tree, in a way that is not constrained by the
streamability rules.</p>
</dd>
<dt><a href="#dt-non-contextual-function-call">non-contextual
function call</a></dt>
<dd>
<p>The term <b>non-contextual function call</b> is used to refer to
function calls that do not pass the dynamic context to the called
function. This includes all calls on <a title="stylesheet function"
class="termref" href="#dt-stylesheet-function">stylesheet
functions</a> and all <a href=
"http://www.w3.org/TR/xpath-30/#dt-dynamic-function-invocation">dynamic
function invocations</a><sup><small>XP30</small></sup>, (that is
calls to function items as permitted by XPath 3.0). <span>It
excludes calls to some functions in the namespace
<code>http://www.w3.org/2005/xpath-functions</code></span>, in
particular those that explicitly depend on the context, such as the
<a href="#func-current-group"><code>current-group</code></a> and
<a href="#func-regex-group"><code>regex-group</code></a> functions.
It is <a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> whether,
and under what circumstances, calls to <a title=
"extension function" class="termref" href=
"#dt-extension-function">extension functions</a> are
non-contextual.</p>
</dd>
<dt><a href="#dt-non-positional-predicate">non-positional
predicate</a></dt>
<dd>
<p>A predicate is a <b>non-positional predicate</b> if it satisfies
both of the following conditions:</p>
</dd>
<dt><a href="#dt-non-schema-aware-processor">non-schema-aware
processor</a></dt>
<dd>
<p>A <b>non-schema-aware processor</b> is a processor that does not
claim conformance with the schema-aware conformance feature. Such a
processor <span class="verb">must</span> handle constructs
associated with schema-aware processing as described in this
section.</p>
</dd>
<dt><a href="#dt-operand">operand</a></dt>
<dd>
<p>In an actual instance of a construct, there will be a number of
<b>operands</b>.</p>
</dd>
<dt><a href="#dt-operand-role">operand role</a></dt>
<dd>
<p>For every construct kind, there is a set of zero or more
<b>operand roles</b>.</p>
</dd>
<dt><a href="#dt-operand-usage">operand usage</a></dt>
<dd>
<p>The <b>operand usage</b>. This gives information, in the case
where the operand value contains nodes, about how those nodes are
used. The operand usage takes one of the values <a title=
"absorption" class="termref" href="#dt-absorption">absorption</a>,
<a title="inspection" class="termref" href=
"#dt-inspection">inspection</a>, <a title="transmission" class=
"termref" href="#dt-transmission">transmission</a>, or <a title=
"navigation" class="termref" href=
"#dt-navigation">navigation</a>.</p>
</dd>
<dt><a href="#dt-first-appearance">order of first
appearance</a></dt>
<dd>
<p>There is a <span>total</span> ordering among <a title="group"
class="termref" href="#dt-group">groups</a> referred to as the
<b>order of first appearance</b>. A group <var>G</var> is defined
to precede a group <var>H</var> in order of first appearance if the
<a title="initial item" class="termref" href=
"#dt-initial-item">initial item</a> of <var>G</var> precedes the
initial item of <var>H</var> in population order. If two groups
<var>G</var> and <var>H</var> have the same initial item (because
the item is in both groups) then <var>G</var> precedes <var>H</var>
if the <a title="grouping key" class="termref" href=
"#dt-grouping-key">grouping key</a> of <var>G</var> precedes the
grouping key of <var>H</var> in the sequence that results from
evaluating the <code>group-by</code> expression of this initial
item.</p>
</dd>
<dt><a href="#dt-output-definition">output definition</a></dt>
<dd>
<p>All the <a href="#element-output"><code>xsl:output</code></a>
declarations <span>within a <a title="package" class="termref"
href="#dt-package">package</a></span> that share the same name are
grouped into a named <b>output definition</b>; those that have no
name are grouped into a single unnamed output definition.</p>
</dd>
<dt><a href="#dt-output-state">output state</a></dt>
<dd>
<p>Each instruction in the <a title="stylesheet" class="termref"
href="#dt-stylesheet">stylesheet</a> is evaluated in one of two
possible <b>output states</b>: <a title="final output state" class=
"termref" href="#dt-final-output-state">final output state</a> or
<a title="temporary output state" class="termref" href=
"#dt-temporary-output-state">temporary output state</a></p>
</dd>
<dt><a href="#dt-override">override</a></dt>
<dd>
<p>A component in a using package may <b>override</b> a component
in a used package, provided that the <a title="visibility" class=
"termref" href="#dt-visibility">visibility</a> of the component in
the used package is either <code>abstract</code> or
<code>public</code>. The overriding declaration is written as a
child of the <a href=
"#element-override"><code>xsl:override</code></a> element, which in
turn appears as a child of <a href=
"#element-use-package"><code>xsl:use-package</code></a>.</p>
</dd>
<dt><a href="#dt-package">package</a></dt>
<dd>
<p>An explicit <b>package</b> is represented by an <a href=
"#element-package"><code>xsl:package</code></a> element, which will
generally be the outermost element of an XML document. <span>When
the <a href="#element-package"><code>xsl:package</code></a> element
is not used explicitly, the entire stylesheet comprises a single
implicit package.</span></p>
</dd>
<dt><a href="#dt-package-manifest">package manifest</a></dt>
<dd>
<p>The content of the <a href=
"#element-package"><code>xsl:package</code></a> element is referred
to as the <b>package manifest</b></p>
</dd>
<dt><a href="#dt-parameter">parameter</a></dt>
<dd>
<p>The <a href="#element-param"><code>xsl:param</code></a> element
declares a <b>parameter</b>, which may be a <a title=
"stylesheet parameter" class="termref" href=
"#dt-stylesheet-parameter">stylesheet parameter</a>, a <a title=
"template parameter" class="termref" href=
"#dt-template-parameter">template parameter</a>, a <a title=
"function parameter" class="termref" href=
"#dt-function-parameter">function parameter</a><span>, or an
<a href="#element-iterate"><code>xsl:iterate</code></a>
parameter</span>. A parameter is a <a title="variable" class=
"termref" href="#dt-variable">variable</a> with the additional
property that its value can be set by the caller.</p>
</dd>
<dt><a href="#dt-pattern">pattern</a></dt>
<dd>
<p>A <b>pattern</b> specifies a set of conditions on an
<span>item</span>. An <span>item</span> that satisfies the
conditions matches the pattern; an <span>item</span> that does not
satisfy the conditions does not match the pattern.</p>
</dd>
<dt><a href="#dt-picture-string">picture string</a></dt>
<dd>
<p>The <b>picture string</b> is the string supplied as the second
argument of the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-number"><code>
format-number</code></a><sup><small>FO30</small></sup>
function.</p>
</dd>
<dt><a href="#dt-place-marker">place marker</a></dt>
<dd>
<p>The <a href="#element-number"><code>xsl:number</code></a>
instruction performs two tasks: firstly, determining a <b>place
marker</b> (this is a sequence of integers, to allow for hierarchic
numbering schemes such as <code>1.12.2</code> or
<code>3(c)ii</code>), and secondly, formatting the place marker for
output as a text node in the result sequence.</p>
</dd>
<dt><a href="#dt-population">population</a></dt>
<dd>
<p>The sequence of items to be grouped, which is referred to as the
<b>population</b>, is determined by evaluating the XPath <a title=
"expression" class="termref" href="#dt-expression">expression</a>
contained in the <code>select</code> attribute.</p>
</dd>
<dt><a href="#dt-population-order">population order</a></dt>
<dd>
<p>The population is treated as a sequence; the order of items in
this sequence is referred to as <b>population order</b></p>
</dd>
<dt><a href="#dt-post-descent-instruction">post-descent
instruction</a></dt>
<dd>
<p>A <a title="motionless" class="termref" href=
"#dt-motionless">motionless</a> <a title="instruction" class=
"termref" href="#dt-instruction">instruction</a> having no
<a title="consuming" class="termref" href=
"#dt-consuming">consuming</a> instruction as a following sibling is
referred to as a <b>post-descent instruction</b>.</p>
</dd>
<dt><a href="#dt-posture">posture</a></dt>
<dd>
<p>The <b>posture</b> of the expression. This captures information
about the way in which the streamed input document is positioned on
return from evaluating the construct. The posture takes one of the
values <a title="climbing" class="termref" href=
"#dt-climbing">climbing</a>, <a title="striding" class="termref"
href="#dt-striding">striding</a>, <a title="crawling" class=
"termref" href="#dt-crawling">crawling</a>, <a title="roaming"
class="termref" href="#dt-roaming">roaming</a>, or <a title=
"grounded" class="termref" href="#dt-grounded">grounded</a>.</p>
</dd>
<dt><a href="#dt-potentially-consuming">potentially
consuming</a></dt>
<dd>
<p>An <a title="operand" class="termref" href=
"#dt-operand">operand</a> is <b>potentially consuming</b> if either
or both of the following conditions applies:</p>
</dd>
<dt><a href="#dt-pre-descent-instruction">pre-descent
instruction</a></dt>
<dd>
<p>A <a title="motionless" class="termref" href=
"#dt-motionless">motionless</a> <a title="instruction" class=
"termref" href="#dt-instruction">instruction</a> having no
<a title="consuming" class="termref" href=
"#dt-consuming">consuming</a> instruction as a preceding sibling is
referred to as a <b>pre-descent instruction</b>.</p>
</dd>
<dt><a href="#dt-predicate-pattern">predicate pattern</a></dt>
<dd>
<p>A <b>predicate pattern</b> is written as <code>.</code> (dot)
followed by zero or more predicates in square brackets, and it
matches any item for which each of the predicates evaluates to
<code>true</code>.</p>
</dd>
<dt><a href="#dt-principal-stylesheet-module">principal stylesheet
module</a></dt>
<dd>
<p>Within a <a title="package" class="termref" href=
"#dt-package">package</a>, one <a title="stylesheet module" class=
"termref" href="#dt-stylesheet-module">stylesheet module</a>
functions as the <b>principal stylesheet module</b>. The complete
package is assembled by finding the stylesheet modules referenced
directly or indirectly from the principal stylesheet module using
<a href="#element-include"><code>xsl:include</code></a> and
<a href="#element-import"><code>xsl:import</code></a> elements: see
<a href="#include"><i>3.12.2 Stylesheet Inclusion</i></a> and
<a href="#import"><i>3.12.3 Stylesheet Import</i></a>.</p>
</dd>
<dt><a href="#dt-priority">priority</a></dt>
<dd>
<p>The <b>priority</b> of a template rule is specified by the
<code>priority</code> attribute on the <a href=
"#element-template"><code>xsl:template</code></a> declaration. If
no priority is specified explicitly for a template rule, its
<a title="default priority" class="termref" href=
"#dt-default-priority">default priority</a> is used, as defined in
<a href="#default-priority"><i>6.5 Default Priority for Template
Rules</i></a>.</p>
</dd>
<dt><a href="#dt-processing-order">processing order</a></dt>
<dd>
<p>There is another <span>total</span> ordering among groups
referred to as <b>processing order</b>. If group <var>R</var>
precedes group <var>S</var> in processing order, then in the result
sequence returned by the <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
instruction the items generated by processing group <var>R</var>
will precede the items generated by processing group
<var>S</var>.</p>
</dd>
<dt><a href="#dt-processor">processor</a></dt>
<dd>
<p>The software responsible for transforming source trees into
result trees using an XSLT stylesheet is referred to as the
<b>processor</b>. This is sometimes expanded to <em>XSLT
processor</em> to avoid any confusion with other processors, for
example an XML processor.</p>
</dd>
<dt><a href="#dt-raw-result">raw result</a></dt>
<dd>
<p>The result of invoking the selected component, after any
required conversion to the declared result type of the component,
is referred to as the <b>raw result</b>.</p>
</dd>
<dt><a href="#dt-reference-resolution">reference
resolution</a></dt>
<dd>
<p>The process of identifying the <a title="component" class=
"termref" href="#dt-component">component</a> to which a <a title=
"symbolic reference" class="termref" href=
"#dt-symbolic-reference">symbolic reference</a> applies (possibly
chosen from several <a title="homonymous" class="termref" href=
"#dt-homonymous">homonymous</a> alternatives) is called
<b>reference binding</b>.</p>
</dd>
<dt><a href="#dt-required-type">required type</a></dt>
<dd>
<p>The context within a <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> where an XPath <a title=
"expression" class="termref" href="#dt-expression">expression</a>
appears may specify the <b>required type</b> of the expression. The
required type indicates the type of the value that the expression
is expected to return.</p>
</dd>
<dt><a href="#dt-reserved-namespace">reserved namespace</a></dt>
<dd>
<p>The XSLT namespace, together with certain other namespaces
recognized by an XSLT processor, are classified as <b>reserved
namespaces</b> and <span class="verb">must</span> be used only as
specified in this and related specifications.</p>
</dd>
<dt><a href="#dt-result-tree">result tree</a></dt>
<dd>
<p>The term <b>result tree</b> is used to refer to any tree
constructed by <a title="instruction" class="termref" href=
"#dt-instruction">instructions</a> in the stylesheet. A result tree
is either a <a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a> or a <a title=
"temporary tree" class="termref" href=
"#dt-temporary-tree">temporary tree</a>.</p>
</dd>
<dt><a href="#dt-roaming">roaming</a></dt>
<dd>
<p><b>Roaming</b>: indicates that the nodes returned by an
expression could be anywhere in the tree, which inevitably means
that the construct cannot be evaluated using streaming.</p>
</dd>
<dt><a href="#dt-same-key">same key</a></dt>
<dd>
<p>Within a map, no two entries have the <b>same key</b>. <span>Two
atomic values <code>K1</code> and <code>K2</code> are the <b>same
key</b> for this purpose if the relation <code>deep-equal(K1, K2,
$UCC)</code> holds, where <code>$UCC</code> is the Unicode
codepoint collation.</span></p>
</dd>
<dt><a href="#dt-schema-component">schema component</a></dt>
<dd>
<p>Type definitions and element and attribute declarations are
referred to collectively as <b>schema components</b>.</p>
</dd>
<dt><a href="#dt-schema-instance-namespace">schema instance
namespace</a></dt>
<dd>
<p>The <b>schema instance namespace</b>
<code>http://www.w3.org/2001/XMLSchema-instance</code> is used as
defined in <a href="#xmlschema-1">[XML Schema Part 1]</a></p>
</dd>
<dt><a href="#dt-schema-namespace">schema namespace</a></dt>
<dd>
<p>The <b>schema namespace</b>
<code>http://www.w3.org/2001/XMLSchema</code> is used as defined in
<a href="#xmlschema-1">[XML Schema Part 1]</a></p>
</dd>
<dt><a href="#dt-schema-aware-xslt-processor">schema-aware XSLT
processor</a></dt>
<dd>
<p>A <b>schema-aware XSLT processor</b> is an XSLT processor that
implements the mandatory requirements of this specification
connected with the <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>
declaration, the <code>[xsl:]validation</code> and <code>[xsl:]type
attributes</code>, and the ability to handle input documents whose
nodes have type annotations other than <code>xs:untyped</code> and
<code>xs:untypedAtomic</code>. The mandatory requirements of this
specification are taken to include the mandatory requirements of
<span>XPath 3.0</span>, as described in <a href="#xpath-30">[XPath
3.0]</a>. A requirement is mandatory unless the specification
includes wording (such as the use of the words <span class=
"verb">should</span> or <span class="verb">may</span>) that clearly
indicates that it is optional.</p>
</dd>
<dt><a href="#dt-selection-pattern">selection pattern</a></dt>
<dd>
<p>A <b>selection pattern</b> uses a subset of the syntax for path
expressions, and is defined to match a node if the corresponding
path expression would select the node. Selection patterns may also
be formed by combining other patterns using union, intersection,
and difference operators.</p>
</dd>
<dt><a href="#dt-sequence-constructor">sequence
constructor</a></dt>
<dd>
<p>A <b>sequence constructor</b> is a sequence of zero or more
sibling nodes in the <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> that can be evaluated to return a
sequence of nodes, atomic values, <span>and function items</span>.
The way that the resulting sequence is used depends on the
containing instruction.</p>
</dd>
<dt><a href="#dt-serialization">serialization</a></dt>
<dd>
<p>A frequent requirement is to output a <a title=
"final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a> as an XML document
(or in other formats such as HTML). This process is referred to as
<b>serialization</b>.</p>
</dd>
<dt><a href="#dt-serialization-error">serialization error</a></dt>
<dd>
<p>If a transformation has successfully produced a <a title=
"final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a>, it is still possible
that errors may occur in serializing the result tree. For example,
it may be impossible to serialize the result tree using the
encoding selected by the user. Such an error is referred to as a
<b>serialization error</b>.</p>
</dd>
<dt><a href="#dt-serialization-feature">serialization
feature</a></dt>
<dd>
<p>A processor that claims conformance with the <b>serialization
feature</b> <span class="verb">must</span> support the conversion
of a <a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a> to a sequence of
octets following the rules defined in <a href=
"#serialization"><i>25 Serialization</i></a>.</p>
</dd>
<dt><a href="#dt-shadows">shadows</a></dt>
<dd>
<p>A binding <b>shadows</b> another binding if the binding occurs
at a point where the other binding is visible, and the bindings
have the same name.</p>
</dd>
<dt><a href="#dt-simplified-stylesheet-module">simplified
stylesheet</a></dt>
<dd>
<p>A <b>simplified stylesheet</b>, which is a subtree rooted at a
<a title="literal result element" class="termref" href=
"#dt-literal-result-element">literal result element</a>, as
described in <a href="#simplified-stylesheet"><i>3.9 Simplified
Stylesheet Modules</i></a>. This is first converted to a <a title=
"standard stylesheet module" class="termref" href=
"#dt-standard-stylesheet-module">standard stylesheet module</a> by
wrapping it in an xsl:stylesheet element using the transformation
described in <a href="#simplified-stylesheet"><i>3.9 Simplified
Stylesheet Modules</i></a>.</p>
</dd>
<dt><a href="#dt-singleton-focus">singleton focus</a></dt>
<dd>
<p>A <b>singleton focus</b> based on an item <var>J</var> has the
<span><a title="context item" class="termref" href=
"#dt-context-item">context item</a> (and therefore the <a title=
"context node" class="termref" href="#dt-context-node">context
node</a>, if <var>J</var> is a node)</span> set to <var>J</var>,
and the <a title="context position" class="termref" href=
"#dt-context-position">context position</a> and <a title=
"context size" class="termref" href="#dt-context-size">context
size</a> both set to 1 (one).</p>
</dd>
<dt><a href="#dt-snapshot">snapshot</a></dt>
<dd>
<p>A <b>snapshot</b> of a node <var>N</var> is a deep copy of
<var>N</var>, as produced by the <a href=
"#element-copy-of"><code>xsl:copy-of</code></a> instruction with
<code>copy-namespaces</code> set to <code>yes</code> and
<code>validation</code> set to <code>preserve</code>, with the
additional property that for every ancestor of <var>N</var>, the
copy also has a corresponding ancestor whose name, node-kind, and
base URI are the same as the corresponding ancestor of
<var>N</var>, and that has copies of the attributes and namespaces
of the corresponding ancestor of <var>N</var>. But the ancestor has
a type annotation of <code>xs:anyType</code>, has the properties
<code>nilled</code>, <code>is-id</code>, and <code>is-idref</code>
set to false, and has no children other than the child that is a
copy of <var>N</var> or one of its ancestors.</p>
</dd>
<dt><a href="#dt-sort-key-component">sort key component</a></dt>
<dd>
<p>Within a <a title="sort key specification" class="termref" href=
"#dt-sort-key-specification">sort key specification</a>, each
<a href="#element-sort"><code>xsl:sort</code></a> element defines
one <b>sort key component</b>.</p>
</dd>
<dt><a href="#dt-sort-key-specification">sort key
specification</a></dt>
<dd>
<p>A <b>sort key specification</b> is a sequence of one or more
adjacent <a href="#element-sort"><code>xsl:sort</code></a> elements
which together define rules for sorting the items in an input
sequence to form a sorted sequence.</p>
</dd>
<dt><a href="#dt-sort-key-value">sort key value</a></dt>
<dd>
<p>For each item in the <a title="initial sequence" class="termref"
href="#dt-initial-sequence">initial sequence</a>, a value is
computed for each <a title="sort key component" class="termref"
href="#dt-sort-key-component">sort key component</a> within the
<a title="sort key specification" class="termref" href=
"#dt-sort-key-specification">sort key specification</a>. The value
computed for an item by using the <var>N</var>th sort key component
is referred to as the <var>N</var>th <b>sort key value</b> of that
item.</p>
</dd>
<dt><a href="#dt-sorted-sequence">sorted sequence</a></dt>
<dd>
<p>The sequence after sorting as defined by the <a href=
"#element-sort"><code>xsl:sort</code></a> elements is referred to
as the <b>sorted sequence</b>.</p>
</dd>
<dt><a href="#dt-source-tree">source tree</a></dt>
<dd>
<p>The term <b>source tree</b> means any tree provided as input to
the transformation. This includes the document containing the
<span><a title="global context item" class="termref" href=
"#dt-global-context-item">global context item</a></span> if any,
<span>documents containing nodes present in the <a title=
"initial match selection" class="termref" href=
"#dt-initial-match-selection">initial match selection</a></span>,
documents containing nodes supplied as the values of <a title=
"stylesheet parameter" class="termref" href=
"#dt-stylesheet-parameter">stylesheet parameters</a>, documents
obtained from the results of functions such as <a href=
"#func-document"><code>document</code></a>, <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-collection"><code>collection</code></a><sup><small>FO30</small></sup>,
<span>documents read using the <a href=
"#element-stream"><code>xsl:stream</code></a> instruction,</span>
and documents returned by extension functions or extension
instructions. In the context of a particular XSLT instruction, the
term <b>source tree</b> means any tree provided as input to that
instruction; this may be a source tree of the transformation as a
whole, or it may be a <a title="temporary tree" class="termref"
href="#dt-temporary-tree">temporary tree</a> produced during the
course of the transformation.</p>
</dd>
<dt><a href="#dt-stable">stable</a></dt>
<dd>
<p>A <a title="sort key specification" class="termref" href=
"#dt-sort-key-specification">sort key specification</a> is said to
be <b>stable</b> if its first <a href=
"#element-sort"><code>xsl:sort</code></a> element has no
<code>stable</code> attribute, or has a <code>stable</code>
attribute whose <a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> is <code>yes</code>.</p>
</dd>
<dt><a href="#dt-standard-attributes">standard attributes</a></dt>
<dd>
<p>There are a number of <b>standard attributes</b> that may appear
on any <a title="XSLT element" class="termref" href=
"#dt-xslt-element">XSLT element</a>: specifically
<code>default-collation</code>, <code>default-mode</code>,
<code>default-validation</code>,
<code>exclude-result-prefixes</code>,
<span><code>expand-text</code>,</span>
<code>extension-element-prefixes</code>, <code>use-when</code>,
<code>version</code>, and <code>xpath-default-namespace</code>.</p>
</dd>
<dt><a href="#dt-standard-error-namespace">standard error
namespace</a></dt>
<dd>
<p>The <b>standard error namespace</b>
<code>http://www.w3.org/2005/xqt-errors</code> is used for error
codes defined in this specification and related specifications. It
is also used for the names of certain predefined variables
accessible within the scope of an <a href=
"#element-catch"><code>xsl:catch</code></a> element.</p>
</dd>
<dt><a href="#dt-standard-function-namespace">standard function
namespace</a></dt>
<dd>
<p>The <b>standard function namespace</b>
<code>http://www.w3.org/2005/xpath-functions</code> is used for
functions in the function library defined in <a href=
"#xpath-functions-30">[Functions and Operators]</a> and for
standard functions defined in this specification.</p>
</dd>
<dt><a href="#dt-standard-stylesheet-module">standard stylesheet
module</a></dt>
<dd>
<p>A <b>standard stylesheet module</b>, which is a subtree rooted
at an <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>
or <a href="#element-transform"><code>xsl:transform</code></a>
element.</p>
</dd>
<dt><a href="#dt-static-error">static error</a></dt>
<dd>
<p>An error that can be detected by examining a <a title=
"stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>
before execution starts (that is, before the source document and
values of stylesheet parameters are available) is referred to as a
<b>static error</b>.</p>
</dd>
<dt><a href="#dt-static-expression">static expression</a></dt>
<dd>
<p>A <b>static expression</b> is an XPath <a title="expression"
class="termref" href="#dt-expression">expression</a> whose value
must be computed during static analysis of the stylesheet.</p>
</dd>
<dt><a href="#dt-static-parameter">static parameter</a></dt>
<dd>
<p>A <a title="static variable" class="termref" href=
"#dt-static-variable">static variable</a> declared using an
<a href="#element-param"><code>xsl:param</code></a> element is
referred to as a <b>static parameter</b>.</p>
</dd>
<dt><a href="#dt-static-type">static type</a></dt>
<dd>
<p>The <b>static type</b> of a <a title="construct" class="termref"
href="#dt-construct">construct</a> is such that all values produced
by evaluating the construct will conform to that type. The static
type of a construct is a <a title="U-type" class="termref" href=
"#dt-utype">U-type</a>.</p>
</dd>
<dt><a href="#dt-static-variable">static variable</a></dt>
<dd>
<p>A <a title="top-level" class="termref" href=
"#dt-top-level">top-level</a> <a title="variable-binding element"
class="termref" href=
"#dt-variable-binding-element">variable-binding element</a> having
the attribute <code>static="yes"</code> declares a <b>static
variable</b>: that is, a <a title="global variable" class="termref"
href="#dt-global-variable">global variable</a> whose value is known
during static analysis of the stylesheet.</p>
</dd>
<dt><a href="#dt-streamable-mode">streamable mode</a></dt>
<dd>
<p>A <b>streamable mode</b> is a <a title="mode" class="termref"
href="#dt-mode">mode</a> that is declared in an <a href=
"#element-mode"><code>xsl:mode</code></a> declaration with the
attribute <code>streamable="yes"</code>.</p>
</dd>
<dt><a href="#dt-streamed-document">streamed document</a></dt>
<dd>
<p>A <b>streamed document</b> is a <a title="source tree" class=
"termref" href="#dt-source-tree">source tree</a> that is processed
using streaming, that is, without constructing a complete tree of
nodes in memory.</p>
</dd>
<dt><a href="#dt-streamed-document-node">streamed node</a></dt>
<dd>
<p>A <b>streamed node</b> is a node in a <a title=
"streamed document" class="termref" href=
"#dt-streamed-document">streamed document</a>.</p>
</dd>
<dt><a href="#dt-streaming">streaming</a></dt>
<dd>
<p>The term <b>streaming</b> refers to a manner of processing in
which documents (such as source and result documents) are not
represented by a complete tree of nodes occupying memory
proportional to document size, but instead are processed "on the
fly" as a sequence of events, similar in concept to the stream of
events notified by an XML parser to represent markup in lexical
XML.</p>
</dd>
<dt><a href="#dt-streaming-feature">streaming feature</a></dt>
<dd>
<p>A processor that claims conformance with the <b>streaming
feature</b> <span class="verb">must</span> use streamed processing
in cases where (a) streaming is requested (for example by using the
attribute <code>streamable="yes"</code> on <a href=
"#element-mode"><code>xsl:mode</code></a>, or the <a href=
"#element-stream"><code>xsl:stream</code></a> instruction) and (b)
the constructs in question are <a title="guaranteed-streamable"
class="termref" href=
"#dt-guaranteed-streamable">guaranteed-streamable</a> according to
this specification.</p>
</dd>
<dt><a href="#dt-striding">striding</a></dt>
<dd>
<p><b>Striding</b>: indicates that the result of a construct is a
sequence of nodes, in document order, that are peers in the sense
that none of them is an ancestor or descendant of any other.</p>
</dd>
<dt><a href="#dt-string-value">string value</a></dt>
<dd>
<p>The term <b>string value</b> is defined in <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dm-string-value">Section
5.13 string-value Accessor</a> <sup><small>DM30</small></sup>.
Every node has a <a title="string value" class="termref" href=
"#dt-string-value">string value</a>. For example, the <a title=
"string value" class="termref" href="#dt-string-value">string
value</a> of an element is the concatenation of the <a title=
"string value" class="termref" href="#dt-string-value">string
values</a> of all its descendant text nodes.</p>
</dd>
<dt><a href="#dt-stylesheet">stylesheet</a></dt>
<dd>
<p>A <b>stylesheet</b> consists of one or more packages:
specifically, one <a title="top-level package" class="termref"
href="#dt-top-level-package">top-level package</a> and zero or more
<a title="library package" class="termref" href=
"#dt-library-package">library packages</a>.</p>
</dd>
<dt><a href="#dt-stylesheet-function">stylesheet function</a></dt>
<dd>
<p>An <a href="#element-function"><code>xsl:function</code></a>
declaration declares the name, parameters, and implementation of a
<b>stylesheet function</b> that can be called from any XPath
<a title="expression" class="termref" href=
"#dt-expression">expression</a> within the <a title="stylesheet"
class="termref" href="#dt-stylesheet">stylesheet</a> <span>(subject
to visibility rules)</span>.</p>
</dd>
<dt><a href="#dt-stylesheet-level">stylesheet level</a></dt>
<dd>
<p>A <b>stylesheet level</b> is a collection of <a title=
"stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet modules</a> connected using
<a href="#element-include"><code>xsl:include</code></a>
declarations: specifically, two stylesheet modules <var>A</var> and
<var>B</var> are part of the same stylesheet level if one of them
includes the other by means of an <a href=
"#element-include"><code>xsl:include</code></a> declaration, or if
there is a third stylesheet module <var>C</var> that is in the same
stylesheet level as both <var>A</var> and <var>B</var>.</p>
</dd>
<dt><a href="#dt-stylesheet-module">stylesheet module</a></dt>
<dd>
<p>A <span><a title="package" class="termref" href=
"#dt-package">package</a></span> consists of one or more
<b>stylesheet modules</b>, each one forming all or part of an XML
document.</p>
</dd>
<dt><a href="#dt-stylesheet-parameter">stylesheet
parameter</a></dt>
<dd>
<p>A top-level <a href="#element-param"><code>xsl:param</code></a>
element declares a <b>stylesheet parameter</b>. A stylesheet
parameter is a global variable with the additional property that
its value can be supplied by the caller when a transformation is
initiated.</p>
</dd>
<dt><a href="#dt-supplied-value">supplied value</a></dt>
<dd>
<p>The value of the variable is computed using the <a title=
"expression" class="termref" href="#dt-expression">expression</a>
given in the <code>select</code> attribute or the contained
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a>, as described
in <a href="#variable-values"><i>9.3 Values of Variables and
Parameters</i></a>. This value is referred to as the <b>supplied
value</b> of the variable.</p>
</dd>
<dt><a href="#dt-sweep">sweep</a></dt>
<dd>
<p>Every construct has a <b>sweep</b>, which is a measure of the
extent to which the current position in the input stream moves
during the evaluation of the expression. The sweep is one of:
<a title="motionless" class="termref" href=
"#dt-motionless">motionless</a>, <a title="consuming" class=
"termref" href="#dt-consuming">consuming</a>, or <a title=
"free-ranging" class="termref" href=
"#dt-free-ranging">free-ranging</a> .</p>
</dd>
<dt><a href="#dt-symbolic-identifier">symbolic identifier</a></dt>
<dd>
<p>The <b>symbolic identifier</b> of a <a title="component" class=
"termref" href="#dt-component">component</a> is a composite name
used to identify the component uniquely within a package. The
symbolic identifier comprises the kind of component (stylesheet
function, named template, <span>accumulator</span>, attribute set,
global variable, or mode), the <a title="expanded QName" class=
"termref" href="#dt-expanded-qname">expanded QName</a> of the
component (namespace URI plus local name), and in the case of
stylesheet functions, the <a title="arity" class="termref" href=
"#dt-arity">arity</a>.</p>
</dd>
<dt><a href="#dt-symbolic-reference">symbolic reference</a></dt>
<dd>
<p>The <a title="declaration" class="termref" href=
"#dt-declaration">declaration</a> of a component includes
constructs that can be interpreted as references to other <a title=
"component" class="termref" href="#dt-component">components</a> by
means of their <a title="symbolic identifier" class="termref" href=
"#dt-symbolic-identifier">symbolic identifiers</a>. These
constructs are generically referred to as <b>symbolic
references</b>. Examples of constructs that give rise to symbolic
references are the <code>name</code> attribute of <a href=
"#element-call-template"><code>xsl:call-template</code></a>; the
<code>[xsl:]use-attribute-sets</code> attribute of <a href=
"#element-copy"><code>xsl:copy</code></a>, <a href=
"#element-element"><code>xsl:element</code></a>, and <a title=
"literal result element" class="termref" href=
"#dt-literal-result-element">literal result elements</a>; the
<code>mode</code> attribute of <a href=
"#element-template"><code>xsl:template</code></a> and <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>;
XPath variable references referring to global variables; and XPath
function calls referring to <a title="stylesheet function" class=
"termref" href="#dt-stylesheet-function">stylesheet functions</a>
<span>or <a title="accumulator function" class="termref" href=
"#dt-accumulator-function">accumulator functions</a></span>.</p>
</dd>
<dt><a href="#dt-tail-position">tail position</a></dt>
<dd>
<p>An <a title="instruction" class="termref" href=
"#dt-instruction">instruction</a> <var>J</var> is in a <b>tail
position</b> within a <a title="sequence constructor" class=
"termref" href="#dt-sequence-constructor">sequence constructor</a>
<var>SC</var> if it satisfies one of the following conditions:</p>
</dd>
<dt><a href="#dt-target-expression">target expression</a></dt>
<dd>
<p>The string that results from evaluating the expression in the
<code>xpath</code> attribute is referred to as the <b>target
expression</b>.</p>
</dd>
<dt><a href="#dt-target-namespace-uri">target namespace
URI</a></dt>
<dd>
<p>The namespace URI that is to be used in the <a title=
"result tree" class="termref" href="#dt-result-tree">result
tree</a> as a substitute for a <a title="literal namespace URI"
class="termref" href="#dt-literal-namespace-uri">literal namespace
URI</a> is called the <b>target namespace URI</b>.</p>
</dd>
<dt><a href="#dt-template">template</a></dt>
<dd>
<p>An <a href="#element-template"><code>xsl:template</code></a>
declaration defines a <b>template</b>, which contains a <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> <span>; this
sequence constructor is evaluated to determine the result of the
template</span>. A template can serve either as a <a title=
"template rule" class="termref" href="#dt-template-rule">template
rule</a>, invoked by matching <span>items</span> against a
<a title="pattern" class="termref" href="#dt-pattern">pattern</a>,
or as a <a title="named template" class="termref" href=
"#dt-named-template">named template</a>, invoked explicitly by
name. It is also possible for the same template to serve in both
capacities.</p>
</dd>
<dt><a href="#dt-template-parameter">template parameter</a></dt>
<dd>
<p>An <a href="#element-param"><code>xsl:param</code></a> element
may appear as a child of an <a href=
"#element-template"><code>xsl:template</code></a> element, before
any non-<a href="#element-param"><code>xsl:param</code></a>
children of that element. Such a parameter is known as a
<b>template parameter</b>. A template parameter is a <a title=
"local variable" class="termref" href="#dt-local-variable">local
variable</a> with the additional property that its value can be set
when the template is called, using any of the instructions <a href=
"#element-call-template"><code>xsl:call-template</code></a>,
<a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a>, or
<a href="#element-next-match"><code>xsl:next-match</code></a>.</p>
</dd>
<dt><a href="#dt-template-rule">template rule</a></dt>
<dd>
<p>A stylesheet contains a set of <b>template rules</b> (see
<a href="#rules"><i>6 Template Rules</i></a>). A template rule has
three parts: a <a title="pattern" class="termref" href=
"#dt-pattern">pattern</a> that is matched against nodes, a
(possibly empty) set of <a title="template parameter" class=
"termref" href="#dt-template-parameter">template parameters</a>,
and a <a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> that is
evaluated to produce a sequence of items.</p>
</dd>
<dt><a href="#dt-temporary-output-state">temporary output
state</a></dt>
<dd>
<p>The second of the two <a title="output state" class="termref"
href="#dt-output-state">output states</a> is called <b>temporary
output</b> state. This state applies when instructions are writing
to a <a title="temporary tree" class="termref" href=
"#dt-temporary-tree">temporary tree</a> or any other non-final
destination.</p>
</dd>
<dt><a href="#dt-temporary-tree">temporary tree</a></dt>
<dd>
<p>The term <b>temporary tree</b> means any tree that is neither a
<a title="source tree" class="termref" href=
"#dt-source-tree">source tree</a> nor a <a title=
"final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a>.</p>
</dd>
<dt><a href="#dt-text-value-template">text value template</a></dt>
<dd>
<p>In a text node that is designated as a <b>text value
template</b>, <a title="expression" class="termref" href=
"#dt-expression">expressions</a> can be used by surrounding each
expression with curly brackets (<code>{}</code>).</p>
</dd>
<dt><a href="#dt-top-level">top-level</a></dt>
<dd>
<p>An element occurring as a child of an <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a><span>,
<a href="#element-transform"><code>xsl:transform</code></a>, or
<a href="#element-override"><code>xsl:override</code></a></span>
element is called a <b>top-level</b> element.</p>
</dd>
<dt><a href="#dt-top-level-package">top-level package</a></dt>
<dd>
<p>For a given transformation, one <a title="package" class=
"termref" href="#dt-package">package</a> functions as the
<b>top-level package</b>. The complete <a title="stylesheet" class=
"termref" href="#dt-stylesheet">stylesheet</a> is assembled by
finding the packages referenced directly or indirectly from the
top-level package using <a href=
"#element-use-package"><code>xsl:use-package</code></a>
declarations: see <a href="#package-dependencies"><i>3.6.2
Dependencies between Packages</i></a>.</p>
</dd>
<dt><a href="#dt-transmission">transmission</a></dt>
<dd>
<p>An operand usage of <b>transmission</b> indicates that the
construct will (potentially) return a supplied node as part of its
result to the calling construct (that is, to its parent in the
construct tree).</p>
</dd>
<dt><a href="#dt-traversal">traversal</a></dt>
<dd>
<p>A <b>traversal</b> of a tree is a sequence of <a title=
"traversal-event" class="termref" href=
"#dt-traversal-event">traversal events</a>.</p>
</dd>
<dt><a href="#dt-traversal-event">traversal-event</a></dt>
<dd>
<p>a <b>traversal event</b> (shortened to <b>event</b> in this
section) is a pair comprising a phase (start or end) and a
node.</p>
</dd>
<dt><a href="#dt-tunnel-parameter">tunnel parameter</a></dt>
<dd>
<p>A parameter passed to a template may be defined as a <b>tunnel
parameter</b>. Tunnel parameters have the property that they are
automatically passed on by the called template to any further
templates that it calls, and so on recursively.</p>
</dd>
<dt><a href="#dt-type-annotation">type annotation</a></dt>
<dd>
<p>The term <b>type annotation</b> is used in this specification to
refer to the value returned by the <code>dm:type-name</code>
accessor of a node: see <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dm-type-name">Section
5.14 type-name Accessor</a> <sup><small>DM30</small></sup>.</p>
</dd>
<dt><a href="#dt-type-error">type error</a></dt>
<dd>
<p>Certain errors are classified as <b>type errors</b>. A type
error occurs when the value supplied as input to an operation is of
the wrong type for that operation, for example when an integer is
supplied to an operation that expects a node.</p>
</dd>
<dt><a href="#dt-type-determined-usage">type-determined
usage</a></dt>
<dd>
<p>The <b>type-determined usage</b> of an <a title="operand" class=
"termref" href="#dt-operand">operand</a> is as follows: if the
required type (ignoring occurrence indicator) is
<code>function(*)</code> or a subtype thereof, then <a title=
"inspection" class="termref" href="#dt-inspection">inspection</a>;
if the required type (ignoring occurrence indicator) is
<code>xs:anyAtomicType</code> or a subtype thereof, then <a title=
"absorption" class="termref" href="#dt-absorption">absorption</a>;
otherwise <a title="navigation" class="termref" href=
"#dt-navigation">navigation</a>.</p>
</dd>
<dt><a href="#dt-typed-value">typed value</a></dt>
<dd>
<p>The term <b>typed value</b> is defined in <a href=
"http://www.w3.org/TR/xpath-datamodel-30/#dm-typed-value">Section
5.15 typed-value Accessor</a> <sup><small>DM30</small></sup>. Every
node, <span>other than an element whose type annotation identifies
it as having</span> element-only content, has a <a title=
"string value" class="termref" href="#dt-string-value">typed
value</a>. For example, the <a title="typed value" class="termref"
href="#dt-typed-value">typed value</a> of an attribute of type
<code>xs:IDREFS</code> is a sequence of zero or more
<code>xs:IDREF</code> values.</p>
</dd>
<dt><a href="#dt-utype">U-type</a></dt>
<dd>
<p>A <b>U-type</b> is a set of <a title="fundamental item type"
class="termref" href="#dt-fundamental-item-type">fundamental item
types</a>.</p>
</dd>
<dt><a href="#dt-unnamed-mode">unnamed mode</a></dt>
<dd>
<p>The <b>unnamed mode</b> is the default mode used when no
<code>mode</code> attribute is specified on an <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction or <a href=
"#element-template"><code>xsl:template</code></a> declaration,
unless a different default mode has been specified using the
<span><code>[xsl:]default-mode</code> attribute of a containing
element</span>.</p>
</dd>
<dt><a href="#dt-uri-reference">URI Reference</a></dt>
<dd>
<p>Within this specification, the term <b>URI Reference</b>, unless
otherwise stated, refers to a string in the lexical space of the
<code>xs:anyURI</code> datatype as defined in <a href=
"#xmlschema-2">[XML Schema Part 2]</a>.</p>
</dd>
<dt><a href="#dt-use">use</a></dt>
<dd>
<p>If a package <var>Q</var> contains an <a href=
"#element-use-package"><code>xsl:use-package</code></a> element
that references package <var>P</var>, then package <var>Q</var> is
said to <b>use</b> package <var>P</var>. In this relationship
package <var>Q</var> is referred to as the <b>using</b> package,
package <var>P</var> as the <b>used</b> package.</p>
</dd>
<dt><a href="#dt-data-element">user-defined data element</a></dt>
<dd>
<p>In addition to <a title="declaration" class="termref" href=
"#dt-declaration">declarations</a>, the <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> element may
contain among its children any element not from the <a title=
"XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT
namespace</a>, provided that the <a title="expanded QName" class=
"termref" href="#dt-expanded-qname">expanded QName</a> of the
element has a non-null namespace URI. Such elements are referred to
as <b>user-defined data elements</b>.</p>
</dd>
<dt><a href="#dt-value">value</a></dt>
<dd>
<p>A variable is a binding between a name and a value. The
<b>value</b> of a variable is any sequence (of nodes, atomic
values, <span>and/or function items</span>), as defined in <a href=
"#xpath-datamodel-30">[Data Model]</a>.</p>
</dd>
<dt><a href="#dt-value-template">value template</a></dt>
<dd>
<p>Collectively, attribute value templates and text value templates
are referred to as <b>value templates</b>.</p>
</dd>
<dt><a href="#dt-variable">variable</a></dt>
<dd>
<p>The <a href="#element-variable"><code>xsl:variable</code></a>
element declares a <b>variable</b>, which may be a <a title=
"global variable" class="termref" href="#dt-global-variable">global
variable</a> or a <a title="local variable" class="termref" href=
"#dt-local-variable">local variable</a>.</p>
</dd>
<dt><a href="#dt-variable-binding-element">variable-binding
element</a></dt>
<dd>
<p>The two elements <a href=
"#element-variable"><code>xsl:variable</code></a> and <a href=
"#element-param"><code>xsl:param</code></a> are referred to as
<b>variable-binding elements</b></p>
</dd>
<dt><a href="#dt-visibility">visibility</a></dt>
<dd>
<p>The <b>visibility</b> of a <a title="component" class="termref"
href="#dt-component">component</a> is one of: <code>private</code>,
<code>public</code>, <code>abstract</code>, <code>final</code>, or
<code>hidden</code>.</p>
</dd>
<dt><a href="#dt-whitespace-text-node">whitespace text
node</a></dt>
<dd>
<p>A <b>whitespace text node</b> is a text node whose content
consists entirely of whitespace characters (that is, #x09, #x0A,
#x0D, or #x20).</p>
</dd>
<dt><a href="#xml-namespace">XML namespace</a></dt>
<dd>
<p>The <b>XML namespace</b>, defined in <a href=
"#xml-names">[Namespaces in XML]</a> as
<code>http://www.w3.org/XML/1998/namespace</code>, is used for
attributes such as <code>xml:lang</code>, <code>xml:space</code>,
and <code>xml:id</code>.</p>
</dd>
<dt><a href="#dt-xpath-compat-mode">XPath 1.0 compatibility
mode</a></dt>
<dd>
<p>The term <b>XPath 1.0 compatibility mode</b> is defined in
<a href="http://www.w3.org/TR/xpath-30/#static_context">Section
2.1.1 Static Context</a> <sup><small>XP30</small></sup>. This is a
setting in the static context of an XPath expression; it has two
values, <code>true</code> and <code>false</code>. When the value is
set to true, the semantics of function calls and certain other
operations are adjusted to give a greater degree of backwards
compatibility between <span>XPath 3.0</span> and XPath 1.0.</p>
</dd>
<dt><a href="#dt-xquery-invocation-feature">XQuery Invocation
Feature</a></dt>
<dd>
<p>A processor that claims conformance with the <b>XQuery
invocation feature</b> <span class="verb">must</span> allow XQuery
library modules to be referenced in <a href=
"#element-use-package"><code>xsl:use-package</code></a>, and must
allow the using package to reference the public functions and
variables declared in the referenced library module.</p>
</dd>
<dt><a href="#dt-xslt-10-behavior">XSLT 1.0 behavior</a></dt>
<dd>
<p>An element in the stylesheet is processed with <b>XSLT 1.0
behavior</b> if its <a title="effective version" class="termref"
href="#dt-effective-version">effective version</a> is equal to
1.0.</p>
</dd>
<dt><a href="#dt-1.0-compatibility-feature">XSLT 1.0 compatibility
feature</a></dt>
<dd>
<p>A processor that claims conformance with the <b>XSLT 1.0
compatibility feature</b> <span class="verb">must</span> support
the processing of stylesheet instructions and XPath expressions
with <a title="XSLT 1.0 behavior" class="termref" href=
"#dt-xslt-10-behavior">XSLT 1.0 behavior</a>, as defined in
<a href="#backwards"><i>3.10 Backwards Compatible
Processing</i></a>.</p>
</dd>
<dt><a href="#dt-xslt-20-behavior">XSLT 2.0 behavior</a></dt>
<dd>
<p>An element is processed with <b>XSLT 2.0 behavior</b> if its
<a title="effective version" class="termref" href=
"#dt-effective-version">effective version</a> is equal to 2.0.</p>
</dd>
<dt><a href="#dt-xslt-element">XSLT element</a></dt>
<dd>
<p>An <b>XSLT element</b> is an element in the <a title=
"XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT
namespace</a> whose syntax and semantics are defined in this
specification.</p>
</dd>
<dt><a href="#dt-xslt-instruction">XSLT instruction</a></dt>
<dd>
<p>An <b>XSLT instruction</b> is an <a title="XSLT element" class=
"termref" href="#dt-xslt-element">XSLT element</a> whose syntax
summary in this specification contains the annotation <code>&lt;!--
category: instruction --&gt;</code>.</p>
</dd>
<dt><a href="#dt-xslt-namespace">XSLT namespace</a></dt>
<dd>
<p>The <b>XSLT namespace</b> has the URI
<code>http://www.w3.org/1999/XSL/Transform</code>. It is used to
identify elements, attributes, and other names that have a special
meaning defined in this specification.</p>
</dd>
</dl>
</div>
<div class="div1">
<h2><a name="element-syntax-summary" id=
"element-syntax-summary"></a>D Element Syntax Summary
(Non-Normative)</h2>
<p>The syntax of each XSLT element is summarized below, together
with the context in the stylesheet where the element may appear.
Some elements (specifically, instructions) are allowed as a child
of any element that is allowed to contain a sequence constructor.
These elements are:</p>
<ul>
<li>Literal result elements</li>
<li>Extension instructions, if so defined</li>
</ul>
<p><b><a href="#element-accept">xsl:accept</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:accept">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:accept<br />
&#160;&#160;<b>component</b> = "template" | "function" |
"accumulator" | "attribute-set" | "variable" | "mode"<br />
&#160;&#160;<b>names</b> = <var>tokens</var><br />
&#160;&#160;<b>visibility</b> = "public" | "private" | "final" |
"abstract" | "hidden" | "absent"&#160;/&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-use-package">xsl:use-package</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-accumulator">xsl:accumulator</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:accumulator">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> declaration</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:accumulator<br />
&#160;&#160;<b>name</b> = <var>eqname</var><br />
&#160;&#160;applies-to? = <var>pattern</var><br />
&#160;&#160;<b>initial-value</b> = <var>expression</var><br />
&#160;&#160;as? = <var>sequence-type</var><br />
&#160;&#160;visibility? = "public" | "private" | "final" |
"abstract"<br />
&#160;&#160;streamable? = <var>boolean</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <a href=
"#element-accumulator-rule">xsl:accumulator-rule</a>+ --&gt;<br />
&lt;/xsl:accumulator&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-package">xsl:package</a></li>
<li><a href="#element-stylesheet">xsl:stylesheet</a></li>
<li><a href="#element-transform">xsl:transform</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href=
"#element-accumulator-rule">xsl:accumulator-rule</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:accumulator-rule">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Model:</i></p>
<p class="element-syntax-summary">
<code>&lt;xsl:accumulator-rule<br />
&#160;&#160;<b>match</b> = <var>pattern</var><br />
&#160;&#160;phase? = "start" | "end"<br />
&#160;&#160;select? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:accumulator-rule&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-accumulator">xsl:accumulator</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href=
"#element-analyze-string">xsl:analyze-string</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:analyze-string">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary">
<code>&lt;xsl:analyze-string<br />
&#160;&#160;<b>select</b> = <var>expression</var><br />
&#160;&#160;<b>regex</b> = { <var>string</var> }<br />
&#160;&#160;flags? = { <var>string</var> }&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-matching-substring">xsl:matching-substring</a>?, <a href=
"#element-non-matching-substring">xsl:non-matching-substring</a>?,
<a href="#element-fallback">xsl:fallback</a>*) --&gt;<br />
&lt;/xsl:analyze-string&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href=
"#element-apply-imports">xsl:apply-imports</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:apply-imports">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary">
<code>&lt;xsl:apply-imports&gt;<br />
&#160;&#160;&lt;!-- Content: <a href=
"#element-with-param">xsl:with-param</a>* --&gt;<br />
&lt;/xsl:apply-imports&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href=
"#element-apply-templates">xsl:apply-templates</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:apply-templates">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary">
<code>&lt;xsl:apply-templates<br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;mode? = <var>token</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href="#element-sort">xsl:sort</a>
| <a href="#element-with-param">xsl:with-param</a>)* --&gt;<br />
&lt;/xsl:apply-templates&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-assert">xsl:assert</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:assert">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:assert<br />
&#160;&#160;<b>test</b> = <var>expression</var><br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;error-code? = { <var>eqname</var> }&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:assert&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-attribute">xsl:attribute</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:attribute">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:attribute<br />
&#160;&#160;<b>name</b> = { <var>qname</var> }<br />
&#160;&#160;namespace? = { <var>uri</var> }<br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;separator? = { <var>string</var> }<br />
&#160;&#160;type? = <var>eqname</var><br />
&#160;&#160;validation? = "strict" | "lax" | "preserve" |
"strip"&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:attribute&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-attribute-set">xsl:attribute-set</a></li>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href=
"#element-attribute-set">xsl:attribute-set</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:attribute-set">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> declaration</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:attribute-set<br />
&#160;&#160;<b>name</b> = <var>eqname</var><br />
&#160;&#160;use-attribute-sets? = <var>eqnames</var><br />
&#160;&#160;visibility? = "public" | "private" | "final" |
"abstract"<br />
&#160;&#160;streamable? = <var>boolean</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <a href=
"#element-attribute">xsl:attribute</a>* --&gt;<br />
&lt;/xsl:attribute-set&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-package">xsl:package</a></li>
<li><a href="#element-stylesheet">xsl:stylesheet</a></li>
<li><a href="#element-transform">xsl:transform</a></li>
<li><a href="#element-override">xsl:override</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-break">xsl:break</a></b></p>
<table width="100%" summary="Syntax summary for element xsl:break">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:break<br />
&#160;&#160;select? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:break&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href=
"#element-call-template">xsl:call-template</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:call-template">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:call-template<br />
&#160;&#160;<b>name</b> = <var>eqname</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <a href=
"#element-with-param">xsl:with-param</a>* --&gt;<br />
&lt;/xsl:call-template&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-catch">xsl:catch</a></b></p>
<table width="100%" summary="Syntax summary for element xsl:catch">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:catch<br />
&#160;&#160;errors? = <var>tokens</var><br />
&#160;&#160;select? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:catch&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-try">xsl:try</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href=
"#element-character-map">xsl:character-map</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:character-map">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> declaration</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:character-map<br />
&#160;&#160;<b>name</b> = <var>eqname</var><br />
&#160;&#160;use-character-maps? =
<var>eqnames</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-output-character">xsl:output-character</a>*) --&gt;<br />
&lt;/xsl:character-map&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-package">xsl:package</a></li>
<li><a href="#element-stylesheet">xsl:stylesheet</a></li>
<li><a href="#element-transform">xsl:transform</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-choose">xsl:choose</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:choose">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:choose&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-when">xsl:when</a>+, <a href=
"#element-otherwise">xsl:otherwise</a>?) --&gt;<br />
&lt;/xsl:choose&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-comment">xsl:comment</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:comment">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:comment<br />
&#160;&#160;select? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:comment&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-context-item">xsl:context-item</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:context-item">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:context-item<br />
&#160;&#160;as? = <var>sequence-type</var><br />
&#160;&#160;use? = "required" | "optional" |
"prohibited"&#160;/&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-template">xsl:template</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-copy">xsl:copy</a></b></p>
<table width="100%" summary="Syntax summary for element xsl:copy">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:copy<br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;copy-namespaces? = <var>boolean</var><br />
&#160;&#160;inherit-namespaces? = <var>boolean</var><br />
&#160;&#160;use-attribute-sets? = <var>eqnames</var><br />
&#160;&#160;type? = <var>eqname</var><br />
&#160;&#160;validation? = "strict" | "lax" | "preserve" |
"strip"<br />
&#160;&#160;on-empty? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:copy&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-copy-of">xsl:copy-of</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:copy-of">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:copy-of<br />
&#160;&#160;<b>select</b> = <var>expression</var><br />
&#160;&#160;copy-namespaces? = <var>boolean</var><br />
&#160;&#160;type? = <var>eqname</var><br />
&#160;&#160;validation? = "strict" | "lax" | "preserve" |
"strip"&#160;/&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href=
"#element-decimal-format">xsl:decimal-format</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:decimal-format">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> declaration</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary">
<code>&lt;xsl:decimal-format<br />
&#160;&#160;name? = <var>eqname</var><br />
&#160;&#160;decimal-separator? = <var>char</var><br />
&#160;&#160;grouping-separator? = <var>char</var><br />
&#160;&#160;infinity? = <var>string</var><br />
&#160;&#160;minus-sign? = <var>char</var><br />
&#160;&#160;exponent-separator? = <var>char</var><br />
&#160;&#160;NaN? = <var>string</var><br />
&#160;&#160;percent? = <var>char</var><br />
&#160;&#160;per-mille? = <var>char</var><br />
&#160;&#160;zero-digit? = <var>char</var><br />
&#160;&#160;digit? = <var>char</var><br />
&#160;&#160;pattern-separator? =
<var>char</var>&#160;/&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-package">xsl:package</a></li>
<li><a href="#element-stylesheet">xsl:stylesheet</a></li>
<li><a href="#element-transform">xsl:transform</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-document">xsl:document</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:document">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:document<br />
&#160;&#160;validation? = "strict" | "lax" | "preserve" |
"strip"<br />
&#160;&#160;type? = <var>eqname</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:document&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-element">xsl:element</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:element">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:element<br />
&#160;&#160;<b>name</b> = { <var>qname</var> }<br />
&#160;&#160;namespace? = { <var>uri</var> }<br />
&#160;&#160;inherit-namespaces? = <var>boolean</var><br />
&#160;&#160;use-attribute-sets? = <var>eqnames</var><br />
&#160;&#160;type? = <var>eqname</var><br />
&#160;&#160;validation? = "strict" | "lax" | "preserve" |
"strip"<br />
&#160;&#160;on-empty? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:element&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-evaluate">xsl:evaluate</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:evaluate">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:evaluate<br />
&#160;&#160;<b>xpath</b> = <var>expression</var><br />
&#160;&#160;as? = <var>sequence-type</var><br />
&#160;&#160;base-uri? = { <var>uri</var> }<br />
&#160;&#160;with-params? = <var>expression</var><br />
&#160;&#160;context-item? = <var>expression</var><br />
&#160;&#160;namespace-context? = <var>expression</var><br />
&#160;&#160;schema-aware? = { <var>boolean</var> }&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-with-param">xsl:with-param</a> | <a href=
"#element-fallback">xsl:fallback</a>)* --&gt;<br />
&lt;/xsl:evaluate&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-expose">xsl:expose</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:expose">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:expose<br />
&#160;&#160;<b>component</b> = "template" | "function" |
"accumulator" | "attribute-set" | "variable" | "mode"<br />
&#160;&#160;<b>names</b> = <var>tokens</var><br />
&#160;&#160;<b>visibility</b> = "public" | "private" | "final" |
"abstract"&#160;/&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-package">xsl:package</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-fallback">xsl:fallback</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:fallback">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:fallback&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:fallback&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-analyze-string">xsl:analyze-string</a></li>
<li><a href="#element-evaluate">xsl:evaluate</a></li>
<li><a href="#element-fork">xsl:fork</a></li>
<li><a href="#element-merge">xsl:merge</a></li>
<li><a href="#element-next-match">xsl:next-match</a></li>
<li><a href="#element-try">xsl:try</a></li>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-for-each">xsl:for-each</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:for-each">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:for-each<br />
&#160;&#160;<b>select</b> = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-sort">xsl:sort</a>*, <var>sequence-constructor</var>)
--&gt;<br />
&lt;/xsl:for-each&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href=
"#element-for-each-group">xsl:for-each-group</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:for-each-group">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary">
<code>&lt;xsl:for-each-group<br />
&#160;&#160;<b>select</b> = <var>expression</var><br />
&#160;&#160;group-by? = <var>expression</var><br />
&#160;&#160;group-adjacent? = <var>expression</var><br />
&#160;&#160;group-starting-with? = <var>pattern</var><br />
&#160;&#160;group-ending-with? = <var>pattern</var><br />
&#160;&#160;composite? = <var>boolean</var><br />
&#160;&#160;collation? = { <var>uri</var> }&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-sort">xsl:sort</a>*, <var>sequence-constructor</var>)
--&gt;<br />
&lt;/xsl:for-each-group&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-fork">xsl:fork</a></b></p>
<table width="100%" summary="Syntax summary for element xsl:fork">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:fork&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-fallback">xsl:fallback</a>*, ((<a href=
"#element-sequence">xsl:sequence</a>, <a href=
"#element-fallback">xsl:fallback</a>*)* | (<a href=
"#element-for-each-group">xsl:for-each-group</a>, <a href=
"#element-fallback">xsl:fallback</a>*))) --&gt;<br />
&lt;/xsl:fork&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-function">xsl:function</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:function">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> declaration</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:function<br />
&#160;&#160;<b>name</b> = <var>eqname</var><br />
&#160;&#160;as? = <var>sequence-type</var><br />
&#160;&#160;visibility? = "public" | "private" | "final" |
"abstract"<br />
&#160;&#160;streamable? = <var>boolean</var><br />
&#160;&#160;override-extension-function? = <var>boolean</var><br />
&#160;&#160;<span class="grayed">[override]?</span> =
<var>boolean</var><br />
&#160;&#160;identity-sensitive? = <var>boolean</var><br />
&#160;&#160;cache? = "full" | "partial" | "no"&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-param">xsl:param</a>*, <var>sequence-constructor</var>)
--&gt;<br />
&lt;/xsl:function&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-package">xsl:package</a></li>
<li><a href="#element-stylesheet">xsl:stylesheet</a></li>
<li><a href="#element-transform">xsl:transform</a></li>
<li><a href="#element-override">xsl:override</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href=
"#element-global-context-item">xsl:global-context-item</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:global-context-item">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Model:</i></p>
<p class="element-syntax-summary">
<code>&lt;xsl:global-context-item<br />
&#160;&#160;as? = <var>sequence-type</var><br />
&#160;&#160;use? = "required" | "optional" | "prohibited"<br />
&#160;&#160;streamable? = <var>boolean</var>&#160;/&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-package">xsl:package</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-if">xsl:if</a></b></p>
<table width="100%" summary="Syntax summary for element xsl:if">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:if<br />
&#160;&#160;<b>test</b> = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:if&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-import">xsl:import</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:import">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> declaration</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:import<br />
&#160;&#160;<b>href</b> = <var>uri</var>&#160;/&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-package">xsl:package</a></li>
<li><a href="#element-stylesheet">xsl:stylesheet</a></li>
<li><a href="#element-transform">xsl:transform</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href=
"#element-import-schema">xsl:import-schema</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:import-schema">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> declaration</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:import-schema<br />
&#160;&#160;namespace? = <var>uri</var><br />
&#160;&#160;schema-location? = <var>uri</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: xs:schema? --&gt;<br />
&lt;/xsl:import-schema&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-package">xsl:package</a></li>
<li><a href="#element-stylesheet">xsl:stylesheet</a></li>
<li><a href="#element-transform">xsl:transform</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-include">xsl:include</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:include">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> declaration</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:include<br />
&#160;&#160;<b>href</b> = <var>uri</var>&#160;/&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-package">xsl:package</a></li>
<li><a href="#element-stylesheet">xsl:stylesheet</a></li>
<li><a href="#element-transform">xsl:transform</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-iterate">xsl:iterate</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:iterate">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:iterate<br />
&#160;&#160;<b>select</b> = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-param">xsl:param</a>*, <a href=
"#element-on-completion">xsl:on-completion</a>?,
<var>sequence-constructor</var>) --&gt;<br />
&lt;/xsl:iterate&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-key">xsl:key</a></b></p>
<table width="100%" summary="Syntax summary for element xsl:key">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> declaration</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:key<br />
&#160;&#160;<b>name</b> = <var>eqname</var><br />
&#160;&#160;<b>match</b> = <var>pattern</var><br />
&#160;&#160;use? = <var>expression</var><br />
&#160;&#160;composite? = <var>boolean</var><br />
&#160;&#160;collation? = <var>uri</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:key&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-package">xsl:package</a></li>
<li><a href="#element-stylesheet">xsl:stylesheet</a></li>
<li><a href="#element-transform">xsl:transform</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-map">xsl:map</a></b></p>
<table width="100%" summary="Syntax summary for element xsl:map">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:map&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:map&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-map-entry">xsl:map-entry</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:map-entry">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:map-entry<br />
&#160;&#160;<b>key</b> = <var>expression</var><br />
&#160;&#160;select? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:map-entry&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href=
"#element-matching-substring">xsl:matching-substring</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:matching-substring">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Model:</i></p>
<p class="element-syntax-summary">
<code>&lt;xsl:matching-substring&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:matching-substring&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-analyze-string">xsl:analyze-string</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-merge">xsl:merge</a></b></p>
<table width="100%" summary="Syntax summary for element xsl:merge">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:merge&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-merge-source">xsl:merge-source</a>+, <a href=
"#element-merge-action">xsl:merge-action</a>, <a href=
"#element-fallback">xsl:fallback</a>*) --&gt;<br />
&lt;/xsl:merge&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-merge-action">xsl:merge-action</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:merge-action">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Model:</i></p>
<p class="element-syntax-summary">
<code>&lt;xsl:merge-action&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:merge-action&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-merge">xsl:merge</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-merge-key">xsl:merge-key</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:merge-key">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:merge-key<br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;lang? = { <var>language</var> }<br />
&#160;&#160;order? = { "ascending" | "descending" }<br />
&#160;&#160;collation? = { <var>uri</var> }<br />
&#160;&#160;case-order? = { "upper-first" | "lower-first" }<br />
&#160;&#160;data-type? = { "text" | "number" | <var>eqname</var>
}&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:merge-key&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-merge-source">xsl:merge-source</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-merge-source">xsl:merge-source</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:merge-source">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:merge-source<br />
&#160;&#160;name? = <var>ncname</var><br />
&#160;&#160;for-each-item? = <var>expression</var><br />
&#160;&#160;for-each-stream? = <var>expression</var><br />
&#160;&#160;<b>select</b> = <var>expression</var><br />
&#160;&#160;streamable? = <var>boolean</var><br />
&#160;&#160;sort-before-merge? = <var>boolean</var><br />
&#160;&#160;validation? = "strict" | "lax" | "preserve" |
"strip"<br />
&#160;&#160;type? = <var>eqname</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <a href=
"#element-merge-key">xsl:merge-key</a>+ --&gt;<br />
&lt;/xsl:merge-source&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-merge">xsl:merge</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-message">xsl:message</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:message">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:message<br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;terminate? = { <var>boolean</var> }<br />
&#160;&#160;error-code? = { <var>eqname</var> }&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:message&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-mode">xsl:mode</a></b></p>
<table width="100%" summary="Syntax summary for element xsl:mode">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> declaration</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:mode<br />
&#160;&#160;name? = <var>eqname</var><br />
&#160;&#160;streamable? = <var>boolean</var><br />
&#160;&#160;on-no-match? = "deep-copy" | "shallow-copy" |
"deep-skip" | "shallow-skip" | "text-only-copy" | "fail"<br />
&#160;&#160;on-multiple-match? = "use-last" | "fail"<br />
&#160;&#160;warning-on-no-match? = <var>boolean</var><br />
&#160;&#160;warning-on-multiple-match? = <var>boolean</var><br />
&#160;&#160;typed? = <var>boolean</var> | "strict" | "lax" |
"unspecified"<br />
&#160;&#160;visibility? = "public" | "private" |
"final"&#160;/&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-package">xsl:package</a></li>
<li><a href="#element-stylesheet">xsl:stylesheet</a></li>
<li><a href="#element-transform">xsl:transform</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-namespace">xsl:namespace</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:namespace">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:namespace<br />
&#160;&#160;<b>name</b> = { <var>ncname</var> }<br />
&#160;&#160;select? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:namespace&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href=
"#element-namespace-alias">xsl:namespace-alias</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:namespace-alias">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> declaration</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary">
<code>&lt;xsl:namespace-alias<br />
&#160;&#160;<b>stylesheet-prefix</b> = <var>prefix</var> |
"#default"<br />
&#160;&#160;<b>result-prefix</b> = <var>prefix</var> |
"#default"&#160;/&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-package">xsl:package</a></li>
<li><a href="#element-stylesheet">xsl:stylesheet</a></li>
<li><a href="#element-transform">xsl:transform</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href=
"#element-next-iteration">xsl:next-iteration</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:next-iteration">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary">
<code>&lt;xsl:next-iteration&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-with-param">xsl:with-param</a>*) --&gt;<br />
&lt;/xsl:next-iteration&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-next-match">xsl:next-match</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:next-match">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary">
<code>&lt;xsl:next-match&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-with-param">xsl:with-param</a> | <a href=
"#element-fallback">xsl:fallback</a>)* --&gt;<br />
&lt;/xsl:next-match&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href=
"#element-non-matching-substring">xsl:non-matching-substring</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:non-matching-substring">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Model:</i></p>
<p class="element-syntax-summary">
<code>&lt;xsl:non-matching-substring&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:non-matching-substring&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-analyze-string">xsl:analyze-string</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-number">xsl:number</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:number">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:number<br />
&#160;&#160;value? = <var>expression</var><br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;level? = "single" | "multiple" | "any"<br />
&#160;&#160;count? = <var>pattern</var><br />
&#160;&#160;from? = <var>pattern</var><br />
&#160;&#160;format? = { <var>string</var> }<br />
&#160;&#160;lang? = { <var>language</var> }<br />
&#160;&#160;letter-value? = { "alphabetic" | "traditional" }<br />
&#160;&#160;ordinal? = { <var>string</var> }<br />
&#160;&#160;start-at? = { <var>integer</var> }<br />
&#160;&#160;grouping-separator? = { <var>char</var> }<br />
&#160;&#160;grouping-size? = { <var>integer</var>
}&#160;/&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href=
"#element-on-completion">xsl:on-completion</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:on-completion">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:on-completion<br />
&#160;&#160;select? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:on-completion&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-iterate">xsl:iterate</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-otherwise">xsl:otherwise</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:otherwise">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:otherwise&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:otherwise&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-choose">xsl:choose</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-output">xsl:output</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:output">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> declaration</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:output<br />
&#160;&#160;name? = <var>eqname</var><br />
&#160;&#160;method? = "xml" | "html" | "xhtml" | "text" |
<var>eqname</var><br />
&#160;&#160;byte-order-mark? = <var>boolean</var><br />
&#160;&#160;cdata-section-elements? = <var>eqnames</var><br />
&#160;&#160;doctype-public? = <var>string</var><br />
&#160;&#160;doctype-system? = <var>string</var><br />
&#160;&#160;encoding? = <var>string</var><br />
&#160;&#160;escape-uri-attributes? = <var>boolean</var><br />
&#160;&#160;html-version? = <var>decimal</var><br />
&#160;&#160;include-content-type? = <var>boolean</var><br />
&#160;&#160;indent? = <var>boolean</var><br />
&#160;&#160;item-separator? = <var>string</var><br />
&#160;&#160;media-type? = <var>string</var><br />
&#160;&#160;normalization-form? = "NFC" | "NFD" | "NFKC" | "NFKD" |
"fully-normalized" | "none" | <var>nmtoken</var><br />
&#160;&#160;omit-xml-declaration? = <var>boolean</var><br />
&#160;&#160;parameter-document? = <var>uri</var><br />
&#160;&#160;standalone? = <var>boolean</var> | "omit"<br />
&#160;&#160;suppress-indentation? = <var>eqnames</var><br />
&#160;&#160;undeclare-prefixes? = <var>boolean</var><br />
&#160;&#160;use-character-maps? = <var>eqnames</var><br />
&#160;&#160;version? = <var>nmtoken</var>&#160;/&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-package">xsl:package</a></li>
<li><a href="#element-stylesheet">xsl:stylesheet</a></li>
<li><a href="#element-transform">xsl:transform</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href=
"#element-output-character">xsl:output-character</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:output-character">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Model:</i></p>
<p class="element-syntax-summary">
<code>&lt;xsl:output-character<br />
&#160;&#160;<b>character</b> = <var>char</var><br />
&#160;&#160;<b>string</b> = <var>string</var>&#160;/&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-character-map">xsl:character-map</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-override">xsl:override</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:override">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:override&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-template">xsl:template</a> | <a href=
"#element-function">xsl:function</a> | <a href=
"#element-accumulator">xsl:accumulator</a> | <a href=
"#element-variable">xsl:variable</a> | <a href=
"#element-param">xsl:param</a> | <a href=
"#element-attribute-set">xsl:attribute-set</a>)* --&gt;<br />
&lt;/xsl:override&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-use-package">xsl:use-package</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-package">xsl:package</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:package">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:package<br />
&#160;&#160;name? = <var>uri</var><br />
&#160;&#160;package-version? = <var>string</var><br />
&#160;&#160;<b>version</b> = <var>decimal</var><br />
&#160;&#160;input-type-annotations? = "preserve" | "strip" |
"unspecified"<br />
&#160;&#160;declared-modes? = <var>boolean</var><br />
&#160;&#160;default-mode? = <var>eqname</var> | "#unnamed"<br />
&#160;&#160;default-validation? = "preserve" | "strip"<br />
&#160;&#160;default-collation? = <var>uris</var><br />
&#160;&#160;extension-element-prefixes? = <var>prefixes</var><br />
&#160;&#160;exclude-result-prefixes? = <var>prefixes</var><br />
&#160;&#160;expand-text? = <var>boolean</var><br />
&#160;&#160;use-when? = <var>expression</var><br />
&#160;&#160;xpath-default-namespace? =
<var>uri</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: ((<a href=
"#element-use-package">xsl:use-package</a> | <a href=
"#element-expose">xsl:expose</a> | <a href=
"#element-global-context-item">xsl:global-context-item</a> |
<var>declarations</var>)*) --&gt;<br />
&lt;/xsl:package&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>None</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-param">xsl:param</a></b></p>
<table width="100%" summary="Syntax summary for element xsl:param">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> declaration</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:param<br />
&#160;&#160;<b>name</b> = <var>eqname</var><br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;as? = <var>sequence-type</var><br />
&#160;&#160;required? = <var>boolean</var><br />
&#160;&#160;tunnel? = <var>boolean</var><br />
&#160;&#160;static? = <var>boolean</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:param&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-package">xsl:package</a></li>
<li><a href="#element-stylesheet">xsl:stylesheet</a></li>
<li><a href="#element-transform">xsl:transform</a></li>
<li><a href="#element-override">xsl:override</a></li>
<li><a href="#element-function">xsl:function</a></li>
<li><a href="#element-template">xsl:template</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-perform-sort">xsl:perform-sort</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:perform-sort">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:perform-sort<br />
&#160;&#160;select? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-sort">xsl:sort</a>+, <var>sequence-constructor</var>)
--&gt;<br />
&lt;/xsl:perform-sort&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href=
"#element-preserve-space">xsl:preserve-space</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:preserve-space">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> declaration</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary">
<code>&lt;xsl:preserve-space<br />
&#160;&#160;<b>elements</b> =
<var>tokens</var>&#160;/&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-package">xsl:package</a></li>
<li><a href="#element-stylesheet">xsl:stylesheet</a></li>
<li><a href="#element-transform">xsl:transform</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href=
"#element-processing-instruction">xsl:processing-instruction</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:processing-instruction">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary">
<code>&lt;xsl:processing-instruction<br />
&#160;&#160;<b>name</b> = { <var>ncname</var> }<br />
&#160;&#160;select? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:processing-instruction&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href=
"#element-result-document">xsl:result-document</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:result-document">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary">
<code>&lt;xsl:result-document<br />
&#160;&#160;format? = { <var>eqname</var> }<br />
&#160;&#160;href? = { <var>uri</var> }<br />
&#160;&#160;validation? = "strict" | "lax" | "preserve" |
"strip"<br />
&#160;&#160;type? = <var>eqname</var><br />
&#160;&#160;method? = { "xml" | "html" | "xhtml" | "text" |
<var>eqname</var> }<br />
&#160;&#160;byte-order-mark? = { <var>boolean</var> }<br />
&#160;&#160;cdata-section-elements? = { <var>eqnames</var> }<br />
&#160;&#160;doctype-public? = { <var>string</var> }<br />
&#160;&#160;doctype-system? = { <var>string</var> }<br />
&#160;&#160;encoding? = { <var>string</var> }<br />
&#160;&#160;escape-uri-attributes? = { <var>boolean</var> }<br />
&#160;&#160;html-version? = { <var>decimal</var> }<br />
&#160;&#160;include-content-type? = { <var>boolean</var> }<br />
&#160;&#160;indent? = { <var>boolean</var> }<br />
&#160;&#160;item-separator? = { <var>string</var> }<br />
&#160;&#160;media-type? = { <var>string</var> }<br />
&#160;&#160;normalization-form? = { "NFC" | "NFD" | "NFKC" | "NFKD"
| "fully-normalized" | "none" | <var>nmtoken</var> }<br />
&#160;&#160;omit-xml-declaration? = { <var>boolean</var> }<br />
&#160;&#160;parameter-document? = { <var>uri</var> }<br />
&#160;&#160;standalone? = { <var>boolean</var> | "omit" }<br />
&#160;&#160;suppress-indentation? = { <var>eqnames</var> }<br />
&#160;&#160;undeclare-prefixes? = { <var>boolean</var> }<br />
&#160;&#160;use-character-maps? = <var>eqnames</var><br />
&#160;&#160;output-version? = { <var>nmtoken</var>
}&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:result-document&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-sequence">xsl:sequence</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:sequence">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:sequence<br />
&#160;&#160;select? = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:sequence&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-sort">xsl:sort</a></b></p>
<table width="100%" summary="Syntax summary for element xsl:sort">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:sort<br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;lang? = { <var>language</var> }<br />
&#160;&#160;order? = { "ascending" | "descending" }<br />
&#160;&#160;collation? = { <var>uri</var> }<br />
&#160;&#160;stable? = { <var>boolean</var> }<br />
&#160;&#160;case-order? = { "upper-first" | "lower-first" }<br />
&#160;&#160;data-type? = { "text" | "number" | <var>eqname</var>
}&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:sort&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-apply-templates">xsl:apply-templates</a></li>
<li><a href="#element-for-each">xsl:for-each</a></li>
<li><a href="#element-for-each-group">xsl:for-each-group</a></li>
<li><a href="#element-perform-sort">xsl:perform-sort</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-stream">xsl:stream</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:stream">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:stream<br />
&#160;&#160;<b>href</b> = { <var>uri</var> }<br />
&#160;&#160;validation? = "strict" | "lax" | "preserve" |
"strip"<br />
&#160;&#160;type? = <var>eqname</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:stream&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-strip-space">xsl:strip-space</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:strip-space">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> declaration</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:strip-space<br />
&#160;&#160;<b>elements</b> =
<var>tokens</var>&#160;/&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-package">xsl:package</a></li>
<li><a href="#element-stylesheet">xsl:stylesheet</a></li>
<li><a href="#element-transform">xsl:transform</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-stylesheet">xsl:stylesheet</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:stylesheet">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:stylesheet<br />
&#160;&#160;id? = <var>id</var><br />
&#160;&#160;<b>version</b> = <var>decimal</var><br />
&#160;&#160;default-mode? = <var>eqname</var> | "#unnamed"<br />
&#160;&#160;default-validation? = "preserve" | "strip"<br />
&#160;&#160;input-type-annotations? = "preserve" | "strip" |
"unspecified"<br />
&#160;&#160;default-collation? = <var>uris</var><br />
&#160;&#160;extension-element-prefixes? = <var>prefixes</var><br />
&#160;&#160;exclude-result-prefixes? = <var>prefixes</var><br />
&#160;&#160;expand-text? = <var>boolean</var><br />
&#160;&#160;use-when? = <var>expression</var><br />
&#160;&#160;xpath-default-namespace? =
<var>uri</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<var>declarations</var>) --&gt;<br />
&lt;/xsl:stylesheet&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-package">xsl:package</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-template">xsl:template</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:template">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> declaration</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:template<br />
&#160;&#160;match? = <var>pattern</var><br />
&#160;&#160;name? = <var>eqname</var><br />
&#160;&#160;priority? = <var>decimal</var><br />
&#160;&#160;mode? = <var>tokens</var><br />
&#160;&#160;as? = <var>sequence-type</var><br />
&#160;&#160;visibility? = "public" | "private" | "final" |
"abstract"&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-context-item">xsl:context-item</a>?, <a href=
"#element-param">xsl:param</a>*, <var>sequence-constructor</var>)
--&gt;<br />
&lt;/xsl:template&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-package">xsl:package</a></li>
<li><a href="#element-stylesheet">xsl:stylesheet</a></li>
<li><a href="#element-transform">xsl:transform</a></li>
<li><a href="#element-override">xsl:override</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-text">xsl:text</a></b></p>
<table width="100%" summary="Syntax summary for element xsl:text">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:text<br />
&#160;&#160;<span class="grayed">[disable-output-escaping]?</span>
= <var>boolean</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: #PCDATA --&gt;<br />
&lt;/xsl:text&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-transform">xsl:transform</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:transform">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:transform<br />
&#160;&#160;id? = <var>id</var><br />
&#160;&#160;<b>version</b> = <var>decimal</var><br />
&#160;&#160;default-mode? = <var>eqname</var> | "#unnamed"<br />
&#160;&#160;default-validation? = "preserve" | "strip"<br />
&#160;&#160;input-type-annotations? = "preserve" | "strip" |
"unspecified"<br />
&#160;&#160;default-collation? = <var>uris</var><br />
&#160;&#160;extension-element-prefixes? = <var>prefixes</var><br />
&#160;&#160;exclude-result-prefixes? = <var>prefixes</var><br />
&#160;&#160;expand-text? = <var>boolean</var><br />
&#160;&#160;use-when? = <var>expression</var><br />
&#160;&#160;xpath-default-namespace? =
<var>uri</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<var>declarations</var>) --&gt;<br />
&lt;/xsl:transform&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-package">xsl:package</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-try">xsl:try</a></b></p>
<table width="100%" summary="Syntax summary for element xsl:try">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:try<br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;rollback-output? = <var>boolean</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<var>sequence-constructor</var>,
<a href="#element-catch">xsl:catch</a>, (<a href=
"#element-catch">xsl:catch</a> | <a href=
"#element-fallback">xsl:fallback</a>)*) --&gt;<br />
&lt;/xsl:try&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-use-package">xsl:use-package</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:use-package">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:use-package<br />
&#160;&#160;<b>name</b> = <var>uri</var><br />
&#160;&#160;package-version? = <var>string</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: (<a href=
"#element-accept">xsl:accept</a> | <a href=
"#element-override">xsl:override</a>)* --&gt;<br />
&lt;/xsl:use-package&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-package">xsl:package</a></li>
<li><a href="#element-package">xsl:package</a></li>
<li><a href="#element-stylesheet">xsl:stylesheet</a></li>
<li><a href="#element-transform">xsl:transform</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-value-of">xsl:value-of</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:value-of">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:value-of<br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;separator? = { <var>string</var> }<br />
&#160;&#160;<span class="grayed">[disable-output-escaping]?</span>
= <var>boolean</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:value-of&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-variable">xsl:variable</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:variable">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Category:</i> declaration instruction</p>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:variable<br />
&#160;&#160;<b>name</b> = <var>eqname</var><br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;as? = <var>sequence-type</var><br />
&#160;&#160;static? = <var>boolean</var><br />
&#160;&#160;visibility? = "public" | "private" | "final" |
"abstract"&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:variable&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-package">xsl:package</a></li>
<li><a href="#element-stylesheet">xsl:stylesheet</a></li>
<li><a href="#element-transform">xsl:transform</a></li>
<li><a href="#element-override">xsl:override</a></li>
<li><a href="#element-function">xsl:function</a></li>
<li>any XSLT element whose content model is <i>sequence
constructor</i></li>
<li>any literal result element</li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-when">xsl:when</a></b></p>
<table width="100%" summary="Syntax summary for element xsl:when">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:when<br />
&#160;&#160;<b>test</b> = <var>expression</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:when&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-choose">xsl:choose</a></li>
</ul>
</td>
</tr>
</table>
<p><b><a href="#element-with-param">xsl:with-param</a></b></p>
<table width="100%" summary=
"Syntax summary for element xsl:with-param">
<tr>
<td width="10%">&#160;</td>
<td>
<p><i>Model:</i></p>
<p class="element-syntax-summary"><code>&lt;xsl:with-param<br />
&#160;&#160;<b>name</b> = <var>eqname</var><br />
&#160;&#160;select? = <var>expression</var><br />
&#160;&#160;as? = <var>sequence-type</var><br />
&#160;&#160;tunnel? = <var>boolean</var>&#160;&gt;<br />
&#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
--&gt;<br />
&lt;/xsl:with-param&gt;</code></p>
<p><i>Permitted parent elements:</i></p>
<ul>
<li><a href="#element-apply-templates">xsl:apply-templates</a></li>
<li><a href="#element-apply-imports">xsl:apply-imports</a></li>
<li><a href="#element-call-template">xsl:call-template</a></li>
<li><a href="#element-next-match">xsl:next-match</a></li>
</ul>
</td>
</tr>
</table>
</div>
<div class="div1">
<h2><a name="error-summary" id="error-summary"></a>E Summary of
Error Conditions (Non-Normative)</h2>
<p>This appendix provides a summary of error conditions that a
processor may signal. This list includes all error codes defined in
this specification, but this is not an exhaustive list of all
errors that can occur. Implementations <span class=
"verb">must</span> signal errors using these error codes, and
applications can test for these codes; however, when more than one
rule in the specification is violated, different processors will
not necessarily signal the same error code. Implementations are not
<span class="verb">required</span> to signal errors using the
descriptive text used here.</p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The appendix is non-normative because the same information is
given normatively elsewhere.</p>
</div>
<p><b>Static errors</b></p>
<dl>
<dt><a href="#err-XTSE0010"><span class="error">ERR
XTSE0010</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if an XSLT-defined element is
used in a context where it is not permitted, if a <span class=
"verb">required</span> attribute is omitted, or if the content of
the element does not correspond to the content that is allowed for
the element.</p>
</dd>
<dt><a href="#err-XTSE0020"><span class="error">ERR
XTSE0020</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if an attribute (other than an
attribute written using curly brackets in a position where an
<a title="attribute value template" class="termref" href=
"#dt-attribute-value-template">attribute value template</a> is
permitted) contains a value that is not one of the permitted values
for that attribute.</p>
</dd>
<dt><a href="#err-XTSE0080"><span class="error">ERR
XTSE0080</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> to use a <a title=
"reserved namespace" class="termref" href=
"#dt-reserved-namespace">reserved namespace</a> in the name of a
<a title="named template" class="termref" href=
"#dt-named-template">named template</a>, a <a title="mode" class=
"termref" href="#dt-mode">mode</a>, an <a title="attribute set"
class="termref" href="#dt-attribute-set">attribute set</a>, a
<a title="key" class="termref" href="#dt-key">key</a>, a <a title=
"decimal format" class="termref" href=
"#dt-decimal-format">decimal-format</a>, a <a title="variable"
class="termref" href="#dt-variable">variable</a> or <a title=
"parameter" class="termref" href="#dt-parameter">parameter</a>, a
<a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet function</a>, a named
<a title="output definition" class="termref" href=
"#dt-output-definition">output definition</a>, <span>an
accumulator,</span> or a <a title="character map" class="termref"
href="#dt-character-map">character map</a><span>; except that the
name <code>xsl:initial-template</code> is permitted as a template
name.</span></p>
</dd>
<dt><a href="#err-XTSE0090"><span class="error">ERR
XTSE0090</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> for an element from the XSLT
namespace to have an attribute whose namespace is either null (that
is, an attribute with an unprefixed name) or the XSLT namespace,
other than attributes defined for the element in this document.</p>
</dd>
<dt><a href="#err-XTSE0110"><span class="error">ERR
XTSE0110</span></a></dt>
<dd>
<p>The value of the <code>version</code> attribute <span class=
"verb">must</span> be a number: specifically, it <span class=
"verb">must</span> be a valid instance of the type
<code>xs:decimal</code> as defined in <a href="#xmlschema-2">[XML
Schema Part 2]</a>.</p>
</dd>
<dt><a href="#err-XTSE0120"><span class="error">ERR
XTSE0120</span></a></dt>
<dd>
<p>An <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>
element <span class="verb">must not</span> have any text node
children.</p>
</dd>
<dt><a href="#err-XTSE0125"><span class="error">ERR
XTSE0125</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the value of an
<code>[xsl:]default-collation</code> attribute, after resolving
against the base URI, contains no URI that the implementation
recognizes as a collation URI.</p>
</dd>
<dt><a href="#err-XTSE0130"><span class="error">ERR
XTSE0130</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a> element has a
child element whose name has a null namespace URI.</p>
</dd>
<dt><a href="#err-XTSE0150"><span class="error">ERR
XTSE0150</span></a></dt>
<dd>
<p>A <a title="literal result element" class="termref" href=
"#dt-literal-result-element">literal result element</a> that is
used as the outermost element of a simplified stylesheet module
<span class="verb">must</span> have an <code>xsl:version</code>
attribute.</p>
</dd>
<dt><a href="#err-XTSE0165"><span class="error">ERR
XTSE0165</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the processor is not able to
retrieve the resource identified by the URI reference [ in the
<code>href</code> attribute of <a href=
"#element-include"><code>xsl:include</code></a> or <a href=
"#element-import"><code>xsl:import</code></a> ] , or if the
resource that is retrieved does not contain a stylesheet
module.</p>
</dd>
<dt><a href="#err-XTSE0170"><span class="error">ERR
XTSE0170</span></a></dt>
<dd>
<p>An <a href="#element-include"><code>xsl:include</code></a>
element <span class="verb">must</span> be a <a title="top-level"
class="termref" href="#dt-top-level">top-level</a> element.</p>
</dd>
<dt><a href="#err-XTSE0180"><span class="error">ERR
XTSE0180</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if a stylesheet module directly
or indirectly includes itself.</p>
</dd>
<dt><a href="#err-XTSE0190"><span class="error">ERR
XTSE0190</span></a></dt>
<dd>
<p>An <a href="#element-import"><code>xsl:import</code></a> element
<span class="verb">must</span> be a <a title="top-level" class=
"termref" href="#dt-top-level">top-level</a> element.</p>
</dd>
<dt><a href="#err-XTSE0210"><span class="error">ERR
XTSE0210</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if a stylesheet module directly
or indirectly imports itself.</p>
</dd>
<dt><a href="#err-XTSE0215"><span class="error">ERR
XTSE0215</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if an <a href=
"#element-import-schema"><code>xsl:import-schema</code></a> element
that contains an <code>xs:schema</code> element has a
<code>schema-location</code> attribute, or if it has a
<code>namespace</code> attribute that conflicts with the target
namespace of the contained schema.</p>
</dd>
<dt><a href="#err-XTSE0220"><span class="error">ERR
XTSE0220</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the synthetic schema
document does not satisfy the constraints described in <a href=
"#xmlschema-1">[XML Schema Part 1]</a> (section 5.1, <em>Errors in
Schema Construction and Structure</em>). This includes, without
loss of generality, conflicts such as multiple definitions of the
same name.</p>
</dd>
<dt><a href="#err-XTSE0260"><span class="error">ERR
XTSE0260</span></a></dt>
<dd>
<p>Within an <a title="XSLT element" class="termref" href=
"#dt-xslt-element">XSLT element</a> that is <span class=
"verb">required</span> to be empty, any content other than comments
or processing instructions, including any <a title=
"whitespace text node" class="termref" href=
"#dt-whitespace-text-node">whitespace text node</a> preserved using
the <code>xml:space="preserve"</code> attribute, is a <a title=
"static error" class="termref" href="#dt-static-error">static
error</a>.</p>
</dd>
<dt><a href="#err-XTSE0265"><span class="error">ERR
XTSE0265</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if there is a <a title=
"stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet module</a> in a <a title=
"package" class="termref" href="#dt-package">package</a> that
specifies <code>input-type-annotations="strip"</code> and another
<a title="stylesheet module" class="termref" href=
"#dt-stylesheet-module">stylesheet module</a> that specifies
<code>input-type-annotations="preserve"</code>, <span>or if a
stylesheet module specifies the value <code>strip</code> or
<code>preserve</code> and the same value is not specified on the
<a href="#element-package"><code>xsl:package</code></a> element of
the containing package.</span></p>
</dd>
<dt><a href="#err-XTSE0270"><span class="error">ERR
XTSE0270</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if <span>within any <a title=
"package" class="termref" href="#dt-package">package</a></span> the
same <a href=
"http://www.w3.org/TR/xpath-30/#prod-xpath30-NameTest">NameTest</a><sup><small>XP30</small></sup>
appears in both an <a href=
"#element-strip-space"><code>xsl:strip-space</code></a> and an
<a href=
"#element-preserve-space"><code>xsl:preserve-space</code></a>
declaration if both have the same <a title="import precedence"
class="termref" href="#dt-import-precedence">import precedence</a>.
Two NameTests are considered the same if they match the same set of
names (which can be determined by comparing them after expanding
namespace prefixes to URIs).</p>
</dd>
<dt><a href="#err-XTSE0280"><span class="error">ERR
XTSE0280</span></a></dt>
<dd>
<p>In the case of a prefixed <a title="lexical QName" class=
"termref" href="#dt-lexical-qname">lexical QName</a> used as the
value <span>(or as part of the value)</span> of an attribute in the
<a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a>, or appearing within an XPath
<a title="expression" class="termref" href=
"#dt-expression">expression</a> in the stylesheet, it is a
<a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the <a title=
"defining element" class="termref" href=
"#dt-defining-element">defining element</a> has no namespace node
whose name matches the prefix of the <a title="lexical QName"
class="termref" href="#dt-lexical-qname">lexical QName</a>.</p>
</dd>
<dt><a href="#err-XTSE0340"><span class="error">ERR
XTSE0340</span></a></dt>
<dd>
<p>Where an attribute is defined to contain a <a title="pattern"
class="termref" href="#dt-pattern">pattern</a>, it is a <a title=
"static error" class="termref" href="#dt-static-error">static
error</a> if the pattern does not match the production <a href=
"#doc-xslt30-patterns-Pattern30">Pattern30</a>.</p>
</dd>
<dt><a href="#err-XTSE0350"><span class="error">ERR
XTSE0350</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if an unescaped left curly
bracket appears in a fixed part of a value template without a
matching right curly bracket.</p>
</dd>
<dt><a href="#err-XTSE0370"><span class="error">ERR
XTSE0370</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if an unescaped right curly
bracket occurs in a fixed part of a value template.</p>
</dd>
<dt><a href="#err-XTSE0500"><span class="error">ERR
XTSE0500</span></a></dt>
<dd>
<p>An <a href="#element-template"><code>xsl:template</code></a>
element <span class="verb">must</span> have either a
<code>match</code> attribute or a <code>name</code> attribute, or
both. An <a href="#element-template"><code>xsl:template</code></a>
element that has no <code>match</code> attribute <span class=
"verb">must</span> have no <code>mode</code> attribute and no
<code>priority</code> attribute. <span>An <a href=
"#element-template"><code>xsl:template</code></a> element that has
no <code>name</code> attribute <span class="verb">must</span> have
no <code>visibility</code> attribute.</span></p>
</dd>
<dt><a href="#err-XTSE0530"><span class="error">ERR
XTSE0530</span></a></dt>
<dd>
<p>The value of the <code>priority</code> attribute [ of the
<a href="#element-template"><code>xsl:template</code></a> element]
<span class="verb">must</span> conform to the rules for the
<code>xs:decimal</code> type defined in <a href="#xmlschema-2">[XML
Schema Part 2]</a>. Negative values are permitted.</p>
</dd>
<dt><a href="#err-XTSE0545"><span class="error">ERR
XTSE0545</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if for any named or unnamed
<a title="mode" class="termref" href="#dt-mode">mode</a>, <span>a
package explicitly specifies</span> two conflicting values for the
same attribute in different <a href=
"#element-mode"><code>xsl:mode</code></a> declarations having the
same <a title="import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a>, unless there is
another definition of the same attribute with higher import
precedence. The attributes in question are the attributes other
than <code>name</code> on the <a href=
"#element-mode"><code>xsl:mode</code></a> element.</p>
</dd>
<dt><a href="#err-XTSE0550"><span class="error">ERR
XTSE0550</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the list of modes [in the
<code>mode</code> attribute of <a href=
"#element-template"><code>xsl:template</code></a> ] is empty, if
the same token is included more than once in the list, if the list
contains an invalid token, or if the token <code>#all</code>
appears together with any other value.</p>
</dd>
<dt><a href="#err-XTSE0580"><span class="error">ERR
XTSE0580</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the values of the
<code>name</code> attribute of two <span>sibling <a href=
"#element-param"><code>xsl:param</code></a> elements represent the
same <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a></span>.</p>
</dd>
<dt><a href="#err-XTSE0620"><span class="error">ERR
XTSE0620</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if a <a title=
"variable-binding element" class="termref" href=
"#dt-variable-binding-element">variable-binding element</a> has a
<code>select</code> attribute and has non-empty content.</p>
</dd>
<dt><a href="#err-XTSE0630"><span class="error">ERR
XTSE0630</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if a <a title="package" class=
"termref" href="#dt-package">package</a> contains more than one
<span>non-hidden</span> binding of a global variable with the same
name and same <a title="import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a>, unless it also
contains another binding with the same name and higher import
precedence.</p>
</dd>
<dt><a href="#err-XTSE0650"><span class="error">ERR
XTSE0650</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if a <a title="package" class=
"termref" href="#dt-package">package</a> contains an <a href=
"#element-call-template"><code>xsl:call-template</code></a>
instruction whose <code>name</code> attribute does not match the
<code>name</code> attribute of any <span><a title="named template"
class="termref" href="#dt-named-template">named template</a>
visible in the containing <a title="package" class="termref" href=
"#dt-package">package</a> (this includes any template defined in
this package, as well as templates accepted from used packages
whose visibility in this package is not <code>hidden</code>). For
more details of the process of binding the called template, see
<a href="#component-references"><i>3.6.3.4 Binding References to
Components</i></a>.</span></p>
</dd>
<dt><a href="#err-XTSE0660"><span class="error">ERR
XTSE0660</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if a <span><a title="package"
class="termref" href="#dt-package">package</a></span> contains more
than one <span>non-hidden</span> <a title="template" class=
"termref" href="#dt-template">template</a> with the same name and
the same <a title="import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a>, unless it also
contains a <a title="template" class="termref" href=
"#dt-template">template</a> with the same name and higher <a title=
"import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a>.</p>
</dd>
<dt><a href="#err-XTSE0670"><span class="error">ERR
XTSE0670</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if two or more sibling <a href=
"#element-with-param"><code>xsl:with-param</code></a> elements have
<code>name</code> attributes that represent the same <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a>.</p>
</dd>
<dt><a href="#err-XTSE0680"><span class="error">ERR
XTSE0680</span></a></dt>
<dd>
<p>In the case of <a href=
"#element-call-template"><code>xsl:call-template</code></a>, it is
a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> to pass a non-tunnel parameter
named <var>x</var> to a template that does not have a
<span>non-tunnel</span> <a title="template parameter" class=
"termref" href="#dt-template-parameter">template parameter</a>
named <var>x</var>, unless <span>the <a href=
"#element-call-template"><code>xsl:call-template</code></a>
instruction is processed with <a title="XSLT 1.0 behavior" class=
"termref" href="#dt-xslt-10-behavior">XSLT 1.0
behavior</a></span>.</p>
</dd>
<dt><a href="#err-XTSE0690"><span class="error">ERR
XTSE0690</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if a <a title="package" class=
"termref" href="#dt-package">package</a> contains both (a) a named
template named <var>T</var> that is not overridden by another named
template of higher import precedence and that has an <a title=
"explicitly mandatory" class="termref" href=
"#dt-explicitly-mandatory">explicitly mandatory</a> non-tunnel
parameter named <var>P</var>, and (b) an <a href=
"#element-call-template"><code>xsl:call-template</code></a>
instruction whose <code>name</code> attribute equals <var>T</var>
and that has no non-tunnel <a href=
"#element-with-param"><code>xsl:with-param</code></a> child element
whose <code>name</code> attribute equals <var>P</var>. (All names
are compared as QNames.)</p>
</dd>
<dt><a href="#err-XTSE0710"><span class="error">ERR
XTSE0710</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the value of the
<code>use-attribute-sets</code> attribute of an <a href=
"#element-copy"><code>xsl:copy</code></a>, <a href=
"#element-element"><code>xsl:element</code></a>, or <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a>
element, or the <code>xsl:use-attribute-sets</code> attribute of a
<a title="literal result element" class="termref" href=
"#dt-literal-result-element">literal result element</a>, is not a
whitespace-separated sequence of <span><a title="EQName" class=
"termref" href="#dt-eqname">EQNames</a></span>, or if it contains a
QName that does not match the <code>name</code> attribute of any
<a href="#element-attribute-set"><code>xsl:attribute-set</code></a>
declaration in the <span>containing <a title="package" class=
"termref" href="#dt-package">package</a></span>.</p>
</dd>
<dt><a href="#err-XTSE0720"><span class="error">ERR
XTSE0720</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if an <a href=
"#element-attribute-set"><code>xsl:attribute-set</code></a> element
directly or indirectly references itself via the names contained in
the <code>use-attribute-sets</code> attribute.</p>
</dd>
<dt><a href="#err-XTSE0730"><span class="error">ERR
XTSE0730</span></a></dt>
<dd>
<p>If an <a href=
"#element-attribute"><code>xsl:attribute</code></a> set element
specifies <code>streamable="yes"</code> then every attribute set
referenced in its <code>use-attribute-sets</code> attribute (if
present) must also specify <code>streamable="yes"</code>.</p>
</dd>
<dt><a href="#err-XTSE0740"><span class="error">ERR
XTSE0740</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if a <a title=
"stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet function</a> has a name that
is in no namespace.</p>
</dd>
<dt><a href="#err-XTSE0760"><span class="error">ERR
XTSE0760</span></a></dt>
<dd>
<p>Because arguments to a stylesheet function call <span class=
"verb">must</span> all be specified, the <a href=
"#element-param"><code>xsl:param</code></a> elements within an
<a href="#element-function"><code>xsl:function</code></a> element
<span class="verb">must not</span> specify a default value: this
means they <span class="verb">must</span> be empty, and
<span class="verb">must not</span> have a <code>select</code>
attribute.</p>
</dd>
<dt><a href="#err-XTSE0770"><span class="error">ERR
XTSE0770</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> for a <span><a title="package"
class="termref" href="#dt-package">package</a></span> to contain
two or more <span>non-hidden</span> functions with the same
<a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a>, the same <a title="arity"
class="termref" href="#dt-arity">arity</a>, and the same <a title=
"import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a>, unless there is
another function with the same <a title="expanded QName" class=
"termref" href="#dt-expanded-qname">expanded QName</a> and arity,
and a higher import precedence.</p>
</dd>
<dt><a href="#err-XTSE0805"><span class="error">ERR
XTSE0805</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if an attribute on a literal
result element is in the <a title="XSLT namespace" class="termref"
href="#dt-xslt-namespace">XSLT namespace</a>, unless it is one of
the attributes explicitly defined in this specification.</p>
</dd>
<dt><a href="#err-XTSE0808"><span class="error">ERR
XTSE0808</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if a namespace prefix is used
within the <code>[xsl:]exclude-result-prefixes</code> attribute and
there is no namespace binding in scope for that prefix.</p>
</dd>
<dt><a href="#err-XTSE0809"><span class="error">ERR
XTSE0809</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the value
<code>#default</code> is used within the
<code>[xsl:]exclude-result-prefixes</code> attribute and the parent
element of the <code>[xsl:]exclude-result-prefixes</code> attribute
has no default namespace.</p>
</dd>
<dt><a href="#err-XTSE0810"><span class="error">ERR
XTSE0810</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if <span>within a <a title=
"package" class="termref" href="#dt-package">package</a></span>
there is more than one such declaration [more than one <a href=
"#element-namespace-alias"><code>xsl:namespace-alias</code></a>
declaration] with the same <a title="literal namespace URI" class=
"termref" href="#dt-literal-namespace-uri">literal namespace
URI</a> and the same <a title="import precedence" class="termref"
href="#dt-import-precedence">import precedence</a> and different
values for the <a title="target namespace URI" class="termref"
href="#dt-target-namespace-uri">target namespace URI</a>, unless
there is also an <a href=
"#element-namespace-alias"><code>xsl:namespace-alias</code></a>
declaration with the same <a title="literal namespace URI" class=
"termref" href="#dt-literal-namespace-uri">literal namespace
URI</a> and a higher import precedence.</p>
</dd>
<dt><a href="#err-XTSE0812"><span class="error">ERR
XTSE0812</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if a value other than
<code>#default</code> is specified for either the
<code>stylesheet-prefix</code> or the <code>result-prefix</code>
attributes of the <a href=
"#element-namespace-alias"><code>xsl:namespace-alias</code></a>
element when there is no in-scope binding for that namespace
prefix.</p>
</dd>
<dt><a href="#err-XTSE0840"><span class="error">ERR
XTSE0840</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the <code>select</code>
attribute of the <a href=
"#element-attribute"><code>xsl:attribute</code></a> element is
present unless the element has empty content.</p>
</dd>
<dt><a href="#err-XTSE0870"><span class="error">ERR
XTSE0870</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the <code>select</code>
attribute of the <a href=
"#element-value-of"><code>xsl:value-of</code></a> element is
present when the content of the element is non-empty</p>
</dd>
<dt><a href="#err-XTSE0880"><span class="error">ERR
XTSE0880</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the <code>select</code>
attribute of the <a href=
"#element-processing-instruction"><code>xsl:processing-instruction</code></a>
element is present unless the element has empty content.</p>
</dd>
<dt><a href="#err-XTSE0910"><span class="error">ERR
XTSE0910</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the <code>select</code>
attribute of the <a href=
"#element-namespace"><code>xsl:namespace</code></a> element is
present when the element has content other than one or more
<a href="#element-fallback"><code>xsl:fallback</code></a>
instructions, or if the <code>select</code> attribute is absent
when the element has empty content.</p>
</dd>
<dt><a href="#err-XTSE0940"><span class="error">ERR
XTSE0940</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the <code>select</code>
attribute of the <a href=
"#element-comment"><code>xsl:comment</code></a> element is present
unless the element has empty content.</p>
</dd>
<dt><a href="#err-XTSE0975"><span class="error">ERR
XTSE0975</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the <code>value</code>
attribute of <a href="#element-number"><code>xsl:number</code></a>
is present unless the <code>select</code>, <code>level</code>,
<code>count</code>, and <code>from</code> attributes are all
absent.</p>
</dd>
<dt><a href="#err-XTSE1015"><span class="error">ERR
XTSE1015</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if an <a href=
"#element-sort"><code>xsl:sort</code></a> element with a
<code>select</code> attribute has non-empty content.</p>
</dd>
<dt><a href="#err-XTSE1017"><span class="error">ERR
XTSE1017</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if an <a href=
"#element-sort"><code>xsl:sort</code></a> element other than the
first in a sequence of sibling <a href=
"#element-sort"><code>xsl:sort</code></a> elements has a
<code>stable</code> attribute.</p>
</dd>
<dt><a href="#err-XTSE1040"><span class="error">ERR
XTSE1040</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if an <a href=
"#element-perform-sort"><code>xsl:perform-sort</code></a>
instruction with a <code>select</code> attribute has any content
other than <a href="#element-sort"><code>xsl:sort</code></a> and
<a href="#element-fallback"><code>xsl:fallback</code></a>
instructions.</p>
</dd>
<dt><a href="#err-XTSE1060"><span class="error">ERR
XTSE1060</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the <a href=
"#func-current-group"><code>current-group</code></a> function is
used within a <a title="pattern" class="termref" href=
"#dt-pattern">pattern</a>.</p>
</dd>
<dt><a href="#err-XTSE1070"><span class="error">ERR
XTSE1070</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the <a href=
"#func-current-grouping-key"><code>current-grouping-key</code></a>
function is used within a <a title="pattern" class="termref" href=
"#dt-pattern">pattern</a>.</p>
</dd>
<dt><a href="#err-XTSE1080"><span class="error">ERR
XTSE1080</span></a></dt>
<dd>
<p>These four attributes [the <code>group-by</code>,
<code>group-adjacent</code>, <code>group-starting-with</code>, and
<code>group-ending-with</code> attributes of <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a> ] are
mutually exclusive: it is a <a title="static error" class="termref"
href="#dt-static-error">static error</a> if none of these four
attributes is present or if more than one of them is present.</p>
</dd>
<dt><a href="#err-XTSE1090"><span class="error">ERR
XTSE1090</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> to specify the
<code>collation</code> attribute <span>or the
<code>composite</code> attribute</span> if neither the
<code>group-by</code> attribute nor <code>group-adjacent</code>
attribute is specified.</p>
</dd>
<dt><a href="#err-XTSE1130"><span class="error">ERR
XTSE1130</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the <a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a>
instruction contains neither an <a href=
"#element-matching-substring"><code>xsl:matching-substring</code></a>
nor an <a href=
"#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>
element.</p>
</dd>
<dt><a href="#err-XTSE1205"><span class="error">ERR
XTSE1205</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if an <a href=
"#element-key"><code>xsl:key</code></a> declaration has a
<code>use</code> attribute and has non-empty content, or if it has
empty content and no <code>use</code> attribute.</p>
</dd>
<dt><a href="#err-XTSE1210"><span class="error">ERR
XTSE1210</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the <a href=
"#element-key"><code>xsl:key</code></a> declaration has a
<code>collation</code> attribute whose value (after resolving
against the base URI) is not a URI recognized by the implementation
as referring to a collation.</p>
</dd>
<dt><a href="#err-XTSE1220"><span class="error">ERR
XTSE1220</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if there are several <a href=
"#element-key"><code>xsl:key</code></a> declarations in the
<span>same <a title="package" class="termref" href=
"#dt-package">package</a></span> with the same key name and
different effective collations. Two collations are the same if
their URIs are equal under the rules for comparing
<code>xs:anyURI</code> values, or if the implementation can
determine that they are different URIs referring to the same
collation.</p>
</dd>
<dt><a href="#err-XTSE1222"><span class="error">ERR
XTSE1222</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if there are several <a href=
"#element-key"><code>xsl:key</code></a> declarations in a <a title=
"package" class="termref" href="#dt-package">package</a> with the
same key name and different effective values for the
<code>composite</code> attribute.</p>
</dd>
<dt><a href="#err-XTSE1290"><span class="error">ERR
XTSE1290</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if a named or unnamed <a title=
"decimal format" class="termref" href="#dt-decimal-format">decimal
format</a> contains two conflicting values for the same attribute
in different <a href=
"#element-decimal-format"><code>xsl:decimal-format</code></a>
declarations having the same <a title="import precedence" class=
"termref" href="#dt-import-precedence">import precedence</a>,
unless there is another definition of the same attribute with
higher import precedence.</p>
</dd>
<dt><a href="#err-XTSE1295"><span class="error">ERR
XTSE1295</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the character specified in
the <code>zero-digit</code> attribute is not a digit or is a digit
that does not have the numeric value zero.</p>
</dd>
<dt><a href="#err-XTSE1300"><span class="error">ERR
XTSE1300</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if, for any named or unnamed
decimal format, the variables representing characters used in a
<a title="picture string" class="termref" href=
"#dt-picture-string">picture string</a> do not each have distinct
values. These variables are <var>decimal-separator-sign</var>,
<var>grouping-sign</var>, <var>percent-sign</var>,
<var>per-mille-sign</var>, <var>digit-zero-sign</var>,
<var>digit-sign</var>, and <var>pattern-separator-sign</var>.</p>
</dd>
<dt><a href="#err-XTSE1430"><span class="error">ERR
XTSE1430</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if there is no namespace bound
to the prefix on the element bearing the
<code>[xsl:]extension-element-prefixes</code> attribute or, when
<code>#default</code> is specified, if there is no default
namespace.</p>
</dd>
<dt><a href="#err-XTSE1505"><span class="error">ERR
XTSE1505</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if both the
<code>[xsl:]type</code> and <code>[xsl:]validation</code>
attributes are present on the <a href=
"#element-element"><code>xsl:element</code></a>, <a href=
"#element-attribute"><code>xsl:attribute</code></a>, <a href=
"#element-copy"><code>xsl:copy</code></a>, <a href=
"#element-copy-of"><code>xsl:copy-of</code></a>, <a href=
"#element-document"><code>xsl:document</code></a>, <a href=
"#element-result-document"><code>xsl:result-document</code></a>,
<span><a href="#element-stream"><code>xsl:stream</code></a>, or
<a href=
"#element-merge-source"><code>xsl:merge-source</code></a></span>
elements, or on a <a title="literal result element" class="termref"
href="#dt-literal-result-element">literal result element</a>.</p>
</dd>
<dt><a href="#err-XTSE1520"><span class="error">ERR
XTSE1520</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the value of the
<code>type</code> attribute of an <a href=
"#element-element"><code>xsl:element</code></a>, <a href=
"#element-attribute"><code>xsl:attribute</code></a>, <a href=
"#element-copy"><code>xsl:copy</code></a>, <a href=
"#element-copy-of"><code>xsl:copy-of</code></a>, <a href=
"#element-document"><code>xsl:document</code></a>, or <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction, or the <code>xsl:type</code> attribute of a literal
result element, is not a valid <code>QName</code>, or if it uses a
prefix that is not defined in an in-scope namespace declaration, or
if the QName is not the name of a type definition included in the
<a title="in-scope schema component" class="termref" href=
"#dt-in-scope-schema-component">in-scope schema components</a> for
the <a title="package" class="termref" href=
"#dt-package">package</a>.</p>
</dd>
<dt><a href="#err-XTSE1530"><span class="error">ERR
XTSE1530</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the value of the
<code>type</code> attribute of an <a href=
"#element-attribute"><code>xsl:attribute</code></a> instruction
refers to a complex type definition</p>
</dd>
<dt><a href="#err-XTSE1560"><span class="error">ERR
XTSE1560</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if two <a href=
"#element-output"><code>xsl:output</code></a> declarations within
an <a title="output definition" class="termref" href=
"#dt-output-definition">output definition</a> specify explicit
values for the same attribute (other than
<code>cdata-section-elements</code>,
<span><code>suppress-indentation</code>,</span> and
<code>use-character-maps</code>), with the values of the attributes
being not equal, unless there is another <a href=
"#element-output"><code>xsl:output</code></a> declaration within
the same <a title="output definition" class="termref" href=
"#dt-output-definition">output definition</a> that has higher
import precedence and that specifies an explicit value for the same
attribute.</p>
</dd>
<dt><a href="#err-XTSE1570"><span class="error">ERR
XTSE1570</span></a></dt>
<dd>
<p>The value [of the <code>method</code> attribute on <a href=
"#element-output"><code>xsl:output</code></a> ] <span class=
"verb">must</span> (if present) be a valid <a title="EQName" class=
"termref" href="#dt-eqname">EQName</a>. If it is a <a title=
"lexical QName" class="termref" href="#dt-lexical-qname">lexical
QName</a> with no a prefix, then it identifies a method specified
in <a href="#xslt-xquery-serialization-30">[XSLT and XQuery
Serialization]</a> and <span class="verb">must</span> be one of
<code>xml</code>, <code>html</code>, <code>xhtml</code>, or
<code>text</code>.</p>
</dd>
<dt><a href="#err-XTSE1580"><span class="error">ERR
XTSE1580</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if a <a title="package" class=
"termref" href="#dt-package">package</a> contains two or more
character maps with the same name and the same <a title=
"import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a>, unless it also
contains another character map with the same name and higher import
precedence.</p>
</dd>
<dt><a href="#err-XTSE1590"><span class="error">ERR
XTSE1590</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if a name in the
<code>use-character-maps</code> attribute of the <a href=
"#element-output"><code>xsl:output</code></a> or <a href=
"#element-character-map"><code>xsl:character-map</code></a>
elements does not match the <code>name</code> attribute of any
<a href="#element-character-map"><code>xsl:character-map</code></a>
in the <span>containing <a title="package" class="termref" href=
"#dt-package">package</a></span>.</p>
</dd>
<dt><a href="#err-XTSE1600"><span class="error">ERR
XTSE1600</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if a character map references
itself, directly or indirectly, via a name in the
<code>use-character-maps</code> attribute.</p>
</dd>
<dt><a href="#err-XTSE1650"><span class="error">ERR
XTSE1650</span></a></dt>
<dd>
<p>A <a title="non-schema-aware processor" class="termref" href=
"#dt-non-schema-aware-processor">non-schema-aware processor</a>
<span class="verb">must</span> signal a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if <span>a
<a title="package" class="termref" href=
"#dt-package">package</a></span> includes an <a href=
"#element-import-schema"><code>xsl:import-schema</code></a>
declaration.</p>
</dd>
<dt><a href="#err-XTSE1660"><span class="error">ERR
XTSE1660</span></a></dt>
<dd>
<p>A <a title="non-schema-aware processor" class="termref" href=
"#dt-non-schema-aware-processor">non-schema-aware processor</a>
<span class="verb">must</span> signal a <a title="static error"
class="termref" href="#dt-static-error">static error</a> if <span>a
<a title="package" class="termref" href=
"#dt-package">package</a></span> includes an
<code>[xsl:]type</code> attribute, or an
<code>[xsl:]validation</code> or
<code>[xsl:]default-validation</code> attribute with a value other
than <code>strip</code><span>, <code>preserve</code>, or
<code>lax</code></span>.</p>
</dd>
<dt><a href="#err-XTSE2200"><span class="error">ERR
XTSE2200</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the number of <a href=
"#element-merge-key"><code>xsl:merge-key</code></a> children of a
<a href="#element-merge-source"><code>xsl:merge-source</code></a>
element is not equal to the number of <a href=
"#element-merge-key"><code>xsl:merge-key</code></a> children of
another <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> child of
the same <a href="#element-merge"><code>xsl:merge</code></a>
instruction.</p>
</dd>
<dt><a href="#err-XTSE3000"><span class="error">ERR
XTSE3000</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if no package matching the
package name and version specified in an <a href=
"#element-use-package"><code>xsl:use-package</code></a> declaration
can be located.</p>
</dd>
<dt><a href="#err-XTSE3010"><span class="error">ERR
XTSE3010</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the explicit exposed
visibility of a component is inconsistent with its declared
visibility, as defined in the above table. (This error occurs only
when the component declaration has an explicit
<code>visibility</code> attribute, and the component is also listed
explicitly by name in an <a href=
"#element-expose"><code>xsl:expose</code></a> declaration.)</p>
</dd>
<dt><a href="#err-XTSE3020"><span class="error">ERR
XTSE3020</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if a token in the
<code>names</code> attribute of <code>xsl:expose</code>, other than
a wildcard, matches no component in the containing package.</p>
</dd>
<dt><a href="#err-XTSE3030"><span class="error">ERR
XTSE3030</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if a token in the
<code>names</code> attribute of <code>xsl:accept</code>, other than
a wildcard, matches no component in the used package.</p>
</dd>
<dt><a href="#err-XTSE3040"><span class="error">ERR
XTSE3040</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the visibility assigned to a
component by an <a href=
"#element-accept"><code>xsl:accept</code></a> element is
incompatible with the visibility of the corresponding component in
the used package, as defined by the above table, unless the token
that matches the component name is a wildcard, in which case the
<a href="#element-accept"><code>xsl:accept</code></a> element is
treated as not matching that component.</p>
</dd>
<dt><a href="#err-XTSE3050"><span class="error">ERR
XTSE3050</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the <a href=
"#element-use-package"><code>xsl:use-package</code></a> elements in
a <a title="package manifest" class="termref" href=
"#dt-package-manifest">package manifest</a> cause two or more
<a title="homonymous" class="termref" href=
"#dt-homonymous">homonymous</a> components to be accepted with a
visibility other than <code>hidden</code>.</p>
</dd>
<dt><a href="#err-XTSE3055"><span class="error">ERR
XTSE3055</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if a component declaration
appearing as a child of <a href=
"#element-override"><code>xsl:override</code></a> is <a title=
"homonymous" class="termref" href="#dt-homonymous">homonymous</a>
with any other declaration in the using package, regardless of
<a title="import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a>, including any other
overriding declaration in the package manifest of the using
package.</p>
</dd>
<dt><a href="#err-XTSE3058"><span class="error">ERR
XTSE3058</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if a component declaration
appearing as a child of <a href=
"#element-override"><code>xsl:override</code></a> does not match
(is not <a title="homonymous" class="termref" href=
"#dt-homonymous">homonymous</a> with) some component in the used
package.</p>
</dd>
<dt><a href="#err-XTSE3060"><span class="error">ERR
XTSE3060</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the component referenced by
an <a href="#element-override"><code>xsl:override</code></a>
declaration has <a title="visibility" class="termref" href=
"#dt-visibility">visibility</a> other than <code>public</code> or
<code>abstract</code></p>
</dd>
<dt><a href="#err-XTSE3070"><span class="error">ERR
XTSE3070</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the signature of an
overriding component is not <a title="compatible" class="termref"
href="#dt-compatible">compatible</a> with the signature of the
component that it is overriding.</p>
</dd>
<dt><a href="#err-XTSE3080"><span class="error">ERR
XTSE3080</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if a <a title=
"top-level package" class="termref" href=
"#dt-top-level-package">top-level package</a> (as distinct from a
<a title="library package" class="termref" href=
"#dt-library-package">library package</a>) contains symbolic
references referring to components whose visibility is
<code>abstract</code>.</p>
</dd>
<dt><a href="#err-XTSE3085"><span class="error">ERR
XTSE3085</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a>, unless the value of the
<code>declared-modes</code> attribute of an <a href=
"#element-package"><code>xsl:package</code></a> element is
<code>no</code>, if the <code>mode</code> attribute of an <a href=
"#element-template"><code>xsl:template</code></a> or <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction within the package contains, either explicitly or
implicitly (for example, by virtue of a relevant
<code>default-mode</code> attribute), a mode name that is not the
subject of an <a href="#element-mode"><code>xsl:mode</code></a>
declaration appearing within the package nor a <code>public</code>
or <code>final</code> <code>xsl:mode</code> declaration accepted
from a used package. For this purpose the <a title="unnamed mode"
class="termref" href="#dt-unnamed-mode">unnamed mode</a> behaves in
the same way as a named mode, so that a reference to the unnamed
mode is allowed only if the unnamed mode is declared.</p>
</dd>
<dt><a href="#err-XTSE3105"><span class="error">ERR
XTSE3105</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if a template rule applicable
to a mode that is defined with <code>typed="strict"</code> uses a
match pattern that contains a <code>RelativePathExprP</code> whose
first <code>StepExprP</code> is an <code>AxisStepP</code> whose
<code>ForwardStepP</code> uses an axis whose principal node kind is
<code>Element</code> and whose <code>NodeTest</code> is an
<code>EQName</code> that does not correspond to the name of any
global element declaration in the <a title=
"in-scope schema component" class="termref" href=
"#dt-in-scope-schema-component">in-scope schema components</a>.</p>
</dd>
<dt><a href="#err-XTSE3120"><span class="error">ERR
XTSE3120</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if an <a href=
"#element-break"><code>xsl:break</code></a> or <a href=
"#element-next-iteration"><code>xsl:next-iteration</code></a>
element appears other than in a <a title="tail position" class=
"termref" href="#dt-tail-position">tail position</a> within the
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> forming the
body of an <a href="#element-iterate"><code>xsl:iterate</code></a>
instruction.</p>
</dd>
<dt><a href="#err-XTSE3125"><span class="error">ERR
XTSE3125</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the <code>select</code>
attribute of <a href="#element-break"><code>xsl:break</code></a> or
<a href="#element-on-completion"><code>xsl:on-completion</code></a>
is present and the instruction has children.</p>
</dd>
<dt><a href="#err-XTSE3130"><span class="error">ERR
XTSE3130</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the <code>name</code>
attribute of an <a href=
"#element-with-param"><code>xsl:with-param</code></a> child of an
<a href=
"#element-next-iteration"><code>xsl:next-iteration</code></a>
element does not match the <code>name</code> attribute of an
<a href="#element-param"><code>xsl:param</code></a> child of the
<span>innermost</span> containing <a href=
"#element-iterate"><code>xsl:iterate</code></a> instruction.</p>
</dd>
<dt><a href="#err-XTSE3140"><span class="error">ERR
XTSE3140</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the <code>select</code>
attribute of the <a href="#element-try"><code>xsl:try</code></a>
element is present and the element has children other than <a href=
"#element-catch"><code>xsl:catch</code></a> and <a href=
"#element-fallback"><code>xsl:fallback</code></a> elements.</p>
</dd>
<dt><a href="#err-XTSE3150"><span class="error">ERR
XTSE3150</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the <code>select</code>
attribute of the <a href=
"#element-catch"><code>xsl:catch</code></a> element is present
unless the element has empty content.</p>
</dd>
<dt><a href="#err-XTSE3185"><span class="error">ERR
XTSE3185</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the <code>select</code>
attribute of <a href=
"#element-sequence"><code>xsl:sequence</code></a> is present and
the instruction has children other than <a href=
"#element-fallback"><code>xsl:fallback</code></a>.</p>
</dd>
<dt><a href="#err-XTSE3190"><span class="error">ERR
XTSE3190</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if two sibling <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> elements
have the same name.</p>
</dd>
<dt><a href="#err-XTSE3200"><span class="error">ERR
XTSE3200</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if an <a href=
"#element-merge-key"><code>xsl:merge-key</code></a> element with a
<code>select</code> attribute has non-empty content.</p>
</dd>
<dt><a href="#err-XTSE3280"><span class="error">ERR
XTSE3280</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the <code>select</code>
attribute of the <a href=
"#element-map-entry"><code>xsl:map-entry</code></a> element is
present unless the element has no children other than <a href=
"#element-fallback"><code>xsl:fallback</code></a> elements.</p>
</dd>
<dt><a href="#err-XTSE3350"><span class="error">ERR
XTSE3350</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> for a <a title="package" class=
"termref" href="#dt-package">package</a> to contain two or more
non-hidden accumulators with the same <a title="expanded QName"
class="termref" href="#dt-expanded-qname">expanded QName</a> and
the same <a title="import precedence" class="termref" href=
"#dt-import-precedence">import precedence</a>, unless there is
another accumulator with the same <a title="expanded QName" class=
"termref" href="#dt-expanded-qname">expanded QName</a>, and a
higher import precedence.</p>
</dd>
<dt><a href="#err-XTSE3430"><span class="error">ERR
XTSE3430</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if a <a title="package" class=
"termref" href="#dt-package">package</a> contains a construct that
is declared to be streamable but which is not <a title=
"guaranteed-streamable" class="termref" href=
"#dt-guaranteed-streamable">guaranteed-streamable</a>, unless the
user has indicated that the processor is to handle this situation
by processing the stylesheet without streaming or by making use of
processor extensions to the streamability rules where
available.</p>
</dd>
<dt><a href="#err-XTSE3440"><span class="error">ERR
XTSE3440</span></a></dt>
<dd>
<p>In the case of a <a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a> (that is, an <a href=
"#element-template"><code>xsl:template</code></a> element having a
<code>match</code> attribute) appearing as a child of <a href=
"#element-override"><code>xsl:override</code></a>, it is a
<a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the list of modes in the
<code>mode</code> attribute contains <code>#all</code> or
<code>#unnamed</code>, or if it contains <code>#default</code> and
the default mode is the <a title="unnamed mode" class="termref"
href="#dt-unnamed-mode">unnamed mode</a>, or if the
<code>mode</code> attribute is omitted when the default mode is the
<a title="unnamed mode" class="termref" href=
"#dt-unnamed-mode">unnamed mode</a>.</p>
</dd>
<dt><a href="#err-XTSE3450"><span class="error">ERR
XTSE3450</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if a variable declared with
<code>static="yes"</code> is inconsistent with another static
variable of the same name that is declared earlier in stylesheet
tree order and that has lower <a title="import precedence" class=
"termref" href="#dt-import-precedence">import precedence</a>.</p>
</dd>
<dt><a href="#err-XTSE3460"><span class="error">ERR
XTSE3460</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if an <a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a> element
appears in a <a title="template rule" class="termref" href=
"#dt-template-rule">template rule</a> declared within an <a href=
"#element-override"><code>xsl:override</code></a> element. (To
invoke the template rule that is being overridden, <a href=
"#element-next-match"><code>xsl:next-match</code></a> should
therefore be used.)</p>
</dd>
<dt><a href="#err-XTSE3470"><span class="error">ERR
XTSE3470</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the <a href=
"#func-current-merge-group"><code>current-merge-group</code></a>
function is used within a <a title="pattern" class="termref" href=
"#dt-pattern">pattern</a>.</p>
</dd>
<dt><a href="#err-XTSE3500"><span class="error">ERR
XTSE3500</span></a></dt>
<dd>
<p>It is a <a title="static error" class="termref" href=
"#dt-static-error">static error</a> if the <a href=
"#func-current-merge-key"><code>current-merge-key</code></a>
function is used within a <a title="pattern" class="termref" href=
"#dt-pattern">pattern</a>.</p>
</dd>
<dt><a href="#err-XTSE3520"><span class="error">ERR
XTSE3520</span></a></dt>
<dd>
<p>It is a static error if a parameter to <a href=
"#element-iterate"><code>xsl:iterate</code></a> is <a title=
"implicitly mandatory" class="termref" href=
"#dt-implicitly-mandatory">implicitly mandatory</a>.</p>
</dd>
</dl>
<p><b>Type errors</b></p>
<dl>
<dt><a href="#err-XTTE0505"><span class="error">ERR
XTTE0505</span></a></dt>
<dd>
<p>It is a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> if the result of evaluating the
<a title="sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> cannot be
converted to the required type.</p>
</dd>
<dt><a href="#err-XTTE0510"><span class="error">ERR
XTTE0510</span></a></dt>
<dd>
<p>It is a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> if an <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction with no <code>select</code> attribute is evaluated when
the <a title="context item" class="termref" href=
"#dt-context-item">context item</a> is not a node.</p>
</dd>
<dt><a href="#err-XTTE0570"><span class="error">ERR
XTTE0570</span></a></dt>
<dd>
<p>It is a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> if the <a title="supplied value"
class="termref" href="#dt-supplied-value">supplied value</a> of a
variable cannot be converted to the required type.</p>
</dd>
<dt><a href="#err-XTTE0590"><span class="error">ERR
XTTE0590</span></a></dt>
<dd>
<p>It is a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> if the conversion of the <a title=
"supplied value" class="termref" href="#dt-supplied-value">supplied
value</a> of a parameter to its <a title="required type" class=
"termref" href="#dt-required-type">required type</a> fails.</p>
</dd>
<dt><a href="#err-XTTE0780"><span class="error">ERR
XTTE0780</span></a></dt>
<dd>
<p>If the <code>as</code> attribute [of <a href=
"#element-function"><code>xsl:function</code></a> ] is specified,
then the result evaluated by the <a title="sequence constructor"
class="termref" href="#dt-sequence-constructor">sequence
constructor</a> (see <a href="#sequence-constructors"><i>5.8
Sequence Constructors</i></a>) is converted to the required type,
using the <a title="function conversion rules" class="termref"
href="#dt-function-conversion-rules">function conversion rules</a>.
It is a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> if this conversion fails.</p>
</dd>
<dt><a href="#err-XTTE0790"><span class="error">ERR
XTTE0790</span></a></dt>
<dd>
<p>If the value of a parameter to a <a title="stylesheet function"
class="termref" href="#dt-stylesheet-function">stylesheet
function</a> cannot be converted to the required type, a <a title=
"type error" class="termref" href="#dt-type-error">type error</a>
is signaled.</p>
</dd>
<dt><a href="#err-XTTE0945"><span class="error">ERR
XTTE0945</span></a></dt>
<dd>
<p>It is a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> to use the <a href=
"#element-copy"><code>xsl:copy</code></a> instruction with no
<code>select</code> attribute when the context item is absent.</p>
</dd>
<dt><a href="#err-XTTE0950"><span class="error">ERR
XTTE0950</span></a></dt>
<dd>
<p>It is a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> to use the <a href=
"#element-copy"><code>xsl:copy</code></a> or <a href=
"#element-copy-of"><code>xsl:copy-of</code></a> instruction to copy
a node that has namespace-sensitive content if the
<code>copy-namespaces</code> attribute has the value
<code>no</code> and its explicit or implicit
<code>validation</code> attribute has the value
<code>preserve</code>. It is also a type error if either of these
instructions (with <code>validation="preserve"</code>) is used to
copy an attribute having namespace-sensitive content, unless the
parent element is also copied. A node has namespace-sensitive
content if its typed value contains an item of type
<code>xs:QName</code> or <code>xs:NOTATION</code> or a type derived
therefrom. The reason this is an error is because the validity of
the content depends on the namespace context being preserved.</p>
</dd>
<dt><a href="#err-XTTE0990"><span class="error">ERR
XTTE0990</span></a></dt>
<dd>
<p>It is a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> if the <a href=
"#element-number"><code>xsl:number</code></a> instruction is
evaluated, with no <code>value</code> or <code>select</code>
attribute, when the <a title="context item" class="termref" href=
"#dt-context-item">context item</a> is not a node.</p>
</dd>
<dt><a href="#err-XTTE1000"><span class="error">ERR
XTTE1000</span></a></dt>
<dd>
<p>It is a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> if the result of evaluating the
<code>select</code> attribute of the <a href=
"#element-number"><code>xsl:number</code></a> instruction is
anything other than a single node.</p>
</dd>
<dt><a href="#err-XTTE1020"><span class="error">ERR
XTTE1020</span></a></dt>
<dd>
<p>If any <a title="sort key value" class="termref" href=
"#dt-sort-key-value">sort key value</a>, after <a title="atomize"
class="termref" href="#dt-atomization">atomization</a> and any type
conversion <span class="verb">required</span> by the
<code>data-type</code> attribute, is a sequence containing more
than one item, then the effect depends on whether the <a href=
"#element-sort"><code>xsl:sort</code></a> element <span>is
processed with <a title="XSLT 1.0 behavior" class="termref" href=
"#dt-xslt-10-behavior">XSLT 1.0 behavior</a>. With XSLT 1.0
behavior,</span> the effective sort key value is the first item in
the sequence. In other cases, this is a <a title="type error"
class="termref" href="#dt-type-error">type error</a>.</p>
</dd>
<dt><a href="#err-XTTE1100"><span class="error">ERR
XTTE1100</span></a></dt>
<dd>
<p>It is a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> if the result of evaluating the
<code>group-adjacent</code> expression is an empty sequence or a
sequence containing more than one item, <span>unless
<code>composite="yes"</code> is specified.</span></p>
</dd>
<dt><a href="#err-XTTE1510"><span class="error">ERR
XTTE1510</span></a></dt>
<dd>
<p>If the <code>validation</code> attribute of an <a href=
"#element-element"><code>xsl:element</code></a>, <a href=
"#element-attribute"><code>xsl:attribute</code></a>, <a href=
"#element-copy"><code>xsl:copy</code></a>, <a href=
"#element-copy-of"><code>xsl:copy-of</code></a>, or <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction, or the <code>xsl:validation</code> attribute of a
literal result element, has the effective value
<code>strict</code>, and schema validity assessment concludes that
the validity of the element or attribute is invalid or unknown, a
<a title="type error" class="termref" href="#dt-type-error">type
error</a> occurs. As with other type errors, the error <span class=
"verb">may</span> be signaled statically if it can be detected
statically.</p>
</dd>
<dt><a href="#err-XTTE1512"><span class="error">ERR
XTTE1512</span></a></dt>
<dd>
<p>If the <code>validation</code> attribute of an <a href=
"#element-element"><code>xsl:element</code></a>, <a href=
"#element-attribute"><code>xsl:attribute</code></a>, <a href=
"#element-copy"><code>xsl:copy</code></a>, <a href=
"#element-copy-of"><code>xsl:copy-of</code></a>, or <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction, or the <code>xsl:validation</code> attribute of a
literal result element, has the effective value
<code>strict</code>, and there is no matching top-level declaration
in the schema, then a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> occurs. As with other type errors,
the error <span class="verb">may</span> be signaled statically if
it can be detected statically.</p>
</dd>
<dt><a href="#err-XTTE1515"><span class="error">ERR
XTTE1515</span></a></dt>
<dd>
<p>If the <code>validation</code> attribute of an <a href=
"#element-element"><code>xsl:element</code></a>, <a href=
"#element-attribute"><code>xsl:attribute</code></a>, <a href=
"#element-copy"><code>xsl:copy</code></a>, <a href=
"#element-copy-of"><code>xsl:copy-of</code></a>, or <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction, or the <code>xsl:validation</code> attribute of a
literal result element, has the effective value <code>lax</code>,
and schema validity assessment concludes that the element or
attribute is invalid, a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> occurs. As with other type errors,
the error <span class="verb">may</span> be signaled statically if
it can be detected statically.</p>
</dd>
<dt><a href="#err-XTTE1535"><span class="error">ERR
XTTE1535</span></a></dt>
<dd>
<p>It is a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> if the value of the
<code>type</code> attribute of an <a href=
"#element-copy"><code>xsl:copy</code></a> or <a href=
"#element-copy-of"><code>xsl:copy-of</code></a> instruction refers
to a complex type definition and one or more of the items being
copied is an attribute node.</p>
</dd>
<dt><a href="#err-XTTE1540"><span class="error">ERR
XTTE1540</span></a></dt>
<dd>
<p>It is a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> if an <code>[xsl:]type</code>
attribute is defined for a constructed element or attribute, and
the outcome of schema validity assessment against that type is that
the <code>validity</code> property of that element or attribute
information item is other than <code>valid</code>.</p>
</dd>
<dt><a href="#err-XTTE1545"><span class="error">ERR
XTTE1545</span></a></dt>
<dd>
<p>A <a title="type error" class="termref" href=
"#dt-type-error">type error</a> occurs if a <code>type</code> or
<code>validation</code> attribute is defined (explicitly or
implicitly) for an instruction that constructs a new attribute
node, if the effect of this is to cause the attribute value to be
validated against a type that is derived from, or constructed by
list or union from, the primitive types <code>xs:QName</code> or
<code>xs:NOTATION</code>.</p>
</dd>
<dt><a href="#err-XTTE1550"><span class="error">ERR
XTTE1550</span></a></dt>
<dd>
<p>A <a title="type error" class="termref" href=
"#dt-type-error">type error</a> occurs [when a document node is
validated] unless the children of the document node comprise
exactly one element node, no text nodes, and zero or more comment
and processing instruction nodes, in any order.</p>
</dd>
<dt><a href="#err-XTTE1555"><span class="error">ERR
XTTE1555</span></a></dt>
<dd>
<p>It is a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> if, when validating a document
node, document-level constraints (such as ID/IDREF constraints) are
not satisfied.</p>
</dd>
<dt><a href="#err-XTTE2230"><span class="error">ERR
XTTE2230</span></a></dt>
<dd>
<p>It is a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> if some item selected by a
particular merge key in one input sequence is not comparable using
the XPath <code>le</code> operator with some item selected by the
corresponding sort key in another input sequence.</p>
</dd>
<dt><a href="#err-XTTE3090"><span class="error">ERR
XTTE3090</span></a></dt>
<dd>
<p>It is a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> if the <a href=
"#element-context-item"><code>xsl:context-item</code></a> child of
<a href="#element-template"><code>xsl:template</code></a> specifies
that a context item is required and none is supplied by the caller,
that is, if the context item is absent at the point where <a href=
"#element-call-template"><code>xsl:call-template</code></a> is
evaluated.</p>
</dd>
<dt><a href="#err-XTTE3100"><span class="error">ERR
XTTE3100</span></a></dt>
<dd>
<p>It is a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> if an <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction in a particular <code>mode</code> selects an element or
attribute whose type is <code>xs:untyped</code> or
<code>xs:untypedAtomic</code> when the <code>typed</code> attribute
of that mode specifies the value <code>yes</code>,
<code>strict</code>, or <code>lax</code>.</p>
</dd>
<dt><a href="#err-XTTE3110"><span class="error">ERR
XTTE3110</span></a></dt>
<dd>
<p>It is a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> if an <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
instruction in a particular <code>mode</code> selects an element or
attribute whose type is anything other than <code>xs:untyped</code>
or <code>xs:untypedAtomic</code> when the <code>typed</code>
attribute of that mode specifies the value <code>no</code>.</p>
</dd>
<dt><a href="#err-XTTE3170"><span class="error">ERR
XTTE3170</span></a></dt>
<dd>
<p>It is a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> if the result of evaluating the
<code>namespace-context</code> attribute of the <a href=
"#element-evaluate"><code>xsl:evaluate</code></a> instruction is
anything other than a single node.</p>
</dd>
<dt><a href="#err-XTTE3180"><span class="error">ERR
XTTE3180</span></a></dt>
<dd>
<p>It is a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> if the result of evaluating the
<code>select</code> expression [of the <a href=
"#element-copy"><code>xsl:copy</code></a> element] is a sequence of
more than one item.</p>
</dd>
<dt><a href="#err-XTTE3210"><span class="error">ERR
XTTE3210</span></a></dt>
<dd>
<p>If the result of evaluating the <code>context-item</code>
expression [of an <a href=
"#element-evaluate"><code>xsl:evaluate</code></a> instruction] is a
sequence containing more than one item, then a <a title=
"type error" class="termref" href="#dt-type-error">type error</a>
is signaled.</p>
</dd>
<dt><a href="#err-XTTE3300"><span class="error">ERR
XTTE3300</span></a></dt>
<dd>
<p>It is a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> if the result of evaluating the
<code>xsl:on-empty</code> attribute [on a literal result element]
does not satisfy the required type <code>element()?</code>. That
is, the expression must deliver either a single element node, or an
empty sequence.</p>
</dd>
<dt><a href="#err-XTTE3310"><span class="error">ERR
XTTE3310</span></a></dt>
<dd>
<p>It is a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> if the result of evaluating the
<code>on-empty</code> attribute [on the <a href=
"#element-element"><code>xsl:element</code></a> instruction] does
not satisfy the required type <code>element()?</code>. That is, the
expression must deliver either a single element node, or an empty
sequence.</p>
</dd>
<dt><a href="#err-XTTE3330"><span class="error">ERR
XTTE3330</span></a></dt>
<dd>
<p>It is a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> if the result of evaluating the
<code>on-empty</code> attribute [on the <a href=
"#element-copy"><code>xsl:copy</code></a> instruction] does not
satisfy the required type <code>element()?</code>. That is, the
expression must deliver either a single element node, or an empty
sequence.</p>
</dd>
<dt><a href="#err-XTTE3375"><span class="error">ERR
XTTE3375</span></a></dt>
<dd>
<p>A type error occurs if the result of evaluating the sequence
constructor [within an <a href=
"#element-map"><code>xsl:map</code></a> instruction] is not an
instance of the required type <code>map(*)*</code>.</p>
</dd>
</dl>
<p><b>Dynamic errors</b></p>
<dl>
<dt><a href="#err-XTDE0030"><span class="error">ERR
XTDE0030</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the <a title=
"effective value" class="termref" href=
"#dt-effective-value">effective value</a> of an attribute written
using curly brackets, in a position where an <a title=
"attribute value template" class="termref" href=
"#dt-attribute-value-template">attribute value template</a> is
permitted, is a value that is not one of the permitted values for
that attribute. If the processor is able to detect the error
statically (for example, when any XPath expressions within the
curly brackets can be evaluated statically), then the processor may
optionally signal this as a static error.</p>
</dd>
<dt><a href="#err-XTDE0040"><span class="error">ERR
XTDE0040</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the invocation of the
<a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> specifies a template name that does
not match the <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> of a named template defined
in the <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a>, <span>whose visibility is
<code>public</code> or <code>final</code></span>.</p>
</dd>
<dt><a href="#err-XTDE0041"><span class="error">ERR
XTDE0041</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the invocation of the
<a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> specifies a function name and arity
that does not match the <a title="expanded QName" class="termref"
href="#dt-expanded-qname">expanded QName</a> and arity of a named
<a title="stylesheet function" class="termref" href=
"#dt-stylesheet-function">stylesheet function</a> defined in the
<a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a>, whose visibility is
<code>public</code> or <code>final</code>.</p>
</dd>
<dt><a href="#err-XTDE0044"><span class="error">ERR
XTDE0044</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the invocation of the
<a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> specifies an initial <a title=
"mode" class="termref" href="#dt-mode">mode</a> and if no
<span><a title="initial match selection" class="termref" href=
"#dt-initial-match-selection">initial match selection</a> is
supplied (either explicitly, or defaulted to the <a title=
"global context item" class="termref" href=
"#dt-global-context-item">global context item</a>)</span>.</p>
</dd>
<dt><a href="#err-XTDE0045"><span class="error">ERR
XTDE0045</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the invocation of the
<a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> specifies an initial <a title=
"mode" class="termref" href="#dt-mode">mode</a> (other than the
unnamed mode) that does not match <span>either the <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a> in the <code>name</code> attribute of an <a href=
"#element-mode"><code>xsl:mode</code></a> declaration, or</span>
the <a title="expanded QName" class="termref" href=
"#dt-expanded-qname">expanded QName</a> in the <code>mode</code>
attribute of any template defined in the <a title="stylesheet"
class="termref" href="#dt-stylesheet">stylesheet</a>.</p>
</dd>
<dt><a href="#err-XTDE0050"><span class="error">ERR
XTDE0050</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if a stylesheet declares a
visible <a title="stylesheet parameter" class="termref" href=
"#dt-stylesheet-parameter">stylesheet parameter</a> with
<code>required="yes"</code> and no value for this parameter is
supplied when the stylesheet is primed. A stylesheet parameter is
visible if it is not masked by another global variable or parameter
with the same name and higher <a title="import precedence" class=
"termref" href="#dt-import-precedence">import precedence</a>.
<span>If the parameter is a <a title="static parameter" class=
"termref" href="#dt-static-parameter">static parameter</a> then the
value <span class="verb">must</span> be supplied prior to the
static analysis phase.</span></p>
</dd>
<dt><a href="#err-XTDE0160"><span class="error">ERR
XTDE0160</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if an element has an
<a title="effective version" class="termref" href=
"#dt-effective-version">effective version</a> of <var>V</var> (with
<var>V</var> &lt; 3.0) when the implementation does not support
backwards compatible behavior for XSLT version <var>V</var>.</p>
</dd>
<dt><a href="#err-XTDE0290"><span class="error">ERR
XTDE0290</span></a></dt>
<dd>
<p>Where the result of evaluating an XPath expression (or an
attribute value template) is required to be a <a title=
"lexical QName" class="termref" href="#dt-lexical-qname">lexical
QName</a>, or if it is permitted to be a <a title="lexical QName"
class="termref" href="#dt-lexical-qname">lexical QName</a> and the
actual value takes the form of a <a title="lexical QName" class=
"termref" href="#dt-lexical-qname">lexical QName</a>, then unless
otherwise specified it is a <a title="dynamic error" class=
"termref" href="#dt-dynamic-error">dynamic error</a> if the value
has a prefix and the <a title="defining element" class="termref"
href="#dt-defining-element">defining element</a> has no namespace
node whose name matches that prefix. This error <span class=
"verb">may</span> be signaled as a <a title="static error" class=
"termref" href="#dt-static-error">static error</a> if the value of
the expression can be determined statically.</p>
</dd>
<dt><a href="#err-XTDE0410"><span class="error">ERR
XTDE0410</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the result sequence used
to construct the content of an element node contains a namespace
node or attribute node that is preceded in the sequence by a node
that is neither a namespace node nor an attribute node.</p>
</dd>
<dt><a href="#err-XTDE0420"><span class="error">ERR
XTDE0420</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the result sequence used
to construct the content of a document node contains a namespace
node or attribute node.</p>
</dd>
<dt><a href="#err-XTDE0430"><span class="error">ERR
XTDE0430</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the result sequence
contains two or more namespace nodes having the same name but
different <a title="string value" class="termref" href=
"#dt-string-value">string values</a> (that is, namespace nodes that
map the same prefix to different namespace URIs).</p>
</dd>
<dt><a href="#err-XTDE0440"><span class="error">ERR
XTDE0440</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the result sequence
contains a namespace node with no name and the element node being
constructed has a null namespace URI (that is, it is an error to
define a default namespace when the element is in no
namespace).</p>
</dd>
<dt><a href="#err-XTDE0450"><span class="error">ERR
XTDE0450</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the result sequence
contains a function item.</p>
</dd>
<dt><a href="#err-XTDE0540"><span class="error">ERR
XTDE0540</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the conflict resolution
algorithm for template rules leaves more than one matching template
rule <span>when the declaration of the relevant <a title="mode"
class="termref" href="#dt-mode">mode</a> has an
<code>on-multiple-match</code> attribute with the value
<code>fail</code></span>.</p>
</dd>
<dt><a href="#err-XTDE0555"><span class="error">ERR
XTDE0555</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>,
<a href="#element-apply-imports"><code>xsl:apply-imports</code></a>
or <a href="#element-next-match"><code>xsl:next-match</code></a> is
used to process a node using a mode whose declaration specifies
<code>on-no-match="fail"</code> when there is no <a title=
"template rule" class="termref" href="#dt-template-rule">template
rule</a> in the <a title="stylesheet" class="termref" href=
"#dt-stylesheet">stylesheet</a> whose match pattern matches that
node.</p>
</dd>
<dt><a href="#err-XTDE0560"><span class="error">ERR
XTDE0560</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if <a href=
"#element-apply-imports"><code>xsl:apply-imports</code></a> or
<a href="#element-next-match"><code>xsl:next-match</code></a> is
evaluated when the <a title="current template rule" class="termref"
href="#dt-current-template-rule">current template rule</a> is
<span><a title="absent" class="termref" href=
"#dt-absent">absent</a></span>.</p>
</dd>
<dt><a href="#err-XTDE0640"><span class="error">ERR
XTDE0640</span></a></dt>
<dd>
<p>In general, a <a title="circularity" class="termref" href=
"#dt-circularity">circularity</a> in a <a title="stylesheet" class=
"termref" href="#dt-stylesheet">stylesheet</a> is a <a title=
"dynamic error" class="termref" href="#dt-dynamic-error">dynamic
error</a>.</p>
</dd>
<dt><a href="#err-XTDE0700"><span class="error">ERR
XTDE0700</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if a template that has an
<a title="explicitly mandatory" class="termref" href=
"#dt-explicitly-mandatory">explicitly mandatory</a> or <a title=
"implicitly mandatory" class="termref" href=
"#dt-implicitly-mandatory">implicitly mandatory</a> parameter is
invoked without supplying a value for that parameter.</p>
</dd>
<dt><a href="#err-XTDE0820"><span class="error">ERR
XTDE0820</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the <a title=
"effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the <code>name</code>
attribute [of the <a href=
"#element-element"><code>xsl:element</code></a> instruction] is not
a <a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a>.</p>
</dd>
<dt><a href="#err-XTDE0830"><span class="error">ERR
XTDE0830</span></a></dt>
<dd>
<p>In the case of an <a href=
"#element-element"><code>xsl:element</code></a> instruction with no
<code>namespace</code> attribute, it is a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
<a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the <code>name</code>
attribute is a <a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a> whose prefix is not declared
in an in-scope namespace declaration for the <a href=
"#element-element"><code>xsl:element</code></a> instruction.</p>
</dd>
<dt><a href="#err-XTDE0835"><span class="error">ERR
XTDE0835</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the <a title=
"effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the
<code>namespace</code> attribute [of the <a href=
"#element-element"><code>xsl:element</code></a> instruction] is not
in the lexical space of the <code>xs:anyURI</code> datatype or if
it is the string <code>http://www.w3.org/2000/xmlns/</code>.</p>
</dd>
<dt><a href="#err-XTDE0850"><span class="error">ERR
XTDE0850</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the <a title=
"effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the <code>name</code>
attribute [of an <a href=
"#element-attribute"><code>xsl:attribute</code></a> instruction] is
not a <a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a>.</p>
</dd>
<dt><a href="#err-XTDE0855"><span class="error">ERR
XTDE0855</span></a></dt>
<dd>
<p>In the case of an <a href=
"#element-attribute"><code>xsl:attribute</code></a> instruction
with no <code>namespace</code> attribute, it is a <a title=
"dynamic error" class="termref" href="#dt-dynamic-error">dynamic
error</a> if the <a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the <code>name</code>
attribute is the string <code>xmlns</code>.</p>
</dd>
<dt><a href="#err-XTDE0860"><span class="error">ERR
XTDE0860</span></a></dt>
<dd>
<p>In the case of an <a href=
"#element-attribute"><code>xsl:attribute</code></a> instruction
with no <code>namespace</code> attribute, it is a <a title=
"dynamic error" class="termref" href="#dt-dynamic-error">dynamic
error</a> if the <a title="effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the <code>name</code>
attribute is a <a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a> whose prefix is not declared
in an in-scope namespace declaration for the <a href=
"#element-attribute"><code>xsl:attribute</code></a>
instruction.</p>
</dd>
<dt><a href="#err-XTDE0865"><span class="error">ERR
XTDE0865</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the <a title=
"effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the
<code>namespace</code> attribute [of the <a href=
"#element-attribute"><code>xsl:attribute</code></a> instruction] is
not in the lexical space of the <code>xs:anyURI</code> datatype or
if it is the string <code>http://www.w3.org/2000/xmlns/</code>.</p>
</dd>
<dt><a href="#err-XTDE0890"><span class="error">ERR
XTDE0890</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the <a title=
"effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the <code>name</code>
attribute [of the <a href=
"#element-processing-instruction"><code>xsl:processing-instruction</code></a>
instruction] is not both an <a href=
"http://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a><sup><small>Names</small></sup>
and a <a href=
"http://www.w3.org/TR/REC-xml/#NT-PITarget">PITarget</a><sup><small>XML</small></sup>.</p>
</dd>
<dt><a href="#err-XTDE0905"><span class="error">ERR
XTDE0905</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the string value of the
new namespace node is not valid in the lexical space of the
datatype <code>xs:anyURI</code>, or if it is the string
<code>http://www.w3.org/2000/xmlns/</code>.</p>
</dd>
<dt><a href="#err-XTDE0920"><span class="error">ERR
XTDE0920</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the <a title=
"effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the <code>name</code>
attribute [of the <a href=
"#element-namespace"><code>xsl:namespace</code></a> instruction] is
neither a zero-length string nor an <a href=
"http://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a><sup><small>Names</small></sup>,
or if it is <code>xmlns</code>.</p>
</dd>
<dt><a href="#err-XTDE0925"><span class="error">ERR
XTDE0925</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the <a href=
"#element-namespace"><code>xsl:namespace</code></a> instruction
generates a namespace node whose name is <code>xml</code> and whose
string value is not
<code>http://www.w3.org/XML/1998/namespace</code>, or a namespace
node whose string value is
<code>http://www.w3.org/XML/1998/namespace</code> and whose name is
not <code>xml</code>.</p>
</dd>
<dt><a href="#err-XTDE0930"><span class="error">ERR
XTDE0930</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if evaluating the
<code>select</code> attribute or the contained <a title=
"sequence constructor" class="termref" href=
"#dt-sequence-constructor">sequence constructor</a> of an <a href=
"#element-namespace"><code>xsl:namespace</code></a> instruction
results in a zero-length string.</p>
</dd>
<dt><a href="#err-XTDE0980"><span class="error">ERR
XTDE0980</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if any undiscarded item in
the atomized sequence supplied as the value of the
<code>value</code> attribute of <a href=
"#element-number"><code>xsl:number</code></a> cannot be converted
to an integer, or if the resulting integer is less than 0
(zero).</p>
</dd>
<dt><a href="#err-XTDE1001"><span class="error">ERR
XTDE1001</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the <a title=
"effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the
<code>start-at</code> attribute of the <a href=
"#element-number"><code>xsl:number</code></a> instruction is not in
the lexical space of <code>xs:integer</code>. The error may be
signaled statically if it can be detected statically.</p>
</dd>
<dt><a href="#err-XTDE1030"><span class="error">ERR
XTDE1030</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if, for any <a title=
"sort key component" class="termref" href=
"#dt-sort-key-component">sort key component</a>, the set of
<a title="sort key value" class="termref" href=
"#dt-sort-key-value">sort key values</a> evaluated for all the
items in the <a title="initial sequence" class="termref" href=
"#dt-initial-sequence">initial sequence</a>, after any type
conversion requested, contains a pair of ordinary values for which
the result of the XPath <code>lt</code> operator is an error.
<span>If the processor is able to detect the error statically, it
<span class="verb">may</span> optionally signal it as a <a title=
"static error" class="termref" href="#dt-static-error">static
error</a>.</span></p>
</dd>
<dt><a href="#err-XTDE1035"><span class="error">ERR
XTDE1035</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the <code>collation</code>
attribute of <a href="#element-sort"><code>xsl:sort</code></a>
(after resolving against the base URI) is not a URI that is
recognized by the implementation as referring to a collation.</p>
</dd>
<dt><a href="#err-XTDE1061"><span class="error">ERR
XTDE1061</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the <a href=
"#func-current-group"><code>current-group</code></a> function is
used when the current group is <a title="absent" class="termref"
href="#dt-absent">absent</a> <span>, or when it is invoked in the
course of evaluating a pattern</span>. The error <span class=
"verb">may</span> be reported statically if it can be detected
statically.</p>
</dd>
<dt><a href="#err-XTDE1071"><span class="error">ERR
XTDE1071</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the <a href=
"#func-current-grouping-key"><code>current-grouping-key</code></a>
function is used when the current grouping key is <a title="absent"
class="termref" href="#dt-absent">absent</a>, <span>or when it is
invoked in the course of evaluating a pattern.</span> The error
<span class="verb">may</span> be reported statically if it can be
detected statically.</p>
</dd>
<dt><a href="#err-XTDE1110"><span class="error">ERR
XTDE1110</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the collation URI
specified to <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>
(after resolving against the base URI) is a collation that is not
recognized by the implementation. (For notes, <span class=
"error">[see <a href="#err-XTDE1035">ERR XTDE1035</a>]</span>.)</p>
</dd>
<dt><a href="#err-XTDE1140"><span class="error">ERR
XTDE1140</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the <a title=
"effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the <code>regex</code>
attribute [of the <a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a>
instruction] does not conform to the <span class=
"verb">required</span> syntax for regular expressions, as specified
in <a href="#xpath-functions-30">[Functions and Operators]</a>. If
the regular expression is known statically (for example, if the
attribute does not contain any <a title="expression" class=
"termref" href="#dt-expression">expressions</a> enclosed in curly
brackets) then the processor <span class="verb">may</span> signal
the error as a <a title="static error" class="termref" href=
"#dt-static-error">static error</a>.</p>
</dd>
<dt><a href="#err-XTDE1145"><span class="error">ERR
XTDE1145</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the <a title=
"effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the <code>flags</code>
attribute [of the <a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a>
instruction] has a value other than the values defined in <a href=
"#xpath-functions-30">[Functions and Operators]</a>. If the value
of the attribute is known statically (for example, if the attribute
does not contain any <a title="expression" class="termref" href=
"#dt-expression">expressions</a> enclosed in curly brackets) then
the processor <span class="verb">may</span> signal the error as a
<a title="static error" class="termref" href=
"#dt-static-error">static error</a>.</p>
</dd>
<dt><a href="#err-XTDE1160"><span class="error">ERR
XTDE1160</span></a></dt>
<dd>
<p>When a URI reference [supplied to the <a href=
"#func-document"><code>document</code></a> function] contains a
fragment identifier, it is a <a title="dynamic error" class=
"termref" href="#dt-dynamic-error">dynamic error</a> if the media
type is not one that is recognized by the processor, or if the
fragment identifier does not conform to the rules for fragment
identifiers for that media type, or if the fragment identifier
selects something other than a sequence of nodes (for example, if
it selects a range of characters within a text node).</p>
</dd>
<dt><a href="#err-XTDE1162"><span class="error">ERR
XTDE1162</span></a></dt>
<dd>
<p>When a URI reference [supplied to the <a href=
"#func-document"><code>document</code></a> function] is a relative
reference, it is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if no base URI is available
to resolve the relative reference. This can arise for example when
the URI is contained in a node that has no base URI (for example a
parentless text node), or when the second argument to the function
is a node that has no base URI, or when the base URI from the
static context is undefined.</p>
</dd>
<dt><a href="#err-XTDE1260"><span class="error">ERR
XTDE1260</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the value [of the first
argument to the <a href="#func-key"><code>key</code></a> function]
is not a valid QName, or if there is no namespace declaration in
scope for the prefix of the QName, or if the name obtained by
expanding the QName is not the same as the expanded name of any
<a href="#element-key"><code>xsl:key</code></a> declaration in the
<span>containing <a title="package" class="termref" href=
"#dt-package">package</a></span>. If the processor is able to
detect the error statically (for example, when the argument is
supplied as a string literal), then the processor <span class=
"verb">may</span> optionally signal this as a <a title=
"static error" class="termref" href="#dt-static-error">static
error</a>.</p>
</dd>
<dt><a href="#err-XTDE1270"><span class="error">ERR
XTDE1270</span></a></dt>
<dd>
<p>It is a <span><a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a></span> to call the <a href=
"#func-key"><code>key</code></a> function with two arguments if
there is no <a title="context node" class="termref" href=
"#dt-context-node">context node</a>, or if the root of the tree
containing the context node is not a document node; or to call the
function with three arguments if the root of the tree containing
the node supplied in the third argument is not a document node.</p>
</dd>
<dt><a href="#err-XTDE1360"><span class="error">ERR
XTDE1360</span></a></dt>
<dd>
<p>If the <a href="#func-current"><code>current</code></a> function
is evaluated within an expression that is evaluated when the
context item is absent, a <a title="dynamic error" class="termref"
href="#dt-dynamic-error">dynamic error</a> occurs.</p>
</dd>
<dt><a href="#err-XTDE1370"><span class="error">ERR
XTDE1370</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the <a href=
"#func-unparsed-entity-uri"><code>unparsed-entity-uri</code></a>
function is called when there is no <a title="context node" class=
"termref" href="#dt-context-node">context node</a>, or when the
root of the tree containing the context node is not a document
node.</p>
</dd>
<dt><a href="#err-XTDE1380"><span class="error">ERR
XTDE1380</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the <a href=
"#func-unparsed-entity-public-id"><code>unparsed-entity-public-id</code></a>
function is called when there is no <a title="context node" class=
"termref" href="#dt-context-node">context node</a>, or when the
root of the tree containing the context node is not a document
node.</p>
</dd>
<dt><a href="#err-XTDE1390"><span class="error">ERR
XTDE1390</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the value supplied as the
<code>$property-name</code> argument [to the <a href=
"#func-system-property"><code>system-property</code></a> function]
is not a valid QName, or if there is no namespace declaration in
scope for the prefix of the QName. If the processor is able to
detect the error statically (for example, when the argument is
supplied as a string literal), then the processor <span class=
"verb">may</span> optionally signal this as a <a title=
"static error" class="termref" href="#dt-static-error">static
error</a>.</p>
</dd>
<dt><a href="#err-XTDE1400"><span class="error">ERR
XTDE1400</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the argument [passed to
the <a href=
"#func-function-available"><code>function-available</code></a>
function] does not evaluate to a string that is a valid <a title=
"EQName" class="termref" href="#dt-eqname">EQName</a>, or if the
value is a <a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a> with a prefix for which no
namespace declaration is present in the static context. If the
processor is able to detect the error statically (for example, when
the argument is supplied as a string literal), then the processor
<span class="verb">may</span> optionally signal this as a <a title=
"static error" class="termref" href="#dt-static-error">static
error</a>.</p>
</dd>
<dt><a href="#err-XTDE1420"><span class="error">ERR
XTDE1420</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the arguments supplied to
a call on an extension function do not satisfy the rules defined
for that particular extension function, or if the extension
function reports an error, or if the result of the extension
function cannot be converted to an XPath value.</p>
</dd>
<dt><a href="#err-XTDE1425"><span class="error">ERR
XTDE1425</span></a></dt>
<dd>
<p><span>When the containing element is processed with <a title=
"XSLT 1.0 behavior" class="termref" href=
"#dt-xslt-10-behavior">XSLT 1.0 behavior</a>,</span> it is a
<a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> to evaluate an extension
function call if no implementation of the extension function is
available.</p>
</dd>
<dt><a href="#err-XTDE1428"><span class="error">ERR
XTDE1428</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the argument [passed to
the <a href="#func-type-available"><code>type-available</code></a>
function] does not evaluate to a string that is a valid <a title=
"EQName" class="termref" href="#dt-eqname">EQName</a>, or if the
value is a <a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a> with a prefix for which no
namespace declaration is present in the static context. If the
processor is able to detect the error statically (for example, when
the argument is supplied as a string literal), then the processor
<span class="verb">may</span> optionally signal this as a <a title=
"static error" class="termref" href="#dt-static-error">static
error</a>.</p>
</dd>
<dt><a href="#err-XTDE1440"><span class="error">ERR
XTDE1440</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the argument [passed to
the <a href=
"#func-element-available"><code>element-available</code></a>
function] does not evaluate to a string that is a valid <a title=
"EQName" class="termref" href="#dt-eqname">EQName</a>, or if the
value is a <a title="lexical QName" class="termref" href=
"#dt-lexical-qname">lexical QName</a> with a prefix for which no
namespace declaration is present in the static context. If the
processor is able to detect the error statically (for example, when
the argument is supplied as a string literal), then the processor
<span class="verb">may</span> optionally signal this as a <a title=
"static error" class="termref" href="#dt-static-error">static
error</a>.</p>
</dd>
<dt><a href="#err-XTDE1450"><span class="error">ERR
XTDE1450</span></a></dt>
<dd>
<p>When a <a title="processor" class="termref" href=
"#dt-processor">processor</a> performs fallback for an <a title=
"extension instruction" class="termref" href=
"#dt-extension-instruction">extension instruction</a> that is not
recognized, if the instruction element has one or more <a href=
"#element-fallback"><code>xsl:fallback</code></a> children, then
the content of each of the <a href=
"#element-fallback"><code>xsl:fallback</code></a> children
<span class="verb">must</span> be evaluated; it is a <a title=
"dynamic error" class="termref" href="#dt-dynamic-error">dynamic
error</a> if it has no <a href=
"#element-fallback"><code>xsl:fallback</code></a> children.</p>
</dd>
<dt><a href="#err-XTDE1460"><span class="error">ERR
XTDE1460</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the <a title=
"effective value" class="termref" href=
"#dt-effective-value">effective value</a> of the
<code>format</code> attribute [of an <a href=
"#element-result-document"><code>xsl:result-document</code></a>
element] is not a valid <a title="EQName" class="termref" href=
"#dt-eqname">EQName</a>, or if it does not match the <a title=
"expanded QName" class="termref" href="#dt-expanded-qname">expanded
QName</a> of an <a title="output definition" class="termref" href=
"#dt-output-definition">output definition</a> in the <a title=
"stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>.
If the processor is able to detect the error statically (for
example, when the <code>format</code> attribute contains no curly
brackets), then the processor <span class="verb">may</span>
optionally signal this as a <a title="static error" class="termref"
href="#dt-static-error">static error</a>.</p>
</dd>
<dt><a href="#err-XTDE1480"><span class="error">ERR
XTDE1480</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> to evaluate the <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction in <a title="temporary output state" class="termref"
href="#dt-temporary-output-state">temporary output state</a>.</p>
</dd>
<dt><a href="#err-XTDE1490"><span class="error">ERR
XTDE1490</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> for a transformation to
generate two or more <a title="final result tree" class="termref"
href="#dt-final-result-tree">final result trees</a> with the same
URI.</p>
</dd>
<dt><a href="#err-XTDE1500"><span class="error">ERR
XTDE1500</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> for a <a title="stylesheet"
class="termref" href="#dt-stylesheet">stylesheet</a> to write to an
external resource and read from the same resource during a single
transformation, <span>if the same absolute URI is used to access
the resource in both cases</span>.</p>
</dd>
<dt><a href="#err-XTDE1665"><span class="error">ERR
XTDE1665</span></a></dt>
<dd>
<p>A <a title="non-schema-aware processor" class="termref" href=
"#dt-non-schema-aware-processor">non-schema-aware processor</a>
<span class="verb">must</span> raise a <a title="dynamic error"
class="termref" href="#dt-dynamic-error">dynamic error</a> if the
input to the processor includes a node with a <a title=
"type annotation" class="termref" href="#dt-type-annotation">type
annotation</a> other than <code>xs:untyped</code> or
<code>xs:untypedAtomic</code>, or an atomic value of a type other
than those which a basic XSLT processor supports.</p>
</dd>
<dt><a href="#err-XTDE2210"><span class="error">ERR
XTDE2210</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if there are two <a href=
"#element-merge-key"><code>xsl:merge-key</code></a> elements that
occupy corresponding positions among the <a href=
"#element-merge-key"><code>xsl:merge-key</code></a> children of two
different <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> elements
and that have differing <a title="effective value" class="termref"
href="#dt-effective-value">effective values</a> for any of the
attributes <code>lang</code>, <code>order</code>,
<code>collation</code>, <code>case-order</code>, or
<code>data-type</code>. Values are considered to differ if the
attribute is present on one element and not on the other, or if it
is present on both elements with <a title="effective value" class=
"termref" href="#dt-effective-value">effective values</a> that are
not equal to each other. In the case of the <code>collation</code>
attribute, the values are compared as absolute URIs after resolving
against the base URI. The error <span class="verb">may</span> be
reported statically if it is detected statically.</p>
</dd>
<dt><a href="#err-XTDE2220"><span class="error">ERR
XTDE2220</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if any input sequence to an
<a href="#element-merge"><code>xsl:merge</code></a> instruction
contains two items that are not correctly sorted according to the
merge key values defined on the <a href=
"#element-merge-key"><code>xsl:merge-key</code></a> children of the
corresponding <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> element,
when compared using the collation rules defined by the attributes
of the corresponding <a href=
"#element-merge-key"><code>xsl:merge-key</code></a> children of the
<a href="#element-merge"><code>xsl:merge</code></a> instruction,
unless the attribute <code>sort-before-merge</code> is present with
the value <code>yes</code>.</p>
</dd>
<dt><a href="#err-XTDE3052"><span class="error">ERR
XTDE3052</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if an invocation of an absent
component (that is, an abstract component accepted into a using
package with <code>visibility="absent"</code>) is evaluated.</p>
</dd>
<dt><a href="#err-XTDE3160"><span class="error">ERR
XTDE3160</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the <a title=
"target expression" class="termref" href=
"#dt-target-expression">target expression</a> [of an <a href=
"#element-evaluate"><code>xsl:evaluate</code></a> instruction] is
not a valid XPath 3.0 expression (that is, if a static error occurs
when analyzing the string according to the rules of the XPath 3.0
specification).</p>
</dd>
<dt><a href="#err-XTDE3175"><span class="error">ERR
XTDE3175</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if an <a href=
"#element-evaluate"><code>xsl:evaluate</code></a> instruction is
evaluated when use of <a href=
"#element-evaluate"><code>xsl:evaluate</code></a> has been
statically or dynamically disabled.</p>
</dd>
<dt><a href="#err-XTDE3240"><span class="error">ERR
XTDE3240</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the value of
<code>$input</code> does not conform to the JSON grammar <span>as
defined by <a href="#rfc7159">[RFC 7159]</a>, allowing
implementation-defined extensions if the <code>liberal</code>
option is set to <code>yes</code></span>.</p>
</dd>
<dt><a href="#err-XTDE3245"><span class="error">ERR
XTDE3245</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the value of the
<code>validate</code> option is <code>true</code> and the processor
is not schema-aware.</p>
</dd>
<dt><a href="#err-XTDE3250"><span class="error">ERR
XTDE3250</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the value of
<code>$input</code> contains an escaped representation of a
character (or codepoint) that is not a valid character in the
version of XML supported by the implementation, unless the
<code>unescape</code> option is set to false.</p>
</dd>
<dt><a href="#err-XTDE3255"><span class="error">ERR
XTDE3255</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the value of
<code>$options</code> includes an entry whose key is
<code>indent</code>, <code>validate</code>, <code>unescape</code>,
or <code>fallback</code>, and whose value is not a permitted value
for that key.</p>
</dd>
<dt><a href="#err-XTDE3260"><span class="error">ERR
XTDE3260</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the value of
<code>$options</code> includes an entry whose key is
<span><code>liberal</code>, <code>validate</code>,
<code>unescape</code>, or <code>fallback</code>, and whose value is
not a permitted value for that key</span>.</p>
</dd>
<dt><a href="#err-XTDE3265"><span class="error">ERR
XTDE3265</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the value of
<code>$input</code> is not valid according to the schema for the
XML representation of JSON.</p>
</dd>
<dt><a href="#err-XTDE3340"><span class="error">ERR
XTDE3340</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the value of the first
argument to the <a href=
"#func-accumulator-before"><code>accumulator-before</code></a> or
<a href=
"#func-accumulator-after"><code>accumulator-after</code></a>
function is not a valid <a title="EQName" class="termref" href=
"#dt-eqname">EQName</a>, or if there is no namespace declaration in
scope for the prefix of the QName, or if the name obtained by
expanding the QName is not the same as the expanded name of any
<a href="#element-accumulator"><code>xsl:accumulator</code></a>
declaration visible in the <a title="package" class="termref" href=
"#dt-package">package</a> in which the function call appears. If
the processor is able to detect the error statically (for example,
when the argument is supplied as a string literal), then the
processor <span class="verb">may</span> optionally signal this as a
<a title="static error" class="termref" href=
"#dt-static-error">static error</a>.</p>
</dd>
<dt><a href="#err-XTDE3350"><span class="error">ERR
XTDE3350</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> to call the <a href=
"#func-accumulator-before"><code>accumulator-before</code></a> or
<a href=
"#func-accumulator-after"><code>accumulator-after</code></a>
function when there is no <a title="context item" class="termref"
href="#dt-context-item">context item</a>.</p>
</dd>
<dt><a href="#err-XTTE3360"><span class="error">ERR
XTTE3360</span></a></dt>
<dd>
<p>It is a <a title="type error" class="termref" href=
"#dt-type-error">type error</a> to call the <a href=
"#func-accumulator-before"><code>accumulator-before</code></a> or
<a href=
"#func-accumulator-after"><code>accumulator-after</code></a>
function when the <a title="context item" class="termref" href=
"#dt-context-item">context item</a> is not a node, or when it is an
attribute or namespace node.</p>
</dd>
<dt><a href="#err-XTDE3362"><span class="error">ERR
XTDE3362</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> to call the <a href=
"#func-accumulator-before"><code>accumulator-before</code></a> or
<a href=
"#func-accumulator-after"><code>accumulator-after</code></a>
function when the context item is a node in a streamed document,
unless the selected accumulator is declared with
<code>streamable="yes"</code>.</p>
</dd>
<dt><a href="#err-XTDE3365"><span class="error">ERR
XTDE3365</span></a></dt>
<dd>
<p>A <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> occurs if the set of keys in
the maps resulting from evaluating the sequence constructor [within
an <a href="#element-map"><code>xsl:map</code></a> instruction]
contains duplicates.</p>
</dd>
<dt><a href="#err-XTDE3368"><span class="error">ERR
XTDE3368</span></a></dt>
<dd>
<p>A <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> occurs if the set of keys in
a map produced by the evaluation of any expression or instruction
contains an instance of any of the types <code>xs:dateTime</code>,
<code>xs:date</code>, <code>xs:time</code>, <code>xs:gYear</code>
<code>xs:gYearMonth</code>, <code>xs:gMonth</code>,
<code>xs:gMonthDay</code>, or <code>xs:gDay</code> having a
timezone and also contains an instance of any of these types having
no timezone.</p>
</dd>
<dt><a href="#err-XTDE3400"><span class="error">ERR
XTDE3400</span></a></dt>
<dd>
<p>It is an error if there is a cyclic set of dependencies among
accumulators such that the (pre- or post-descent) value of an
accumulator depends directly or indirectly on itself. A processor
<span class="verb">may</span> report this as a <a title=
"static error" class="termref" href="#dt-static-error">static
error</a> if it can be detected statically. Alternatively a
processor <span class="verb">may</span> report this as a <a title=
"dynamic error" class="termref" href="#dt-dynamic-error">dynamic
error</a>. As a further option, a processor may fail
catastrophically when this error occurs.</p>
</dd>
<dt><a href="#err-XTDE3480"><span class="error">ERR
XTDE3480</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the <a href=
"#func-current-merge-group"><code>current-merge-group</code></a>
function is used when the current merge group is <a title="absent"
class="termref" href="#dt-absent">absent</a>. The error
<span class="verb">may</span> be reported statically if it can be
detected statically.</p>
</dd>
<dt><a href="#err-XTDE3490"><span class="error">ERR
XTDE3490</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the <code>$source</code>
argument of the <a href=
"#func-current-merge-group"><code>current-merge-group</code></a>
function does not match the <code>name</code> attribute of any
<a href="#element-merge-source"><code>xsl:merge-source</code></a>
element for the current merge operation. The error <span class=
"verb">may</span> be reported statically if it can be detected
statically.</p>
</dd>
<dt><a href="#err-XTDE3510"><span class="error">ERR
XTDE3510</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if the <a href=
"#func-current-merge-key"><code>current-merge-key</code></a>
function is used when the current <span>merge</span> key is
<a title="absent" class="termref" href="#dt-absent">absent</a>, or
when it is invoked in the course of evaluating a pattern. The error
<span class="verb">may</span> be reported statically if it can be
detected statically.</p>
</dd>
<dt><a href="#err-XTDE3530"><span class="error">ERR
XTDE3530</span></a></dt>
<dd>
<p>It is a <a title="dynamic error" class="termref" href=
"#dt-dynamic-error">dynamic error</a> if an <a href=
"#element-try"><code>xsl:try</code></a> instruction is unable to
recover the state of a final result tree because recovery has been
disabled by use of the attribute
<code>rollback-output="no"</code>.</p>
</dd>
<dt><a href="#err-XTMM9000"><span class="error">ERR
XTMM9000</span></a></dt>
<dd>
<p>When a transformation is terminated by use of <code>xsl:message
terminate="yes"</code>, the effect is the same as when a <a title=
"dynamic error" class="termref" href="#dt-dynamic-error">dynamic
error</a> occurs during the transformation. <span>The default error
code is <code>XTMM9000</code>; this may be overridden using the
<code>error-code</code> attribute of the <a href=
"#element-message"><code>xsl:message</code></a>
instruction.</span></p>
</dd>
<dt><a href="#err-XTMM9001"><span class="error">ERR
XTMM9001</span></a></dt>
<dd>
<p>When a transformation is terminated by use of
<code>xsl:assert</code>, the effect is the same as when a <a title=
"dynamic error" class="termref" href="#dt-dynamic-error">dynamic
error</a> occurs during the transformation. The default error code
is <code>XTMM9001</code>; this may be overridden using the
<code>error-code</code> attribute of the <a href=
"#element-assert"><code>xsl:assert</code></a> instruction.</p>
</dd>
</dl>
<p><b>Unclassified errors</b></p>
<dl>
<dt><a href="#err-XTSE3195"><span class="error">ERR
XTSE3195</span></a></dt>
<dd>
<p>The two attributes <code>for-each-item</code> and
<code>for-each-stream</code> are mutually exclusive. The <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> element
may contain either or neither, but not both. It is a <a title=
"static error" class="termref" href="#dt-static-error">static
error</a> if both are present. Furthermore, if the
<code>for-each-stream</code> attribute is present, the only
permitted value (and the default value) of the
<code>streamable</code> attribute is <code>yes</code>.</p>
</dd>
</dl>
</div>
<div class="div1">
<h2><a name="implementation-defined-features" id=
"implementation-defined-features"></a>F Checklist of
Implementation-Defined Features (Non-Normative)</h2>
<p>This appendix provides a summary of XSLT language features whose
effect is explicitly <a title="implementation-defined" class=
"termref" href=
"#dt-implementation-defined">implementation-defined</a>. The
conformance rules (see <a href="#conformance"><i>26
Conformance</i></a>) require vendors to provide documentation that
explains how these choices have been exercised.</p>
<ol>
<li>
<p>The way in which an XSLT processor is invoked, and the way in
which values are supplied for the source document, starting node,
<a title="stylesheet parameter" class="termref" href=
"#dt-stylesheet-parameter">stylesheet parameters</a>, and <a title=
"base output URI" class="termref" href="#dt-base-output-uri">base
output URI</a>, are implementation-defined. (See <a href=
"#priming-stylesheet"><i>2.3.2 Priming a Stylesheet</i></a>)</p>
</li>
<li>
<p>The way in which a <a title="base output URI" class="termref"
href="#dt-base-output-uri">base output URI</a> is established is
<a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> (See
<a href="#post-processing"><i>2.3.6 Post-processing the Raw
Result</i></a>)</p>
</li>
<li>
<p>The mechanisms for creating new <a title="extension instruction"
class="termref" href="#dt-extension-instruction">extension
instructions</a> and <a title="extension function" class="termref"
href="#dt-extension-function">extension functions</a> are <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. (See
<a href="#extensibility"><i>2.8 Extensibility</i></a>)</p>
</li>
<li>
<p>It is <a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> whether
type errors are signaled statically. (See <a href="#errors"><i>2.11
Error Handling</i></a>)</p>
</li>
<li>
<p>Mechanisms to locate the source or executable code of a
<a title="package" class="termref" href="#dt-package">package</a>
are implementation-defined. (See <a href=
"#package-dependencies"><i>3.6.2 Dependencies between
Packages</i></a>)</p>
</li>
<li>
<p>The set of namespaces that are specially recognized by the
implementation (for example, for user-defined data elements, and
<a title="extension attribute" class="termref" href=
"#dt-extension-attribute">extension attributes</a>) is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. (See
<a href="#user-defined-top-level"><i>3.8.3 User-defined Data
Elements</i></a>)</p>
</li>
<li>
<p>The effect of user-defined data elements whose name is in a
namespace recognized by the implementation is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. (See
<a href="#user-defined-top-level"><i>3.8.3 User-defined Data
Elements</i></a>)</p>
</li>
<li>
<p>If the <a title="effective version" class="termref" href=
"#dt-effective-version">effective version</a> of any element in the
stylesheet is not 1.0 or 2.0 but is less than 3.0, the <span class=
"verb">recommended</span> action is to report a static error;
however, processors <span class="verb">may</span> recognize such
values and process the element in an <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> way. (See
<a href="#backwards"><i>3.10 Backwards Compatible
Processing</i></a>)</p>
</li>
<li>
<p>It is implementation-defined whether an <span>XSLT 3.0</span>
processor supports backwards compatible behavior for any XSLT
version earlier than XSLT 3.0. (See <a href="#backwards"><i>3.10
Backwards Compatible Processing</i></a>)</p>
</li>
<li>
<p>It is implementation-defined what forms of URI reference are
acceptable in the <code>href</code> attribute of the <a href=
"#element-include"><code>xsl:include</code></a> and <a href=
"#element-import"><code>xsl:import</code></a> elements, for
example, the URI schemes that may be used, the forms of fragment
identifier that may be used, and the media types that are
supported. (See <a href="#locating-modules"><i>3.12.1 Locating
Stylesheet Modules</i></a>)</p>
</li>
<li>
<p>An implementation may define mechanisms, above and beyond
<a href="#element-import-schema"><code>xsl:import-schema</code></a>
that allow <a title="schema component" class="termref" href=
"#dt-schema-component">schema components</a> such as type
definitions to be made available within a stylesheet. (See <a href=
"#built-in-types"><i>3.15 Built-in Types</i></a>)</p>
</li>
<li>
<p>It is implementation-defined which versions and editions of XML
and XML Namespaces (1.0 and/or 1.1) are supported. (See <a href=
"#xml-versions"><i>4.1 XML Versions</i></a>)</p>
</li>
<li>
<p>Limits on the value space of primitive datatypes, where not
fixed by <a href="#xmlschema-2">[XML Schema Part 2]</a>, are
implementation-defined. (See <a href="#limits"><i>4.7
Limits</i></a>)</p>
</li>
<li>
<p>The set of <a href=
"http://www.w3.org/TR/xpath-30/#dt-known-docs">statically known
documents</a><sup><small>XP30</small></sup> is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. (See
<a href="#static-context"><i>5.4.1 Initializing the Static
Context</i></a>)</p>
</li>
<li>
<p>The set of <a href=
"http://www.w3.org/TR/xpath-30/#dt-known-collections">statically
known collections</a><sup><small>XP30</small></sup> is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. (See
<a href="#static-context"><i>5.4.1 Initializing the Static
Context</i></a>)</p>
</li>
<li>
<p>The <a href=
"http://www.w3.org/TR/xpath-30/#dt-known-default-collection">statically
known default collection type</a><sup><small>XP30</small></sup> is
<a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. (See
<a href="#static-context"><i>5.4.1 Initializing the Static
Context</i></a>)</p>
</li>
<li>
<p>Implementations may provide user options that relax the
requirement for the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-collection"><code>collection</code></a><sup><small>FO30</small></sup>
functions (and therefore, by implication, the <a href=
"#func-document"><code>document</code></a> function) to return
stable results. The manner in which such user options are provided,
if at all, is <a title="implementation-defined" class="termref"
href="#dt-implementation-defined">implementation-defined</a>. (See
<a href="#xpath-dynamic-context"><i>5.4.3 Initializing the Dynamic
Context</i></a>)</p>
</li>
<li>
<p>The implicit timezone for a transformation is
implementation-defined. (See <a href=
"#evaluation-context"><i>5.4.3.2 Other Components of the XPath
Dynamic Context</i></a>)</p>
</li>
<li>
<p>The <a href=
"http://www.w3.org/TR/xpath-30/#dt-default-collection">default
collection</a><sup><small>XP30</small></sup> is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. (See
<a href="#evaluation-context"><i>5.4.3.2 Other Components of the
XPath Dynamic Context</i></a>)</p>
</li>
<li>
<p>The availability of dynamic context information within <a title=
"extension function" class="termref" href=
"#dt-extension-function">extension functions</a> is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. (See
<a href="#additional-dynamic-context"><i>5.4.4 Additional Dynamic
Context Components used by XSLT</i></a>)</p>
</li>
<li>
<p>The default values for the <code>warning-on-no-match</code> and
<code>warning-on-multiple-match</code> attributes of <a href=
"#element-mode"><code>xsl:mode</code></a> are <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. (See
<a href="#declaring-modes"><i>6.6.1 Declaring Modes</i></a>)</p>
</li>
<li>
<p>The form of any warnings output when there is no matching
template rule or when there are multiple matching template rules is
implementation-defined. (See <a href="#declaring-modes"><i>6.6.1
Declaring Modes</i></a>)</p>
</li>
<li>
<p>The mechanism by which the caller supplies a value for a
<a title="stylesheet parameter" class="termref" href=
"#dt-stylesheet-parameter">stylesheet parameter</a> is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. (See
<a href="#global-variables"><i>9.5 Global Variables and
Parameters</i></a>)</p>
</li>
<li>
<p>The set of extension functions available in the static context
for the target expression of <a href=
"#element-evaluate"><code>xsl:evaluate</code></a> is <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. (See
<a href="#evaluate-static-context"><i>10.4.1 Static context for the
target expression</i></a>)</p>
</li>
<li>
<p>If an <code>xml:id</code> attribute that has not been subjected
to attribute value normalization is copied from a source tree to a
result tree, it is implementation-defined whether attribute value
normalization will be applied during the copy process. (See
<a href="#shallow-copy"><i>11.9.1 Shallow Copy</i></a>)</p>
</li>
<li>
<p>The numbering sequences supported by the <a href=
"#element-number"><code>xsl:number</code></a> instructions, beyond
those defined in this specification, are implementation-defined.
(See <a href="#convert"><i>12.3 Number to String Conversion
Attributes</i></a>)</p>
</li>
<li>
<p>There <span class="verb">may</span> be implementation-defined
upper bounds on the numbers that can be formatted by <a href=
"#element-number"><code>xsl:number</code></a> using any particular
numbering sequence. (See <a href="#convert"><i>12.3 Number to
String Conversion Attributes</i></a>)</p>
</li>
<li>
<p>The set of languages for which numbering is supported by
<a href="#element-number"><code>xsl:number</code></a>, and the
method of choosing a default language, are implementation-defined.
(See <a href="#convert"><i>12.3 Number to String Conversion
Attributes</i></a>)</p>
</li>
<li>
<p>With <a href="#element-number"><code>xsl:number</code></a>, it
is <a title="implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a> what
combinations of values of the format token, the language, and the
<code>ordinal</code> attribute are supported. (See <a href=
"#convert"><i>12.3 Number to String Conversion
Attributes</i></a>)</p>
</li>
<li>
<p>If the <code>data-type</code> attribute of the <a href=
"#element-sort"><code>xsl:sort</code></a> element has a value other
than <code>text</code> or <code>number</code>, the effect is
implementation-defined. (See <a href=
"#comparing-sort-keys"><i>13.1.2 Comparing Sort Key
Values</i></a>)</p>
</li>
<li>
<p>The facilities for defining collations and allocating URIs to
identify them are implementation-defined. (See <a href=
"#collating-sequences"><i>13.1.3 Sorting Using
Collations</i></a>)</p>
</li>
<li>
<p>The algorithm used by <a href=
"#element-sort"><code>xsl:sort</code></a> to locate a collation,
given the values of the <code>lang</code> and
<code>case-order</code> attributes, is implementation-defined. (See
<a href="#collating-sequences"><i>13.1.3 Sorting Using
Collations</i></a>)</p>
</li>
<li>
<p>The set of media types recognized by the processor, for the
purpose of interpreting fragment identifiers in URI references
passed to the <a href="#func-document"><code>document</code></a>
function, is implementation-defined. (See <a href=
"#func-document"><i>20.1 fn:document</i></a>)</p>
</li>
<li>
<p>The values returned by the <a href=
"#func-system-property"><code>system-property</code></a> function,
and the names of the additional properties that are recognized, are
implementation-defined. (See <a href=
"#func-system-property"><i>20.3.4 fn:system-property</i></a>)</p>
</li>
<li>
<p>The destination and formatting of messages written using the
<a href="#element-message"><code>xsl:message</code></a> instruction
are implementation-defined. (See <a href="#message"><i>22.1
Messages</i></a>)</p>
</li>
<li>
<p>The detail of any external mechanism allowing a processor to
disable checking of assertions is implementation-defined. (See
<a href="#assertions"><i>22.2 Assertions</i></a>)</p>
</li>
<li>
<p>This specification does not define any mechanism for creating or
binding implementations of <a title="extension instruction" class=
"termref" href="#dt-extension-instruction">extension
instructions</a> or <a title="extension function" class="termref"
href="#dt-extension-function">extension functions</a>, and it is
not <span class="verb">required</span> that implementations support
any such mechanism. Such mechanisms, if they exist, are <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>. (See
<a href="#extension"><i>23 Extensibility and Fallback</i></a>)</p>
</li>
<li>
<p>The effect of an extension function returning a string
containing characters that are not permitted in XML is
implementation-defined. (See <a href=
"#calling-extension-functions"><i>23.1.2 Calling Extension
Functions</i></a>)</p>
</li>
<li>
<p>The way in which external objects are represented in the type
system is implementation-defined. (See <a href=
"#external-objects"><i>23.1.3 External Objects</i></a>)</p>
</li>
<li>
<p>The way in which a final result tree is delivered to an
application is implementation-defined. (See <a href=
"#result-trees"><i>24 Final Result Trees</i></a>)</p>
</li>
<li>
<p>There <span class="verb">may</span> be <a title=
"implementation-defined" class="termref" href=
"#dt-implementation-defined">implementation-defined</a>
restrictions on the form of absolute URI that may be used in the
<code>href</code> attribute of the <a href=
"#element-result-document"><code>xsl:result-document</code></a>
instruction. (See <a href="#creating-result-trees"><i>24.1 Creating
Final Result Trees</i></a>)</p>
</li>
<li>
<p>Implementations <span class="verb">may</span> provide additional
mechanisms allowing users to define the way in which <a title=
"final result tree" class="termref" href=
"#dt-final-result-tree">final result trees</a> are processed. (See
<a href="#creating-result-trees"><i>24.1 Creating Final Result
Trees</i></a>)</p>
</li>
<li>
<p>If serialization is supported, then the location to which a
<a title="final result tree" class="termref" href=
"#dt-final-result-tree">final result tree</a> is serialized is
implementation-defined, subject to the constraint that relative URI
<span>references</span> used to reference one tree from another
remain valid. (See <a href="#serialization"><i>25
Serialization</i></a>)</p>
</li>
<li>
<p>The default value of the <code>encoding</code> attribute of the
<a href="#element-output"><code>xsl:output</code></a> element is
implementation-defined. (See <a href="#serialization"><i>25
Serialization</i></a>)</p>
</li>
<li>
<p>It is implementation-defined which versions of XML, HTML, and
XHTML are supported in the <code>version</code> attribute of the
<a href="#element-output"><code>xsl:output</code></a> declaration.
(See <a href="#serialization"><i>25 Serialization</i></a>)</p>
</li>
<li>
<p>The default value of the <code>byte-order-mark</code>
serialization parameter is implementation-defined in the case of
UTF-8 encoding. (See <a href="#serialization"><i>25
Serialization</i></a>)</p>
</li>
<li>
<p>It is implementation-defined whether, and under what
circumstances, disabling output escaping is supported. (See
<a href="#disable-output-escaping"><i>25.2 Disabling Output
Escaping</i></a>)</p>
</li>
</ol>
</div>
<div class="div1">
<h2><a name="XSLT-defined-functions" id=
"XSLT-defined-functions"></a>G List of XSLT-defined functions
(Non-Normative)</h2>
<p>This appendix acts as an index of functions defined in this
specification, to augment the set of functions defined in <a href=
"#xpath-functions-30">[Functions and Operators]</a>.</p>
<!--{xsl-query} XSLT Processor: Saxonica SAXON HE 9.4.0.3-->
<!--{xmlspec} XSLT Processor: SaxonicaSAXONHE 9.4.0.3-->
<dl>
<dt class="label"><a href=
"#func-accumulator-after"><code>accumulator-after</code></a></dt>
<dd>See <a href="#func-accumulator-after"><i>18.2.5
fn:accumulator-after</i></a></dd>
<dt class="label"><a href=
"#func-accumulator-before"><code>accumulator-before</code></a></dt>
<dd>See <a href="#func-accumulator-before"><i>18.2.4
fn:accumulator-before</i></a></dd>
<dt class="label"><a href=
"#func-collation-key"><code>collation-key</code></a></dt>
<dd>See <a href="#func-collation-key"><i>21.1.2.10
fn:collation-key</i></a></dd>
<dt class="label"><a href=
"#func-copy-of"><code>copy-of</code></a></dt>
<dd>See <a href="#func-copy-of"><i>18.3 fn:copy-of</i></a></dd>
<dt class="label"><a href=
"#func-current"><code>current</code></a></dt>
<dd>See <a href="#func-current"><i>20.3.1 fn:current</i></a></dd>
<dt class="label"><a href=
"#func-current-group"><code>current-group</code></a></dt>
<dd>See <a href="#func-current-group"><i>14.2.1
fn:current-group</i></a></dd>
<dt class="label"><a href=
"#func-current-grouping-key"><code>current-grouping-key</code></a></dt>
<dd>See <a href="#func-current-grouping-key"><i>14.2.2
fn:current-grouping-key</i></a></dd>
<dt class="label"><a href=
"#func-current-merge-group"><code>current-merge-group</code></a></dt>
<dd>See <a href="#func-current-merge-group"><i>15.6.1
fn:current-merge-group</i></a></dd>
<dt class="label"><a href=
"#func-current-merge-key"><code>current-merge-key</code></a></dt>
<dd>See <a href="#func-current-merge-key"><i>15.6.2
fn:current-merge-key</i></a></dd>
<dt class="label"><a href=
"#func-current-output-uri"><code>current-output-uri</code></a></dt>
<dd>See <a href="#func-current-output-uri"><i>24.3.1
fn:current-output-uri</i></a></dd>
<dt class="label"><a href=
"#func-deep-equal"><code>deep-equal</code></a></dt>
<dd>See <a href="#func-deep-equal"><i>21.1.2.12
fn:deep-equal</i></a></dd>
<dt class="label"><a href=
"#func-document"><code>document</code></a></dt>
<dd>See <a href="#func-document"><i>20.1 fn:document</i></a></dd>
<dt class="label"><a href=
"#func-element-available"><code>element-available</code></a></dt>
<dd>See <a href="#func-element-available"><i>23.2.2
fn:element-available</i></a></dd>
<dt class="label"><a href=
"#func-function-available"><code>function-available</code></a></dt>
<dd>See <a href="#func-function-available"><i>23.1.1
fn:function-available</i></a></dd>
<dt class="label"><a href=
"#func-json-to-xml"><code>json-to-xml</code></a></dt>
<dd>See <a href="#func-json-to-xml"><i>21.2.2
fn:json-to-xml</i></a></dd>
<dt class="label"><a href="#func-key"><code>key</code></a></dt>
<dd>See <a href="#func-key"><i>20.2.2 fn:key</i></a></dd>
<dt class="label"><a href=
"#func-map-contains"><code>map:contains</code></a></dt>
<dd>See <a href="#func-map-contains"><i>21.1.2.4
map:contains</i></a></dd>
<dt class="label"><a href=
"#func-map-entry"><code>map:entry</code></a></dt>
<dd>See <a href="#func-map-entry"><i>21.1.2.7
map:entry</i></a></dd>
<dt class="label"><a href=
"#func-map-for-each"><code>map:for-each</code></a></dt>
<dd>See <a href="#func-map-for-each"><i>21.1.2.9
map:for-each</i></a></dd>
<dt class="label"><a href=
"#func-map-get"><code>map:get</code></a></dt>
<dd>See <a href="#func-map-get"><i>21.1.2.5 map:get</i></a></dd>
<dt class="label"><a href=
"#func-map-keys"><code>map:keys</code></a></dt>
<dd>See <a href="#func-map-keys"><i>21.1.2.3 map:keys</i></a></dd>
<dt class="label"><a href=
"#func-map-merge"><code>map:merge</code></a></dt>
<dd>See <a href="#func-map-merge"><i>21.1.2.1
map:merge</i></a></dd>
<dt class="label"><a href=
"#func-map-put"><code>map:put</code></a></dt>
<dd>See <a href="#func-map-put"><i>21.1.2.6 map:put</i></a></dd>
<dt class="label"><a href=
"#func-map-remove"><code>map:remove</code></a></dt>
<dd>See <a href="#func-map-remove"><i>21.1.2.8
map:remove</i></a></dd>
<dt class="label"><a href=
"#func-map-size"><code>map:size</code></a></dt>
<dd>See <a href="#func-map-size"><i>21.1.2.2 map:size</i></a></dd>
<dt class="label"><a href=
"#func-regex-group"><code>regex-group</code></a></dt>
<dd>See <a href="#func-regex-group"><i>17.2
fn:regex-group</i></a></dd>
<dt class="label"><a href=
"#func-snapshot"><code>snapshot</code></a></dt>
<dd>See <a href="#func-snapshot"><i>18.4 fn:snapshot</i></a></dd>
<dt class="label"><a href=
"#func-stream-available"><code>stream-available</code></a></dt>
<dd>See <a href="#func-stream-available"><i>18.1.3
fn:stream-available</i></a></dd>
<dt class="label"><a href=
"#func-system-property"><code>system-property</code></a></dt>
<dd>See <a href="#func-system-property"><i>20.3.4
fn:system-property</i></a></dd>
<dt class="label"><a href=
"#func-type-available"><code>type-available</code></a></dt>
<dd>See <a href="#func-type-available"><i>23.1.4
fn:type-available</i></a></dd>
<dt class="label"><a href=
"#func-unparsed-entity-public-id"><code>unparsed-entity-public-id</code></a></dt>
<dd>See <a href="#func-unparsed-entity-public-id"><i>20.3.3
fn:unparsed-entity-public-id</i></a></dd>
<dt class="label"><a href=
"#func-unparsed-entity-uri"><code>unparsed-entity-uri</code></a></dt>
<dd>See <a href="#func-unparsed-entity-uri"><i>20.3.2
fn:unparsed-entity-uri</i></a></dd>
<dt class="label"><a href=
"#func-xml-to-json"><code>xml-to-json</code></a></dt>
<dd>See <a href="#func-xml-to-json"><i>21.2.3
fn:xml-to-json</i></a></dd>
</dl>
</div>
<div class="div1">
<h2><a name="schema-for-xslt" id="schema-for-xslt"></a>H Schema for
XSLT Stylesheets (Non-Normative)</h2>
<p>The following XSD 1.1 schema describes the structure of an XSLT
stylesheet module. It does not define all the constraints that
apply to a stylesheet (for example, it does not attempt to define a
datatype that precisely represents attributes containing XPath
<a title="expression" class="termref" href=
"#dt-expression">expressions</a>). However, every valid stylesheet
module conforms to this schema, unless it contains elements that
invoke <a title="forwards compatible behavior" class="termref"
href="#dt-forwards-compatible-behavior">forwards compatible
behavior</a>.</p>
<p>A copy of this schema is available at <a href=
"http://www.w3.org/2012/07/schema-for-xslt30.xsd">http://www.w3.org/2012/07/schema-for-xslt30.xsd</a></p>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The schema as written uses a lax wildcard to permit literal
result elements to appear in a sequence constructor. This assumes
that the schema used for validation will not contain any global
element declaration that matches the element name of a literal
result element. The content model for an element such as
<code>invoice</code> appearing within a stylesheet is not the same
as the content model for the same element appearing within a source
document (it is likely to contain XSLT instructions rather than
other elements from the target vocabulary): therefore, including
such declarations in the schema used for validating a stylesheet is
inappropriate.</p>
<p>The reason that lax validation rather than skip validation is
used is so that XSLT instructions appearing as children of the
literal result element will themselves be validated, using the
appropriate global element declaration.</p>
</div>
<div class="note">
<p class="prefix"><b>Note:</b></p>
<p>The schema uses XSD 1.1 assertions to represent some of the
non-grammatical constraints appearing in the specification, for
example the rule that some elements can have either a
<code>select</code> attribute or a contained sequence constructor,
but not both. At this stage, no attempt has been made to represent
every such constraint, even where it is not difficult to express
the rule. There will always be some constraints that cannot be
expressed at all, for example those that require access to multiple
stylesheet modules, those that require access to the in-scope
schema components, and those that involve parsing a non-regular
grammar, such as the grammar for patterns.</p>
<p>Apart from assertions, the only other significant use of XSD 1.1
features is that the elements <a href=
"#element-param"><code>xsl:param</code></a> and <a href=
"#element-variable"><code>xsl:variable</code></a> are in two
substitution groups: one containing all instructions, and one
containing all declarations. If the schema needs to be converted to
an XSD 1.0 schema, removing all assertions is straightforward; the
other change needed is to remove <a href=
"#element-param"><code>xsl:param</code></a> and <a href=
"#element-variable"><code>xsl:variable</code></a> from the
substitution group for declarations, and instead permit them
explicitly as children of <a href=
"#element-transform"><code>xsl:transform</code></a>.</p>
</div>
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!--* &lt;!DOCTYPE xs:schema PUBLIC "-//W3C//DTD XMLSCHEMA 200105//EN"
       "http://www.w3.org/2001/XMLSchema.dtd" [
&lt;!ENTITY % schemaAttrs "
  xmlns:xs   CDATA #IMPLIED
  xmlns:xsl  CDATA #IMPLIED
  xmlns:xsd  CDATA #IMPLIED"
&gt;
&lt;!ENTITY % p "xs:"&gt;
&lt;!ENTITY % s ":xs"&gt;
]&gt; *--&gt;

&lt;?xml-stylesheet href="http://www.w3.org/2008/09/xsd.xsl" type="text/xsl"?&gt; 
&lt;!--* &lt;?xml-stylesheet href="http://www.w3.org/2008/09/xsd.xsl" type="application/xslt+xml"?&gt;  *--&gt;
&lt;!--* &lt;?xml-stylesheet href="../../../www.w3.org/2008/09/xsd.xsl" type="application/xslt+xml"?&gt; *--&gt;

&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  targetNamespace="http://www.w3.org/1999/XSL/Transform" elementFormDefault="qualified"&gt;

  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      &lt;p&gt;This is an XSD 1.1 schema for XSLT 3.0 stylesheets.
      It defines all the elements that appear in the XSLT namespace; it also provides hooks that
      allow the inclusion of user-defined literal result elements, extension instructions, and
      top-level data elements.&lt;/p&gt;
      
      &lt;p&gt;This schema is available for use under the conditions of the W3C
      Software License published at http://www.w3.org/Consortium/Legal/copyright-software-19980720&lt;/p&gt;
      
      &lt;p&gt;The schema is organized as follows:&lt;/p&gt;
      &lt;ul&gt;
         &lt;li&gt;PART A: definitions of complex types and model groups used
         as the basis for element definitions&lt;/li&gt;
         &lt;li&gt;PART B: definitions of individual XSLT elements&lt;/li&gt; 
         &lt;li&gt;PART C: definitions for literal result elements&lt;/li&gt; 
         &lt;li&gt;PART D: definitions of simple types used in attribute definitions&lt;/li&gt;
      &lt;/ul&gt;
      
      &lt;p&gt;The schema has a number of limitations:&lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;The XSLT specification allows additional elements and attributes to be present
        where forwards compatibility is invoked. This schema does not.&lt;/li&gt;
        &lt;li&gt;The XSLT specification allows arbitrary content in a part of the stylesheet
        that is excluded by virtue of a use-when attribute. This schema does not.&lt;/li&gt;
        &lt;li&gt;The handling of literal result elements in this schema is imperfect; although
        various options are allowed, none matches the specification exactly. For example,
        the content of a literal result element uses lax validation, which permits child
        elements in the XSLT namespace that have no declaration in this schema.&lt;/li&gt;
        &lt;li&gt;The schema makes no attempt to check XPath expressions for syntactic or
        semantic correctness, nor to check that component references are resolved (for example
        that a template named in xsl:call-template has a declaration). Doing this in general
        requires cross-document validation, which is beyond the scope of XSD.&lt;/li&gt;
        &lt;li&gt;The schema imports the schema for XSD 1.0 schema documents. In stylesheets that contain
        an inline XSD 1.1 schema, this import should be replaced with one for the schema for XSD 1.1
        schema documents.&lt;/li&gt;
       &lt;/ul&gt;
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;

  &lt;!--
The declaration of xml:space and xml:lang may need to be commented out because
of problems processing the schema using various tools
--&gt;

  &lt;xs:import namespace="http://www.w3.org/XML/1998/namespace"/&gt;
  &lt;!--schemaLocation="http://www.w3.org/2001/xml.xsd"--&gt;

  &lt;!-- 
    An XSLT stylesheet may contain an in-line schema within an xsl:import-schema element,
    so the Schema for schemas needs to be imported
--&gt;

  &lt;xs:import namespace="http://www.w3.org/2001/XMLSchema"
    schemaLocation="http://www.w3.org/2001/XMLSchema.xsd"/&gt;

  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt; PART A: definitions of complex types and model groups used as the basis for
      element definitions &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;

  &lt;xs:complexType name="generic-element-type" mixed="true"&gt;
    &lt;xs:annotation&gt;
        &lt;xs:documentation&gt;
            &lt;p&gt;This complex type provides a generic supertype for all XSLT elements; it contains the
                definitions of the standard attributes that may appear on any element.&lt;/p&gt;    
        &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:attribute name="default-collation" type="xsl:uri-list"/&gt;
    &lt;xs:attribute name="default-mode" type="xsl:default-mode-type"/&gt;
    &lt;xs:attribute name="default-validation" type="xsl:validation-strip-or-preserve" default="strip"/&gt;
    &lt;xs:attribute name="exclude-result-prefixes" type="xsl:prefix-list-or-all"/&gt;
    &lt;xs:attribute name="expand-text" type="xsl:yes-or-no"/&gt;
    &lt;xs:attribute name="extension-element-prefixes" type="xsl:prefix-list"/&gt;
    &lt;xs:attribute name="use-when" type="xsl:expression"/&gt;
    &lt;xs:attribute name="xpath-default-namespace" type="xs:anyURI"/&gt;
    &lt;xs:attribute name="_default-collation" type="xs:string"/&gt;
    &lt;xs:attribute name="_default-mode" type="xs:string"/&gt;
    &lt;xs:attribute name="_default-validation" type="xs:string"/&gt;
    &lt;xs:attribute name="_exclude-result-prefixes" type="xs:string"/&gt;
    &lt;xs:attribute name="_expand-text" type="xs:string"/&gt;
    &lt;xs:attribute name="_extension-element-prefixes" type="xs:string"/&gt;
    &lt;xs:attribute name="_use-when" type="xs:string"/&gt;
    &lt;xs:attribute name="_xpath-default-namespace" type="xs:string"/&gt;
    &lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="versioned-element-type" mixed="true"&gt;
    &lt;xs:annotation&gt;
        &lt;xs:documentation&gt;
            &lt;p&gt;This complex type provides a generic supertype for all XSLT elements with
                the exception of &lt;code&gt;xsl:output&lt;/code&gt;; it contains the
                definitions of the &lt;code&gt;version&lt;/code&gt; attribute that may appear on any element.
                &lt;/p&gt;
             &lt;p&gt;The &lt;code&gt;xsl:output&lt;/code&gt; does not use this definition because, although it
             has a &lt;code&gt;version&lt;/code&gt; attribute, the syntax and semantics of this attribute are
             unrelated to the standard &lt;code&gt;version&lt;/code&gt; attribute allowed on other elements.&lt;/p&gt;    
        &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:extension base="xsl:generic-element-type"&gt;
        &lt;xs:attribute name="version" type="xs:decimal" use="optional"/&gt;
        &lt;xs:attribute name="_version" type="xs:string"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="element-only-versioned-element-type" mixed="false"&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:restriction base="xsl:versioned-element-type"&gt;
        &lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="sequence-constructor"&gt;
    &lt;xs:annotation&gt;
        &lt;xs:documentation&gt;
            &lt;p&gt;This complex type provides a generic supertype for all XSLT elements that
                allow a sequence constructor as their content.
                &lt;/p&gt;
        &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:versioned-element-type"&gt;
        &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="sequence-constructor-and-select"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;This complex type allows a sequence constructor and a select attribute.&lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:sequence-constructor"&gt;
        &lt;xs:attribute name="select" type="xsl:expression"/&gt;
        &lt;xs:attribute name="_select" type="xs:string"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="sequence-constructor-or-select"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;This complex type allows a sequence constructor or a select attribute, but not both.&lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:restriction base="xsl:sequence-constructor-and-select"&gt;
        &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt;
        &lt;xs:assert test="not(exists(@select) and (exists(* except xsl:fallback) or exists(text()[normalize-space()])))"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:group name="sequence-constructor-group"&gt;
    &lt;xs:annotation&gt;
        &lt;xs:documentation&gt;
            &lt;p&gt;This complex type provides a generic supertype for all XSLT elements that
                allow a sequence constructor as their content.
                &lt;/p&gt;
        &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:choice&gt;
      &lt;xs:element ref="xsl:instruction"/&gt;
      &lt;xs:group ref="xsl:result-elements"/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:group&gt;

  &lt;xs:element name="declaration" type="xsl:generic-element-type" abstract="true"/&gt;

  &lt;xs:element name="instruction" type="xsl:versioned-element-type" abstract="true"/&gt;

  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt; 
      PART B: definitions of individual XSLT elements 
      Elements are listed in alphabetical order. 
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
  
  &lt;xs:element name="accept"&gt;
    &lt;xs:annotation&gt;
        &lt;xs:documentation&gt;
            &lt;p&gt;This element appears as a child of &lt;code&gt;xsl:use-package&lt;/code&gt; and defines 
            any variations that the containing package wishes to make to the visibility of
            components made available from a library package. For example, it may indicate that
            some of the public components in the library package are not to be made available
            to the containing package.&lt;/p&gt;
        &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="component" type="xsl:component-kind-type"/&gt;
          &lt;xs:attribute name="names" type="xsl:EQNames"/&gt;
          &lt;xs:attribute name="visibility" type="xsl:visibility-type"/&gt;
          &lt;xs:attribute name="_component" type="xs:string"/&gt;
          &lt;xs:attribute name="_names" type="xs:string"/&gt;
          &lt;xs:attribute name="_visibility" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@component | @_component)"/&gt;
          &lt;xs:assert test="exists(@names | @_names)"/&gt;
          &lt;xs:assert test="exists(@visibility | @_visibility)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="accumulator" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:accumulator-rule" minOccurs="1"  maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="name" type="xsl:EQName" /&gt;
          &lt;xs:attribute name="applies-to" type="xsl:pattern"/&gt;
          &lt;xs:attribute name="initial-value" type="xsl:expression"/&gt;
          &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt;
          &lt;xs:attribute name="visibility" type="xsl:visibility-type"/&gt;
          &lt;xs:attribute name="streamable" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="_name" type="xs:string" /&gt;
          &lt;xs:attribute name="_applies-to" type="xs:string"/&gt; 
          &lt;xs:attribute name="_initial-value" type="xs:string"/&gt;
          &lt;xs:attribute name="_as" type="xs:string"/&gt;
          &lt;xs:attribute name="_visibility" type="xs:string"/&gt;
          &lt;xs:attribute name="_streamable" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="accumulator-rule"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:sequence/&gt;
          &lt;xs:attribute name="match" type="xsl:pattern"/&gt;
          &lt;xs:attribute name="phase"&gt;
            &lt;xs:simpleType&gt;
              &lt;xs:restriction base="xs:token"&gt;
                &lt;xs:enumeration value="start"/&gt;
                &lt;xs:enumeration value="end"/&gt;
              &lt;/xs:restriction&gt;           
            &lt;/xs:simpleType&gt;
          &lt;/xs:attribute&gt;
          &lt;xs:attribute name="_match" type="xs:string"/&gt;
          &lt;xs:attribute name="_phase" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@match | @_match)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="analyze-string" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:matching-substring" minOccurs="0"/&gt;
            &lt;xs:element ref="xsl:non-matching-substring" minOccurs="0"/&gt;
            &lt;xs:element ref="xsl:fallback" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="regex" type="xsl:avt"/&gt;
          &lt;xs:attribute name="flags" type="xsl:avt" default=""/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_regex" type="xs:string"/&gt;
          &lt;xs:attribute name="_flags" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@select | @_select)"/&gt;
          &lt;xs:assert test="exists(@regex | @_regex)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="apply-imports" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:with-param" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="apply-templates" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xs:element ref="xsl:sort"/&gt;
            &lt;xs:element ref="xsl:with-param"/&gt;
          &lt;/xs:choice&gt;
          &lt;xs:attribute name="select" type="xsl:expression" default="child::node()"/&gt;
          &lt;xs:attribute name="mode" type="xsl:mode"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_mode" type="xs:string"/&gt;
          &lt;xs:assert test="every $e in subsequence(xsl:sort, 2) satisfies empty($e/@stable)"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;It is a static error if an xsl:sort element other than the first in a 
                  sequence of sibling xsl:sort elements has a stable attribute.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="assert" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="test" type="xsl:expression"/&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="error-code" type="xsl:avt"/&gt;
          &lt;xs:attribute name="_test" type="xs:string"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_error-code" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@test | @_test)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="attribute" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="name" type="xsl:avt"/&gt;
          &lt;xs:attribute name="namespace" type="xsl:avt"/&gt;
          &lt;xs:attribute name="separator" type="xsl:avt"/&gt;
          &lt;xs:attribute name="type" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_namespace" type="xs:string"/&gt;
          &lt;xs:attribute name="_separator" type="xs:string"/&gt;
          &lt;xs:attribute name="_type" type="xs:string"/&gt;
          &lt;xs:attribute name="_validation" type="xs:string"/&gt;
          &lt;xs:assert test="not(exists(@type) and exists(@validation))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;The &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;validation&lt;/code&gt; attributes are mutually exclusive
                (if one is present, the other must be absent).&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="attribute-set" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xs:element ref="xsl:attribute"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="streamable" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="use-attribute-sets" type="xsl:EQNames" default=""/&gt;
          &lt;xs:attribute name="visibility" type="xsl:visibility-type"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_streamable" type="xs:string"/&gt;
          &lt;xs:attribute name="_use-attribute-sets" type="xs:string"/&gt;
          &lt;xs:attribute name="_visibility" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="break" substitutionGroup="xsl:instruction" type="xsl:sequence-constructor-or-select"/&gt;

  &lt;xs:element name="call-template" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:with-param" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="catch"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="errors" type="xs:token" use="optional"/&gt;
          &lt;xs:attribute name="_errors" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="character-map" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:output-character" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="use-character-maps" type="xsl:EQNames" default=""/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_use-character-maps" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="choose" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:when" maxOccurs="unbounded"/&gt;
            &lt;xs:element ref="xsl:otherwise" minOccurs="0"/&gt;
          &lt;/xs:sequence&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="comment" substitutionGroup="xsl:instruction" type="xsl:sequence-constructor-or-select"/&gt;

  &lt;xs:element name="context-item"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="as" type="xsl:item-type"/&gt;
          &lt;xs:attribute name="use"&gt;
            &lt;xs:simpleType&gt;
              &lt;xs:restriction base="xs:token"&gt;
                &lt;xs:enumeration value="required"/&gt;
                &lt;xs:enumeration value="optional"/&gt;
                &lt;xs:enumeration value="prohibited"/&gt;
              &lt;/xs:restriction&gt;
            &lt;/xs:simpleType&gt;
          &lt;/xs:attribute&gt;
          &lt;xs:attribute name="_as" type="xs:string"/&gt;
          &lt;xs:attribute name="_use" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="copy" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="copy-namespaces" type="xsl:yes-or-no" default="yes"/&gt;
          &lt;xs:attribute name="inherit-namespaces" type="xsl:yes-or-no" default="yes"/&gt;
          &lt;xs:attribute name="use-attribute-sets" type="xsl:EQNames" default=""/&gt;
          &lt;xs:attribute name="type" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
          &lt;xs:attribute name="on-empty" type="xsl:expression"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_copy-namespaces" type="xs:string"/&gt;
          &lt;xs:attribute name="_inherit-namespaces" type="xs:string"/&gt;
          &lt;xs:attribute name="_use-attribute-sets" type="xs:string"/&gt;
          &lt;xs:attribute name="_type" type="xs:string"/&gt;
          &lt;xs:attribute name="_validation" type="xs:string"/&gt;
          &lt;xs:attribute name="_on-empty" type="xs:string"/&gt;
          &lt;xs:assert test="not(exists(@type) and exists(@validation))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;The &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;validation&lt;/code&gt; attributes are mutually exclusive
                  (if one is present, the other must be absent).&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="copy-of" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="copy-namespaces" type="xsl:yes-or-no" default="yes"/&gt;
          &lt;xs:attribute name="type" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_copy-namespaces" type="xs:string"/&gt;
          &lt;xs:attribute name="_type" type="xs:string"/&gt;
          &lt;xs:attribute name="_validation" type="xs:string"/&gt;
          &lt;xs:assert test="not(exists(@type) and exists(@validation))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;The &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;validation&lt;/code&gt; attributes are mutually exclusive
                  (if one is present, the other must be absent).&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="exists(@select | @_select)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="document" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="type" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
          &lt;xs:attribute name="_type" type="xs:string"/&gt;
          &lt;xs:attribute name="_validation" type="xs:string"/&gt;
          &lt;xs:assert test="not(exists(@type) and exists(@validation))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;The &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;validation&lt;/code&gt; attributes are mutually exclusive
                  (if one is present, the other must be absent).&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="decimal-format" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="decimal-separator" type="xsl:char" default="."/&gt;
          &lt;xs:attribute name="grouping-separator" type="xsl:char" default=","/&gt;
          &lt;xs:attribute name="infinity" type="xs:string" default="Infinity"/&gt;
          &lt;xs:attribute name="minus-sign" type="xsl:char" default="-"/&gt;
          &lt;xs:attribute name="exponent-separator" type="xsl:char" default="e"/&gt;
          &lt;xs:attribute name="NaN" type="xs:string" default="NaN"/&gt;
          &lt;xs:attribute name="percent" type="xsl:char" default="%"/&gt;
          &lt;xs:attribute name="per-mille" type="xsl:char" default="~"/&gt;
          &lt;xs:attribute name="zero-digit" type="xsl:zero-digit" default="0"/&gt;
          &lt;xs:attribute name="digit" type="xsl:char" default="#"/&gt;
          &lt;xs:attribute name="pattern-separator" type="xsl:char" default=";"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_decimal-separator" type="xs:string"/&gt;
          &lt;xs:attribute name="_grouping-separator" type="xs:string"/&gt;
          &lt;xs:attribute name="_infinity" type="xs:string"/&gt;
          &lt;xs:attribute name="_minus-sign" type="xs:string"/&gt;
          &lt;xs:attribute name="_exponent-separator" type="xs:string"/&gt;
          &lt;xs:attribute name="_NaN" type="xs:string"/&gt;
          &lt;xs:attribute name="_percent" type="xs:string"/&gt;
          &lt;xs:attribute name="_per-mille" type="xs:string"/&gt;
          &lt;xs:attribute name="_zero-digit" type="xs:string"/&gt;
          &lt;xs:attribute name="_digit" type="xs:string"/&gt;
          &lt;xs:attribute name="_pattern-separator" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="element" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType mixed="true"&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="name" type="xsl:avt"/&gt;
          &lt;xs:attribute name="namespace" type="xsl:avt"/&gt;
          &lt;xs:attribute name="inherit-namespaces" type="xsl:yes-or-no" default="yes"/&gt;
          &lt;xs:attribute name="use-attribute-sets" type="xsl:EQNames" default=""/&gt;
          &lt;xs:attribute name="type" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
          &lt;xs:attribute name="on-empty" type="xsl:expression"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_namespace" type="xs:string"/&gt;
          &lt;xs:attribute name="_inherit-namespaces" type="xs:string"/&gt;
          &lt;xs:attribute name="_use-attribute-sets" type="xs:string"/&gt;
          &lt;xs:attribute name="_type" type="xs:string"/&gt;
          &lt;xs:attribute name="_validation" type="xs:string"/&gt;
          &lt;xs:attribute name="_on-empty" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
          &lt;xs:assert test="not(exists(@type) and exists(@validation))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;The &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;validation&lt;/code&gt; attributes are mutually exclusive
                  (if one is present, the other must be absent).&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="evaluate" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xs:element ref="xsl:with-param"/&gt;
            &lt;xs:element ref="xsl:fallback"/&gt;
          &lt;/xs:choice&gt;
          &lt;xs:attribute name="xpath" type="xsl:expression"/&gt;
          &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt;
          &lt;xs:attribute name="base-uri" type="xsl:avt"/&gt;
          &lt;xs:attribute name="context-item" type="xsl:expression"/&gt;
          &lt;xs:attribute name="namespace-context" type="xsl:expression"/&gt;
          &lt;xs:attribute name="schema-aware" type="xsl:avt"/&gt;
          &lt;xs:attribute name="with-params" type="xsl:expression"/&gt; 
          &lt;xs:attribute name="_xpath" type="xs:string"/&gt;
          &lt;xs:attribute name="_as" type="xs:string"/&gt;
          &lt;xs:attribute name="_base-uri" type="xs:string"/&gt;
          &lt;xs:attribute name="_context-item" type="xs:string"/&gt;
          &lt;xs:attribute name="_namespace-context" type="xs:string"/&gt;
          &lt;xs:attribute name="_schema-aware" type="xs:string"/&gt;
          &lt;xs:attribute name="_with-params" type="xs:string"/&gt; 
          &lt;xs:assert test="exists(@xpath | @_xpath)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="expose"&gt;
    &lt;xs:annotation&gt;
        &lt;xs:documentation&gt;
            &lt;p&gt;This element appears as a child of &lt;code&gt;xsl:use-package&lt;/code&gt; and defines 
            the visibility of components that are made available (or not) by this package
            to other using packages.&lt;/p&gt;
        &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="component" type="xsl:component-kind-type"/&gt;
          &lt;xs:attribute name="names" type="xsl:EQNames"/&gt;
          &lt;xs:attribute name="visibility" type="xsl:visibility-not-hidden-type"/&gt;
          &lt;xs:attribute name="_component" type="xs:string"/&gt;
          &lt;xs:attribute name="_names" type="xs:string"/&gt;
          &lt;xs:attribute name="_visibility" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="fallback" substitutionGroup="xsl:instruction" type="xsl:sequence-constructor"/&gt;

  &lt;xs:element name="for-each" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:sort" minOccurs="0" maxOccurs="unbounded"/&gt;
            &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:assert test="every $e in subsequence(xsl:sort, 2) satisfies empty($e/@stable)"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;It is a static error if an xsl:sort element other than the first in a 
                  sequence of sibling xsl:sort elements has a stable attribute.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="exists(@select | @_select)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="for-each-group" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:sort" minOccurs="0" maxOccurs="unbounded"/&gt;
            &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="group-by" type="xsl:expression"/&gt;
          &lt;xs:attribute name="group-adjacent" type="xsl:expression"/&gt;
          &lt;xs:attribute name="group-starting-with" type="xsl:pattern"/&gt;
          &lt;xs:attribute name="group-ending-with" type="xsl:pattern"/&gt;
          &lt;xs:attribute name="composite" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="collation" type="xsl:avt"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_group-by" type="xs:string"/&gt;
          &lt;xs:attribute name="_group-adjacent" type="xs:string"/&gt;
          &lt;xs:attribute name="_group-starting-with" type="xs:string"/&gt;
          &lt;xs:attribute name="_group-ending-with" type="xs:string"/&gt;
          &lt;xs:attribute name="_composite" type="xs:string"/&gt;
          &lt;xs:attribute name="_collation" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@select | @_select)"/&gt;
          &lt;xs:assert test="every $e in subsequence(xsl:sort, 2) satisfies empty($e/@stable)"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;It is a static error if an xsl:sort element other than the first in a 
                  sequence of sibling xsl:sort elements has a stable attribute.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="count((@group-by, @group-adjacent, @group-starting-with, @group-ending-with)) = 1"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;These four attributes are mutually exclusive: it is a static error 
                  if none of these four attributes is present or if more than one of them is present.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="if (exists(@collation) or exists(@composite)) then (exists(@group-by) or exists(@group-adjacent)) else true()"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;It is an error to specify the collation attribute or the composite attribute 
                  if neither the group-by attribute nor group-adjacent attribute is specified.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="fork" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:fallback" minOccurs="0" maxOccurs="unbounded"/&gt;
            &lt;xs:choice&gt;
              &lt;xs:sequence minOccurs="0" maxOccurs="unbounded"&gt;
                &lt;xs:element ref="xsl:sequence"/&gt;
                &lt;xs:element ref="xsl:fallback" minOccurs="0" maxOccurs="unbounded"/&gt;
              &lt;/xs:sequence&gt;
              &lt;xs:sequence&gt;
                &lt;xs:element ref="xsl:for-each-group"/&gt;
                &lt;xs:element ref="xsl:fallback" minOccurs="0" maxOccurs="unbounded"/&gt;
              &lt;/xs:sequence&gt;
            &lt;/xs:choice&gt;
          &lt;/xs:sequence&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="function" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:param" minOccurs="0" maxOccurs="unbounded"/&gt;
            &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="name" type="xsl:EQName-in-namespace"/&gt;
          &lt;xs:attribute name="override" type="xsl:yes-or-no" default="yes"/&gt;
          &lt;xs:attribute name="as" type="xsl:sequence-type" default="item()*"/&gt;
          &lt;xs:attribute name="visibility" type="xsl:visibility-type"/&gt;
          &lt;xs:attribute name="streamable" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="override-extension-function" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="identity-sensitive" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="cache" type="xsl:caching-values"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_override" type="xs:string"/&gt;
          &lt;xs:attribute name="_as" type="xs:string"/&gt;
          &lt;xs:attribute name="_visibility" type="xs:string"/&gt;
          &lt;xs:attribute name="_streamable" type="xs:string"/&gt;
          &lt;xs:attribute name="_override-extension-function" type="xs:string"/&gt;
          &lt;xs:attribute name="_identity-sensitive" type="xs:string"/&gt;
          &lt;xs:attribute name="_cache" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
          &lt;xs:assert test="every $e in xsl:param satisfies (empty($e/@select) and empty($e/child::node()))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;A parameter for a function must have no default value.&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="every $e in xsl:param satisfies empty($e/@visibility)"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;A parameter for a function must have no &lt;code&gt;visibility&lt;/code&gt; attribute.&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="every $e in xsl:param satisfies empty($e/@required)"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;A parameter for a function must have no &lt;code&gt;required&lt;/code&gt; attribute.&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="global-context-item"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="as" type="xsl:item-type"/&gt;
          &lt;xs:attribute name="use"&gt;
            &lt;xs:simpleType&gt;
              &lt;xs:restriction base="xs:token"&gt;
                &lt;xs:enumeration value="required"/&gt;
                &lt;xs:enumeration value="optional"/&gt;
                &lt;xs:enumeration value="prohibited"/&gt;
              &lt;/xs:restriction&gt;
            &lt;/xs:simpleType&gt;
          &lt;/xs:attribute&gt;
          &lt;xs:attribute name="streamable" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="_as" type="xs:string"/&gt;
          &lt;xs:attribute name="_use" type="xs:string"/&gt;
          &lt;xs:attribute name="_streamable" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  

  &lt;xs:element name="if" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="test" type="xsl:expression"/&gt;
          &lt;xs:attribute name="_test" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@test | @_test)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="import" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="href" type="xs:anyURI"/&gt;
          &lt;xs:attribute name="_href" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@href | @_href)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="import-schema" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xs:schema" minOccurs="0" maxOccurs="1"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="namespace" type="xs:anyURI"/&gt;
          &lt;xs:attribute name="schema-location" type="xs:anyURI"/&gt;
          &lt;xs:attribute name="_namespace" type="xs:string"/&gt;
          &lt;xs:attribute name="_schema-location" type="xs:string"/&gt;
          &lt;xs:assert test="not(exists(@schema-location) and exists(xs:schema))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;XTSE0215: It is a static error if an xsl:import-schema element that contains an 
                xs:schema element has a schema-location attribute
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt; 
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="include" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="href" type="xs:anyURI"/&gt;
          &lt;xs:attribute name="_href" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@href | @_href)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="iterate" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:param" minOccurs="0" maxOccurs="unbounded"/&gt;
            &lt;xs:element ref="xsl:on-completion" minOccurs="0" maxOccurs="1"/&gt;
            &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt;           
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@select | @_select)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="key" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="match" type="xsl:pattern"/&gt;
          &lt;xs:attribute name="use" type="xsl:expression"/&gt;
          &lt;xs:attribute name="composite" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="collation" type="xs:anyURI"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_match" type="xs:string"/&gt;
          &lt;xs:attribute name="_use" type="xs:string"/&gt;
          &lt;xs:attribute name="_composite" type="xs:string"/&gt;
          &lt;xs:attribute name="_collation" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
          &lt;xs:assert test="exists(@match | @_match)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="map" type="xsl:sequence-constructor" substitutionGroup="xsl:instruction"/&gt;
  
  &lt;xs:element name="map-entry" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-and-select"&gt;
          &lt;xs:attribute name="key" type="xsl:expression"/&gt;
          &lt;xs:attribute name="_key" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@key | @_key)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="matching-substring" type="xsl:sequence-constructor"/&gt;

  &lt;xs:element name="merge" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:merge-source" minOccurs="1" maxOccurs="unbounded"/&gt;
            &lt;xs:element ref="xsl:merge-action" minOccurs="1" maxOccurs="1"/&gt;
            &lt;xs:element ref="xsl:fallback" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="merge-action" type="xsl:sequence-constructor"/&gt;

  &lt;xs:element name="merge-key" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="lang" type="xsl:avt"/&gt;
          &lt;xs:attribute name="order" type="xsl:avt"/&gt;
          &lt;xs:attribute name="collation" type="xs:anyURI"/&gt;
          &lt;xs:attribute name="case-order" type="xsl:avt"/&gt;
          &lt;xs:attribute name="data-type" type="xsl:avt"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_lang" type="xs:string"/&gt;
          &lt;xs:attribute name="_order" type="xs:string"/&gt;
          &lt;xs:attribute name="_collation" type="xs:string"/&gt;
          &lt;xs:attribute name="_case-order" type="xs:string"/&gt;
          &lt;xs:attribute name="_data-type" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="merge-source"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:merge-key" minOccurs="1" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="name" type="xs:NCName"/&gt;
          &lt;xs:attribute name="for-each-item" type="xsl:expression"/&gt;
          &lt;xs:attribute name="for-each-stream" type="xsl:expression"/&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="streamable" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="sort-before-merge" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="type" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_for-each-item" type="xs:string"/&gt;
          &lt;xs:attribute name="_for-each-stream" type="xs:string"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_streamable" type="xs:string"/&gt;
          &lt;xs:attribute name="_sort-before-merge" type="xs:string"/&gt;
          &lt;xs:attribute name="_type" type="xs:string"/&gt;
          &lt;xs:attribute name="_validation" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@select | @_select)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="message" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="terminate" type="xsl:avt" default="no"/&gt;
          &lt;xs:attribute name="error-code" type="xsl:avt"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_terminate" type="xs:string"/&gt;
          &lt;xs:attribute name="_error-code" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="mode" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="false"&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="streamable" type="xsl:yes-or-no" default="no"/&gt;
          &lt;xs:attribute name="on-no-match" type="xsl:on-no-match-type" default="shallow-skip"/&gt;
          &lt;xs:attribute name="on-multiple-match" type="xsl:on-multiple-match-type" default="use-last"/&gt;
          &lt;xs:attribute name="warning-on-no-match" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="warning-on-multiple-match" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="typed" type="xsl:typed-type"/&gt;
          &lt;xs:attribute name="visibility"&gt;
            &lt;xs:simpleType&gt;
              &lt;xs:restriction base="xsl:visibility-type"&gt;
                &lt;xs:enumeration value="public"/&gt;
                &lt;xs:enumeration value="private"/&gt;
                &lt;xs:enumeration value="final"/&gt;
              &lt;/xs:restriction&gt;
            &lt;/xs:simpleType&gt;
          &lt;/xs:attribute&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_streamable" type="xs:string"/&gt;
          &lt;xs:attribute name="_on-no-match" type="xs:string"/&gt;
          &lt;xs:attribute name="_on-multiple-match" type="xs:string"/&gt;
          &lt;xs:attribute name="_warning-on-no-match" type="xs:string"/&gt;
          &lt;xs:attribute name="_warning-on-multiple-match" type="xs:string"/&gt;
          &lt;xs:attribute name="_typed" type="xs:string"/&gt;
          &lt;xs:attribute name="_visibility" type="xs:string"/&gt;
          &lt;xs:assert test="not(exists(@name) and normalize-space(@visibility) = 'private' and exists(xsl:context-item))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;It is a static error if a named xsl:mode declaration specifying visibility="private" 
                  contains an xsl:context-item element.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt; 
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;


  &lt;xs:element name="namespace" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="name" type="xsl:avt"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="namespace-alias" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="stylesheet-prefix" type="xsl:prefix-or-default"/&gt;
          &lt;xs:attribute name="result-prefix" type="xsl:prefix-or-default"/&gt;
          &lt;xs:attribute name="_stylesheet-prefix" type="xs:string"/&gt;
          &lt;xs:attribute name="_result-prefix" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@stylesheet-prefix | @_stylesheet-prefix)"/&gt;
          &lt;xs:assert test="exists(@result-prefix | @_result-prefix)"/&gt;
          &lt;xs:assert test="every $prefix in (@stylesheet-prefix, @result-prefix)[. ne '#default']
            satisfies $prefix = in-scope-prefixes(.)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;


  &lt;xs:element name="next-iteration" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:with-param" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;


  &lt;xs:element name="next-match" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xs:element ref="xsl:with-param"/&gt;
            &lt;xs:element ref="xsl:fallback"/&gt;
          &lt;/xs:choice&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="non-matching-substring" type="xsl:sequence-constructor"/&gt;

  &lt;xs:element name="number" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:attribute name="value" type="xsl:expression"/&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="level" type="xsl:level" default="single"/&gt;
          &lt;xs:attribute name="count" type="xsl:pattern"/&gt;
          &lt;xs:attribute name="from" type="xsl:pattern"/&gt;
          &lt;xs:attribute name="format" type="xsl:avt" default="1"/&gt;
          &lt;xs:attribute name="lang" type="xsl:avt"/&gt;
          &lt;xs:attribute name="letter-value" type="xsl:avt"/&gt;
          &lt;xs:attribute name="ordinal" type="xsl:avt"/&gt;
          &lt;xs:attribute name="start-at" type="xsl:avt"/&gt;
          &lt;xs:attribute name="grouping-separator" type="xsl:avt"/&gt;
          &lt;xs:attribute name="grouping-size" type="xsl:avt"/&gt;
          &lt;xs:attribute name="_value" type="xs:string"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_level" type="xs:string"/&gt;
          &lt;xs:attribute name="_count" type="xs:string"/&gt;
          &lt;xs:attribute name="_from" type="xs:string"/&gt;
          &lt;xs:attribute name="_format" type="xs:string"/&gt;
          &lt;xs:attribute name="_lang" type="xs:string"/&gt;
          &lt;xs:attribute name="_letter-value" type="xs:string"/&gt;
          &lt;xs:attribute name="_ordinal" type="xs:string"/&gt;
          &lt;xs:attribute name="_start-at" type="xs:string"/&gt;
          &lt;xs:attribute name="_grouping-separator" type="xs:string"/&gt;
          &lt;xs:attribute name="_grouping-size" type="xs:string"/&gt;
          &lt;xs:assert test="if (exists(@value)) then empty((@select, @count, @from)) and @level='single' else true()"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;It is a static error if the value attribute of xsl:number is present unless the 
                  select, level, count, and from attributes are all absent.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;         
          &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="on-completion" type="xsl:sequence-constructor-or-select"/&gt;

  &lt;xs:element name="otherwise" type="xsl:sequence-constructor"/&gt;

  &lt;xs:element name="output" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:generic-element-type"&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="recoverable" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="method" type="xsl:method"/&gt;
          &lt;xs:attribute name="byte-order-mark" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="cdata-section-elements" type="xsl:EQNames"/&gt;
          &lt;xs:attribute name="doctype-public" type="xs:string"/&gt;
          &lt;xs:attribute name="doctype-system" type="xs:string"/&gt;
          &lt;xs:attribute name="encoding" type="xs:string"/&gt;
          &lt;xs:attribute name="escape-uri-attributes" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="html-version" type="xs:decimal"/&gt;
          &lt;xs:attribute name="include-content-type" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="indent" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="item-separator" type="xs:string"/&gt;
          &lt;xs:attribute name="media-type" type="xs:string"/&gt;
          &lt;xs:attribute name="normalization-form" type="xs:NMTOKEN"/&gt;
          &lt;xs:attribute name="omit-xml-declaration" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="parameter-document" type="xs:anyURI"/&gt;
          &lt;xs:attribute name="standalone" type="xsl:yes-or-no-or-omit"/&gt;
          &lt;xs:attribute name="suppress-indentation" type="xsl:EQNames"/&gt;
          &lt;xs:attribute name="undeclare-prefixes" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="use-character-maps" type="xsl:EQNames"/&gt;
          &lt;xs:attribute name="version" type="xs:NMTOKEN"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_method" type="xs:string"/&gt;
          &lt;xs:attribute name="_byte-order-mark" type="xs:string"/&gt;
          &lt;xs:attribute name="_cdata-section-elements" type="xs:string"/&gt;
          &lt;xs:attribute name="_doctype-public" type="xs:string"/&gt;
          &lt;xs:attribute name="_doctype-system" type="xs:string"/&gt;
          &lt;xs:attribute name="_encoding" type="xs:string"/&gt;
          &lt;xs:attribute name="_escape-uri-attributes" type="xs:string"/&gt;
          &lt;xs:attribute name="_html-version" type="xs:string"/&gt;
          &lt;xs:attribute name="_include-content-type" type="xs:string"/&gt;
          &lt;xs:attribute name="_indent" type="xs:string"/&gt;
          &lt;xs:attribute name="_item-separator" type="xs:string"/&gt;
          &lt;xs:attribute name="_media-type" type="xs:string"/&gt;
          &lt;xs:attribute name="_normalization-form" type="xs:string"/&gt;
          &lt;xs:attribute name="_omit-xml-declaration" type="xs:string"/&gt;
          &lt;xs:attribute name="_parameter-document" type="xs:string"/&gt;
          &lt;xs:attribute name="_standalone" type="xs:string"/&gt;
          &lt;xs:attribute name="_suppress-indentation" type="xs:string"/&gt;
          &lt;xs:attribute name="_undeclare-prefixes" type="xs:string"/&gt;
          &lt;xs:attribute name="_use-character-maps" type="xs:string"/&gt;
          &lt;xs:attribute name="_version" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="output-character"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="character" type="xsl:char"/&gt;
          &lt;xs:attribute name="string" type="xs:string"/&gt;
          &lt;xs:attribute name="_character" type="xs:string"/&gt;
          &lt;xs:attribute name="_string" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@character | @_character)"/&gt;
          &lt;xs:assert test="exists(@string | @_string)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="override"&gt;
    &lt;xs:annotation&gt;
        &lt;xs:documentation&gt;
            &lt;p&gt;This element appears as a child of &lt;code&gt;xsl:use-package&lt;/code&gt; and defines 
            any overriding definitions of components that the containing package wishes to make 
            to the components made available from a library package.&lt;/p&gt;
        &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xs:element ref="xsl:template"/&gt;
            &lt;xs:element ref="xsl:function"/&gt;
            &lt;xs:element ref="xsl:variable"/&gt;
            &lt;xs:element ref="xsl:param"/&gt;
            &lt;xs:element ref="xsl:attribute-set"/&gt;
          &lt;/xs:choice&gt;          
          &lt;xs:assert test="every $e in * satisfies exists($e/@name)"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;Every component that is overridden (in particular, templates) must have a &lt;code&gt;name&lt;/code&gt; attribute&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="every $e in xsl:template satisfies empty($e/@match)"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;A template that is overridden must not have a &lt;code&gt;match&lt;/code&gt; attribute&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;  
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;   
  &lt;/xs:element&gt;
    
  &lt;xs:element name="package"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;             
              &lt;xs:element ref="xsl:use-package"/&gt;
              &lt;xs:element ref="xsl:expose"/&gt;
              &lt;xs:element ref="xsl:global-context-item"/&gt;
              &lt;xs:element ref="xsl:declaration"/&gt;
              &lt;xs:any namespace="##other" processContents="lax"/&gt;
            &lt;/xs:choice&gt;  
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="id" type="xs:ID"/&gt;         
          &lt;xs:attribute name="name" type="xs:anyURI"/&gt;
          &lt;xs:attribute name="package-version" type="xs:string"/&gt;
          &lt;xs:attribute name="input-type-annotations" type="xsl:input-type-annotations-type"/&gt;
          &lt;xs:attribute name="_id" type="xs:string"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_package-version" type="xs:string"/&gt;
          &lt;xs:attribute name="_input-type-annotations" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="param" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:annotation&gt;
        &lt;xs:documentation&gt;
            &lt;p&gt;Declaration of the &lt;code&gt;xsl:param&lt;/code&gt; element, used both defining function
            parameters, template parameters, parameters to &lt;code&gt;xsl:iterate&lt;/code&gt;,
            and global stylesheet parameters.&lt;/p&gt;
        &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt;
          &lt;xs:attribute name="required" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="tunnel" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="static" type="xsl:yes-or-no"/&gt;  
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_as" type="xs:string"/&gt;
          &lt;xs:attribute name="_required" type="xs:string"/&gt;
          &lt;xs:attribute name="_tunnel" type="xs:string"/&gt;
          &lt;xs:attribute name="_static" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
          &lt;xs:assert test="if (normalize-space(@static) = 'yes') 
                           then normalize-space(@visibility) = ('', 'private', 'final') 
                           else true()"&gt;
              &lt;xs:annotation&gt;
                &lt;xs:documentation&gt;
                  &lt;p&gt;When the static attribute is present with the value yes, 
                    the visibility attribute must not have a value other than private 
                    or final.&lt;/p&gt;
                &lt;/xs:documentation&gt;
              &lt;/xs:annotation&gt;
            &lt;/xs:assert&gt;
          &lt;xs:assert test="if (normalize-space(@static) = 'yes')
                           then empty((*,text()))
                           else true()"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;When the attribute static="yes" is specified, 
                  the xsl:param element must have empty content.&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt; 
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  

  &lt;xs:element name="perform-sort" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:sort" minOccurs="1" maxOccurs="unbounded"/&gt;
            &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:assert test="every $e in subsequence(xsl:sort, 2) satisfies empty($e/@stable)"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;It is a static error if an xsl:sort element other than the first in a 
                  sequence of sibling xsl:sort elements has a stable attribute.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="preserve-space" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="elements" type="xsl:nametests"/&gt;
          &lt;xs:attribute name="_elements" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@elements | @_elements)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="processing-instruction" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="name" type="xsl:avt"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="result-document" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="format" type="xsl:avt"/&gt;
          &lt;xs:attribute name="href" type="xsl:avt"/&gt;
          &lt;xs:attribute name="type" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
          &lt;xs:attribute name="recoverable" type="xsl:avt"/&gt;
          &lt;xs:attribute name="method" type="xsl:avt"/&gt;
          &lt;xs:attribute name="byte-order-mark" type="xsl:avt"/&gt;
          &lt;xs:attribute name="cdata-section-elements" type="xsl:avt"/&gt;
          &lt;xs:attribute name="doctype-public" type="xsl:avt"/&gt;
          &lt;xs:attribute name="doctype-system" type="xsl:avt"/&gt;
          &lt;xs:attribute name="encoding" type="xsl:avt"/&gt;
          &lt;xs:attribute name="escape-uri-attributes" type="xsl:avt"/&gt;
          &lt;xs:attribute name="html-version" type="xsl:avt"/&gt;
          &lt;xs:attribute name="include-content-type" type="xsl:avt"/&gt;
          &lt;xs:attribute name="indent" type="xsl:avt"/&gt;
          &lt;xs:attribute name="item-separator" type="xsl:avt"/&gt;
          &lt;xs:attribute name="media-type" type="xsl:avt"/&gt;
          &lt;xs:attribute name="normalization-form" type="xsl:avt"/&gt;
          &lt;xs:attribute name="omit-xml-declaration" type="xsl:avt"/&gt;
          &lt;xs:attribute name="parameter-document" type="xsl:avt"/&gt;
          &lt;xs:attribute name="standalone" type="xsl:avt"/&gt;
          &lt;xs:attribute name="suppress-indentation" type="xsl:avt"/&gt;
          &lt;xs:attribute name="undeclare-prefixes" type="xsl:avt"/&gt;
          &lt;xs:attribute name="use-character-maps" type="xsl:EQNames"/&gt;
          &lt;xs:attribute name="output-version" type="xsl:avt"/&gt;
          &lt;xs:attribute name="_format" type="xs:string"/&gt;
          &lt;xs:attribute name="_href" type="xs:string"/&gt;
          &lt;xs:attribute name="_type" type="xs:string"/&gt;
          &lt;xs:attribute name="_validation" type="xs:string"/&gt;
          &lt;xs:attribute name="_method" type="xs:string"/&gt;
          &lt;xs:attribute name="_byte-order-mark" type="xs:string"/&gt;
          &lt;xs:attribute name="_cdata-section-elements" type="xs:string"/&gt;
          &lt;xs:attribute name="_doctype-public" type="xs:string"/&gt;
          &lt;xs:attribute name="_doctype-system" type="xs:string"/&gt;
          &lt;xs:attribute name="_encoding" type="xs:string"/&gt;
          &lt;xs:attribute name="_escape-uri-attributes" type="xs:string"/&gt;
          &lt;xs:attribute name="_html-version" type="xs:string"/&gt;
          &lt;xs:attribute name="_include-content-type" type="xs:string"/&gt;
          &lt;xs:attribute name="_indent" type="xs:string"/&gt;
          &lt;xs:attribute name="_item-separator" type="xs:string"/&gt;
          &lt;xs:attribute name="_media-type" type="xs:string"/&gt;
          &lt;xs:attribute name="_normalization-form" type="xs:string"/&gt;
          &lt;xs:attribute name="_omit-xml-declaration" type="xs:string"/&gt;
          &lt;xs:attribute name="_parameter-document" type="xs:string"/&gt;
          &lt;xs:attribute name="_standalone" type="xs:string"/&gt;
          &lt;xs:attribute name="_suppress-indentation" type="xs:string"/&gt;
          &lt;xs:attribute name="_undeclare-prefixes" type="xs:string"/&gt;
          &lt;xs:attribute name="_use-character-maps" type="xs:string"/&gt;
          &lt;xs:attribute name="_output-version" type="xs:string"/&gt;
          &lt;xs:assert test="not(exists(@type) and exists(@validation))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;The &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;validation&lt;/code&gt; attributes are mutually exclusive
                  (if one is present, the other must be absent).&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="sequence" substitutionGroup="xsl:instruction" type="xsl:sequence-constructor-or-select"/&gt;

  &lt;xs:element name="sort"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="lang" type="xsl:avt"/&gt;
          &lt;xs:attribute name="data-type" type="xsl:avt" default="text"/&gt;
          &lt;xs:attribute name="order" type="xsl:avt" default="ascending"/&gt;
          &lt;xs:attribute name="case-order" type="xsl:avt"/&gt;
          &lt;xs:attribute name="collation" type="xsl:avt"/&gt;
          &lt;xs:attribute name="stable" type="xsl:avt"/&gt;
          &lt;xs:attribute name="_lang" type="xs:string"/&gt;
          &lt;xs:attribute name="_data-type" type="xs:string"/&gt;
          &lt;xs:attribute name="_order" type="xs:string"/&gt;
          &lt;xs:attribute name="_case-order" type="xs:string"/&gt;
          &lt;xs:attribute name="_collation" type="xs:string"/&gt;
          &lt;xs:attribute name="_stable" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="strip-space" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="elements" type="xsl:nametests"/&gt;
          &lt;xs:attribute name="_elements" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@elements | @_elements)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="stylesheet" substitutionGroup="xsl:transform"/&gt;

  &lt;xs:element name="stream" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="href" type="xsl:avt"/&gt;
          &lt;xs:attribute name="type" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
          &lt;xs:attribute name="_href" type="xs:string"/&gt;
          &lt;xs:attribute name="_type" type="xs:string"/&gt;
          &lt;xs:attribute name="_validation" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@href | @_href)"/&gt;
          &lt;xs:assert test="not(exists(@type) and exists(@validation))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;The &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;validation&lt;/code&gt; attributes are mutually exclusive
                  (if one is present, the other must be absent).&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="template" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:context-item" minOccurs="0" maxOccurs="1"/&gt;
            &lt;xs:element ref="xsl:param" minOccurs="0" maxOccurs="unbounded"/&gt;
            &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="match" type="xsl:pattern"/&gt;
          &lt;xs:attribute name="priority" type="xs:decimal"/&gt;
          &lt;xs:attribute name="mode" type="xsl:modes"/&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="as" type="xsl:sequence-type" default="item()*"/&gt;
          &lt;xs:attribute name="visibility" type="xsl:visibility-type"/&gt;
          &lt;xs:attribute name="_match" type="xs:string"/&gt;
          &lt;xs:attribute name="_priority" type="xs:string"/&gt;
          &lt;xs:attribute name="_mode" type="xs:string"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_as" type="xs:string"/&gt;
          &lt;xs:attribute name="_visibility" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@match) or exists(@name)"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;An xsl:template element must have either a match attribute or a name attribute, or both.&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="if (empty(@match)) then (empty(@mode) and empty(@priority)) else true()"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;An xsl:template element that has no match attribute must have no mode attribute and no priority attribute.&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="not(exists(@visibility) and empty(@name))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;An xsl:template element that has no name attribute must have no visibility attribute&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="if (normalize-space(@visibility) = 'abstract') then empty(* except (xsl:context-item, xsl:param)) else true()"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;If the visibility attribute is present with the value abstract then (a) the sequence constructor defining 
                  the template body must be empty: that is, the only permitted children are xsl:context-item and xsl:param&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="not(normalize-space(@visibility) = 'abstract' and exists(@match))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;If the visibility attribute is present with the value abstract then there must be no match attribute.&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="every $e in xsl:param satisfies empty($e/@visibility)"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;A parameter for a template must have no &lt;code&gt;visibility&lt;/code&gt; attribute.&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:complexType name="text-element-base-type"&gt;
    &lt;xs:simpleContent&gt;
      &lt;xs:restriction base="xsl:versioned-element-type"&gt;
        &lt;xs:simpleType&gt;
          &lt;xs:restriction base="xs:string"/&gt;
        &lt;/xs:simpleType&gt;
        &lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:simpleContent&gt;
  &lt;/xs:complexType&gt;

  &lt;!--* first cut (for reference)
&lt;xs:element name="text" substitutionGroup="xsl:instruction"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:simpleContent&gt;
      &lt;xs:extension base="xsl:text-element-base-type"&gt;
        &lt;xs:attribute name="disable-output-escaping" type="xsl:yes-or-no" default="no"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:simpleContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
*--&gt;

  &lt;xs:complexType name="text-element-type"&gt;
    &lt;xs:simpleContent&gt;
      &lt;xs:extension base="xsl:text-element-base-type"&gt;
        &lt;xs:attribute name="disable-output-escaping" type="xsl:yes-or-no" default="no"/&gt;
        &lt;xs:attribute name="_disable-output-escaping" type="xs:string"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:simpleContent&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:element name="text" substitutionGroup="xsl:instruction" type="xsl:text-element-type"/&gt;


  &lt;xs:complexType name="transform-element-base-type"&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:restriction base="xsl:element-only-versioned-element-type"&gt;
        &lt;xs:attribute name="version" type="xs:decimal" use="optional"/&gt;
        &lt;xs:attribute name="_version" type="xs:string"&gt;
          &lt;xs:annotation&gt;
            &lt;xs:documentation&gt;
              &lt;p&gt;The version attribute indicates the version of XSLT that 
                the stylesheet module requires. The attribute is required, 
                unless the xsl:stylesheet element is a child of an xsl:package 
                element, in which case it is optional: the default is then 
                taken from the parent xsl:package element.&lt;/p&gt;
            &lt;/xs:documentation&gt;
          &lt;/xs:annotation&gt;
        &lt;/xs:attribute&gt;
        &lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:element name="transform"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:transform-element-base-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
              &lt;xs:element ref="xsl:declaration"/&gt;
              &lt;xs:any namespace="##other" processContents="lax"/&gt;
              &lt;!-- weaker than XSLT 1.0 --&gt;
            &lt;/xs:choice&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="id" type="xs:ID"/&gt;
          &lt;xs:attribute name="input-type-annotations" type="xsl:input-type-annotations-type"
            default="unspecified"/&gt;
          &lt;xs:attribute name="_id" type="xs:string"/&gt;
          &lt;xs:attribute name="_input-type-annotations" type="xs:string"/&gt;
          &lt;!--* The 'static' attribute may be used on 'param' and 'variable'
              * only when they are top-level elements. *--&gt;
          &lt;xs:assert test="every $v in (.//xsl:param, .//xsl:variable)[@static]
            satisfies
            $v[parent::xsl:stylesheet or parent::xsl:transform or parent::xsl:override]
            "&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;The static attribute must not be present on an xsl:variable or xsl:param 
                  element unless it is a top-level element.&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="every $prefix in (@exclude-result-prefixes[not(. = '#all')], @extension-element-prefixes)
            satisfies ((if ($prefix = '#default') then '' else $prefix) = in-scope-prefixes(.))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;XTSE0808: It is a static error if a namespace prefix is used within the [xsl:]exclude-result-prefixes 
                  attribute and there is no namespace binding in scope for that prefix.
                &lt;/p&gt;
                &lt;p&gt;XTSE0809: It is a static error if the value #default is used within the [xsl:]exclude-result-prefixes 
                  attribute and the parent element of the [xsl:]exclude-result-prefixes attribute has no default namespace.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="try" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt;
            &lt;xs:element ref="xsl:catch" minOccurs="1" maxOccurs="1"/&gt;
            &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
              &lt;xs:element ref="xsl:catch"/&gt;
              &lt;xs:element ref="xsl:fallback"/&gt;
            &lt;/xs:choice&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="select" type="xsl:expression" use="optional"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="use-package"&gt;
    &lt;xs:annotation&gt;
        &lt;xs:documentation&gt;
            &lt;p&gt;This element appears as a child of &lt;code&gt;xsl:package&lt;/code&gt; and defines a dependency
            of the containing package on another package, identified by URI in the &lt;code&gt;name&lt;/code&gt;
            attribute. The &lt;code&gt;package-version&lt;/code&gt; attribute indicates which version of the
            library package is required, or may indicate a range of versions.&lt;/p&gt;
        &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="false"&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xs:element ref="xsl:accept"/&gt;
            &lt;xs:element ref="xsl:override"/&gt;
          &lt;/xs:choice&gt;
          &lt;xs:attribute name="name" type="xs:anyURI"/&gt;
          &lt;xs:attribute name="package-version" type="xs:string"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_package-version" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="value-of" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="separator" type="xsl:avt"/&gt;
          &lt;xs:attribute name="disable-output-escaping" type="xsl:yes-or-no" default="no"/&gt;
          &lt;xs:attribute name="_separator" type="xs:string"/&gt;
          &lt;xs:attribute name="_disable-output-escaping" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="variable" substitutionGroup="xsl:declaration xsl:instruction"&gt;
    &lt;xs:annotation&gt;
        &lt;xs:documentation&gt;
            &lt;p&gt;Declaration of the &lt;code&gt;xsl:variable&lt;/code&gt; element, used both for local
            and global variable bindings.&lt;/p&gt;
            &lt;p&gt;This definition takes advantage of the ability in XSD 1.1 for an element
                to belong to more than one substitution group. A global variable
                is a declaration, while a local variable can appear as an instruction
                in a sequence constructor.&lt;/p&gt;
        &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt;
          &lt;xs:attribute name="visibility" type="xsl:visibility-type"/&gt;
          &lt;xs:attribute name="static" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_as" type="xs:string"/&gt;
          &lt;xs:attribute name="_visibility" type="xs:string"/&gt;
          &lt;xs:attribute name="_static" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
          &lt;xs:assert test="if (normalize-space(@static) = 'yes') 
                           then normalize-space(@visibility) = ('', 'private', 'final') 
                           else true()"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;When the static attribute is present with the value yes, 
                  the visibility attribute must not have a value other than private 
                  or final.&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="if (normalize-space(@static) = 'yes')
                           then (empty((*,text())) and @select) 
                           else true()"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;When the attribute static="yes" is specified, 
                  the xsl:variable element must have empty content,
                  and the select attribute must be present to 
                  define the value of the variable.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;          
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="when"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="test" type="xsl:expression"/&gt;
          &lt;xs:attribute name="_test" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@test | @_test)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="with-param"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt;
          &lt;xs:attribute name="tunnel" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_as" type="xs:string"/&gt;
          &lt;xs:attribute name="_tunnel" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt; PART C: definition of literal result elements There are three ways to define
      the literal result elements permissible in a stylesheet. (a) do nothing. This allows any
      element to be used as a literal result element, provided it is not in the XSLT namespace (b)
      declare all permitted literal result elements as members of the xsl:literal-result-element
      substitution group (c) redefine the model group xsl:result-elements to accommodate all
      permitted literal result elements. Literal result elements are allowed to take certain
      attributes in the XSLT namespace. These are defined in the attribute group
      literal-result-element-attributes, which can be included in the definition of any literal
      result element. &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;

  &lt;xs:element name="literal-result-element" abstract="true" type="xs:anyType"/&gt;

  &lt;xs:attributeGroup name="literal-result-element-attributes"&gt;
    &lt;xs:attribute name="default-collation" form="qualified" type="xsl:uri-list"/&gt;
    &lt;xs:attribute name="default-mode" type="xsl:default-mode-type"/&gt;
    &lt;xs:attribute name="default-validation" type="xsl:validation-strip-or-preserve"
      default="strip"/&gt;
    &lt;xs:attribute name="expand-text" type="xsl:yes-or-no"/&gt;
    &lt;xs:attribute name="extension-element-prefixes" form="qualified" type="xsl:prefixes"/&gt;
    &lt;xs:attribute name="exclude-result-prefixes" form="qualified" type="xsl:prefixes"/&gt;
    &lt;xs:attribute name="xpath-default-namespace" form="qualified" type="xs:anyURI"/&gt;
    &lt;xs:attribute name="inherit-namespaces" form="qualified" type="xsl:yes-or-no" default="yes"/&gt;
    &lt;xs:attribute name="use-attribute-sets" form="qualified" type="xsl:EQNames" default=""/&gt;
    &lt;xs:attribute name="use-when" form="qualified" type="xsl:expression"/&gt;
    &lt;xs:attribute name="version" form="qualified" type="xs:decimal"/&gt;
    &lt;xs:attribute name="type" form="qualified" type="xsl:EQName"/&gt;
    &lt;xs:attribute name="validation" form="qualified" type="xsl:validation-type"/&gt;
  &lt;/xs:attributeGroup&gt;

  &lt;xs:group name="result-elements"&gt;
    &lt;xs:choice&gt;
      &lt;xs:element ref="xsl:literal-result-element"/&gt;
      &lt;xs:any namespace="##other" processContents="lax"/&gt;
      &lt;xs:any namespace="##local" processContents="lax"/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:group&gt;


  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt; PART D: definitions of simple types used in stylesheet attributes
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;

  &lt;xs:simpleType name="avt"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; This type is used for all attributes that allow an attribute value
        template. The general rules for the syntax of attribute value templates, and the specific
        rules for each such attribute, are described in the XSLT 2.1 Recommendation.
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:string"/&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="caching-values"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; One of the values "full", "partial", or "no". &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="full"/&gt;
      &lt;xs:enumeration value="partial"/&gt;
      &lt;xs:enumeration value="no"/&gt;
    &lt;/xs:restriction&gt;
    
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="char"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; A string containing exactly one character. &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:length value="1"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
   &lt;xs:simpleType name="component-kind-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; Describes a kind of component within a package.
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="template"/&gt;
      &lt;xs:enumeration value="function"/&gt;
      &lt;xs:enumeration value="variable"/&gt;
      &lt;xs:enumeration value="attribute-set"/&gt;
      &lt;xs:enumeration value="mode"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="default-mode-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; The default-mode attribute of xsl:stylesheet, xsl:transform, 
        xsl:package (or any other xsl:* element): either a QName or #unnamed. 
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:union memberTypes="xsl:EQName"&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:token"&gt;
          &lt;xs:enumeration value="#unnamed"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:union&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="expression"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; An XPath 2.0 expression. &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:pattern value=".+"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="item-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; An XPath 2.1 ItemType&lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:pattern value=".+"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="input-type-annotations-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; Describes how type annotations in source documents are handled.
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="preserve"/&gt;
      &lt;xs:enumeration value="strip"/&gt;
      &lt;xs:enumeration value="unspecified"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="level"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; The level attribute of xsl:number: one of single, multiple, or any.
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="single"/&gt;
      &lt;xs:enumeration value="multiple"/&gt;
      &lt;xs:enumeration value="any"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="mode"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; The mode attribute of xsl:apply-templates: either a QName, or #current, or
        #unnamed, or #default. &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:union memberTypes="xsl:EQName"&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:token"&gt;
          &lt;xs:enumeration value="#default"/&gt;
          &lt;xs:enumeration value="#unnamed"/&gt;
          &lt;xs:enumeration value="#current"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:union&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="modes"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; The mode attribute of xsl:template: either a list, each member being either
        a QName or #default or #unnamed; or the value #all &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;   
      &lt;xs:union&gt;
        &lt;xs:simpleType&gt;
          &lt;xs:restriction&gt;           
            &lt;xs:simpleType&gt;
              &lt;xs:list&gt;
                &lt;xs:simpleType&gt;
                  &lt;xs:union memberTypes="xsl:EQName"&gt;
                    &lt;xs:simpleType&gt;
                      &lt;xs:restriction base="xs:token"&gt;
                        &lt;xs:enumeration value="#default"/&gt;
                        &lt;xs:enumeration value="#unnamed"/&gt;
                      &lt;/xs:restriction&gt;
                    &lt;/xs:simpleType&gt;
                  &lt;/xs:union&gt;
                &lt;/xs:simpleType&gt;
              &lt;/xs:list&gt;
            &lt;/xs:simpleType&gt;
            &lt;xs:assertion test="count($value) = count(distinct-values($value))"&gt;
              &lt;xs:annotation&gt;
                &lt;xs:documentation&gt;
                  &lt;p&gt;XTSE0550: It is a static error if the same token is included more than once in the list.
                  &lt;/p&gt;
                &lt;/xs:documentation&gt;
              &lt;/xs:annotation&gt;
            &lt;/xs:assertion&gt;
          &lt;/xs:restriction&gt;
        &lt;/xs:simpleType&gt;
        &lt;xs:simpleType&gt;
          &lt;xs:restriction base="xs:token"&gt;
            &lt;xs:enumeration value="#all"/&gt;
          &lt;/xs:restriction&gt;
        &lt;/xs:simpleType&gt;
      &lt;/xs:union&gt;     
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="nametests"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; A list of NameTests, as defined in the XPath 2.0 Recommendation. Each
        NameTest is either a QName, or "*", or "prefix:*", or "*:localname" &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:list&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:union memberTypes="xsl:EQName"&gt;
          &lt;xs:simpleType&gt;
            &lt;xs:restriction base="xs:token"&gt;
              &lt;xs:enumeration value="*"/&gt;
            &lt;/xs:restriction&gt;
          &lt;/xs:simpleType&gt;
          &lt;xs:simpleType&gt;
            &lt;xs:restriction base="xs:token"&gt;
              &lt;xs:pattern value="\i\c*:\*"/&gt;
              &lt;xs:pattern value="\*:\i\c*"/&gt;
            &lt;/xs:restriction&gt;
          &lt;/xs:simpleType&gt;
        &lt;/xs:union&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:list&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="on-multiple-match-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; Describes the action to be taken when there are several template rules to match an item in a given mode.
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="use-last"/&gt;
      &lt;xs:enumeration value="fail"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="on-no-match-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; Describes the action to be taken when there is no template rule to match an item in a given mode.
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="deep-copy"/&gt;
      &lt;xs:enumeration value="shallow-copy"/&gt;
      &lt;xs:enumeration value="deep-skip"/&gt;
      &lt;xs:enumeration value="shallow-skip"/&gt;
      &lt;xs:enumeration value="text-only-copy"/&gt;
      &lt;xs:enumeration value="fail"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="prefixes"&gt;
    &lt;xs:list itemType="xs:NCName"/&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="prefix-list-or-all"&gt;
    &lt;xs:union memberTypes="xsl:prefix-list"&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:token"&gt;
          &lt;xs:enumeration value="#all"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:union&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="prefix-list"&gt;
    &lt;xs:list itemType="xsl:prefix-or-default"/&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="method"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; The method attribute of xsl:output: Either one of the recognized names
        "xml", "xhtml", "html", "text", or a QName that must include a prefix. &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:union&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:token"&gt;
          &lt;xs:enumeration value="xml"/&gt;
          &lt;xs:enumeration value="xhtml"/&gt;
          &lt;xs:enumeration value="html"/&gt;
          &lt;xs:enumeration value="text"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xsl:EQName"&gt;
          &lt;xs:pattern value="\c*:\c*"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:union&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="pattern"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; A match pattern as defined in the XSLT 2.1 Recommendation. The syntax for
        patterns is a restricted form of the syntax for XPath 2.0 expressions. Change since XSLT
        2.0: Patterns may now match any item (not only nodes) &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xsl:expression"/&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="prefix-or-default"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; Either a namespace prefix, or #default. Used in the xsl:namespace-alias
        element. &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:union memberTypes="xs:NCName"&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:token"&gt;
          &lt;xs:enumeration value="#default"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:union&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="EQNames"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; A list of QNames. Used in the [xsl:]use-attribute-sets attribute of various
        elements, and in the cdata-section-elements attribute of xsl:output &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:list itemType="xsl:EQName"/&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="EQName"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; 
        &lt;p&gt;An extended QName. This schema does not use the built-in type xs:QName, but rather
        defines its own QName type. This may be either a local name, or a prefixed QName, or a name written
        using the extended QName notation Q{uri}local&lt;/p&gt;
        &lt;p&gt;Although xs:QName would define the correct validation on these
        attributes, a schema processor would expand unprefixed QNames incorrectly when constructing
        the PSVI, because (as defined in XML Schema errata) an unprefixed xs:QName is assumed to be
        in the default namespace, which is not the correct assumption for XSLT. The datatype is therefore
        defined as a union of NCName and QName, so that an unprefixed name will be validated as an 
        NCName and will therefore not be treated as having the semantics of an unprefixed xs:QName. &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:union memberTypes="xs:NCName xs:QName"&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:token"&gt;
          &lt;xs:pattern value="Q\{.*\}\i\c*"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:union&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="EQName-in-namespace"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; 
        &lt;p&gt;A subtype of EQNames that excludes no-namespace names&lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
        &lt;xs:restriction base="xsl:EQName"&gt;
          &lt;xs:pattern value="Q\{.+\}.+|\i\c*:.+"/&gt;
        &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;  
  
  &lt;xs:simpleType name="sequence-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; The description of a datatype, conforming to the SequenceType production
        defined in the XPath 2.0 Recommendation &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:pattern value=".+"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="typed-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; Describes whether a mode is designed to match typed or untyped nodes.
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="yes"/&gt;
      &lt;xs:enumeration value="no"/&gt;
      &lt;xs:enumeration value="true"/&gt;
      &lt;xs:enumeration value="false"/&gt;
      &lt;xs:enumeration value="1"/&gt;
      &lt;xs:enumeration value="0"/&gt;
      &lt;xs:enumeration value="strict"/&gt;
      &lt;xs:enumeration value="lax"/&gt;
      &lt;xs:enumeration value="unspecified"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="uri-list"&gt;
    &lt;xs:list itemType="xs:anyURI"/&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="validation-strip-or-preserve"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; Describes different ways of type-annotating an element or attribute.
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xsl:validation-type"&gt;
      &lt;xs:enumeration value="preserve"/&gt;
      &lt;xs:enumeration value="strip"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="validation-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; Describes different ways of type-annotating an element or attribute.
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="strict"/&gt;
      &lt;xs:enumeration value="lax"/&gt;
      &lt;xs:enumeration value="preserve"/&gt;
      &lt;xs:enumeration value="strip"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="visibility-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; Describes the visibility of a component within a package.
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="public"/&gt;
      &lt;xs:enumeration value="private"/&gt;
      &lt;xs:enumeration value="final"/&gt;
      &lt;xs:enumeration value="abstract"/&gt;
      &lt;xs:enumeration value="hidden"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="visibility-not-hidden-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; Describes the visibility of a component within a package.
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xsl:visibility-type"&gt;
      &lt;xs:enumeration value="public"/&gt;
      &lt;xs:enumeration value="private"/&gt;
      &lt;xs:enumeration value="final"/&gt;
      &lt;xs:enumeration value="abstract"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="yes-or-no"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; One of the values "yes" or "no": the values "true" or "false", or "1" or "0" are accepted as synonyms. &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="yes"/&gt;
      &lt;xs:enumeration value="no"/&gt;
      &lt;xs:enumeration value="true"/&gt;
      &lt;xs:enumeration value="false"/&gt;
      &lt;xs:enumeration value="1"/&gt;
      &lt;xs:enumeration value="0"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="yes-or-no-or-omit"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; One of the values "yes" or "no" or "omit". 
        The values "true" or "false", or "1" or "0" are accepted as synonyms of "yes" and "no" respectively.&lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="yes"/&gt;
      &lt;xs:enumeration value="no"/&gt;
      &lt;xs:enumeration value="true"/&gt;
      &lt;xs:enumeration value="false"/&gt;
      &lt;xs:enumeration value="1"/&gt;
      &lt;xs:enumeration value="0"/&gt;
      &lt;xs:enumeration value="omit"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="zero-digit"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt; A digit that has the numerical value zero. &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xsl:char"&gt;
      &lt;xs:pattern value="\p{Nd}"/&gt;
      &lt;xs:assertion test="matches(string-join(codepoints-to-string(for $i in 0 to 9 
                          return string-to-codepoints($value) + $i), ''), '\p{Nd}{10}')"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

&lt;/xs:schema&gt;
</pre></div>
<div class="div1">
<h2><a name="acknowledgements" id="acknowledgements"></a>I
Acknowledgements (Non-Normative)</h2>
<p>This specification was developed and approved for publication by
the W3C XSL Working Group (WG). WG approval of this specification
does not necessarily imply that all WG members voted for its
approval.</p>
<p>The chair of the XSL WG is Sharon Adler. The active membership
of the XSL WG at the time of publication comprises:</p>
<blockquote>
<p>Sharon Adler (Chair)<br />
Anders Berglund<br />
Oliver Becker<br />
Carine Bournez (W3C team)<br />
Abel Braaksma<br />
Florent Georges<br />
Michael Kay (Editor)<br />
Jirka Kosek<br />
Michael Sperberg-McQueen<br />
Mohamed Zergaoui</p>
</blockquote>
<p>The Working Group wishes to acknowledge the contribution of
those who have participated in the work at earlier stages, as well
as the pioneering work of the developers of STX (see <a href=
"#STX">[STX]</a>) which has formed an important intellectual input
to the design of XSLT 3.0 and has demonstrated the feasibility of
creating a streaming transformation language based on the core XSLT
concept of recursive descent of the source tree using rule-based
templates.</p>
</div>
<div class="div1">
<h2><a name="changes-since-2.0" id="changes-since-2.0"></a>J
Changes since XSLT 2.0 (Non-Normative)</h2>
<div class="div2">
<h3><a name="xslt-changes-since-2.0" id=
"xslt-changes-since-2.0"></a>J.1 <a href="#xslt-changes-since-2.0"
style="text-decoration: none">Changes in this
Specification</a></h3>
<ol class="enumar">
<li>
<p>A stylesheet may now consist of multiple packages. The language
specification for packages has been designed with a view to
allowing packages to be compiled independently of each other. The
specification provides control over the interface offered by a
package to other packages; in particular it allows functions,
variables, named templates and other components to be declared as
public, private, final, or abstract.</p>
</li>
<li>
<p>A new <a href="#element-mode"><code>xsl:mode</code></a>
declaration is added.</p>
<ol class="enumla">
<li>
<p>A mode may be declared to be streamable, and rules are given
that constrain what the template rules in a streamable mode can
do.</p>
</li>
<li>
<p>An <a href="#element-mode"><code>xsl:mode</code></a> declaration
may define the action to be taken when there is no matching
template rule, and the action to be taken when there are multiple
matching template rules.</p>
</li>
<li>
<p>An <a href="#element-mode"><code>xsl:mode</code></a> declaration
may indicate that the template rules in a given mode are designed
to process typed (schema-validated) nodes only, or untyped nodes
only. It may also indicate that element names appearing in match
patterns for the mode are only to match elements in the source
document that have been validated against the corresponding element
declarations in the schema.</p>
</li>
<li>
<p>A default mode can be declared for a stylesheet module, making
it easier to reuse existing stylesheet modules to construct a
composite stylesheet.</p>
</li>
</ol>
</li>
<li>
<p>Several new instructions are introduced with the aim of making
it easier to write streamable transformations, although most of
these instructions can also be used without streaming:</p>
<ol class="enumla">
<li>
<p>The <a href="#element-stream"><code>xsl:stream</code></a>
instruction is provided specifically to read and process an input
document using streaming.</p>
</li>
<li>
<p>The <a href="#element-iterate"><code>xsl:iterate</code></a>
instruction allows iterative processing of a sequence, with the
ability for the processing of one item to depend on the results of
processing of previous items, and with the ability to terminate the
iteration before all the items in the sequence have been
processed.</p>
</li>
<li>
<p>The <a href="#element-merge"><code>xsl:merge</code></a>
instruction allows several input sequences to be merged into a
single output sequence, based on the value of a merge key.</p>
</li>
<li>
<p>The <a href="#element-fork"><code>xsl:fork</code></a>
instruction allows multiple results to be computed during a single
pass of a streamed input document.</p>
<p>The <a href="#element-sequence"><code>xsl:sequence</code></a>
instruction can now contain a sequence constructor as an
alternative to using the <code>select</code> attribute. This is
primarily for use cases involving <a href=
"#element-fork"><code>xsl:fork</code></a>.</p>
</li>
</ol>
</li>
<li>
<p>Other changes introduced to facilitate the writing of streamable
stylesheets include:</p>
<ol class="enumla">
<li>
<p>The new <a title="top-level" class="termref" href=
"#dt-top-level">top-level</a> declaration <a href=
"#element-accumulator"><code>xsl:accumulator</code></a> is
introduced. An accumulator represents information about a node in a
document that can be computed during a streamed pass over the
document, starting at the start and ending at that node.</p>
</li>
<li>
<p>An <code>[xsl:]on-empty</code> attribute is provided for
<a href="#element-element"><code>xsl:element</code></a>, <a href=
"#element-copy"><code>xsl:copy</code></a>, and literal result
elements, to control their behavior when the content of the
constructed node would otherwise be empty.</p>
</li>
<li>
<p>New functions <a href="#func-copy-of"><code>copy-of</code></a>
and <a href="#func-snapshot"><code>snapshot</code></a> are
provided, to enable streaming applications to operate in
"windowing" mode, where the input document is divided into a
sequence of small subtrees processed one at a time.</p>
</li>
</ol>
</li>
<li>
<p>Some further new instructions are provided, unrelated to
streaming:</p>
<ol class="enumla">
<li>
<p>The <a href="#element-try"><code>xsl:try</code></a> instruction
allows recovery from dynamic errors.</p>
</li>
<li>
<p>A new <a href="#element-evaluate"><code>xsl:evaluate</code></a>
instruction is provided, to allow evaluation of XPath expressions
constructed dynamically from strings, or read from a source
document.</p>
</li>
<li>
<p>The <a href="#element-assert"><code>xsl:assert</code></a>
instruction allows arbitrary assertions about the state of
variables or the input document, improving testability and
robustness.</p>
</li>
</ol>
</li>
<li>
<p>Text nodes within a sequence constructor may now contain
<a title="text value template" class="termref" href=
"#dt-text-value-template">text value templates</a> (XPath
expressions enclosed in curly brackets), if this is enabled by
setting <code>expand-text="yes"&gt;</code> on an enclosing
element.</p>
</li>
<li>
<p>The syntax of <a title="pattern" class="termref" href=
"#dt-pattern">patterns</a> has been generalized. Patterns may now
match any item (not only nodes). In consequence, <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a> can
now process sequences of atomic values as well as nodes, and
<a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a> with
the <code>group-starting-with</code> and
<code>group-ending-with</code> options can also process atomic
sequences. As a further consequence, the <span>items in the
<a title="initial match selection" class="termref" href=
"#dt-initial-match-selection">initial match selection</a> supplied
when initiating a transformation are no longer required to be
nodes</span>.</p>
</li>
<li>
<p>A new datatype, called a <b>map</b>, has been introduced,
together with supporting functions, operators, and type syntax.
Maps allow more complex data structures to be created than is
possible using atomic values and nodes alone. This has particular
applications to streamed processing: since a streamed application
can visit each node of its primary input document only once, it
often needs more advanced data structures to retain what it has
already seen in the document.</p>
</li>
<li>
<p>Miscellaneous changes to existing instructions and declarations
include:</p>
<ol class="enumla">
<li>
<p>The regular expression supplied to the <a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a>
instruction is now permitted to be one that matches a zero-length
string.</p>
</li>
<li>
<p>The <a href="#element-copy"><code>xsl:copy</code></a>
instruction now has a <code>select</code> attribute, which is
convenient when it is used inside a function where there is no
context item.</p>
</li>
<li>
<p>Composite keys are supported in <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a>.</p>
</li>
<li>
<p>Two new attributes have been added to <a href=
"#element-function"><code>xsl:function</code></a> to provide
increased scope for optimization: <code>identity-sensitive</code>
and <code>cache</code>. The first indicates whether the identity of
nodes passed in the arguments or result of the function is
significant; the second indicates whether the function is to cache
its results (memoization).</p>
</li>
<li>
<p>The <code>override</code> attribute of <a href=
"#element-function"><code>xsl:function</code></a> is renamed
<code>override-extension-function</code>, retaining the old name as
a deprecated synonym.</p>
</li>
<li>
<p>The rule requiring <a href=
"#element-import"><code>xsl:import</code></a> declarations to
precede all other declarations in a stylesheet module has been
removed.</p>
</li>
<li>
<p>Composite keys are supported in <a href=
"#element-key"><code>xsl:key</code></a>.</p>
</li>
<li>
<p>A new attribute on <a href=
"#element-message"><code>xsl:message</code></a> allows
specification of the error code to be returned with
<code>terminate="yes"</code> is specified.</p>
</li>
<li>
<p>The rules for handling conflicts between <a href=
"#element-strip-space"><code>xsl:strip-space</code></a> and
<a href="#element-preserve-space"><code>xsl:preserve-space</code></a>
have changed. A conflict that can be detected statically is now
signaled as a static error; a run-time conflict between two
declarations having the same precedence and priority is now
resolved by taking whichever comes last in declaration order.</p>
</li>
<li>
<p>An <a href="#element-template"><code>xsl:template</code></a>
declaration may contain an <a href=
"#element-context-item"><code>xsl:context-item</code></a> element
to declare the required type of the context item when the template
is called.</p>
</li>
<li>
<p>An empty <a href=
"#element-value-of"><code>xsl:value-of</code></a> instruction with
no <code>select</code> attribute is now permitted; its effect is to
construct a zero-length text node.</p>
</li>
<li>
<p>The <a href="#element-variable"><code>xsl:variable</code></a>
and <a href="#element-param"><code>xsl:param</code></a> elements
may now specify <code>static="yes"</code>, denoting that the
variable is available statically (informally, "at compile time").
Static variables and parameters make the
<code>[xsl:]use-when</code> mechanism more useful, especially in
conjunction with <a href=
"#element-assert"><code>xsl:assert</code></a>.</p>
</li>
</ol>
</li>
<li>
<p>New functions are available to import and export data in JSON
format.</p>
</li>
<li>
<p>A <a title="basic XSLT processor" class="termref" href=
"#dt-basic-xslt-processor">basic XSLT Processor</a> now recognizes
all the built-in types defined in XML Schema.</p>
</li>
<li>
<p>A <a title="basic XSLT processor" class="termref" href=
"#dt-basic-xslt-processor">basic XSLT Processor</a> will now accept
the attribute <code>validation="lax"</code> and interpret it in the
same way as a schema-aware processor when there is no schema
component available to perform the validation.</p>
</li>
<li>
<p>Some functions, including <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-generate-id"><code>generate-id</code></a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-date"><code>format-date</code></a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-dateTime"><code>
format-dateTime</code></a><sup><small>FO30</small></sup>, <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-number"><code>
format-number</code></a><sup><small>FO30</small></sup>, <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-time"><code>format-time</code></a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-unparsed-text"><code>
unparsed-text</code></a><sup><small>FO30</small></sup> have been
moved from this specification to the core Functions and Operators
specification, to make them available in other host languages.</p>
</li>
<li>
<p>The rule that effectively prevented references to external
documents in <code>[xsl:]use-when</code> expressions has been
removed.</p>
</li>
<li>
<p>A default value is defined for the named template to be used
when initiating a transformation (specifically,
<code>xsl:initial-template</code>).</p>
</li>
<li>
<p>Serialization to HTML5 and XHTML5 is supported. To this end, a
new serialization parameter <code>html-version</code> is provided
in <a href="#element-output"><code>xsl:output</code></a> and
<a href=
"#element-result-document"><code>xsl:result-document</code></a>.</p>
</li>
<li>
<p>The concept of recoverable dynamic errors has been dropped. Of
the remaining recoverable dynamic errors, some are no longer
errors, and others are now situations where the behavior of the
processor is <a title="implementation-dependent" class="termref"
href="#dt-implementation-dependent">implementation-dependent</a>.
The adjective "non-recoverable" in describing other dynamic errors
becomes redundant and has therefore been dropped (the term was in
any case misleading since the introduction of a try/catch
mechanism). Error codes of the form <code>XTREnnnn</code> have been
renumbered <code>XTDEnnnn</code>.</p>
<p>Dynamic errors occurring during pattern evaluation are always
masked (they cause the pattern to report a non-match.)</p>
</li>
<li>
<p>The new serialization parameter <code>html-version</code> is
supported in <a href="#element-output"><code>xsl:output</code></a>
and <a href=
"#element-result-document"><code>xsl:result-document</code></a>.
Note that the <code>item-separator</code> attribute is not
available in XSLT because the value that is serialized by XSLT is
always a singleton document node.</p>
</li>
<li>
<p>A family of collation URIs is defined for selecting collations
based on the Unicode Collation Algorithm.</p>
</li>
<li>
<p>The effect of specifying the type <code>xs:untyped</code> or
<code>xs:untypedAtomic</code> when validating by type is now
defined.</p>
</li>
<li>
<p>The <a href="#element-output"><code>xsl:output</code></a> and
<a href=
"#element-result-document"><code>xsl:result-document</code></a>
elements now allow a <code>parameter-document</code> attribute
allowing serialization to be configured in an external
document.</p>
</li>
<li>
<p>The set of constructs that set <a title="temporary output state"
class="termref" href="#dt-temporary-output-state">temporary output
state</a> has been reduced, and no longer includes instructions
that create nodes, such as <a href=
"#element-attribute"><code>xsl:attribute</code></a> and <a href=
"#element-value-of"><code>xsl:value-of</code></a>. However,
<a href="#element-merge-key"><code>xsl:merge-key</code></a> has
been added to the list.</p>
</li>
<li>
<p>The possibilities for invocation of a stylesheet have been
expanded; they now include the ability to directly execute a
stylesheet function; to supply parameters to the initial template;
and to return the results of the invoked template or function as a
raw value, without construction of a result tree.</p>
</li>
</ol>
</div>
<div class="div2">
<h3><a name="xpath-changes-since-2.0" id=
"xpath-changes-since-2.0"></a>J.2 <a href=
"#xpath-changes-since-2.0" style="text-decoration: none">Changes in
Other Related Specifications</a></h3>
<p>A number of changes affecting XSLT 2.0 have been made in other
related specifications. Some of the more significant changes are as
follows:</p>
<ol class="enumar">
<li>
<p>A number of new functions have been defined whose aim is to
facilitate streaming. These include <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-unparsed-text-lines">
<code>unparsed-text-lines</code></a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#func-innermost"><code>innermost</code></a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#func-outermost"><code>outermost</code></a><sup><small>FO30</small></sup>.</p>
</li>
<li>
<p>XPath 3.0 supports a subset of the <code>let</code> expression
from XQuery.</p>
</li>
<li>
<p>XPath 3.0 supports function items as first-class values
(functions can, for example, be bound to variables and passed as
parameters to other functions.)</p>
</li>
<li>
<p>XPath 3.0 supports a new syntax for writing expanded names using
the namespace URI and local part only, avoiding the need to create
a static context that binds namespace prefixes. This is intended to
be particularly useful when XPath expressions are
software-generated. Complementing this, a new function <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-path"><code>path</code></a><sup><small>FO30</small></sup>
is available to generate a (namespace-context-independent) path to
any node that can subsequently be evaluated using the <a href=
"#element-evaluate"><code>xsl:evaluate</code></a> instruction, or
otherwise.</p>
</li>
</ol>
</div>
</div>
<div class="div1">
<h2><a name="changes-since-july-2012" id=
"changes-since-july-2012"></a>K Changes since the Working Draft of
10 July 2012 (Non-Normative)</h2>
<p>This section lists all significant changes since the Working
Draft published on 10 July 2012.</p>
<ol class="enumar">
<li>
<p>Text nodes within a sequence constructor may now contain
<a title="text value template" class="termref" href=
"#dt-text-value-template">text value templates</a> (XPath
expressions enclosed in curly brackets), if this is enabled by
setting <code>expand-text="yes"&gt;</code> on an enclosing
element.</p>
</li>
<li>
<p>An empty <a href=
"#element-value-of"><code>xsl:value-of</code></a> instruction with
no <code>select</code> attribute is now permitted; its effect is to
construct a zero-length text node.</p>
</li>
<li>
<p>Static variables and parameters are introduced, to make the
<code>[xsl:]use-when</code> mechanism more useful, especially in
conjunction with <a href=
"#element-assert"><code>xsl:assert</code></a>.</p>
</li>
<li>
<p>The rule requiring <a href=
"#element-import"><code>xsl:import</code></a> declarations to
precede all other declarations in a stylesheet module has been
removed.</p>
</li>
<li>
<p>The rule that effectively prevented references to external
documents in <code>[xsl:]use-when</code> expressions has been
removed.</p>
</li>
<li>
<p>The <code>enabled</code> attribute of <a href=
"#element-assert"><code>xsl:assert</code></a> is removed; its
effect can now be achieved more conveniently using a
<code>use-when</code> attribute.</p>
</li>
<li>
<p>A default value is defined for the named template to be used
when initiating a transformation (specifically,
<code>xsl:initial-template</code>).</p>
</li>
<li>
<p>The <code>override</code> attribute of <a href=
"#element-function"><code>xsl:function</code></a> is renamed
<code>override-extension-function</code>, retaining the old name as
a deprecated synonym.</p>
</li>
<li>
<p>The rules for conformance against optional features have been
refactored.</p>
</li>
<li>
<p>(In the July 2012 draft but omitted from the change list): The
<a href="#element-sequence"><code>xsl:sequence</code></a>
instruction can now contain a sequence constructor as an
alternative to using the <code>select</code> attribute. This is
primarily for use cases involving <a href=
"#element-fork"><code>xsl:fork</code></a>.</p>
</li>
<li>
<p>A new attribute <code>with-params</code> is provided on <a href=
"#element-evaluate"><code>xsl:evaluate</code></a>, to allow
parameters to be computed dynamically in the form of a map. This
works alongside the existing mechanism using <a href=
"#element-with-param"><code>xsl:with-param</code></a> children.</p>
</li>
<li>
<p>The concept of recoverable dynamic errors has been dropped. Of
the remaining recoverable dynamic errors, some are no longer
errors, and others are now situations where the behavior of the
processor is <a title="implementation-dependent" class="termref"
href="#dt-implementation-dependent">implementation-dependent</a>.
The adjective "non-recoverable" in describing other dynamic errors
becomes redundant and has therefore been dropped (the term was in
any case misleading since the introduction of a try/catch
mechanism). Error codes of the form <code>XTREnnnn</code> have been
renumbered <code>XTDEnnnn</code>.</p>
</li>
<li>
<p>The new serialization parameters <code>html-version</code> and
<code>item-separator</code> are supported in <a href=
"#element-output"><code>xsl:output</code></a> and <a href=
"#element-result-document"><code>xsl:result-document</code></a>.</p>
</li>
<li>
<p>Two new attributes have been added to <a href=
"#element-function"><code>xsl:function</code></a> to provide
increased scope for optimization: <code>identity-sensitive</code>
and <code>cache</code>.</p>
</li>
<li>
<p>A family of collation URIs is defined for selecting collations
based on the Unicode Collation Algorithm.</p>
</li>
<li>
<p>The <code>on-empty</code> attribute of <a href=
"#element-copy"><code>xsl:copy</code></a> is no longer ignored in
cases where the selected node is not a document or element node
(this change was subsequently reversed).</p>
</li>
<li>
<p>Serialization parameters can now be specified in an external
parameter document.</p>
</li>
<li>
<p>The effect of specifying the type <code>xs:untyped</code> or
<code>xs:untypedAtomic</code> when validating by type is now
defined.</p>
</li>
<li>
<p>Maps no longer have an associated collation. In its place, a new
<a href="#func-collation-key"><code>collation-key</code></a>
function is introduced to allow keys to be normalized according to
the rules of a given collation.</p>
</li>
<li>
<p>The syntax for patterns has been rewritten. The grammar is now
closely aligned with the XPath 3.0 grammar, so that it can be
readily verified that the grammar is a subset of XPath, and that
there are no needless restrictions (this was necessary to fix some
bugs in this area). The type-based syntax <code>~typename</code>
used in earlier drafts was found not to be well-aligned with
practical use cases for matching atomic values, and has been
replaced by the construct <code>.[ Expr ]</code> which tests the
item using an arbitrary boolean expression.</p>
</li>
<li>
<p>Accumulators are now classified as components for the purpose of
defining packages; in addition, the rules for overriding them using
<a href="#element-import"><code>xsl:import</code></a> are now
defined. The <code>name</code> and <code>initial-value</code>
attributes of an accumulator are now mandatory.</p>
</li>
<li>
<p>The regular expression supplied to the <a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a>
instruction is now permitted to be one that matches a zero-length
string.</p>
</li>
<li>
<p>The <a href="#element-output"><code>xsl:output</code></a> and
<a href=
"#element-result-document"><code>xsl:result-document</code></a>
elements now allow a <code>parameter-document</code> attribute
allowing serialization to be configured in an external
document.</p>
</li>
<li>
<p>The <a href="#element-evaluate"><code>xsl:evaluate</code></a>
instruction has been made part of an optional feature, the dynamic
evaluation feature.</p>
</li>
<li>
<p>Dynamic errors occurring during pattern evaluation are always
masked (they cause the pattern to report a non-match.)</p>
</li>
<li>
<p>Stylesheet parameters that specify <code>required="yes"</code>
must have visibility equal to <code>public</code>.</p>
</li>
<li>
<p>The meaning of <code>on-no-match="deep-skip"</code> has been
changed when the selected node is a document node; in this case it
is now equivalent to <code>shallow-skip</code>.</p>
</li>
<li>
<p>Redundant parentheses at the outermost level of a pattern in a
template rule now have no effect on the semantics: they do not
affect the default priority, and they do not prevent the branches
of a union being effectively treated as separate template
rules.</p>
</li>
<li>
<p>The method for invoking accumulator functions has changed;
instead of user-defined functions, there are now two built-in
functions <a href=
"#func-accumulator-before"><code>accumulator-before</code></a> and
<a href=
"#func-accumulator-after"><code>accumulator-after</code></a> that
take the accumulator name as an argument.</p>
</li>
<li>
<p>The attributes <code>default-collation</code> and
<code>default-mode</code> can now be specified on any element.</p>
</li>
<li>
<p>The attribute <code>initial</code> on <a href=
"#element-mode"><code>xsl:mode</code></a> is dropped, as the same
effect can be achieved using the <code>visibility</code>
attribute.</p>
</li>
<li>
<p>It is now a dynamic error for a map expression or an <a href=
"#element-map"><code>xsl:map</code></a> instruction to generate
duplicate keys.</p>
</li>
<li>
<p>There has been a substantial rewrite of section <a href=
"#streamability"><i>19 Streamability</i></a>. Some of the changes
are to relax restrictions on streamability that were found to be a
nuisance; others are to fix errors in the analysis rules that meant
some constructs (such as the <a href=
"#func-copy-of"><code>copy-of</code></a> function) could not
effectively be used for their intended purpose. Other changes are
simply for clarity or conciseness of exposition. The new concept of
<a title="posture" class="termref" href="#dt-posture">posture</a>
reintroduces (under a different guise) the path analysis that was
described in graphical terms in an earlier working draft.</p>
</li>
<li>
<p>References to ECMA-262 (for the specification of JSON) have been
replaced with references to ECMA-404.</p>
</li>
<li>
<p>Attributes <code>validation</code> and <code>type</code> have
been added to the <a href=
"#element-stream"><code>xsl:stream</code></a> instruction to
control schema-validation of streamed input documents.</p>
</li>
<li>
<p>The process of initiating a stylesheet is revised to allow
applications to invoke public functions as well as public template
rules, to allow parameters to the initial template or function to
be supplied, and to get the "raw result" of invoking a public
template or function, without the result being wrapped into a
result tree.</p>
</li>
<li>
<p>The syntax for map expressions has changed to use colon
(<code>:</code>) as the separator between key and value, rather
than <code>:=</code>.</p>
</li>
</ol>
</div>
<div class="div1">
<h2><a name="changes-since-dec-2013" id=
"changes-since-dec-2013"></a>L Changes since the Last Call Working
Draft of 12 December 2013 (Non-Normative)</h2>
<p>Substantive changes are <em>highlighted</em>. (Changes are not
classified as substantive if the previous text was unclear,
inconsistent, incomplete, or obviously incorrect.)</p>
<ol class="enumar">
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=6255">Bug6255</a>
(XSLT 2.0 Erratum E38): <em>Specify that base URI is preserved
during validation</em>.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=6857">Bug6857</a>
(XSLT 2.0 Erratum E39): Allow error XTDE1030 to be raised
statically.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=6952">Bug6952</a>
(XSLT 2.0 Erratum E48): <em>Correct the statement that notations
are not checked during validation</em>.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=7130">Bug7130</a>
(XSLT 2.0 Erratum E45): Say what happens when there are two
<a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a>
instructions specifying the same stylesheet URI and result URI, but
different prefixes.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=7385">Bug7385</a>
(XSLT 2.0 Erratum E46): Define what happens when the encoding
specified to <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-unparsed-text"><code>
unparsed-text</code></a><sup><small>FO30</small></sup> is
invalid.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=7353">Bug7353</a>
(XSLT 2.0 Erratum E41): Define what happens when the argument to
<a href="#func-document"><code>document</code></a> is invalid.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=7358">Bug7358</a>
(XSLT 2.0 Erratum E40): Correct one of the examples of
circularities.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=7394">Bug7394</a>
(XSLT 2.0 Erratum E49): Clarify the forwards compatibility rules,
in particular the phrase "part of a sequence constructor".</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=7624">Bug7624</a>
(XSLT 2.0 Erratum E44): Say what <a href=
"#element-copy"><code>xsl:copy</code></a> does if there is no
context item.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=8217">Bug8217</a>
(XSLT 2.0 Erratum E50): Make it clear that XPath 1.0 compatibility
mode is normally set to false when the function conversion rules
are applied.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=8219">Bug8219</a>
(XSLT 2.0 Erratum E42): Clarify the effect of the
<code>xml:base</code> attribute on the base URI of an element
constructed using <a href=
"#element-copy"><code>xsl:copy</code></a>.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=8398">Bug8398</a>
(XSLT 2.0 Erratum E47): Correct one of the grouping examples to
deliver results in the right order.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=8477">Bug8477</a>
(XSLT 2.0 Erratum E54): Provide more complete rules for the
<code>lang</code> attribute in <a href=
"#element-sort"><code>xsl:sort</code></a> and <a href=
"#element-number"><code>xsl:number</code></a>.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=9927">Bug9927</a>
(XSLT 2.0 Erratum E51): Provide rules for the use of <a href=
"#element-number"><code>xsl:number</code></a><code>/@grouping-separator</code>.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=23594">Bug23594</a>:
Refer to RFC7159 as the definitive JSON specification.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=23944">Bug23944</a>:
<em>Relax the rules regarding the order of children of <a href=
"#element-package"><code>xsl:package</code></a>.</em></p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24073">Bug24073</a>:
Correct the streamability rules for the <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-trace"><code>trace</code></a><sup><small>FO30</small></sup>
function.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24078">Bug24078</a>:
Fix a spelling mistake.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24098">Bug24098</a>:
Remove a duplicate entry in the change history.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24108">Bug24108</a>:
Remove a duplicate entry in the list of built-in functions.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24109">Bug24109</a>:
<em>The streamability of a local variable (<a href=
"#element-variable"><code>xsl:variable</code></a>) now depends on
the type specified in its <code>as</code> attribute.</em></p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24125">Bug24125</a>:
Add notes on the streamability of <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-reverse"><code>reverse</code></a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#func-fold-right"><code>fold-right</code></a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-innermost"><code>innermost</code></a><sup><small>FO30</small></sup>.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24136">Bug24136</a>:
Clarify that if <a href=
"#element-copy-of"><code>xsl:copy-of</code></a> requests both
namespace stripping and validation, then namespace stripping is
done first.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24140">Bug24140</a>:
Clarify the effect of type errors in <a href=
"#element-copy"><code>xsl:copy</code></a>.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24142">Bug24142</a>:
Clarify the effect of <code>xsl:copy/@on-empty</code>. Obsoleted by
the decision on bug 24328.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24144">Bug24144</a>:
Add a rule that streamable attribute sets must not invoke
non-streamable attribute sets.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24173">Bug24173</a>:
<em>Use more precise type information when assessing
streamability.</em></p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24179">Bug24179</a>:
<em>Change the position of <a href=
"#element-on-completion"><code>xsl:on-completion</code></a> among
the children of <a href=
"#element-iterate"><code>xsl:iterate</code></a>, to ensure that
local variables are not in scope.</em></p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24234">Bug24234</a>:
Clarify that defaulting attributes on <a href=
"#element-mode"><code>xsl:mode</code></a> does not cause
conflicts.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24235">Bug24235</a>:
Provide definitions for the terms <a title="top-level package"
class="termref" href="#dt-top-level-package">top-level package</a>
and <a title="library package" class="termref" href=
"#dt-library-package">library package</a>.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24237">Bug24237</a>:
Clarify that error XTSE1560 does not apply to the property
<code>suppress-indentation</code>.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24266">Bug24266</a>:
Permit XSLT 3.0 processors to work with future XPath versions, such
as XPath 3.1.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24267">Bug24267</a>:
<em>Change the streamability rules for union expressions to make
more cases streamable.</em></p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24290">Bug24290</a>:
Rephrase all text that uses the word "overlap" as a relationship
between two trees.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24307">Bug24307</a>:
Clarify the rules regarding the visibility of the unnamed mode.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24308">Bug24308</a>:
Clarify the rules for overriding template rules from a different
package.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24309">Bug24309</a>:
Clarify that the effect of <a href=
"#element-import"><code>xsl:import</code></a> and <a href=
"#element-include"><code>xsl:include</code></a> is local to a
package.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24310">Bug24310</a>:
Clarify that the target of <a href=
"#element-import"><code>xsl:import</code></a> and <a href=
"#element-include"><code>xsl:include</code></a> cannot be a package
manifest.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24317">Bug24317</a>:
Permit <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a> as a
child of <a href="#element-fork"><code>xsl:fork</code></a>.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24342">Bug24342</a>:
Rearrange the rules for streamability of variable references to
avoid ambiguity in the "otherwise" case.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24343">Bug24343</a>:
<em>Introduce new syntax for <a href=
"#element-merge-source"><code>xsl:merge-source</code></a> to handle
the streaming case.</em></p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24344">Bug24344</a>:
Add attribute <a href=
"#element-decimal-format"><code>xsl:decimal-format</code></a><code>/@exponent-separator</code></p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24378">Bug24378</a>:
Make <code>[xsl:]on-empty</code> applicable only to instructions
that create element nodes.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24436">Bug24436</a>:
Use a more realistic example for JSON to XML conversion.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24438">Bug24438</a>:
<em>Drop support for <a href=
"#element-use-package"><code>xsl:use-package</code></a> as a child
of <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a></em>.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24456">Bug24456</a>:
Correct the order of arguments in references to the
<code>itemType-subType</code> relation.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24466">Bug24466</a>:
Correct broken internal links within the document, and improve the
link checking in the publishing workflow.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24478">Bug24478</a>:
Disallow conflicting declarations of static variables.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24493">Bug24493</a>:
Improve cross-referencing and navigation links in the discussion of
guaranteed streamability.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24495">Bug24495</a>:
Fill gaps in the streamability rules for <a href=
"#element-try"><code>xsl:try</code></a>.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24496">Bug24496</a>:
Allow <a href="#element-try"><code>xsl:try</code></a> to be
streamed when the try part is motionless and the catch part is
consuming.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24497">Bug24497</a>:
Fill gaps in the streamability rules for <a href=
"#element-merge"><code>xsl:merge</code></a>.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24498">Bug24498</a>:
In the syntax summary of <a href=
"#element-fallback"><code>xsl:fallback</code></a>, correct the list
of allowed parent elements.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24499">Bug24499</a>:
In the syntax summary of <a href=
"#element-stylesheet"><code>xsl:stylesheet</code></a>, correct the
list of allowed parent elements.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24500">Bug24500</a>:
Clarify the rules for the streamability of dynamic function
calls.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24501">Bug24501</a>:
Add an explanatory note to the general streamability rules
concerning the functions <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-head"><code>head</code></a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#func-exactly-one"><code>exactly-one</code></a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-zero-or-one"><code>zero-or-one</code></a><sup><small>FO30</small></sup>.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24502">Bug24502</a>:
Clarify the text that refers to the poorly-defined term "input
posture".</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24503">Bug24503</a>:
Remove a possible ambiguity in the definition of "combined
posture".</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24504">Bug24504</a>:
Clarify what is meant by the "contained instructions" in a sequence
constructor.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24505">Bug24505</a>:
Add streamability rules for <a href=
"#element-fallback"><code>xsl:fallback</code></a>.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24506">Bug24506</a>:
Instructions processed in XSLT 1.0 mode are not streamable.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24508">Bug24508</a>:
Change the ordering of the streamability rules for <a href=
"#element-fork"><code>xsl:fork</code></a>, thereby removing an
ambiguity.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24510">Bug24510</a>:
<em>Drop the <code>bind-group</code> and
<code>bind-grouping-key</code> attributes on <a href=
"#element-for-each-group"><code>xsl:for-each-group</code></a> and
similar attributes on <a href=
"#element-merge"><code>xsl:merge</code></a>; instead, define
constraints on use of <a href=
"#func-current-group"><code>current-group</code></a> with dynamic
scope.</em></p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24512">Bug24512</a>:
Add streamability rules for extension function calls, and clarify
the rules for dynamic function calls, inline function declarations,
and named function references.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24513">Bug24513</a>:
Explain why <a href=
"#func-system-property"><code>system-property</code></a> is
context-dependent.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24521">Bug24521</a>:
Change the definition of "core function" to include the
<code>math</code> and <code>map</code> namespace; and allow
processors to restrict access to external documents in <a href=
"#element-evaluate"><code>xsl:evaluate</code></a></p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24522">Bug24522</a>:
Add <code>schema-aware</code> to the list of operands affecting the
streamability of <a href=
"#element-evaluate"><code>xsl:evaluate</code></a>.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24524">Bug24524</a>:
Remedy omissions in the streamability rules for <a href=
"#element-iterate"><code>xsl:iterate</code></a></p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24525">Bug24525</a>:
Add <code>error-code</code> to the list of operands affecting the
streamability of <a href=
"#element-message"><code>xsl:message</code></a>.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24527">Bug24527</a>:
Add <code>error-code</code> to the list of operands affecting the
streamability of <a href=
"#element-assert"><code>xsl:assert</code></a>.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24528">Bug24528</a>:
Explain the impact of the <code>from</code> and <code>count</code>
patterns on the streamability of <a href=
"#element-number"><code>xsl:number</code></a>.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24529">Bug24529</a>:
Make explicit the default value of
<code>xsl:mode/xsl:context-item/@use</code>.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24530">Bug24530</a>:
Present the streamability rules for <a href=
"#element-map"><code>xsl:map</code></a> in a way that is more
consistent with other instructions.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24531">Bug24531</a>:
Explain more clearly how node order comparisons work when applied
to streamed nodes.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24533">Bug24533</a>:
In the rules for streamability of inline function declarations,
extend the prohibition on <code>bind-group</code> variables to
extend also to the <code>bind-group</code> and
<code>bind-source</code> variables of <a href=
"#element-merge"><code>xsl:merge</code></a>.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24535">Bug24535</a>:
Ensure that streamability rules for every construct define both
posture and sweep.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24536">Bug24536</a>:
Consistently refer to the operands of an infix operator as the
left-hand and right-hand operands, not the first and second
operands.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24537">Bug24537</a>:
Clarify the meaning of the phrase "both operands are striding or
crawling".</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24538">Bug24538</a>:
Mention that streamed processing can also be initiated using
<a href="#element-merge"><code>xsl:merge</code></a>.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24539">Bug24539</a>:
Drop error XTSE3340, and clarify error XTDE0060.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24540">Bug24540</a>:
Introduce the terms "predicate pattern" and "selection pattern" for
the two kinds of pattern.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24541">Bug24541</a>:
Add better explanation of the conventions used for defining
streamability of expressions.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24542">Bug24542</a>:
Extend the rules that treat void expressions such as
<code>@x/@y</code> as motionless to expressions such as
<code>child::attribute()</code>.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24543">Bug24543</a>:
Add the attribute
<code>xsl:global-context-item/@streamable</code>.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24545">Bug24545</a>:
<em>Drop the attribute <code>xsl:mode/@initial</code>, which is
redundant with the <code>visibility</code> attribute.</em></p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24547">Bug24547</a>:
Require the <code>initial-value</code> and <code>select</code>
expressions for a streamable accumulator to be grounded and
motionless; and add an attribute <code>applies-to</code> that
defines which source documents an accumulator applies to.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24548">Bug24548</a>:
Remove ambiguity in describing the effect of try/catch when
initializing global variables.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24549">Bug24549</a>:
Clarify the effect of priming a stylesheet on the stability of
deterministic functions.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24550">Bug24550</a>:
Define the term <a title="initial match selection" class="termref"
href="#dt-initial-match-selection">initial match selection</a> more
clearly.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24551">Bug24551</a>:
Add the function <a href=
"#func-current-output-uri"><code>current-output-uri</code></a>.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24552">Bug24552</a>:
In the list of constructs that are identified by QNames, add
<a href=
"#element-accumulator"><code>xsl:accumulator</code></a>.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24553">Bug24553</a>:
Clarify that the built-in rules for functions also apply to
maps.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24554">Bug24554</a>:
Add pseudo-code for the <code>deep-skip</code> and
<code>shallow-skip</code> built-in templates.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24569">Bug24569</a>:
<em>Improve the formalism for static type analysis</em>.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24618">Bug24618</a>:
Improve explanation of the relationship of the <a href=
"#element-analyze-string"><code>xsl:analyze-string</code></a>
instruction and the new <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-analyze-string"><code>
analyze-string</code></a><sup><small>FO30</small></sup>
function.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24619">Bug24619</a>:
<em>Introduce shadow attributes (static AVTs) allowing any XSLT
attribute to be statically computed during preprocessing.</em></p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24621">Bug24621</a>:
Remove incorrect notes concerning dynamic evaluation of <a href=
"#func-current-group"><code>current-group</code></a> and <a href=
"#func-current-grouping-key"><code>current-grouping-key</code></a>.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24649">Bug24649</a>:
A construct cannot be guaranteed streamable unless it is declared
streamable.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24651">Bug24651</a>:
Change the streamability rules for <a href=
"#func-accumulator-before"><code>accumulator-before</code></a> and
<a href=
"#func-accumulator-after"><code>accumulator-after</code></a>.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24679">Bug24679</a>:
Make streamable stylesheet functions work in more cases.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24690">Bug24690</a>:
Correct use of the term <a title="initial named template" class=
"termref" href="#dt-initial-named-template">initial named
template</a>.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24726">Bug24726</a>:
Renames the <code>map:new</code> function as <a href=
"#func-map-merge"><code>map:merge</code></a>, and introduces
<a href="#func-map-put"><code>map:put</code></a>.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24744">Bug24744</a>:
Reinstate definition of the <a href=
"#func-map-size"><code>map:size</code></a> function which had been
accidentally deleted.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24763">Bug24763</a>:
Rephrase a number of error conditions so that referential and
uniqueness rules apply within a package, not a stylesheet.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24764">Bug24764</a>:
<em>Remove confusion between the global context item and the
initial match selection, in particular by replacing
<code>xsl:mode/xsl:context-item</code> with
<code>xsl:package/xsl:global-context-item</code></em>.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24864">Bug24864</a>:
Error XTDE0060 is absorbed into error XTDE0700.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=24970">Bug24970</a>:
Use the term <a title="core function" class="termref" href=
"#dt-core-function">core function</a> only in the way it is
formally defined.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=25000">Bug25000</a>:
Supplying an incorrect value for a key in a map expression is a
type error not a dynamic error.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=25158">Bug25158</a>:
Add error case when the default value of a parameter to <a href=
"#element-iterate"><code>xsl:iterate</code></a> is invalid. (This
small technical change triggered a substantial editorial
reorganization of section <a href="#parameters"><i>9.2
Parameters</i></a>.)</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=25160">Bug25160</a>:
Change the mechanism for assessing the streamability of expressions
such as <code>section//head</code>; instead of an early rewrite of
such expressions into a different form, the streamability rules for
relative path expressions have been extended to handle the concept
of "scanning expressions".</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=25173">Bug25173</a>:
<em>Provide a new function <a href=
"#func-stream-available"><code>stream-available</code></a> to test
whether a document is available for streaming.</em></p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=25174">Bug25174</a>:
Provide an option <code>recoverable="no"</code> to avoid the costs
of buffering result trees for try/catch recovery.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=25185">Bug25185</a>:
Atomization of crawling expressions is now allowed: for example
<code>&lt;xsl:value-of select=".//title"/&gt;</code>.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=25196">Bug25196</a>:
Define <code>xml-to-json</code> as an ordinary function, with the
XSLT stylesheet becoming an illustrative implementation..</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=25316">Bug25316</a>:
Recognize expressions such as <code>(//x)[$i+1]</code> as striding
rather than crawling.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=25327">Bug25327</a>:
Add further examples to illustrate the effect of the general
streamability rules.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=25335">Bug25335</a>:
<em>Rewrite the rules for streamed merging so that the selected
nodes are snapshotted.</em></p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=25350">Bug25350</a>:
Editorial corrections and improvements to a streamability
example.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=25364">Bug25364</a>:
Editorial corrections to a streamability example.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=25375">Bug25375</a>:
Maps cannot contain a mix of values with timezones and values
without timezones.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=25517">Bug25517</a>:
Clarify the meaning of the <code>xsl:mode/@typed</code> attribute,
and add an error condition.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=25611">Bug25611</a>:
Disallow reference to the global context item from within a library
package.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=25679">Bug25679</a>:
<em>Allow stylesheet functions to be declared as streamable and to
be invoked from streamed templates.</em></p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=25701">Bug25701</a>:
Update references in bibliography.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=25821">Bug25821</a>:
Recognize that a template or function is grounded if its
<code>as</code> attribute specifies an atomic type.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=26268">Bug26268</a>:
The <code>initial-value</code> expression of an accumulator is
evaluated with the root node of the streamed input as context item,
not with the global context item.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=26289">Bug26289</a>:
Correct a nonsensical statement concerning the use of
<code>$value</code> in the <code>new-value</code> expression (now
<code>select</code> expression) of an accumulator rule.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=26308">Bug26308</a>:
Allow <code>true</code> and <code>false</code> as synonyms of
<code>yes</code> and <code>no</code>.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=26328">Bug26328</a>:
Clarify the rules for the use of <a href=
"#func-accumulator-before"><code>accumulator-before</code></a> and
<a href=
"#func-accumulator-after"><code>accumulator-after</code></a> with
streamed nodes.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=26330">Bug26330</a>:
Generalize the definition of accumulators, especially <a href=
"#element-accumulator"><code>xsl:accumulator</code></a><code>/@applies-to</code>,
to work with non-document input trees.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=26378">Bug26378</a>:
Rework examples to align with the latest streamability rules.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=26422">Bug26422</a>:
Extend the definition of the term <a title="package" class=
"termref" href="#dt-package">package</a> so that it includes
implicit packages.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=26438">Bug26438</a>:
The new <code>xsl:package/@declared-modes</code> attribute controls
whether implicit mode declarations are permitted.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=26439">Bug26439</a>:
Improve the streamability of the functions <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-fold-left"><code>fold-left</code></a><sup><small>FO30</small></sup>,
<a href=
"http://www.w3.org/TR/xpath-functions-30/#func-for-each"><code>for-each</code></a><sup><small>FO30</small></sup>,
and <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-for-each-pair"><code>
for-each-pair</code></a><sup><small>FO30</small></sup>.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=26443">Bug26443</a>:
The syntax for package versions and version ranges has been revised
to conform with industry practice.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=26467">Bug26467</a>:
Fixed an editorial ambiguity regarding <a href=
"#element-global-context-item"><code>xsl:global-context-item</code></a>.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=26468">Bug26468</a>:
An <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>
element no longer appears as a child of <a href=
"#element-package"><code>xsl:package</code></a>; instead the
top-level declarations can appear as children of <a href=
"#element-package"><code>xsl:package</code></a>.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=26471">Bug26471</a>:
Replace the <code>new-value</code> attribute of <a href=
"#element-accumulator-rule"><code>xsl:accumulator-rule</code></a>
with a <code>select</code> attribute or the option of a contained
sequence constructor.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=26477">Bug26477</a>:
Allocate an error code for the situation where <a href=
"#element-use-package"><code>xsl:use-package</code></a> fails to
resolve.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=26543">Bug26543</a>:
The requirement to report a <a title="circularity" class="termref"
href="#dt-circularity">circularity</a> overrides the usual rule
that dynamic errors in patterns are masked.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=26525">Bug26525</a>:
Text value templates are recognized within <a href=
"#element-text"><code>xsl:text</code></a> if enabled using
<code>expand-text</code>.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=26559">Bug26559</a>:
The function <code>map:for-each-entry</code> is renamed
<code>map:for-each</code></p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=26648">Bug26648</a>:
The semantics for comparing package versions refer to XPath rules
for edge cases such as overflow.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=26649">Bug26649</a>:
Introduced EBNF to define the package version syntax.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=26679">Bug26679</a>:
Corrected the descriptions of errors XTSE3020 and XTSE3030.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=26737">Bug26737</a>:
Editorial corrections and non-normative advice concerning
accumulators.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=26740">Bug26740</a>:
Disallow <a href=
"#element-param"><code>xsl:param</code></a><code>/@visibility</code>
attribute.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=26742">Bug26742</a>:
Delete obsolete references to the existence of preceding-sibling
counters.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=26752">Bug26752</a>:
Improve the streamability rules for quantified expressions.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=26780">Bug26780</a>:
Clarify the meaning of the <code>version</code> attribute on
<a href="#element-package"><code>xsl:package</code></a>.</p>
</li>
<li>
<p><a href=
"https://www.w3.org/Bugs/Public/show_bug.cgi?id=26781">Bug26781</a>:
Change the interaction of <a href=
"#element-expose"><code>xsl:expose</code></a> with the
<code>visibility</code> attribute on component declarations.</p>
</li>
</ol>
</div>
<div class="div1">
<h2><a name="incompatibilities" id="incompatibilities"></a>M
Incompatibilities with XSLT 2.0 (Non-Normative)</h2>
<p>This section lists all known incompatibilities with XSLT 2.0,
that is, situations <span>where</span> a stylesheet that is
error-free according to the XSLT 2.0 specification and where all
elements have an effective version of <code>2.0</code> or less,
will produce different results depending on whether it is run under
an XSLT 2.0 processor or an XSLT 3.0 processor.</p>
<ol class="enumar">
<li>
<p>XSLT 2.0 gave implementations freedom what to do when a node
selected by <a href=
"#element-apply-templates"><code>xsl:apply-templates</code></a>
matched more than one <a title="template rule" class="termref"
href="#dt-template-rule">template rule</a>. XSLT 3.0 is more
prescriptive in this situation. The behavior prescribed in XSLT 3.0
(selecting the template rule that is last in <a title=
"declaration order" class="termref" href=
"#dt-declaration-order">declaration order</a>) is compatible with
the action of some XSLT 2.0 processors but not necessarily
others.</p>
</li>
<li>
<p>It is now a static error if the same <code>NameTest</code>
appears in both an <a href=
"#element-strip-space"><code>xsl:strip-space</code></a> and an
<a href=
"#element-preserve-space"><code>xsl:preserve-space</code></a>
declaration with the same precedence and priority. Previously this
was a dynamic error, and processors were allowed to recover from
the error.</p>
</li>
<li>
<p>The current group and current grouping key are now absent rather
than empty when not in use, which means that attempting to refer to
them in this state gives a dynamic error.</p>
</li>
<li>
<p>As a consequence of functions such as <a href=
"http://www.w3.org/TR/xpath-functions-30/#func-format-date"><code>format-date</code></a><sup><small>FO30</small></sup>
moving from this specification to <a href=
"#xpath-functions-30">[Functions and Operators]</a>, error codes
associated with these functions have changed.</p>
</li>
<li>
<p>The concept of recoverable dynamic errors has been dropped. Of
the remaining recoverable dynamic errors, some are no longer
errors, and others are now situations where the behavior of the
processor is <a title="implementation-dependent" class="termref"
href="#dt-implementation-dependent">implementation-dependent</a>.
Error codes of the form <code>XTREnnnn</code> have been renumbered
<code>XTDEnnnn</code>.</p>
</li>
<li>
<p>In previous versions of the specification, the <a href=
"#func-element-available"><code>element-available</code></a>
function when applied to names in the XSLT namespace was defined to
return <code>false</code> in the case of XSLT elements other than
instructions. (Actual practice in implementations was not always
consistent with this rule). In XSLT 3.0 the rules have been changed
so that it returns <code>true</code> for the names of such
elements, bringing the specification of the function into line with
the intuitive meaning of its name.</p>
</li>
<li>
<p>(This is not strictly speaking an incompatibility, as conforming
XSLT 2.0 stylesheets will continue to function correctly without
error. It can be considered as migration advice, a warning that
care is needed when introducing new XSLT 3.0 features.)</p>
<p>When a function or template has a parameter with a declared type
of <code>item()</code>, it should not assume (as it could in XSLT
2.0) that when the supplied item is not a node, it must be an
atomic value, and vice versa. In XSLT 3.0 there is a third option:
it might be a function. Functions and templates that fail to cater
for this possibility may fail with a type error if the caller
supplies a function as the relevant parameter value.</p>
</li>
<li>
<p>XSLT 1.0 and 2.0 required the <code>grouping-size</code>
attribute of <a href="#element-number"><code>xsl:number</code></a>
to be a "number" (a term which in other contexts was defined to
mean any decimal value), but no interpretation was provided for
non-integer values. XSLT 3.0 requires the value to be an
integer.</p>
</li>
</ol>
</div>
</div>
</body>
</html>
